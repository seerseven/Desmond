'use strict';

var _createClass = (function () {
	function defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ('value' in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}
	return function (Constructor, protoProps, staticProps) {
		if (protoProps) defineProperties(Constructor.prototype, protoProps);
		if (staticProps) defineProperties(Constructor, staticProps);
		return Constructor;
	};
})();

function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError('Cannot call a class as a function');
	}
}

// Generated by CoffeeScript 2.0.1
(function () {
	// Image Picker source
	// by Rodrigo Vera

	var ImagePicker,
		ImagePickerOption,
		both_array_are_equal,
		sanitized_options,
		indexOf = [].indexOf;

	jQuery.fn.extend({
		imagepicker: function imagepicker() {
			var opts =
				arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			return this.each(function () {
				var select;
				select = jQuery(this);
				if (select.data('picker')) {
					select.data('picker').destroy();
				}
				select.data('picker', new ImagePicker(this, sanitized_options(opts)));
				if (opts.initialized != null) {
					return opts.initialized.call(select.data('picker'));
				}
			});
		},
	});

	sanitized_options = function sanitized_options(opts) {
		var default_options;
		default_options = {
			hide_select: true,
			show_label: false,
			initialized: void 0,
			changed: void 0,
			clicked: void 0,
			selected: void 0,
			limit: void 0,
			limit_reached: void 0,
			font_awesome: false,
		};
		return jQuery.extend(default_options, opts);
	};

	both_array_are_equal = function both_array_are_equal(a, b) {
		var i, j, len, x;
		if (!a || !b || a.length !== b.length) {
			return false;
		}
		a = a.slice(0);
		b = b.slice(0);
		a.sort();
		b.sort();
		for (i = j = 0, len = a.length; j < len; i = ++j) {
			x = a[i];
			if (b[i] !== x) {
				return false;
			}
		}
		return true;
	};

	ImagePicker = (function () {
		function ImagePicker(select_element) {
			var opts1 =
				arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			_classCallCheck(this, ImagePicker);

			this.sync_picker_with_select = this.sync_picker_with_select.bind(this);
			this.opts = opts1;
			this.select = jQuery(select_element);
			this.multiple = this.select.attr('multiple') === 'multiple';
			if (this.select.data('limit') != null) {
				this.opts.limit = parseInt(this.select.data('limit'));
			}
			this.build_and_append_picker();
		}

		_createClass(ImagePicker, [
			{
				key: 'destroy',
				value: function destroy() {
					var j, len, option, ref;
					ref = this.picker_options;
					for (j = 0, len = ref.length; j < len; j++) {
						option = ref[j];
						option.destroy();
					}
					this.picker.remove();
					this.select.off('change', this.sync_picker_with_select);
					this.select.removeData('picker');
					return this.select.show();
				},
			},
			{
				key: 'build_and_append_picker',
				value: function build_and_append_picker() {
					if (this.opts.hide_select) {
						this.select.hide();
					}
					this.select.on('change', this.sync_picker_with_select);
					if (this.picker != null) {
						this.picker.remove();
					}
					this.create_picker();
					this.select.after(this.picker);
					return this.sync_picker_with_select();
				},
			},
			{
				key: 'sync_picker_with_select',
				value: function sync_picker_with_select() {
					var j, len, option, ref, results;
					ref = this.picker_options;
					results = [];
					for (j = 0, len = ref.length; j < len; j++) {
						option = ref[j];
						if (option.is_selected()) {
							results.push(option.mark_as_selected());
						} else {
							results.push(option.unmark_as_selected());
						}
					}
					return results;
				},
			},
			{
				key: 'create_picker',
				value: function create_picker() {
					this.picker = jQuery(
						"<ul class='thumbnails image_picker_selector'></ul>"
					);
					this.picker_options = [];
					this.recursively_parse_option_groups(this.select, this.picker);
					return this.picker;
				},
			},
			{
				key: 'recursively_parse_option_groups',
				value: function recursively_parse_option_groups(
					scoped_dom,
					target_container
				) {
					var container,
						j,
						k,
						len,
						len1,
						option,
						option_group,
						ref,
						ref1,
						results;
					ref = scoped_dom.children('optgroup');
					for (j = 0, len = ref.length; j < len; j++) {
						option_group = ref[j];
						option_group = jQuery(option_group);
						container = jQuery('<ul></ul>');
						container.append(
							jQuery(
								"<li class='group_title'>" +
									option_group.attr('label') +
									'</li>'
							)
						);
						target_container.append(
							jQuery("<li class='group'>").append(container)
						);
						this.recursively_parse_option_groups(option_group, container);
					}
					ref1 = function () {
						var l, len1, ref1, results1;
						ref1 = scoped_dom.children('option');
						results1 = [];
						for (l = 0, len1 = ref1.length; l < len1; l++) {
							option = ref1[l];
							results1.push(new ImagePickerOption(option, this, this.opts));
						}
						return results1;
					}.call(this);
					results = [];
					for (k = 0, len1 = ref1.length; k < len1; k++) {
						option = ref1[k];
						this.picker_options.push(option);
						if (!option.has_image()) {
							continue;
						}
						results.push(target_container.append(option.node));
					}
					return results;
				},
			},
			{
				key: 'has_implicit_blanks',
				value: function has_implicit_blanks() {
					var option;
					return (
						function () {
							var j, len, ref, results;
							ref = this.picker_options;
							results = [];
							for (j = 0, len = ref.length; j < len; j++) {
								option = ref[j];
								if (option.is_blank() && !option.has_image()) {
									results.push(option);
								}
							}
							return results;
						}.call(this).length > 0
					);
				},
			},
			{
				key: 'selected_values',
				value: function selected_values() {
					if (this.multiple) {
						return this.select.val() || [];
					} else {
						return [this.select.val()];
					}
				},
			},
			{
				key: 'toggle',
				value: function toggle(imagepicker_option, original_event) {
					var new_values, old_values, selected_value;
					old_values = this.selected_values();
					selected_value = imagepicker_option.value().toString();
					if (this.multiple) {
						if (indexOf.call(this.selected_values(), selected_value) >= 0) {
							new_values = this.selected_values();
							new_values.splice(jQuery.inArray(selected_value, old_values), 1);
							this.select.val([]);
							this.select.val(new_values);
						} else {
							if (
								this.opts.limit != null &&
								this.selected_values().length >= this.opts.limit
							) {
								if (this.opts.limit_reached != null) {
									this.opts.limit_reached.call(this.select);
								}
							} else {
								this.select.val(this.selected_values().concat(selected_value));
							}
						}
					} else {
						if (
							this.has_implicit_blanks() &&
							imagepicker_option.is_selected()
						) {
							this.select.val('');
						} else {
							this.select.val(selected_value);
						}
					}
					if (!both_array_are_equal(old_values, this.selected_values())) {
						this.select.change();
						if (this.opts.changed != null) {
							return this.opts.changed.call(
								this.select,
								old_values,
								this.selected_values(),
								original_event
							);
						}
					}
				},
			},
		]);

		return ImagePicker;
	})();

	ImagePickerOption = (function () {
		function ImagePickerOption(option_element, picker) {
			var opts1 =
				arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

			_classCallCheck(this, ImagePickerOption);

			this.clicked = this.clicked.bind(this);
			this.picker = picker;
			this.opts = opts1;
			this.option = jQuery(option_element);
			this.create_node();
		}

		_createClass(ImagePickerOption, [
			{
				key: 'destroy',
				value: function destroy() {
					return this.node.find('.thumbnail').off('click', this.clicked);
				},
			},
			{
				key: 'has_image',
				value: function has_image() {
					return this.option.data('img-src') != null;
				},
			},
			{
				key: 'is_blank',
				value: function is_blank() {
					return !(this.value() != null && this.value() !== '');
				},
			},
			{
				key: 'is_selected',
				value: function is_selected() {
					var select_value;
					select_value = this.picker.select.val();
					if (this.picker.multiple) {
						return jQuery.inArray(this.value(), select_value) >= 0;
					} else {
						return this.value() === select_value;
					}
				},
			},
			{
				key: 'mark_as_selected',
				value: function mark_as_selected() {
					return this.node.find('.thumbnail').addClass('selected');
				},
			},
			{
				key: 'unmark_as_selected',
				value: function unmark_as_selected() {
					return this.node.find('.thumbnail').removeClass('selected');
				},
			},
			{
				key: 'value',
				value: function value() {
					return this.option.val();
				},
			},
			{
				key: 'label',
				value: function label() {
					if (this.option.data('img-label')) {
						return this.option.data('img-label');
					} else {
						return this.option.text();
					}
				},
			},
			{
				key: 'clicked',
				value: function clicked(event) {
					this.picker.toggle(this, event);
					if (this.opts.clicked != null) {
						this.opts.clicked.call(this.picker.select, this, event);
					}
					if (this.opts.selected != null && this.is_selected()) {
						return this.opts.selected.call(this.picker.select, this, event);
					}
				},
			},
			{
				key: 'create_node',
				value: function create_node() {
					var image, imgAlt, imgClass, thumbnail;
					this.node = jQuery('<li/>');
					// font-awesome support
					if (this.option.data('font_awesome')) {
						image = jQuery('<i>');
						image.attr('class', 'fa-fw ' + this.option.data('img-src'));
					} else {
						image = jQuery("<img class='image_picker_image'/>");
						image.attr('src', this.option.data('img-src'));
					}
					thumbnail = jQuery("<div class='thumbnail'>");
					// Add custom class
					imgClass = this.option.data('img-class');
					if (imgClass) {
						this.node.addClass(imgClass);
						image.addClass(imgClass);
						thumbnail.addClass(imgClass);
					}
					// Add image alt
					imgAlt = this.option.data('img-alt');
					if (imgAlt) {
						image.attr('alt', imgAlt);
					}
					thumbnail.on('click', this.clicked);
					thumbnail.append(image);
					if (this.opts.show_label) {
						thumbnail.append(jQuery('<p/>').html(this.label()));
					}
					this.node.append(thumbnail);
					return this.node;
				},
			},
		]);

		return ImagePickerOption;
	})();
}.call(undefined));

/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

var fabric = fabric || { version: '5.2.0' };
if (typeof exports !== 'undefined') {
  exports.fabric = fabric;
}
/* _AMD_START_ */
else if (typeof define === 'function' && define.amd) {
  define([], function() { return fabric; });
}
/* _AMD_END_ */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  if (document instanceof (typeof HTMLDocument !== 'undefined' ? HTMLDocument : Document)) {
    fabric.document = document;
  }
  else {
    fabric.document = document.implementation.createHTMLDocument('');
  }
  fabric.window = window;
}
else {
  // assume we're running under node.js when document/window are not present
  var jsdom = require('jsdom');
  var virtualWindow = new jsdom.JSDOM(
    decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
    {
      features: {
        FetchExternalResources: ['img']
      },
      resources: 'usable'
    }).window;
  fabric.document = virtualWindow.document;
  fabric.jsdomImplForWrapper = require('jsdom/lib/jsdom/living/generated/utils').implForWrapper;
  fabric.nodeCanvas = require('jsdom/lib/jsdom/utils').Canvas;
  fabric.window = virtualWindow;
  DOMParser = fabric.window.DOMParser;
}

/**
 * True when in environment that supports touch events
 * @type boolean
 */
fabric.isTouchSupported = 'ontouchstart' in fabric.window || 'ontouchstart' in fabric.document ||
  (fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0);

/**
 * True when in environment that's probably Node.js
 * @type boolean
 */
fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                      typeof window === 'undefined';

/* _FROM_SVG_START_ */
/**
 * Attributes parsed from all SVG elements
 * @type array
 */
fabric.SHARED_ATTRIBUTES = [
  'display',
  'transform',
  'fill', 'fill-opacity', 'fill-rule',
  'opacity',
  'stroke', 'stroke-dasharray', 'stroke-linecap', 'stroke-dashoffset',
  'stroke-linejoin', 'stroke-miterlimit',
  'stroke-opacity', 'stroke-width',
  'id', 'paint-order', 'vector-effect',
  'instantiated_by_use', 'clip-path',
];
/* _FROM_SVG_END_ */

/**
 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
 */
fabric.DPI = 96;
fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)';
fabric.commaWsp = '(?:\\s+,?\\s*|,\\s*)';
fabric.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig;
fabric.reNonWord = /[ \n\.,;!\?\-]/;
fabric.fontPaths = { };
fabric.iMatrix = [1, 0, 0, 1, 0, 0];
fabric.svgNS = 'http://www.w3.org/2000/svg';

/**
 * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.perfLimitSizeTotal = 2097152;

/**
 * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.maxCacheSideLimit = 4096;

/**
 * Lowest pixel limit for cache canvases, set at 256PX
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.minCacheSideLimit = 256;

/**
 * Cache Object for widths of chars in text rendering.
 */
fabric.charWidthsCache = { };

/**
 * if webgl is enabled and available, textureSize will determine the size
 * of the canvas backend
 * @since 2.0.0
 * @type Number
 * @default
 */
fabric.textureSize = 2048;

/**
 * When 'true', style information is not retained when copy/pasting text, making
 * pasted text use destination style.
 * Defaults to 'false'.
 * @type Boolean
 * @default
 */
fabric.disableStyleCopyPaste = false;

/**
 * Enable webgl for filtering picture is available
 * A filtering backend will be initialized, this will both take memory and
 * time since a default 2048x2048 canvas will be created for the gl context
 * @since 2.0.0
 * @type Boolean
 * @default
 */
fabric.enableGLFiltering = true;

/**
 * Device Pixel Ratio
 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
 */
fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                          fabric.window.webkitDevicePixelRatio ||
                          fabric.window.mozDevicePixelRatio ||
                          1;
/**
 * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
 * which is unitless and not rendered equally across browsers.
 *
 * Values that work quite well (as of October 2017) are:
 * - Chrome: 1.5
 * - Edge: 1.75
 * - Firefox: 0.9
 * - Safari: 0.95
 *
 * @since 2.0.0
 * @type Number
 * @default 1
 */
fabric.browserShadowBlurConstant = 1;

/**
 * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.arcToSegmentsCache = { };

/**
 * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.
 * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing
 * you do not get any speed benefit and you get a big object in memory.
 * The object was a private variable before, while now is appended to the lib so that you have access to it and you
 * can eventually clear it.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.boundsOfCurveCache = { };

/**
 * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better
 * @default true
 */
fabric.cachesBoundsOfCurve = true;

/**
 * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on
 * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true
 * this has to be set before instantiating the filtering backend ( before filtering the first image )
 * @type Boolean
 * @default false
 */
fabric.forceGLPutImageData = false;

fabric.initFilterBackend = function() {
  if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
    console.log('max texture size: ' + fabric.maxTextureSize);
    return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
  }
  else if (fabric.Canvas2dFilterBackend) {
    return (new fabric.Canvas2dFilterBackend());
  }
};
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
  window.fabric = fabric;
}
/*:
	----------------------------------------------------
	event.js : 1.1.5 : 2014/02/12 : MIT License
	----------------------------------------------------
	https://github.com/mudcube/Event.js
	----------------------------------------------------
	1  : click, dblclick, dbltap
	1+ : tap, longpress, drag, swipe
	2+ : pinch, rotate
	   : mousewheel, devicemotion, shake
	----------------------------------------------------
	Ideas for the future
	----------------------------------------------------
	* GamePad, and other input abstractions.
	* Event batching - i.e. for every x fingers down a new gesture is created.
	----------------------------------------------------
	http://www.w3.org/TR/2011/WD-touch-events-20110505/
	----------------------------------------------------
*/

if (typeof(eventjs) === "undefined") var eventjs = {};

(function(root) { "use strict";

// Add custom *EventListener commands to HTMLElements (set false to prevent funkiness).
root.modifyEventListener = false;

// Add bulk *EventListener commands on NodeLists from querySelectorAll and others  (set false to prevent funkiness).
root.modifySelectors = false;

root.configure = function(conf) {
	if (isFinite(conf.modifyEventListener)) root.modifyEventListener = conf.modifyEventListener;
	if (isFinite(conf.modifySelectors)) root.modifySelectors = conf.modifySelectors;
	/// Augment event listeners
	if (eventListenersAgumented === false && root.modifyEventListener) {
		augmentEventListeners();
	}
	if (selectorsAugmented === false && root.modifySelectors) {
		augmentSelectors();
	}
};

// Event maintenance.
root.add = function(target, type, listener, configure) {
	return eventManager(target, type, listener, configure, "add");
};

root.remove = function(target, type, listener, configure) {
	return eventManager(target, type, listener, configure, "remove");
};

root.returnFalse = function(event) {
	return false;
};

root.stop = function(event) {
	if (!event) return;
	if (event.stopPropagation) event.stopPropagation();
	event.cancelBubble = true; // <= IE8
	event.cancelBubbleCount = 0;
};

root.prevent = function(event) {
	if (!event) return;
	if (event.preventDefault) {
		event.preventDefault();
	} else if (event.preventManipulation) {
		event.preventManipulation(); // MS
	} else {
		event.returnValue = false; // <= IE8
	}
};

root.cancel = function(event) {
	root.stop(event);
	root.prevent(event);
};

root.blur = function() { // Blurs the focused element. Useful when using eventjs.cancel as canceling will prevent focused elements from being blurred.
	var node = document.activeElement;
	if (!node) return;
	var nodeName = document.activeElement.nodeName;
	if (nodeName === "INPUT" || nodeName === "TEXTAREA" || node.contentEditable === "true") {
		if (node.blur) node.blur();
	}
};

// Check whether event is natively supported (via @kangax)
root.getEventSupport = function (target, type) {
	if (typeof(target) === "string") {
		type = target;
		target = window;
	}
	type = "on" + type;
	if (type in target) return true;
	if (!target.setAttribute) target = document.createElement("div");
	if (target.setAttribute && target.removeAttribute) {
		target.setAttribute(type, "");
		var isSupported = typeof target[type] === "function";
		if (typeof target[type] !== "undefined") target[type] = null;
		target.removeAttribute(type);
		return isSupported;
	}
};

var clone = function (obj) {
	if (!obj || typeof (obj) !== 'object') return obj;
	var temp = new obj.constructor();
	for (var key in obj) {
		if (!obj[key] || typeof (obj[key]) !== 'object') {
			temp[key] = obj[key];
		} else { // clone sub-object
			temp[key] = clone(obj[key]);
		}
	}
	return temp;
};

/// Handle custom *EventListener commands.
var eventManager = function(target, type, listener, configure, trigger, fromOverwrite) {
	configure = configure || {};
	// Check whether target is a configuration variable;
	if (String(target) === "[object Object]") {
		var data = target;
		target = data.target; delete data.target;
		///
		if (data.type && data.listener) {
			type = data.type; delete data.type;
			listener = data.listener; delete data.listener;
			for (var key in data) {
				configure[key] = data[key];
			}
		} else { // specialness
			for (var param in data) {
				var value = data[param];
				if (typeof(value) === "function") continue;
				configure[param] = value;
			}
			///
			var ret = {};
			for (var key in data) {
				var param = key.split(",");
				var o = data[key];
				var conf = {};
				for (var k in configure) { // clone base configuration
					conf[k] = configure[k];
				}
				///
				if (typeof(o) === "function") { // without configuration
					var listener = o;
				} else if (typeof(o.listener) === "function") { // with configuration
					var listener = o.listener;
					for (var k in o) { // merge configure into base configuration
						if (typeof(o[k]) === "function") continue;
						conf[k] = o[k];
					}
				} else { // not a listener
					continue;
				}
				///
				for (var n = 0; n < param.length; n ++) {
					ret[key] = eventjs.add(target, param[n], listener, conf, trigger);
				}
			}
			return ret;
		}
	}
	///
	if (!target || !type || !listener) return;
	// Check for element to load on interval (before onload).
	if (typeof(target) === "string" && type === "ready") {
		if (window.eventjs_stallOnReady) { /// force stall for scripts to load
			type = "load";
			target = window;
		} else { //
			var time = (new Date()).getTime();
			var timeout = configure.timeout;
			var ms = configure.interval || 1000 / 60;
			var interval = window.setInterval(function() {
				if ((new Date()).getTime() - time > timeout) {
					window.clearInterval(interval);
				}
				if (document.querySelector(target)) {
					window.clearInterval(interval);
					setTimeout(listener, 1);
				}
			}, ms);
			return;
		}
	}
	// Get DOM element from Query Selector.
	if (typeof(target) === "string") {
		target = document.querySelectorAll(target);
		if (target.length === 0) return createError("Missing target on listener!", arguments); // No results.
		if (target.length === 1) { // Single target.
			target = target[0];
		}
	}

	/// Handle multiple targets.
	var event;
	var events = {};
	if (target.length > 0 && target !== window) {
		for (var n0 = 0, length0 = target.length; n0 < length0; n0 ++) {
			event = eventManager(target[n0], type, listener, clone(configure), trigger);
			if (event) events[n0] = event;
		}
		return createBatchCommands(events);
	}

	/// Check for multiple events in one string.
	if (typeof(type) === "string") {
		type = type.toLowerCase();
		if (type.indexOf(" ") !== -1) {
			type = type.split(" ");
		} else if (type.indexOf(",") !== -1) {
			type = type.split(",");
		}
	}

	/// Attach or remove multiple events associated with a target.
	if (typeof(type) !== "string") { // Has multiple events.
		if (typeof(type.length) === "number") { // Handle multiple listeners glued together.
			for (var n1 = 0, length1 = type.length; n1 < length1; n1 ++) { // Array [type]
				event = eventManager(target, type[n1], listener, clone(configure), trigger);
				if (event) events[type[n1]] = event;
			}
		} else { // Handle multiple listeners.
			for (var key in type) { // Object {type}
				if (typeof(type[key]) === "function") { // without configuration.
					event = eventManager(target, key, type[key], clone(configure), trigger);
				} else { // with configuration.
					event = eventManager(target, key, type[key].listener, clone(type[key]), trigger);
				}
				if (event) events[key] = event;
			}
		}
		return createBatchCommands(events);
	} else if (type.indexOf("on") === 0) { // to support things like "onclick" instead of "click"
		type = type.slice(2);
	}

	// Ensure listener is a function.
	if (typeof(target) !== "object") return createError("Target is not defined!", arguments);
	if (typeof(listener) !== "function") return createError("Listener is not a function!", arguments);

	// Generate a unique wrapper identifier.
	var useCapture = configure.useCapture || false;
	var id = getID(target) + "." + getID(listener) + "." + (useCapture ? 1 : 0);
	// Handle the event.
	if (root.Gesture && root.Gesture._gestureHandlers[type]) { // Fire custom event.
		id = type + id;
		if (trigger === "remove") { // Remove event listener.
			if (!wrappers[id]) return; // Already removed.
			wrappers[id].remove();
			delete wrappers[id];
		} else if (trigger === "add") { // Attach event listener.
			if (wrappers[id]) {
				wrappers[id].add();
				return wrappers[id]; // Already attached.
			}
			// Retains "this" orientation.
			if (configure.useCall && !root.modifyEventListener) {
				var tmp = listener;
				listener = function(event, self) {
					for (var key in self) event[key] = self[key];
					return tmp.call(target, event);
				};
			}
			// Create listener proxy.
			configure.gesture = type;
			configure.target = target;
			configure.listener = listener;
			configure.fromOverwrite = fromOverwrite;
			// Record wrapper.
			wrappers[id] = root.proxy[type](configure);
		}
		return wrappers[id];
	} else { // Fire native event.
		var eventList = getEventList(type);
		for (var n = 0, eventId; n < eventList.length; n ++) {
			type = eventList[n];
			eventId = type + "." + id;
			if (trigger === "remove") { // Remove event listener.
				if (!wrappers[eventId]) continue; // Already removed.
				target[remove](type, listener, useCapture);
				delete wrappers[eventId];
			} else if (trigger === "add") { // Attach event listener.
				if (wrappers[eventId]) return wrappers[eventId]; // Already attached.
				target[add](type, listener, useCapture);
				// Record wrapper.
				wrappers[eventId] = {
					id: eventId,
					type: type,
					target: target,
					listener: listener,
					remove: function() {
						for (var n = 0; n < eventList.length; n ++) {
							root.remove(target, eventList[n], listener, configure);
						}
					}
				};
			}
		}
		return wrappers[eventId];
	}
};

/// Perform batch actions on multiple events.
var createBatchCommands = function(events) {
	return {
		remove: function() { // Remove multiple events.
			for (var key in events) {
				events[key].remove();
			}
		},
		add: function() { // Add multiple events.
			for (var key in events) {
				events[key].add();
			}
		}
	};
};

/// Display error message in console.
var createError = function(message, data) {
	if (typeof(console) === "undefined") return;
	if (typeof(console.error) === "undefined") return;
	console.error(message, data);
};

/// Handle naming discrepancies between platforms.
var pointerDefs = {
	"msPointer": [ "MSPointerDown", "MSPointerMove", "MSPointerUp" ],
	"touch": [ "touchstart", "touchmove", "touchend" ],
	"mouse": [ "mousedown", "mousemove", "mouseup" ]
};

var pointerDetect = {
	// MSPointer
	"MSPointerDown": 0,
	"MSPointerMove": 1,
	"MSPointerUp": 2,
	// Touch
	"touchstart": 0,
	"touchmove": 1,
	"touchend": 2,
	// Mouse
	"mousedown": 0,
	"mousemove": 1,
	"mouseup": 2
};

var getEventSupport = (function() {
	root.supports = {};
	if (window.navigator.msPointerEnabled) {
		root.supports.msPointer = true;
	}
	if (root.getEventSupport("touchstart")) {
		root.supports.touch = true;
	}
	if (root.getEventSupport("mousedown")) {
		root.supports.mouse = true;
	}
})();

var getEventList = (function() {
	return function(type) {
		var prefix = document.addEventListener ? "" : "on"; // IE
		var idx = pointerDetect[type];
		if (isFinite(idx)) {
			var types = [];
			for (var key in root.supports) {
				types.push(prefix + pointerDefs[key][idx]);
			}
			return types;
		} else {
			return [ prefix + type ];
		}
	};
})();

/// Event wrappers to keep track of all events placed in the window.
var wrappers = {};
var counter = 0;
var getID = function(object) {
	if (object === window) return "#window";
	if (object === document) return "#document";
	if (!object.uniqueID) object.uniqueID = "e" + counter ++;
	return object.uniqueID;
};

/// Detect platforms native *EventListener command.
var add = document.addEventListener ? "addEventListener" : "attachEvent";
var remove = document.removeEventListener ? "removeEventListener" : "detachEvent";

/*
	Pointer.js
	----------------------------------------
	Modified from; https://github.com/borismus/pointer.js
*/

root.createPointerEvent = function (event, self, preventRecord) {
	var eventName = self.gesture;
	var target = self.target;
	var pts = event.changedTouches || root.proxy.getCoords(event);
	if (pts.length) {
		var pt = pts[0];
		self.pointers = preventRecord ? [] : pts;
		self.pageX = pt.pageX;
		self.pageY = pt.pageY;
		self.x = self.pageX;
		self.y = self.pageY;
	}
	///
	var newEvent = document.createEvent("Event");
	newEvent.initEvent(eventName, true, true);
	newEvent.originalEvent = event;
	for (var k in self) {
		if (k === "target") continue;
		newEvent[k] = self[k];
	}
	///
	var type = newEvent.type;
	if (root.Gesture && root.Gesture._gestureHandlers[type]) { // capture custom events.
//		target.dispatchEvent(newEvent);
		self.oldListener.call(target, newEvent, self, false);
	}
};

var eventListenersAgumented = false;
var augmentEventListeners = function() {
	/// Allows *EventListener to use custom event proxies.
	if (!window.HTMLElement) return;
	var augmentEventListener = function(proto) {
		var recall = function(trigger) { // overwrite native *EventListener's
			var handle = trigger + "EventListener";
			var handler = proto[handle];
			proto[handle] = function (type, listener, useCapture) {
				if (root.Gesture && root.Gesture._gestureHandlers[type]) { // capture custom events.
					var configure = useCapture;
					if (typeof(useCapture) === "object") {
						configure.useCall = true;
					} else { // convert to configuration object.
						configure = {
							useCall: true,
							useCapture: useCapture
						};
					}
					eventManager(this, type, listener, configure, trigger, true);
//					handler.call(this, type, listener, useCapture);
				} else { // use native function.
					var types = getEventList(type);
					for (var n = 0; n < types.length; n ++) {
						handler.call(this, types[n], listener, useCapture);
					}
				}
			};
		};
		recall("add");
		recall("remove");
	};
	// NOTE: overwriting HTMLElement doesn't do anything in Firefox.
	if (navigator.userAgent.match(/Firefox/)) {
		// TODO: fix Firefox for the general case.
		augmentEventListener(HTMLDivElement.prototype);
		augmentEventListener(HTMLCanvasElement.prototype);
	} else {
		augmentEventListener(HTMLElement.prototype);
	}
	augmentEventListener(document);
	augmentEventListener(window);
};

var selectorsAugmented = false;
var augmentSelectors = function() {
/// Allows querySelectorAll and other NodeLists to perform *EventListener commands in bulk.
	var proto = NodeList.prototype;
	proto.removeEventListener = function(type, listener, useCapture) {
		for (var n = 0, length = this.length; n < length; n ++) {
			this[n].removeEventListener(type, listener, useCapture);
		}
	};
	proto.addEventListener = function(type, listener, useCapture) {
		for (var n = 0, length = this.length; n < length; n ++) {
			this[n].addEventListener(type, listener, useCapture);
		}
	};
};

return root;

})(eventjs);

/*:
	----------------------------------------------------
	eventjs.proxy : 0.4.2 : 2013/07/17 : MIT License
	----------------------------------------------------
	https://github.com/mudcube/eventjs.js
	----------------------------------------------------
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

/*
	Create a new pointer gesture instance.
*/

root.pointerSetup = function(conf, self) {
	/// Configure.
	conf.target = conf.target || window;
	conf.doc = conf.target.ownerDocument || conf.target; // Associated document.
	conf.minFingers = conf.minFingers || conf.fingers || 1; // Minimum required fingers.
	conf.maxFingers = conf.maxFingers || conf.fingers || Infinity; // Maximum allowed fingers.
	conf.position = conf.position || "relative"; // Determines what coordinate system points are returned.
	delete conf.fingers; //-
	/// Convenience data.
	self = self || {};
	self.enabled = true;
	self.gesture = conf.gesture;
	self.target = conf.target;
	self.env = conf.env;
	///
	if (eventjs.modifyEventListener && conf.fromOverwrite) {
		conf.oldListener = conf.listener;
		conf.listener = eventjs.createPointerEvent;
	}
	/// Convenience commands.
	var fingers = 0;
	var type = self.gesture.indexOf("pointer") === 0 && eventjs.modifyEventListener ? "pointer" : "mouse";
	if (conf.oldListener) self.oldListener = conf.oldListener;
	///
	self.listener = conf.listener;
	self.proxy = function(listener) {
		self.defaultListener = conf.listener;
		conf.listener = listener;
		listener(conf.event, self);
	};
	self.add = function() {
		if (self.enabled === true) return;
		if (conf.onPointerDown) eventjs.add(conf.target, type + "down", conf.onPointerDown);
		if (conf.onPointerMove) eventjs.add(conf.doc, type + "move", conf.onPointerMove);
		if (conf.onPointerUp) eventjs.add(conf.doc, type + "up", conf.onPointerUp);
		self.enabled = true;
	};
	self.remove = function() {
		if (self.enabled === false) return;
		if (conf.onPointerDown) eventjs.remove(conf.target, type + "down", conf.onPointerDown);
		if (conf.onPointerMove) eventjs.remove(conf.doc, type + "move", conf.onPointerMove);
		if (conf.onPointerUp) eventjs.remove(conf.doc, type + "up", conf.onPointerUp);
		self.reset();
		self.enabled = false;
	};
	self.pause = function(opt) {
		if (conf.onPointerMove && (!opt || opt.move)) eventjs.remove(conf.doc, type + "move", conf.onPointerMove);
		if (conf.onPointerUp && (!opt || opt.up)) eventjs.remove(conf.doc, type + "up", conf.onPointerUp);
		fingers = conf.fingers;
		conf.fingers = 0;
	};
	self.resume = function(opt) {
		if (conf.onPointerMove && (!opt || opt.move)) eventjs.add(conf.doc, type + "move", conf.onPointerMove);
		if (conf.onPointerUp && (!opt || opt.up)) eventjs.add(conf.doc, type + "up", conf.onPointerUp);
		conf.fingers = fingers;
	};
	self.reset = function() {
		conf.tracker = {};
		conf.fingers = 0;
	};
	///
	return self;
};

/*
	Begin proxied pointer command.
*/

var sp = eventjs.supports; // Default pointerType
///
eventjs.isMouse = !!sp.mouse;
eventjs.isMSPointer = !!sp.touch;
eventjs.isTouch = !!sp.msPointer;
///
root.pointerStart = function(event, self, conf) {
	/// tracks multiple inputs
	var type = (event.type || "mousedown").toUpperCase();
	if (type.indexOf("MOUSE") === 0) {
		eventjs.isMouse = true;
		eventjs.isTouch = false;
		eventjs.isMSPointer = false;
	} else if (type.indexOf("TOUCH") === 0) {
		eventjs.isMouse = false;
		eventjs.isTouch = true;
		eventjs.isMSPointer = false;
	} else if (type.indexOf("MSPOINTER") === 0) {
		eventjs.isMouse = false;
		eventjs.isTouch = false;
		eventjs.isMSPointer = true;
	}
	///
	var addTouchStart = function(touch, sid) {
		var bbox = conf.bbox;
		var pt = track[sid] = {};
		///
		switch(conf.position) {
			case "absolute": // Absolute from within window.
				pt.offsetX = 0;
				pt.offsetY = 0;
				break;
			case "differenceFromLast": // Since last coordinate recorded.
				pt.offsetX = touch.pageX;
				pt.offsetY = touch.pageY;
				break;
			case "difference": // Relative from origin.
				pt.offsetX = touch.pageX;
				pt.offsetY = touch.pageY;
				break;
			case "move": // Move target element.
				pt.offsetX = touch.pageX - bbox.x1;
				pt.offsetY = touch.pageY - bbox.y1;
				break;
			default: // Relative from within target.
				pt.offsetX = bbox.x1 - bbox.scrollLeft;
				pt.offsetY = bbox.y1 - bbox.scrollTop;
				break;
		}
		///
		var x = touch.pageX - pt.offsetX;
		var y = touch.pageY - pt.offsetY;
		///
		pt.rotation = 0;
		pt.scale = 1;
		pt.startTime = pt.moveTime = (new Date()).getTime();
		pt.move = { x: x, y: y };
		pt.start = { x: x, y: y };
		///
		conf.fingers ++;
	};
	///
	conf.event = event;
	if (self.defaultListener) {
		conf.listener = self.defaultListener;
		delete self.defaultListener;
	}
	///
	var isTouchStart = !conf.fingers;
	var track = conf.tracker;
	var touches = event.changedTouches || root.getCoords(event);
	var length = touches.length;
	// Adding touch events to tracking.
	for (var i = 0; i < length; i ++) {
		var touch = touches[i];
		var sid = touch.identifier || Infinity; // Touch ID.
		// Track the current state of the touches.
		if (conf.fingers) {
			if (conf.fingers >= conf.maxFingers) {
				var ids = [];
				for (var sid in conf.tracker) ids.push(sid);
				self.identifier = ids.join(",");
				return isTouchStart;
			}
			var fingers = 0; // Finger ID.
			for (var rid in track) {
				// Replace removed finger.
				if (track[rid].up) {
					delete track[rid];
					addTouchStart(touch, sid);
					conf.cancel = true;
					break;
				}
				fingers ++;
			}
			// Add additional finger.
			if (track[sid]) continue;
			addTouchStart(touch, sid);
		} else { // Start tracking fingers.
			track = conf.tracker = {};
			self.bbox = conf.bbox = root.getBoundingBox(conf.target);
			conf.fingers = 0;
			conf.cancel = false;
			addTouchStart(touch, sid);
		}
	}
	///
	var ids = [];
	for (var sid in conf.tracker) ids.push(sid);
	self.identifier = ids.join(",");
	///
	return isTouchStart;
};

/*
	End proxied pointer command.
*/

root.pointerEnd = function(event, self, conf, onPointerUp) {
	// Record changed touches have ended (iOS changedTouches is not reliable).
	var touches = event.touches || [];
	var length = touches.length;
	var exists = {};
	for (var i = 0; i < length; i ++) {
		var touch = touches[i];
		var sid = touch.identifier;
		exists[sid || Infinity] = true;
	}
	for (var sid in conf.tracker) {
		var track = conf.tracker[sid];
		if (exists[sid] || track.up) continue;
		if (onPointerUp) { // add changedTouches to mouse.
			onPointerUp({
				pageX: track.pageX,
				pageY: track.pageY,
				changedTouches: [{
					pageX: track.pageX,
					pageY: track.pageY,
					identifier: sid === "Infinity" ? Infinity : sid
				}]
			}, "up");
		}
		track.up = true;
		conf.fingers --;
	}
/*	// This should work but fails in Safari on iOS4 so not using it.
	var touches = event.changedTouches || root.getCoords(event);
	var length = touches.length;
	// Record changed touches have ended (this should work).
	for (var i = 0; i < length; i ++) {
		var touch = touches[i];
		var sid = touch.identifier || Infinity;
		var track = conf.tracker[sid];
		if (track && !track.up) {
			if (onPointerUp) { // add changedTouches to mouse.
				onPointerUp({
					changedTouches: [{
						pageX: track.pageX,
						pageY: track.pageY,
						identifier: sid === "Infinity" ? Infinity : sid
					}]
				}, "up");
			}
			track.up = true;
			conf.fingers --;
		}
	} */
	// Wait for all fingers to be released.
	if (conf.fingers !== 0) return false;
	// Record total number of fingers gesture used.
	var ids = [];
	conf.gestureFingers = 0;
	for (var sid in conf.tracker) {
		conf.gestureFingers ++;
		ids.push(sid);
	}
	self.identifier = ids.join(",");
	// Our pointer gesture has ended.
	return true;
};

/*
	Returns mouse coords in an array to match event.*Touches
	------------------------------------------------------------
	var touch = event.changedTouches || root.getCoords(event);
*/

root.getCoords = function(event) {
	if (typeof(event.pageX) !== "undefined") { // Desktop browsers.
		root.getCoords = function(event) {
			return Array({
				type: "mouse",
				x: event.pageX,
				y: event.pageY,
				pageX: event.pageX,
				pageY: event.pageY,
				identifier: event.pointerId || Infinity // pointerId is MS
			});
		};
	} else { // Internet Explorer <= 8.0
		root.getCoords = function(event) {
			var doc = document.documentElement;
			event = event || window.event;
			return Array({
				type: "mouse",
				x: event.clientX + doc.scrollLeft,
				y: event.clientY + doc.scrollTop,
				pageX: event.clientX + doc.scrollLeft,
				pageY: event.clientY + doc.scrollTop,
				identifier: Infinity
			});
		};
	}
	return root.getCoords(event);
};

/*
	Returns single coords in an object.
	------------------------------------------------------------
	var mouse = root.getCoord(event);
*/

root.getCoord = function(event) {
	if ("ontouchstart" in window) { // Mobile browsers.
		var pX = 0;
		var pY = 0;
		root.getCoord = function(event) {
			var touches = event.changedTouches;
			if (touches && touches.length) { // ontouchstart + ontouchmove
				return {
					x: pX = touches[0].pageX,
					y: pY = touches[0].pageY
				};
			} else { // ontouchend
				return {
					x: pX,
					y: pY
				};
			}
		};
	} else if(typeof(event.pageX) !== "undefined" && typeof(event.pageY) !== "undefined") { // Desktop browsers.
		root.getCoord = function(event) {
			return {
				x: event.pageX,
				y: event.pageY
			};
		};
	} else { // Internet Explorer <=8.0
		root.getCoord = function(event) {
			var doc = document.documentElement;
			event = event || window.event;
			return {
				x: event.clientX + doc.scrollLeft,
				y: event.clientY + doc.scrollTop
			};
		};
	}
	return root.getCoord(event);
};

/*
	Get target scale and position in space.
*/

var getPropertyAsFloat = function(o, type) {
	var n = parseFloat(o.getPropertyValue(type), 10);
	return isFinite(n) ? n : 0;
};

root.getBoundingBox = function(o) {
	if (o === window || o === document) o = document.body;
	///
	var bbox = {};
	var bcr = o.getBoundingClientRect();
	bbox.width = bcr.width;
	bbox.height = bcr.height;
	bbox.x1 = bcr.left;
	bbox.y1 = bcr.top;
	bbox.scaleX = bcr.width / o.offsetWidth || 1;
	bbox.scaleY = bcr.height / o.offsetHeight || 1;
	bbox.scrollLeft = 0;
	bbox.scrollTop = 0;
	///
	var style = window.getComputedStyle(o);
	var borderBox = style.getPropertyValue("box-sizing") === "border-box";
	///
	if (borderBox === false) {
		var left = getPropertyAsFloat(style, "border-left-width");
		var right = getPropertyAsFloat(style, "border-right-width");
		var bottom = getPropertyAsFloat(style, "border-bottom-width");
		var top = getPropertyAsFloat(style, "border-top-width");
		bbox.border = [ left, right, top, bottom ];
		bbox.x1 += left;
		bbox.y1 += top;
		bbox.width -= right + left;
		bbox.height -= bottom + top;
	}

/*	var left = getPropertyAsFloat(style, "padding-left");
	var right = getPropertyAsFloat(style, "padding-right");
	var bottom = getPropertyAsFloat(style, "padding-bottom");
	var top = getPropertyAsFloat(style, "padding-top");
	bbox.padding = [ left, right, top, bottom ];*/
	///
	bbox.x2 = bbox.x1 + bbox.width;
	bbox.y2 = bbox.y1 + bbox.height;

	/// Get the scroll of container element.
	var position = style.getPropertyValue("position");
	var tmp = position === "fixed" ? o : o.parentNode;
	while (tmp !== null) {
		if (tmp === document.body) break;
		if (tmp.scrollTop === undefined) break;
		var style = window.getComputedStyle(tmp);
		var position = style.getPropertyValue("position");
		if (position === "absolute") {

		} else if (position === "fixed") {
//			bbox.scrollTop += document.body.scrollTop;
//			bbox.scrollLeft += document.body.scrollLeft;
			bbox.scrollTop -= tmp.parentNode.scrollTop;
			bbox.scrollLeft -= tmp.parentNode.scrollLeft;
			break;
		} else {
			bbox.scrollLeft += tmp.scrollLeft;
			bbox.scrollTop += tmp.scrollTop;
		}
		///
		tmp = tmp.parentNode;
	};
	///
	bbox.scrollBodyLeft = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
	bbox.scrollBodyTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
	///
	bbox.scrollLeft -= bbox.scrollBodyLeft;
	bbox.scrollTop -= bbox.scrollBodyTop;
	///
	return bbox;
};

/*
	Keep track of metaKey, the proper ctrlKey for users platform.
	----------------------------------------------------
	http://www.quirksmode.org/js/keys.html
	-----------------------------------
	http://unixpapa.com/js/key.html
*/

(function() {
	var agent = navigator.userAgent.toLowerCase();
	var mac = agent.indexOf("macintosh") !== -1;
	var metaKeys;
	if (mac && agent.indexOf("khtml") !== -1) { // chrome, safari.
		metaKeys = { 91: true, 93: true };
	} else if (mac && agent.indexOf("firefox") !== -1) {  // mac firefox.
		metaKeys = { 224: true };
	} else { // windows, linux, or mac opera.
		metaKeys = { 17: true };
	}
	(root.metaTrackerReset = function() {
		eventjs.fnKey = root.fnKey = false;
		eventjs.metaKey = root.metaKey = false;
		eventjs.escKey = root.escKey = false;
		eventjs.ctrlKey = root.ctrlKey = false;
		eventjs.shiftKey = root.shiftKey = false;
		eventjs.altKey = root.altKey = false;
	})();
	root.metaTracker = function(event) {
		var isKeyDown = event.type === "keydown";
		if (event.keyCode === 27) eventjs.escKey = root.escKey = isKeyDown;
		if (metaKeys[event.keyCode]) eventjs.metaKey = root.metaKey = isKeyDown;
		eventjs.ctrlKey = root.ctrlKey = event.ctrlKey;
		eventjs.shiftKey = root.shiftKey = event.shiftKey;
		eventjs.altKey = root.altKey = event.altKey;
	};
})();

return root;

})(eventjs.proxy);
/*:
	----------------------------------------------------
	"MutationObserver" event proxy.
	----------------------------------------------------
	author: Selvakumar Arumugam - MIT LICENSE
	   src: http://stackoverflow.com/questions/10868104/can-you-have-a-javascript-hook-trigger-after-a-dom-elements-style-object-change
	----------------------------------------------------
*/
if (typeof(eventjs) === "undefined") var eventjs = {};

eventjs.MutationObserver = (function() {
	var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
	var DOMAttrModifiedSupported = !MutationObserver && (function() {
		var p = document.createElement("p");
		var flag = false;
		var fn = function() { flag = true };
		if (p.addEventListener) {
			p.addEventListener("DOMAttrModified", fn, false);
		} else if (p.attachEvent) {
			p.attachEvent("onDOMAttrModified", fn);
		} else {
			return false;
		}
		///
		p.setAttribute("id", "target");
		///
		return flag;
	})();
	///
	return function(container, callback) {
		if (MutationObserver) {
			var options = {
				subtree: false,
				attributes: true
			};
			var observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(e) {
					callback.call(e.target, e.attributeName);
				});
			});
			observer.observe(container, options)
		} else if (DOMAttrModifiedSupported) {
			eventjs.add(container, "DOMAttrModified", function(e) {
				callback.call(container, e.attrName);
			});
		} else if ("onpropertychange" in document.body) {
			eventjs.add(container, "propertychange", function(e) {
				callback.call(container, window.event.propertyName);
			});
		}
	}
})();
/*:
	"Click" event proxy.
	----------------------------------------------------
	eventjs.add(window, "click", function(event, self) {});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.click = function(conf) {
	conf.gesture = conf.gesture || "click";
	conf.maxFingers = conf.maxFingers || conf.fingers || 1;
	/// Tracking the events.
	conf.onPointerDown = function (event) {
		if (root.pointerStart(event, self, conf)) {
			eventjs.add(conf.target, "mouseup", conf.onPointerUp);
		}
	};
	conf.onPointerUp = function(event) {
		if (root.pointerEnd(event, self, conf)) {
			eventjs.remove(conf.target, "mouseup", conf.onPointerUp);
			var pointers = event.changedTouches || root.getCoords(event);
			var pointer = pointers[0];
			var bbox = conf.bbox;
			var newbbox = root.getBoundingBox(conf.target);
			var y = pointer.pageY - newbbox.scrollBodyTop;
			var x = pointer.pageX - newbbox.scrollBodyLeft;
			////
			if (x > bbox.x1 && y > bbox.y1 &&
				x < bbox.x2 && y < bbox.y2 &&
				bbox.scrollTop === newbbox.scrollTop) { // has not been scrolled
				///
				for (var key in conf.tracker) break; //- should be modularized? in dblclick too
				var point = conf.tracker[key];
				self.x = point.start.x;
				self.y = point.start.y;
				///
				conf.listener(event, self);
			}
		}
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	self.state = "click";
	// Attach events.
	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.click = root.click;

return root;

})(eventjs.proxy);
/*:
	"Double-Click" aka "Double-Tap" event proxy.
	----------------------------------------------------
	eventjs.add(window, "dblclick", function(event, self) {});
	----------------------------------------------------
	Touch an target twice for <= 700ms, with less than 25 pixel drift.
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.dbltap =
root.dblclick = function(conf) {
	conf.gesture = conf.gesture || "dbltap";
	conf.maxFingers = conf.maxFingers || conf.fingers || 1;
	// Setting up local variables.
	var delay = 700; // in milliseconds
	var time0, time1, timeout;
	var pointer0, pointer1;
	// Tracking the events.
	conf.onPointerDown = function (event) {
		var pointers = event.changedTouches || root.getCoords(event);
		if (time0 && !time1) { // Click #2
			pointer1 = pointers[0];
			time1 = (new Date()).getTime() - time0;
		} else { // Click #1
			pointer0 = pointers[0];
			time0 = (new Date()).getTime();
			time1 = 0;
			clearTimeout(timeout);
			timeout = setTimeout(function() {
				time0 = 0;
			}, delay);
		}
		if (root.pointerStart(event, self, conf)) {
			eventjs.add(conf.target, "mousemove", conf.onPointerMove).listener(event);
			eventjs.add(conf.target, "mouseup", conf.onPointerUp);
		}
	};
	conf.onPointerMove = function (event) {
		if (time0 && !time1) {
			var pointers = event.changedTouches || root.getCoords(event);
			pointer1 = pointers[0];
		}
		var bbox = conf.bbox;
		var ax = (pointer1.pageX - bbox.x1);
		var ay = (pointer1.pageY - bbox.y1);
		if (!(ax > 0 && ax < bbox.width && // Within target coordinates..
			  ay > 0 && ay < bbox.height &&
			  Math.abs(pointer1.pageX - pointer0.pageX) <= 25 && // Within drift deviance.
			  Math.abs(pointer1.pageY - pointer0.pageY) <= 25)) {
			// Cancel out this listener.
			eventjs.remove(conf.target, "mousemove", conf.onPointerMove);
			clearTimeout(timeout);
			time0 = time1 = 0;
		}
	};
	conf.onPointerUp = function(event) {
		if (root.pointerEnd(event, self, conf)) {
			eventjs.remove(conf.target, "mousemove", conf.onPointerMove);
			eventjs.remove(conf.target, "mouseup", conf.onPointerUp);
		}
		if (time0 && time1) {
			if (time1 <= delay) { // && !(event.cancelBubble && ++event.cancelBubbleCount > 1)) {
				self.state = conf.gesture;
				for (var key in conf.tracker) break;
				var point = conf.tracker[key];
				self.x = point.start.x;
				self.y = point.start.y;
				conf.listener(event, self);
			}
			clearTimeout(timeout);
			time0 = time1 = 0;
		}
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	self.state = "dblclick";
	// Attach events.
	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.dbltap = root.dbltap;
eventjs.Gesture._gestureHandlers.dblclick = root.dblclick;

return root;

})(eventjs.proxy);
/*:
	"Drag" event proxy (1+ fingers).
	----------------------------------------------------
	CONFIGURE: maxFingers, position.
	----------------------------------------------------
	eventjs.add(window, "drag", function(event, self) {
		console.log(self.gesture, self.state, self.start, self.x, self.y, self.bbox);
	});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.dragElement = function(that, event) {
	root.drag({
		event: event,
		target: that,
		position: "move",
		listener: function(event, self) {
			that.style.left = self.x + "px";
			that.style.top = self.y + "px";
			eventjs.prevent(event);
		}
	});
};

root.drag = function(conf) {
	conf.gesture = "drag";
	conf.onPointerDown = function (event) {
		if (root.pointerStart(event, self, conf)) {
			if (!conf.monitor) {
				eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			}
		}
		// Process event listener.
		conf.onPointerMove(event, "down");
	};
	conf.onPointerMove = function (event, state) {
		if (!conf.tracker) return conf.onPointerDown(event);
		var bbox = conf.bbox;
		var touches = event.changedTouches || root.getCoords(event);
		var length = touches.length;
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var identifier = touch.identifier || Infinity;
			var pt = conf.tracker[identifier];
			// Identifier defined outside of listener.
			if (!pt) continue;
			pt.pageX = touch.pageX;
			pt.pageY = touch.pageY;
			// Record data.
			self.state = state || "move";
			self.identifier = identifier;
			self.start = pt.start;
			self.fingers = conf.fingers;
			if (conf.position === "differenceFromLast") {
				self.x = (pt.pageX - pt.offsetX);
				self.y = (pt.pageY - pt.offsetY);
				pt.offsetX = pt.pageX;
				pt.offsetY = pt.pageY;
			} else {
				self.x = (pt.pageX - pt.offsetX);
				self.y = (pt.pageY - pt.offsetY);
			}
			///
			conf.listener(event, self);
		}
	};
	conf.onPointerUp = function(event) {
		// Remove tracking for touch.
		if (root.pointerEnd(event, self, conf, conf.onPointerMove)) {
			if (!conf.monitor) {
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
			}
		}
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	// Attach events.
	if (conf.event) {
		conf.onPointerDown(conf.event);
	} else { //
		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
		if (conf.monitor) {
			eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
		}
	}
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.drag = root.drag;

return root;

})(eventjs.proxy);
/*:
	"Gesture" event proxy (2+ fingers).
	----------------------------------------------------
	CONFIGURE: minFingers, maxFingers.
	----------------------------------------------------
	eventjs.add(window, "gesture", function(event, self) {
		console.log(
			self.x, // centroid
			self.y,
			self.rotation,
			self.scale,
			self.fingers,
			self.state
		);
	});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

var RAD_DEG = Math.PI / 180;
var getCentroid = function(self, points) {
	var centroidx = 0;
	var centroidy = 0;
	var length = 0;
	for (var sid in points) {
		var touch = points[sid];
		if (touch.up) continue;
		centroidx += touch.move.x;
		centroidy += touch.move.y;
		length ++;
	}
	self.x = centroidx /= length;
	self.y = centroidy /= length;
	return self;
};

root.gesture = function(conf) {
	conf.gesture = conf.gesture || "gesture";
	conf.minFingers = conf.minFingers || conf.fingers || 2;
	// Tracking the events.
	conf.onPointerDown = function (event) {
		var fingers = conf.fingers;
		if (root.pointerStart(event, self, conf)) {
			eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
		}
		// Record gesture start.
		if (conf.fingers === conf.minFingers && fingers !== conf.fingers) {
			self.fingers = conf.minFingers;
			self.scale = 1;
			self.rotation = 0;
			self.state = "start";
			var sids = ""; //- FIXME(mud): can generate duplicate IDs.
			for (var key in conf.tracker) sids += key;
			self.identifier = parseInt(sids);
			getCentroid(self, conf.tracker);
			conf.listener(event, self);
		}
	};
	///
	conf.onPointerMove = function (event, state) {
		var bbox = conf.bbox;
		var points = conf.tracker;
		var touches = event.changedTouches || root.getCoords(event);
		var length = touches.length;
		// Update tracker coordinates.
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var sid = touch.identifier || Infinity;
			var pt = points[sid];
			// Check whether "pt" is used by another gesture.
			if (!pt) continue;
			// Find the actual coordinates.
			pt.move.x = (touch.pageX - bbox.x1);
			pt.move.y = (touch.pageY - bbox.y1);
		}
		///
		if (conf.fingers < conf.minFingers) return;
		///
		var touches = [];
		var scale = 0;
		var rotation = 0;

		/// Calculate centroid of gesture.
		getCentroid(self, points);
		///
		for (var sid in points) {
			var touch = points[sid];
			if (touch.up) continue;
			var start = touch.start;
			if (!start.distance) {
				var dx = start.x - self.x;
				var dy = start.y - self.y;
				start.distance = Math.sqrt(dx * dx + dy * dy);
				start.angle = Math.atan2(dx, dy) / RAD_DEG;
			}
			// Calculate scale.
			var dx = touch.move.x - self.x;
			var dy = touch.move.y - self.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			// If touch start.distance from centroid is 0, scale should not be updated.
			// This prevents dividing by 0 in cases where start.distance is oddly 0.
			if (start.distance !== 0) {
			  scale += distance / start.distance;
			}
			// Calculate rotation.
			var angle = Math.atan2(dx, dy) / RAD_DEG;
			var rotate = (start.angle - angle + 360) % 360 - 180;
			touch.DEG2 = touch.DEG1; // Previous degree.
			touch.DEG1 = rotate > 0 ? rotate : -rotate; // Current degree.
			if (typeof(touch.DEG2) !== "undefined") {
				if (rotate > 0) {
					touch.rotation += touch.DEG1 - touch.DEG2;
				} else {
					touch.rotation -= touch.DEG1 - touch.DEG2;
				}
				rotation += touch.rotation;
			}
			// Attach current points to self.
			touches.push(touch.move);
		}
		///
		self.touches = touches;
		self.fingers = conf.fingers;
		self.scale = scale / conf.fingers;
		self.rotation = rotation / conf.fingers;
		self.state = "change";
		conf.listener(event, self);
	};
	conf.onPointerUp = function(event) {
		// Remove tracking for touch.
		var fingers = conf.fingers;
		if (root.pointerEnd(event, self, conf)) {
			eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
			eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
		}
		// Check whether fingers has dropped below minFingers.
		if (fingers === conf.minFingers && conf.fingers < conf.minFingers) {
			self.fingers = conf.fingers;
			self.state = "end";
			conf.listener(event, self);
		}
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	// Attach events.
	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.gesture = root.gesture;

return root;

})(eventjs.proxy);
/*:
	"Pointer" event proxy (1+ fingers).
	----------------------------------------------------
	CONFIGURE: minFingers, maxFingers.
	----------------------------------------------------
	eventjs.add(window, "gesture", function(event, self) {
		console.log(self.rotation, self.scale, self.fingers, self.state);
	});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.pointerdown =
root.pointermove =
root.pointerup = function(conf) {
	conf.gesture = conf.gesture || "pointer";
	if (conf.target.isPointerEmitter) return;
	// Tracking the events.
	var isDown = true;
	conf.onPointerDown = function (event) {
		isDown = false;
		self.gesture = "pointerdown";
		conf.listener(event, self);
	};
	conf.onPointerMove = function (event) {
		self.gesture = "pointermove";
		conf.listener(event, self, isDown);
	};
	conf.onPointerUp = function (event) {
		isDown = true;
		self.gesture = "pointerup";
		conf.listener(event, self, true);
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	// Attach events.
	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
	eventjs.add(conf.target, "mousemove", conf.onPointerMove);
	eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
	// Return this object.
	conf.target.isPointerEmitter = true;
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.pointerdown = root.pointerdown;
eventjs.Gesture._gestureHandlers.pointermove = root.pointermove;
eventjs.Gesture._gestureHandlers.pointerup = root.pointerup;

return root;

})(eventjs.proxy);
/*:
	"Device Motion" and "Shake" event proxy.
	----------------------------------------------------
	http://developer.android.com/reference/android/hardware/Sensoreventjs.html#values
	----------------------------------------------------
	eventjs.add(window, "shake", function(event, self) {});
	eventjs.add(window, "devicemotion", function(event, self) {
		console.log(self.acceleration, self.accelerationIncludingGravity);
	});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.shake = function(conf) {
	// Externally accessible data.
	var self = {
		gesture: "devicemotion",
		acceleration: {},
		accelerationIncludingGravity: {},
		target: conf.target,
		listener: conf.listener,
		remove: function() {
			window.removeEventListener('devicemotion', onDeviceMotion, false);
		}
	};
	// Setting up local variables.
	var threshold = 4; // Gravitational threshold.
	var timeout = 1000; // Timeout between shake events.
	var timeframe = 200; // Time between shakes.
	var shakes = 3; // Minimum shakes to trigger event.
	var lastShake = (new Date()).getTime();
	var gravity = { x: 0, y: 0, z: 0 };
	var delta = {
		x: { count: 0, value: 0 },
		y: { count: 0, value: 0 },
		z: { count: 0, value: 0 }
	};
	// Tracking the events.
	var onDeviceMotion = function(e) {
		var alpha = 0.8; // Low pass filter.
		var o = e.accelerationIncludingGravity;
		gravity.x = alpha * gravity.x + (1 - alpha) * o.x;
		gravity.y = alpha * gravity.y + (1 - alpha) * o.y;
		gravity.z = alpha * gravity.z + (1 - alpha) * o.z;
		self.accelerationIncludingGravity = gravity;
		self.acceleration.x = o.x - gravity.x;
		self.acceleration.y = o.y - gravity.y;
		self.acceleration.z = o.z - gravity.z;
		///
		if (conf.gesture === "devicemotion") {
			conf.listener(e, self);
			return;
		}
		var data = "xyz";
		var now = (new Date()).getTime();
		for (var n = 0, length = data.length; n < length; n ++) {
			var letter = data[n];
			var ACCELERATION = self.acceleration[letter];
			var DELTA = delta[letter];
			var abs = Math.abs(ACCELERATION);
			/// Check whether another shake event was recently registered.
			if (now - lastShake < timeout) continue;
			/// Check whether delta surpasses threshold.
			if (abs > threshold) {
				var idx = now * ACCELERATION / abs;
				var span = Math.abs(idx + DELTA.value);
				// Check whether last delta was registered within timeframe.
				if (DELTA.value && span < timeframe) {
					DELTA.value = idx;
					DELTA.count ++;
					// Check whether delta count has enough shakes.
					if (DELTA.count === shakes) {
						conf.listener(e, self);
						// Reset tracking.
						lastShake = now;
						DELTA.value = 0;
						DELTA.count = 0;
					}
				} else {
					// Track first shake.
					DELTA.value = idx;
					DELTA.count = 1;
				}
			}
		}
	};
	// Attach events.
	if (!window.addEventListener) return;
	window.addEventListener('devicemotion', onDeviceMotion, false);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.shake = root.shake;

return root;

})(eventjs.proxy);
/*:
	"Swipe" event proxy (1+ fingers).
	----------------------------------------------------
	CONFIGURE: snap, threshold, maxFingers.
	----------------------------------------------------
	eventjs.add(window, "swipe", function(event, self) {
		console.log(self.velocity, self.angle);
	});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

var RAD_DEG = Math.PI / 180;

root.swipe = function(conf) {
	conf.snap = conf.snap || 90; // angle snap.
	conf.threshold = conf.threshold || 1; // velocity threshold.
	conf.gesture = conf.gesture || "swipe";
	// Tracking the events.
	conf.onPointerDown = function (event) {
		if (root.pointerStart(event, self, conf)) {
			eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
		}
	};
	conf.onPointerMove = function (event) {
		var touches = event.changedTouches || root.getCoords(event);
		var length = touches.length;
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var sid = touch.identifier || Infinity;
			var o = conf.tracker[sid];
			// Identifier defined outside of listener.
			if (!o) continue;
			o.move.x = touch.pageX;
			o.move.y = touch.pageY;
			o.moveTime = (new Date()).getTime();
		}
	};
	conf.onPointerUp = function(event) {
		if (root.pointerEnd(event, self, conf)) {
			eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
			eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
			///
			var velocity1;
			var velocity2
			var degree1;
			var degree2;
			/// Calculate centroid of gesture.
			var start = { x: 0, y: 0 };
			var endx = 0;
			var endy = 0;
			var length = 0;
			///
			for (var sid in conf.tracker) {
				var touch = conf.tracker[sid];
				var xdist = touch.move.x - touch.start.x;
				var ydist = touch.move.y - touch.start.y;
				///
				endx += touch.move.x;
				endy += touch.move.y;
				start.x += touch.start.x;
				start.y += touch.start.y;
				length ++;
				///
				var distance = Math.sqrt(xdist * xdist + ydist * ydist);
				var ms = touch.moveTime - touch.startTime;
				var degree2 = Math.atan2(xdist, ydist) / RAD_DEG + 180;
				var velocity2 = ms ? distance / ms : 0;
				if (typeof(degree1) === "undefined") {
					degree1 = degree2;
					velocity1 = velocity2;
				} else if (Math.abs(degree2 - degree1) <= 20) {
					degree1 = (degree1 + degree2) / 2;
					velocity1 = (velocity1 + velocity2) / 2;
				} else {
					return;
				}
			}
			///
			var fingers = conf.gestureFingers;
			if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
				if (velocity1 > conf.threshold) {
					start.x /= length;
					start.y /= length;
					self.start = start;
					self.x = endx / length;
					self.y = endy / length;
					self.angle = -((((degree1 / conf.snap + 0.5) >> 0) * conf.snap || 360) - 360);
					self.velocity = velocity1;
					self.fingers = fingers;
					self.state = "swipe";
					conf.listener(event, self);
				}
			}
		}
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	// Attach events.
	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.swipe = root.swipe;

return root;

})(eventjs.proxy);
/*:
	"Tap" and "Longpress" event proxy.
	----------------------------------------------------
	CONFIGURE: delay (longpress), timeout (tap).
	----------------------------------------------------
	eventjs.add(window, "tap", function(event, self) {
		console.log(self.fingers);
	});
	----------------------------------------------------
	multi-finger tap // touch an target for <= 250ms.
	multi-finger longpress // touch an target for >= 500ms
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.longpress = function(conf) {
	conf.gesture = "longpress";
	return root.tap(conf);
};

root.tap = function(conf) {
	conf.delay = conf.delay || 500;
	conf.timeout = conf.timeout || 250;
	conf.driftDeviance = conf.driftDeviance || 10;
	conf.gesture = conf.gesture || "tap";
	// Setting up local variables.
	var timestamp, timeout;
	// Tracking the events.
	conf.onPointerDown = function (event) {
		if (root.pointerStart(event, self, conf)) {
			timestamp = (new Date()).getTime();
			// Initialize event listeners.
			eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
			// Make sure this is a "longpress" event.
			if (conf.gesture !== "longpress") return;
			timeout = setTimeout(function() {
				if (event.cancelBubble && ++event.cancelBubbleCount > 1) return;
				// Make sure no fingers have been changed.
				var fingers = 0;
				for (var key in conf.tracker) {
					var point = conf.tracker[key];
					if (point.end === true) return;
					if (conf.cancel) return;
					fingers ++;
				}
				// Send callback.
				if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
					self.state = "start";
					self.fingers = fingers;
					self.x = point.start.x;
					self.y = point.start.y;
					conf.listener(event, self);
				}
			}, conf.delay);
		}
	};
	conf.onPointerMove = function (event) {
		var bbox = conf.bbox;
		var touches = event.changedTouches || root.getCoords(event);
		var length = touches.length;
		for (var i = 0; i < length; i ++) {
			var touch = touches[i];
			var identifier = touch.identifier || Infinity;
			var pt = conf.tracker[identifier];
			if (!pt) continue;
			var x = (touch.pageX - bbox.x1 - parseInt(window.scrollX));
			var y = (touch.pageY - bbox.y1 - parseInt(window.scrollY));
			///
			var dx = x - pt.start.x;
			var dy = y - pt.start.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			if (!(x > 0 && x < bbox.width && // Within target coordinates..
				  y > 0 && y < bbox.height &&
				  distance <= conf.driftDeviance)) { // Within drift deviance.
				// Cancel out this listener.
				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
				conf.cancel = true;
				return;
			}
		}
	};
	conf.onPointerUp = function(event) {
		if (root.pointerEnd(event, self, conf)) {
			clearTimeout(timeout);
			eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
			eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
			if (event.cancelBubble && ++event.cancelBubbleCount > 1) return;
			// Callback release on longpress.
			if (conf.gesture === "longpress") {
				if (self.state === "start") {
					self.state = "end";
					conf.listener(event, self);
				}
				return;
			}
			// Cancel event due to movement.
			if (conf.cancel) return;
			// Ensure delay is within margins.
			if ((new Date()).getTime() - timestamp > conf.timeout) return;
			// Send callback.
			var fingers = conf.gestureFingers;
			if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
				self.state = "tap";
				self.fingers = conf.gestureFingers;
				conf.listener(event, self);
			}
		}
	};
	// Generate maintenance commands, and other configurations.
	var self = root.pointerSetup(conf);
	// Attach events.
	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.tap = root.tap;
eventjs.Gesture._gestureHandlers.longpress = root.longpress;

return root;

})(eventjs.proxy);
/*:
	"Mouse Wheel" event proxy.
	----------------------------------------------------
	eventjs.add(window, "wheel", function(event, self) {
		console.log(self.state, self.wheelDelta);
	});
*/

if (typeof(eventjs) === "undefined") var eventjs = {};
if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};

eventjs.proxy = (function(root) { "use strict";

root.wheelPreventElasticBounce = function(el) {
	if (!el) return;
	if (typeof(el) === "string") el = document.querySelector(el);
	eventjs.add(el, "wheel", function(event, self) {
		self.preventElasticBounce();
		eventjs.stop(event);
	});
};

root.wheel = function(conf) {
	// Configure event listener.
	var interval;
	var timeout = conf.timeout || 150;
	var count = 0;
	// Externally accessible data.
	var self = {
		gesture: "wheel",
		state: "start",
		wheelDelta: 0,
		target: conf.target,
		listener: conf.listener,
		preventElasticBounce: function(event) {
			var target = this.target;
			var scrollTop = target.scrollTop;
			var top = scrollTop + target.offsetHeight;
			var height = target.scrollHeight;
			if (top === height && this.wheelDelta <= 0) eventjs.cancel(event);
			else if (scrollTop === 0 && this.wheelDelta >= 0) eventjs.cancel(event);
			eventjs.stop(event);
		},
		add: function() {
			conf.target[add](type, onMouseWheel, false);
		},
		remove: function() {
			conf.target[remove](type, onMouseWheel, false);
		}
	};
	// Tracking the events.
	var onMouseWheel = function(event) {
		event = event || window.event;
		self.state = count++ ? "change" : "start";
		self.wheelDelta = event.detail ? event.detail * -20 : event.wheelDelta;
		conf.listener(event, self);
		clearTimeout(interval);
		interval = setTimeout(function() {
			count = 0;
			self.state = "end";
			self.wheelDelta = 0;
			conf.listener(event, self);
		}, timeout);
	};
	// Attach events.
	var add = document.addEventListener ? "addEventListener" : "attachEvent";
	var remove = document.removeEventListener ? "removeEventListener" : "detachEvent";
	var type = eventjs.getEventSupport("mousewheel") ? "mousewheel" : "DOMMouseScroll";
	conf.target[add](type, onMouseWheel, false);
	// Return this object.
	return self;
};

eventjs.Gesture = eventjs.Gesture || {};
eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
eventjs.Gesture._gestureHandlers.wheel = root.wheel;

return root;

})(eventjs.proxy);
/*
	"Orientation Change"
	----------------------------------------------------
	https://developer.apple.com/library/safari/documentation/SafariDOMAdditions/Reference/DeviceOrientationEventClassRef/DeviceOrientationEvent/DeviceOrientationEvent.html#//apple_ref/doc/uid/TP40010526
	----------------------------------------------------
	Event.add(window, "deviceorientation", function(event, self) {});
*/

if (typeof(Event) === "undefined") var Event = {};
if (typeof(Event.proxy) === "undefined") Event.proxy = {};

Event.proxy = (function(root) { "use strict";

root.orientation = function(conf) {
	// Externally accessible data.
	var self = {
		gesture: "orientationchange",
		previous: null, /* Report the previous orientation */
		current: window.orientation,
		target: conf.target,
		listener: conf.listener,
		remove: function() {
			window.removeEventListener('orientationchange', onOrientationChange, false);
		}
	};

	// Tracking the events.
	var onOrientationChange = function(e) {

		self.previous = self.current;
		self.current = window.orientation;
	    if(self.previous !== null && self.previous != self.current) {
			conf.listener(e, self);
			return;
	    }


	};
	// Attach events.
	if (window.DeviceOrientationEvent) {
    	window.addEventListener("orientationchange", onOrientationChange, false);
  	}
	// Return this object.
	return self;
};

Event.Gesture = Event.Gesture || {};
Event.Gesture._gestureHandlers = Event.Gesture._gestureHandlers || {};
Event.Gesture._gestureHandlers.orientation = root.orientation;

return root;

})(Event.proxy);
(function() {

  /**
   * @private
   * @param {String} eventName
   * @param {Function} handler
   */
  function _removeEventListener(eventName, handler) {
    if (!this.__eventListeners[eventName]) {
      return;
    }
    var eventListener = this.__eventListeners[eventName];
    if (handler) {
      eventListener[eventListener.indexOf(handler)] = false;
    }
    else {
      fabric.util.array.fill(eventListener, false);
    }
  }

  /**
   * Observes specified event
   * @memberOf fabric.Observable
   * @alias on
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
   * @return {Self} thisArg
   * @chainable
   */
  function on(eventName, handler) {
    if (!this.__eventListeners) {
      this.__eventListeners = { };
    }
    // one object with key/value pairs was passed
    if (arguments.length === 1) {
      for (var prop in eventName) {
        this.on(prop, eventName[prop]);
      }
    }
    else {
      if (!this.__eventListeners[eventName]) {
        this.__eventListeners[eventName] = [];
      }
      this.__eventListeners[eventName].push(handler);
    }
    return this;
  }

  function _once(eventName, handler) {
    var _handler = function () {
      handler.apply(this, arguments);
      this.off(eventName, _handler);
    }.bind(this);
    this.on(eventName, _handler);
  }

  function once(eventName, handler) {
    // one object with key/value pairs was passed
    if (arguments.length === 1) {
      for (var prop in eventName) {
        _once.call(this, prop, eventName[prop]);
      }
    }
    else {
      _once.call(this, eventName, handler);
    }
    return this;
  }

  /**
   * Stops event observing for a particular event handler. Calling this method
   * without arguments removes all handlers for all events
   * @memberOf fabric.Observable
   * @alias off
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function to be deleted from EventListeners
   * @return {Self} thisArg
   * @chainable
   */
  function off(eventName, handler) {
    if (!this.__eventListeners) {
      return this;
    }

    // remove all key/value pairs (event name -> event handler)
    if (arguments.length === 0) {
      for (eventName in this.__eventListeners) {
        _removeEventListener.call(this, eventName);
      }
    }
    // one object with key/value pairs was passed
    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
      for (var prop in eventName) {
        _removeEventListener.call(this, prop, eventName[prop]);
      }
    }
    else {
      _removeEventListener.call(this, eventName, handler);
    }
    return this;
  }

  /**
   * Fires event with an optional options object
   * @memberOf fabric.Observable
   * @param {String} eventName Event name to fire
   * @param {Object} [options] Options object
   * @return {Self} thisArg
   * @chainable
   */
  function fire(eventName, options) {
    if (!this.__eventListeners) {
      return this;
    }

    var listenersForEvent = this.__eventListeners[eventName];
    if (!listenersForEvent) {
      return this;
    }

    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
    }
    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
      return value !== false;
    });
    return this;
  }

  /**
   * @namespace fabric.Observable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
   * @see {@link http://fabricjs.com/events|Events demo}
   */
  fabric.Observable = {
    fire: fire,
    on: on,
    once: once,
    off: off,
  };
})();
/**
 * @namespace fabric.Collection
 */
fabric.Collection = {

  _objects: [],

  /**
   * Adds objects to collection, Canvas or Group, then renders canvas
   * (if `renderOnAddRemove` is not `false`).
   * in case of Group no changes to bounding box are made.
   * Objects should be instances of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the add method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  add: function () {
    this._objects.push.apply(this._objects, arguments);
    if (this._onObjectAdded) {
      for (var i = 0, length = arguments.length; i < length; i++) {
        this._onObjectAdded(arguments[i]);
      }
    }
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
   * An object should be an instance of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the insertAt method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {Object} object Object to insert
   * @param {Number} index Index to insert object at
   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
   * @return {Self} thisArg
   * @chainable
   */
  insertAt: function (object, index, nonSplicing) {
    var objects = this._objects;
    if (nonSplicing) {
      objects[index] = object;
    }
    else {
      objects.splice(index, 0, object);
    }
    this._onObjectAdded && this._onObjectAdded(object);
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  remove: function() {
    var objects = this._objects,
        index, somethingRemoved = false;

    for (var i = 0, length = arguments.length; i < length; i++) {
      index = objects.indexOf(arguments[i]);

      // only call onObjectRemoved if an object was actually removed
      if (index !== -1) {
        somethingRemoved = true;
        objects.splice(index, 1);
        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
      }
    }

    this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
    return this;
  },

  /**
   * Executes given function for each object in this group
   * @param {Function} callback
   *                   Callback invoked with current object as first argument,
   *                   index - as second and an array of all objects - as third.
   *                   Callback is invoked in a context of Global Object (e.g. `window`)
   *                   when no `context` argument is given
   *
   * @param {Object} context Context (aka thisObject)
   * @return {Self} thisArg
   * @chainable
   */
  forEachObject: function(callback, context) {
    var objects = this.getObjects();
    for (var i = 0, len = objects.length; i < len; i++) {
      callback.call(context, objects[i], i, objects);
    }
    return this;
  },

  /**
   * Returns an array of children objects of this instance
   * Type parameter introduced in 1.3.10
   * since 2.3.5 this method return always a COPY of the array;
   * @param {String} [type] When specified, only objects of this type are returned
   * @return {Array}
   */
  getObjects: function(type) {
    if (typeof type === 'undefined') {
      return this._objects.concat();
    }
    return this._objects.filter(function(o) {
      return o.type === type;
    });
  },

  /**
   * Returns object at specified index
   * @param {Number} index
   * @return {Self} thisArg
   */
  item: function (index) {
    return this._objects[index];
  },

  /**
   * Returns true if collection contains no objects
   * @return {Boolean} true if collection is empty
   */
  isEmpty: function () {
    return this._objects.length === 0;
  },

  /**
   * Returns a size of a collection (i.e: length of an array containing its objects)
   * @return {Number} Collection size
   */
  size: function() {
    return this._objects.length;
  },

  /**
   * Returns true if collection contains an object
   * @param {Object} object Object to check against
   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`
   * @return {Boolean} `true` if collection contains an object
   */
  contains: function (object, deep) {
    if (this._objects.indexOf(object) > -1) {
      return true;
    }
    else if (deep) {
      return this._objects.some(function (obj) {
        return typeof obj.contains === 'function' && obj.contains(object, true);
      });
    }
    return false;
  },

  /**
   * Returns number representation of a collection complexity
   * @return {Number} complexity
   */
  complexity: function () {
    return this._objects.reduce(function (memo, current) {
      memo += current.complexity ? current.complexity() : 0;
      return memo;
    }, 0);
  }
};
/**
 * @namespace fabric.CommonMethods
 */
fabric.CommonMethods = {

  /**
   * Sets object's properties from options
   * @param {Object} [options] Options object
   */
  _setOptions: function(options) {
    for (var prop in options) {
      this.set(prop, options[prop]);
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Gradient to
   */
  _initGradient: function(filler, property) {
    if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
      this.set(property, new fabric.Gradient(filler));
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Pattern to
   * @param {Function} [callback] callback to invoke after pattern load
   */
  _initPattern: function(filler, property, callback) {
    if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
      this.set(property, new fabric.Pattern(filler, callback));
    }
    else {
      callback && callback();
    }
  },

  /**
   * @private
   */
  _setObject: function(obj) {
    for (var prop in obj) {
      this._set(prop, obj[prop]);
    }
  },

  /**
   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
   * @param {String|Object} key Property name or object (if object, iterate over the object properties)
   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  set: function(key, value) {
    if (typeof key === 'object') {
      this._setObject(key);
    }
    else {
      this._set(key, value);
    }
    return this;
  },

  _set: function(key, value) {
    this[key] = value;
  },

  /**
   * Toggles specified property from `true` to `false` or from `false` to `true`
   * @param {String} property Property to toggle
   * @return {fabric.Object} thisArg
   * @chainable
   */
  toggle: function(property) {
    var value = this.get(property);
    if (typeof value === 'boolean') {
      this.set(property, !value);
    }
    return this;
  },

  /**
   * Basic getter
   * @param {String} property Property name
   * @return {*} value of a property
   */
  get: function(property) {
    return this[property];
  }
};
(function(global) {

  var sqrt = Math.sqrt,
      atan2 = Math.atan2,
      pow = Math.pow,
      PiBy180 = Math.PI / 180,
      PiBy2 = Math.PI / 2;

  /**
   * @namespace fabric.util
   */
  fabric.util = {

    /**
     * Calculate the cos of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    cos: function(angle) {
      if (angle === 0) { return 1; }
      if (angle < 0) {
        // cos(a) = cos(-a)
        angle = -angle;
      }
      var angleSlice = angle / PiBy2;
      switch (angleSlice) {
        case 1: case 3: return 0;
        case 2: return -1;
      }
      return Math.cos(angle);
    },

    /**
     * Calculate the sin of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    sin: function(angle) {
      if (angle === 0) { return 0; }
      var angleSlice = angle / PiBy2, sign = 1;
      if (angle < 0) {
        // sin(-a) = -sin(a)
        sign = -1;
      }
      switch (angleSlice) {
        case 1: return sign;
        case 2: return 0;
        case 3: return -sign;
      }
      return Math.sin(angle);
    },

    /**
     * Removes value from an array.
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
     * @static
     * @memberOf fabric.util
     * @param {Array} array
     * @param {*} value
     * @return {Array} original array
     */
    removeFromArray: function(array, value) {
      var idx = array.indexOf(value);
      if (idx !== -1) {
        array.splice(idx, 1);
      }
      return array;
    },

    /**
     * Returns random number between 2 specified ones.
     * @static
     * @memberOf fabric.util
     * @param {Number} min lower limit
     * @param {Number} max upper limit
     * @return {Number} random value (between min and max)
     */
    getRandomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Transforms degrees to radians.
     * @static
     * @memberOf fabric.util
     * @param {Number} degrees value in degrees
     * @return {Number} value in radians
     */
    degreesToRadians: function(degrees) {
      return degrees * PiBy180;
    },

    /**
     * Transforms radians to degrees.
     * @static
     * @memberOf fabric.util
     * @param {Number} radians value in radians
     * @return {Number} value in degrees
     */
    radiansToDegrees: function(radians) {
      return radians / PiBy180;
    },

    /**
     * Rotates `point` around `origin` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {fabric.Point} point The point to rotate
     * @param {fabric.Point} origin The origin of the rotation
     * @param {Number} radians The radians of the angle for the rotation
     * @return {fabric.Point} The new rotated point
     */
    rotatePoint: function(point, origin, radians) {
      var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y),
          v = fabric.util.rotateVector(newPoint, radians);
      return new fabric.Point(v.x, v.y).addEquals(origin);
    },

    /**
     * Rotates `vector` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {Object} vector The vector to rotate (x and y)
     * @param {Number} radians The radians of the angle for the rotation
     * @return {Object} The new rotated point
     */
    rotateVector: function(vector, radians) {
      var sin = fabric.util.sin(radians),
          cos = fabric.util.cos(radians),
          rx = vector.x * cos - vector.y * sin,
          ry = vector.x * sin + vector.y * cos;
      return {
        x: rx,
        y: ry
      };
    },

    /**
     * Creates a vetor from points represented as a point
     * @static
     * @memberOf fabric.util
     *
     * @typedef {Object} Point
     * @property {number} x
     * @property {number} y
     *
     * @param {Point} from
     * @param {Point} to
     * @returns {Point} vector
     */
    createVector: function (from, to) {
      return new fabric.Point(to.x - from.x, to.y - from.y);
    },

    /**
     * Calculates angle between 2 vectors using dot product
     * @static
     * @memberOf fabric.util
     * @param {Point} a
     * @param {Point} b
     * @returns the angle in radian between the vectors
     */
    calcAngleBetweenVectors: function (a, b) {
      return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));
    },

    /**
     * @static
     * @memberOf fabric.util
     * @param {Point} v
     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`
     */
    getHatVector: function (v) {
      return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));
    },

    /**
     * @static
     * @memberOf fabric.util
     * @param {Point} A
     * @param {Point} B
     * @param {Point} C
     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle
     */
    getBisector: function (A, B, C) {
      var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);
      var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);
      //  check if alpha is relative to AB->BC
      var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);
      var phi = alpha * (ro === 0 ? 1 : -1) / 2;
      return {
        vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),
        angle: alpha
      };
    },

    /**
     * Project stroke width on points returning 2 projections for each point as follows:
     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.
     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.
     * - `round`: same as `bevel`
     * Used to calculate object's bounding box
     * @static
     * @memberOf fabric.util
     * @param {Point[]} points
     * @param {Object} options
     * @param {number} options.strokeWidth
     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin
     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit
     * @param {boolean} options.strokeUniform
     * @param {number} options.scaleX
     * @param {number} options.scaleY
     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points
     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points
     */
    projectStrokeOnPoints: function (points, options, openPath) {
      var coords = [], s = options.strokeWidth / 2,
          strokeUniformScalar = options.strokeUniform ?
            new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1),
          getStrokeHatVector = function (v) {
            var scalar = s / (Math.hypot(v.x, v.y));
            return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);
          };
      if (points.length <= 1) {return coords;}
      points.forEach(function (p, index) {
        var A = new fabric.Point(p.x, p.y), B, C;
        if (index === 0) {
          C = points[index + 1];
          B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];
        }
        else if (index === points.length - 1) {
          B = points[index - 1];
          C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];
        }
        else {
          B = points[index - 1];
          C = points[index + 1];
        }
        var bisector = fabric.util.getBisector(A, B, C),
            bisectorVector = bisector.vector,
            alpha = bisector.angle,
            scalar,
            miterVector;
        if (options.strokeLineJoin === 'miter') {
          scalar = -s / Math.sin(alpha / 2);
          miterVector = new fabric.Point(
            bisectorVector.x * scalar * strokeUniformScalar.x,
            bisectorVector.y * scalar * strokeUniformScalar.y
          );
          if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {
            coords.push(A.add(miterVector));
            coords.push(A.subtract(miterVector));
            return;
          }
        }
        scalar = -s * Math.SQRT2;
        miterVector = new fabric.Point(
          bisectorVector.x * scalar * strokeUniformScalar.x,
          bisectorVector.y * scalar * strokeUniformScalar.y
        );
        coords.push(A.add(miterVector));
        coords.push(A.subtract(miterVector));
      });
      return coords;
    },

    /**
     * Apply transform t to point p
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Point} p The point to transform
     * @param  {Array} t The transform
     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
     * @return {fabric.Point} The transformed point
     */
    transformPoint: function(p, t, ignoreOffset) {
      if (ignoreOffset) {
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y,
          t[1] * p.x + t[3] * p.y
        );
      }
      return new fabric.Point(
        t[0] * p.x + t[2] * p.y + t[4],
        t[1] * p.x + t[3] * p.y + t[5]
      );
    },

    /**
     * Returns coordinates of points's bounding rectangle (left, top, width, height)
     * @param {Array} points 4 points array
     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix
     * @return {Object} Object with left, top, width, height properties
     */
    makeBoundingBoxFromPoints: function(points, transform) {
      if (transform) {
        for (var i = 0; i < points.length; i++) {
          points[i] = fabric.util.transformPoint(points[i], transform);
        }
      }
      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
          minX = fabric.util.array.min(xPoints),
          maxX = fabric.util.array.max(xPoints),
          width = maxX - minX,
          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
          minY = fabric.util.array.min(yPoints),
          maxY = fabric.util.array.max(yPoints),
          height = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Invert transformation t
     * @static
     * @memberOf fabric.util
     * @param {Array} t The transform
     * @return {Array} The inverted transform
     */
    invertTransform: function(t) {
      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
      r[4] = -o.x;
      r[5] = -o.y;
      return r;
    },

    /**
     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
     * @static
     * @memberOf fabric.util
     * @param {Number|String} number number to operate on
     * @param {Number} fractionDigits number of fraction digits to "leave"
     * @return {Number}
     */
    toFixed: function(number, fractionDigits) {
      return parseFloat(Number(number).toFixed(fractionDigits));
    },

    /**
     * Converts from attribute value to pixel value if applicable.
     * Returns converted pixels or original value not converted.
     * @param {Number|String} value number to operate on
     * @param {Number} fontSize
     * @return {Number|String}
     */
    parseUnit: function(value, fontSize) {
      var unit = /\D{0,2}$/.exec(value),
          number = parseFloat(value);
      if (!fontSize) {
        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }
      switch (unit[0]) {
        case 'mm':
          return number * fabric.DPI / 25.4;

        case 'cm':
          return number * fabric.DPI / 2.54;

        case 'in':
          return number * fabric.DPI;

        case 'pt':
          return number * fabric.DPI / 72; // or * 4 / 3

        case 'pc':
          return number * fabric.DPI / 72 * 12; // or * 16

        case 'em':
          return number * fontSize;

        default:
          return number;
      }
    },

    /**
     * Function which always returns `false`.
     * @static
     * @memberOf fabric.util
     * @return {Boolean}
     */
    falseFunction: function() {
      return false;
    },

    /**
     * Returns klass "Class" object of given namespace
     * @memberOf fabric.util
     * @param {String} type Type of object (eg. 'circle')
     * @param {String} namespace Namespace to get klass "Class" object from
     * @return {Object} klass "Class"
     */
    getKlass: function(type, namespace) {
      // capitalize first letter only
      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
      return fabric.util.resolveNamespace(namespace)[type];
    },

    /**
     * Returns array of attributes for given svg that fabric parses
     * @memberOf fabric.util
     * @param {String} type Type of svg element (eg. 'circle')
     * @return {Array} string names of supported attributes
     */
    getSvgAttributes: function(type) {
      var attributes = [
        'instantiated_by_use',
        'style',
        'id',
        'class'
      ];
      switch (type) {
        case 'linearGradient':
          attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
          break;
        case 'radialGradient':
          attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
          break;
        case 'stop':
          attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
          break;
      }
      return attributes;
    },

    /**
     * Returns object of given namespace
     * @memberOf fabric.util
     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
     * @return {Object} Object for given namespace (default fabric)
     */
    resolveNamespace: function(namespace) {
      if (!namespace) {
        return fabric;
      }

      var parts = namespace.split('.'),
          len = parts.length, i,
          obj = global || fabric.window;

      for (i = 0; i < len; ++i) {
        obj = obj[parts[i]];
      }

      return obj;
    },

    /**
     * Loads image element from given url and passes it to a callback
     * @memberOf fabric.util
     * @param {String} url URL representing an image
     * @param {Function} callback Callback; invoked with loaded image
     * @param {*} [context] Context to invoke callback in
     * @param {Object} [crossOrigin] crossOrigin value to set image element to
     */
    loadImage: function(url, callback, context, crossOrigin) {
      if (!url) {
        callback && callback.call(context, url);
        return;
      }

      var img = fabric.util.createImage();

      /** @ignore */
      var onLoadCallback = function () {
        callback && callback.call(context, img, false);
        img = img.onload = img.onerror = null;
      };

      img.onload = onLoadCallback;
      /** @ignore */
      img.onerror = function() {
        fabric.log('Error loading ' + img.src);
        callback && callback.call(context, null, true);
        img = img.onload = img.onerror = null;
      };

      // data-urls appear to be buggy with crossOrigin
      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
      // see https://code.google.com/p/chromium/issues/detail?id=315152
      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
      // crossOrigin null is the same as not set.
      if (url.indexOf('data') !== 0 &&
        crossOrigin !== undefined &&
        crossOrigin !== null) {
        img.crossOrigin = crossOrigin;
      }

      // IE10 / IE11-Fix: SVG contents from data: URI
      // will only be available if the IMG is present
      // in the DOM (and visible)
      if (url.substring(0,14) === 'data:image/svg') {
        img.onload = null;
        fabric.util.loadImageInDom(img, onLoadCallback);
      }

      img.src = url;
    },

    /**
     * Attaches SVG image with data: URL to the dom
     * @memberOf fabric.util
     * @param {Object} img Image object with data:image/svg src
     * @param {Function} callback Callback; invoked with loaded image
     * @return {Object} DOM element (div containing the SVG image)
     */
    loadImageInDom: function(img, onLoadCallback) {
      var div = fabric.document.createElement('div');
      div.style.width = div.style.height = '1px';
      div.style.left = div.style.top = '-100%';
      div.style.position = 'absolute';
      div.appendChild(img);
      fabric.document.querySelector('body').appendChild(div);
      /**
       * Wrap in function to:
       *   1. Call existing callback
       *   2. Cleanup DOM
       */
      img.onload = function () {
        onLoadCallback();
        div.parentNode.removeChild(div);
        div = null;
      };
    },

    /**
     * Creates corresponding fabric instances from their object representations
     * @static
     * @memberOf fabric.util
     * @param {Array} objects Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * @param {String} namespace Namespace to get klass "Class" object from
     * @param {Function} reviver Method for further parsing of object elements,
     * called after each fabric object created.
     */
    enlivenObjects: function(objects, callback, namespace, reviver) {
      objects = objects || [];

      var enlivenedObjects = [],
          numLoadedObjects = 0,
          numTotalObjects = objects.length;

      function onLoaded() {
        if (++numLoadedObjects === numTotalObjects) {
          callback && callback(enlivenedObjects.filter(function(obj) {
            // filter out undefined objects (objects that gave error)
            return obj;
          }));
        }
      }

      if (!numTotalObjects) {
        callback && callback(enlivenedObjects);
        return;
      }

      objects.forEach(function (o, index) {
        // if sparse array
        if (!o || !o.type) {
          onLoaded();
          return;
        }
        var klass = fabric.util.getKlass(o.type, namespace);
        klass.fromObject(o, function (obj, error) {
          error || (enlivenedObjects[index] = obj);
          reviver && reviver(o, obj, error);
          onLoaded();
        });
      });
    },

    /**
     * Creates corresponding fabric instances residing in an object, e.g. `clipPath`
     * @see {@link fabric.Object.ENLIVEN_PROPS}
     * @param {Object} object
     * @param {Object} [context] assign enlived props to this object (pass null to skip this)
     * @param {(objects:fabric.Object[]) => void} callback
     */
    enlivenObjectEnlivables: function (object, context, callback) {
      var enlivenProps = fabric.Object.ENLIVEN_PROPS.filter(function (key) { return !!object[key]; });
      fabric.util.enlivenObjects(enlivenProps.map(function (key) { return object[key]; }), function (enlivedProps) {
        var objects = {};
        enlivenProps.forEach(function (key, index) {
          objects[key] = enlivedProps[index];
          context && (context[key] = enlivedProps[index]);
        });
        callback && callback(objects);
      });
    },

    /**
     * Create and wait for loading of patterns
     * @static
     * @memberOf fabric.util
     * @param {Array} patterns Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * called after each fabric object created.
     */
    enlivenPatterns: function(patterns, callback) {
      patterns = patterns || [];

      function onLoaded() {
        if (++numLoadedPatterns === numPatterns) {
          callback && callback(enlivenedPatterns);
        }
      }

      var enlivenedPatterns = [],
          numLoadedPatterns = 0,
          numPatterns = patterns.length;

      if (!numPatterns) {
        callback && callback(enlivenedPatterns);
        return;
      }

      patterns.forEach(function (p, index) {
        if (p && p.source) {
          new fabric.Pattern(p, function(pattern) {
            enlivenedPatterns[index] = pattern;
            onLoaded();
          });
        }
        else {
          enlivenedPatterns[index] = p;
          onLoaded();
        }
      });
    },

    /**
     * Groups SVG elements (usually those retrieved from SVG document)
     * @static
     * @memberOf fabric.util
     * @param {Array} elements SVG elements to group
     * @param {Object} [options] Options object
     * @param {String} path Value to set sourcePath to
     * @return {fabric.Object|fabric.Group}
     */
    groupSVGElements: function(elements, options, path) {
      var object;
      if (elements && elements.length === 1) {
        return elements[0];
      }
      if (options) {
        if (options.width && options.height) {
          options.centerPoint = {
            x: options.width / 2,
            y: options.height / 2
          };
        }
        else {
          delete options.width;
          delete options.height;
        }
      }
      object = new fabric.Group(elements, options);
      if (typeof path !== 'undefined') {
        object.sourcePath = path;
      }
      return object;
    },

    /**
     * Populates an object with properties of another object
     * @static
     * @memberOf fabric.util
     * @param {Object} source Source object
     * @param {Object} destination Destination object
     * @return {Array} properties Properties names to include
     */
    populateWithProperties: function(source, destination, properties) {
      if (properties && Array.isArray(properties)) {
        for (var i = 0, len = properties.length; i < len; i++) {
          if (properties[i] in source) {
            destination[properties[i]] = source[properties[i]];
          }
        }
      }
    },

    /**
     * Creates canvas element
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    createCanvasElement: function() {
      return fabric.document.createElement('canvas');
    },

    /**
     * Creates a canvas element that is a copy of another and is also painted
     * @param {CanvasElement} canvas to copy size and content of
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    copyCanvasElement: function(canvas) {
      var newCanvas = fabric.util.createCanvasElement();
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      newCanvas.getContext('2d').drawImage(canvas, 0, 0);
      return newCanvas;
    },

    /**
     * since 2.6.0 moved from canvas instance to utility.
     * @param {CanvasElement} canvasEl to copy size and content of
     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
     * @param {Number} quality <= 1 and > 0
     * @static
     * @memberOf fabric.util
     * @return {String} data url
     */
    toDataURL: function(canvasEl, format, quality) {
      return canvasEl.toDataURL('image/' + format, quality);
    },

    /**
     * Creates image element (works on client and node)
     * @static
     * @memberOf fabric.util
     * @return {HTMLImageElement} HTML image element
     */
    createImage: function() {
      return fabric.document.createElement('img');
    },

    /**
     * Multiply matrix A by matrix B to nest transformations
     * @static
     * @memberOf fabric.util
     * @param  {Array} a First transformMatrix
     * @param  {Array} b Second transformMatrix
     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
     * @return {Array} The product of the two transform matrices
     */
    multiplyTransformMatrices: function(a, b, is2x2) {
      // Matrix multiply a * b
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    },

    /**
     * Decomposes standard 2x3 matrix into transform components
     * @static
     * @memberOf fabric.util
     * @param  {Array} a transformMatrix
     * @return {Object} Components of transform
     */
    qrDecompose: function(a) {
      var angle = atan2(a[1], a[0]),
          denom = pow(a[0], 2) + pow(a[1], 2),
          scaleX = sqrt(denom),
          scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX,
          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
      return {
        angle: angle / PiBy180,
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX / PiBy180,
        skewY: 0,
        translateX: a[4],
        translateY: a[5]
      };
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.angle] angle in degrees
     * @return {Number[]} transform matrix
     */
    calcRotateMatrix: function(options) {
      if (!options.angle) {
        return fabric.iMatrix.concat();
      }
      var theta = fabric.util.degreesToRadians(options.angle),
          cos = fabric.util.cos(theta),
          sin = fabric.util.sin(theta);
      return [cos, sin, -sin, cos, 0, 0];
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet.
     * is called DimensionsTransformMatrix because those properties are the one that influence
     * the size of the resulting box of the object.
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewY]
     * @return {Number[]} transform matrix
     */
    calcDimensionsMatrix: function(options) {
      var scaleX = typeof options.scaleX === 'undefined' ? 1 : options.scaleX,
          scaleY = typeof options.scaleY === 'undefined' ? 1 : options.scaleY,
          scaleMatrix = [
            options.flipX ? -scaleX : scaleX,
            0,
            0,
            options.flipY ? -scaleY : scaleY,
            0,
            0],
          multiply = fabric.util.multiplyTransformMatrices,
          degreesToRadians = fabric.util.degreesToRadians;
      if (options.skewX) {
        scaleMatrix = multiply(
          scaleMatrix,
          [1, 0, Math.tan(degreesToRadians(options.skewX)), 1],
          true);
      }
      if (options.skewY) {
        scaleMatrix = multiply(
          scaleMatrix,
          [1, Math.tan(degreesToRadians(options.skewY)), 0, 1],
          true);
      }
      return scaleMatrix;
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.angle]
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.translateX]
     * @param  {Number} [options.translateY]
     * @return {Number[]} transform matrix
     */
    composeMatrix: function(options) {
      var matrix = [1, 0, 0, 1, options.translateX || 0, options.translateY || 0],
          multiply = fabric.util.multiplyTransformMatrices;
      if (options.angle) {
        matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));
      }
      if (options.scaleX !== 1 || options.scaleY !== 1 ||
          options.skewX || options.skewY || options.flipX || options.flipY) {
        matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));
      }
      return matrix;
    },

    /**
     * reset an object transform state to neutral. Top and left are not accounted for
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to transform
     */
    resetObjectTransform: function (target) {
      target.scaleX = 1;
      target.scaleY = 1;
      target.skewX = 0;
      target.skewY = 0;
      target.flipX = false;
      target.flipY = false;
      target.rotate(0);
    },

    /**
     * Extract Object transform values
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to read from
     * @return {Object} Components of transform
     */
    saveObjectTransform: function (target) {
      return {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        angle: target.angle,
        left: target.left,
        flipX: target.flipX,
        flipY: target.flipY,
        top: target.top
      };
    },

    /**
     * Returns true if context has transparent pixel
     * at specified location (taking tolerance into account)
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x x coordinate
     * @param {Number} y y coordinate
     * @param {Number} tolerance Tolerance
     */
    isTransparent: function(ctx, x, y, tolerance) {

      // If tolerance is > 0 adjust start coords to take into account.
      // If moves off Canvas fix to 0
      if (tolerance > 0) {
        if (x > tolerance) {
          x -= tolerance;
        }
        else {
          x = 0;
        }
        if (y > tolerance) {
          y -= tolerance;
        }
        else {
          y = 0;
        }
      }

      var _isTransparent = true, i, temp,
          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
          l = imageData.data.length;

      // Split image data - for tolerance > 1, pixelDataSize = 4;
      for (i = 3; i < l; i += 4) {
        temp = imageData.data[i];
        _isTransparent = temp <= 0;
        if (_isTransparent === false) {
          break; // Stop if colour found
        }
      }

      imageData = null;

      return _isTransparent;
    },

    /**
     * Parse preserveAspectRatio attribute from element
     * @param {string} attribute to be parsed
     * @return {Object} an object containing align and meetOrSlice attribute
     */
    parsePreserveAspectRatioAttribute: function(attribute) {
      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
          aspectRatioAttrs = attribute.split(' '), align;

      if (aspectRatioAttrs && aspectRatioAttrs.length) {
        meetOrSlice = aspectRatioAttrs.pop();
        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
          align = meetOrSlice;
          meetOrSlice = 'meet';
        }
        else if (aspectRatioAttrs.length) {
          align = aspectRatioAttrs.pop();
        }
      }
      //divide align in alignX and alignY
      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
      return {
        meetOrSlice: meetOrSlice,
        alignX: alignX,
        alignY: alignY
      };
    },

    /**
     * Clear char widths cache for the given font family or all the cache if no
     * fontFamily is specified.
     * Use it if you know you are loading fonts in a lazy way and you are not waiting
     * for custom fonts to load properly when adding text objects to the canvas.
     * If a text object is added when its own font is not loaded yet, you will get wrong
     * measurement and so wrong bounding boxes.
     * After the font cache is cleared, either change the textObject text content or call
     * initDimensions() to trigger a recalculation
     * @memberOf fabric.util
     * @param {String} [fontFamily] font family to clear
     */
    clearFabricFontCache: function(fontFamily) {
      fontFamily = (fontFamily || '').toLowerCase();
      if (!fontFamily) {
        fabric.charWidthsCache = { };
      }
      else if (fabric.charWidthsCache[fontFamily]) {
        delete fabric.charWidthsCache[fontFamily];
      }
    },

    /**
     * Given current aspect ratio, determines the max width and height that can
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Number} ar aspect ratio
     * @param {Number} maximumArea Maximum area you want to achieve
     * @return {Object.x} Limited dimensions by X
     * @return {Object.y} Limited dimensions by Y
     */
    limitDimsByArea: function(ar, maximumArea) {
      var roughWidth = Math.sqrt(maximumArea * ar),
          perfLimitSizeY = Math.floor(maximumArea / roughWidth);
      return { x: Math.floor(roughWidth), y: perfLimitSizeY };
    },

    capValue: function(min, value, max) {
      return Math.max(min, Math.min(value, max));
    },

    /**
     * Finds the scale for the object source to fit inside the object destination,
     * keeping aspect ratio intact.
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Object | fabric.Object} source
     * @param {Number} source.height natural unscaled height of the object
     * @param {Number} source.width natural unscaled width of the object
     * @param {Object | fabric.Object} destination
     * @param {Number} destination.height natural unscaled height of the object
     * @param {Number} destination.width natural unscaled width of the object
     * @return {Number} scale factor to apply to source to fit into destination
     */
    findScaleToFit: function(source, destination) {
      return Math.min(destination.width / source.width, destination.height / source.height);
    },

    /**
     * Finds the scale for the object source to cover entirely the object destination,
     * keeping aspect ratio intact.
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Object | fabric.Object} source
     * @param {Number} source.height natural unscaled height of the object
     * @param {Number} source.width natural unscaled width of the object
     * @param {Object | fabric.Object} destination
     * @param {Number} destination.height natural unscaled height of the object
     * @param {Number} destination.width natural unscaled width of the object
     * @return {Number} scale factor to apply to source to cover destination
     */
    findScaleToCover: function(source, destination) {
      return Math.max(destination.width / source.width, destination.height / source.height);
    },

    /**
     * given an array of 6 number returns something like `"matrix(...numbers)"`
     * @memberOf fabric.util
     * @param {Array} transform an array with 6 numbers
     * @return {String} transform matrix for svg
     * @return {Object.y} Limited dimensions by Y
     */
    matrixToSVG: function(transform) {
      return 'matrix(' + transform.map(function(value) {
        return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);
      }).join(' ') + ')';
    },

    /**
     * given an object and a transform, apply the inverse transform to the object,
     * this is equivalent to remove from that object that transformation, so that
     * added in a space with the removed transform, the object will be the same as before.
     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.
     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg
     * in the opposite direction.
     * This util is used to add objects inside transformed groups or nested groups.
     * @memberOf fabric.util
     * @param {fabric.Object} object the object you want to transform
     * @param {Array} transform the destination transform
     */
    removeTransformFromObject: function(object, transform) {
      var inverted = fabric.util.invertTransform(transform),
          finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());
      fabric.util.applyTransformToObject(object, finalTransform);
    },

    /**
     * given an object and a transform, apply the transform to the object.
     * this is equivalent to change the space where the object is drawn.
     * Adding to an object a transform that scale by 2 is like scaling it by 2.
     * This is used when removing an object from an active selection for example.
     * @memberOf fabric.util
     * @param {fabric.Object} object the object you want to transform
     * @param {Array} transform the destination transform
     */
    addTransformToObject: function(object, transform) {
      fabric.util.applyTransformToObject(
        object,
        fabric.util.multiplyTransformMatrices(transform, object.calcOwnMatrix())
      );
    },

    /**
     * discard an object transform state and apply the one from the matrix.
     * @memberOf fabric.util
     * @param {fabric.Object} object the object you want to transform
     * @param {Array} transform the destination transform
     */
    applyTransformToObject: function(object, transform) {
      var options = fabric.util.qrDecompose(transform),
          center = new fabric.Point(options.translateX, options.translateY);
      object.flipX = false;
      object.flipY = false;
      object.set('scaleX', options.scaleX);
      object.set('scaleY', options.scaleY);
      object.skewX = options.skewX;
      object.skewY = options.skewY;
      object.angle = options.angle;
      object.setPositionByOrigin(center, 'center', 'center');
    },

    /**
     * given a width and height, return the size of the bounding box
     * that can contains the box with width/height with applied transform
     * described in options.
     * Use to calculate the boxes around objects for controls.
     * @memberOf fabric.util
     * @param {Number} width
     * @param {Number} height
     * @param {Object} options
     * @param {Number} options.scaleX
     * @param {Number} options.scaleY
     * @param {Number} options.skewX
     * @param {Number} options.skewY
     * @return {Object.x} width of containing
     * @return {Object.y} height of containing
     */
    sizeAfterTransform: function(width, height, options) {
      var dimX = width / 2, dimY = height / 2,
          points = [
            {
              x: -dimX,
              y: -dimY
            },
            {
              x: dimX,
              y: -dimY
            },
            {
              x: -dimX,
              y: dimY
            },
            {
              x: dimX,
              y: dimY
            }],
          transformMatrix = fabric.util.calcDimensionsMatrix(options),
          bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);
      return {
        x: bbox.width,
        y: bbox.height,
      };
    },

    /**
     * Merges 2 clip paths into one visually equal clip path
     *
     * **IMPORTANT**:\
     * Does **NOT** clone the arguments, clone them proir if necessary.
     *
     * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.
     * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.
     *
     * In order to handle the `inverted` property we follow logic described in the following cases:\
     * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\
     * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\
     * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.
     *
     * @memberOf fabric.util
     * @param {fabric.Object} c1
     * @param {fabric.Object} c2
     * @returns {fabric.Object} merged clip path
     */
    mergeClipPaths: function (c1, c2) {
      var a = c1, b = c2;
      if (a.inverted && !b.inverted) {
        //  case (2)
        a = c2;
        b = c1;
      }
      //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane
      fabric.util.applyTransformToObject(
        b,
        fabric.util.multiplyTransformMatrices(
          fabric.util.invertTransform(a.calcTransformMatrix()),
          b.calcTransformMatrix()
        )
      );
      //  assign the `inverted` prop to the wrapping group
      var inverted = a.inverted && b.inverted;
      if (inverted) {
        //  case (1)
        a.inverted = b.inverted = false;
      }
      return new fabric.Group([a], { clipPath: b, inverted: inverted });
    },
  };
})(typeof exports !== 'undefined' ? exports : this);
(function() {
  var _join = Array.prototype.join,
      commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7
      },
      repeatedCommands = {
        m: 'l',
        M: 'L'
      };
  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
    var costh2 = fabric.util.cos(th2),
        sinth2 = fabric.util.sin(th2),
        costh3 = fabric.util.cos(th3),
        sinth3 = fabric.util.sin(th3),
        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

    return ['C',
      cp1X, cp1Y,
      cp2X, cp2Y,
      toX, toY
    ];
  }

  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
   * http://mozilla.org/MPL/2.0/
   */
  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
    var PI = Math.PI, th = rotateX * PI / 180,
        sinTh = fabric.util.sin(th),
        cosTh = fabric.util.cos(th),
        fromX = 0, fromY = 0;

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
        root = 0;

    if (pl < 0) {
      var s = Math.sqrt(1 - pl / (rx2 * ry2));
      rx *= s;
      ry *= s;
    }
    else {
      root = (large === sweep ? -1.0 : 1.0) *
              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
    }

    var cx = root * rx * py / ry,
        cy = -root * ry * px / rx,
        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

    if (sweep === 0 && dtheta > 0) {
      dtheta -= 2 * PI;
    }
    else if (sweep === 1 && dtheta < 0) {
      dtheta += 2 * PI;
    }

    // Convert into cubic bezier segments <= 90deg
    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
        result = [], mDelta = dtheta / segments,
        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
        th3 = mTheta + mDelta;

    for (var i = 0; i < segments; i++) {
      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
      fromX = result[i][5];
      fromY = result[i][6];
      mTheta = th3;
      th3 += mDelta;
    }
    return result;
  }

  /*
   * Private
   */
  function calcVectorAngle(ux, uy, vx, vy) {
    var ta = Math.atan2(uy, ux),
        tb = Math.atan2(vy, vx);
    if (tb >= ta) {
      return tb - ta;
    }
    else {
      return 2 * Math.PI - (ta - tb);
    }
  }

  /**
   * Calculate bounding box of a beziercurve
   * @param {Number} x0 starting point
   * @param {Number} y0
   * @param {Number} x1 first control point
   * @param {Number} y1
   * @param {Number} x2 secondo control point
   * @param {Number} y2
   * @param {Number} x3 end of bezier
   * @param {Number} y3
   */
  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
  // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?
  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
    var argsString;
    if (fabric.cachesBoundsOfCurve) {
      argsString = _join.call(arguments);
      if (fabric.boundsOfCurveCache[argsString]) {
        return fabric.boundsOfCurveCache[argsString];
      }
    }

    var sqrt = Math.sqrt,
        min = Math.min, max = Math.max,
        abs = Math.abs, tvalues = [],
        bounds = [[], []],
        a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    b = 6 * x0 - 12 * x1 + 6 * x2;
    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
    c = 3 * x1 - 3 * x0;

    for (var i = 0; i < 2; ++i) {
      if (i > 0) {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (abs(a) < 1e-12) {
        if (abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      if (b2ac < 0) {
        continue;
      }
      sqrtb2ac = sqrt(b2ac);
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    var x, y, j = tvalues.length, jlen = j, mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
      bounds[0][j] = x;

      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
      bounds[1][j] = y;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    var result = [
      {
        x: min.apply(null, bounds[0]),
        y: min.apply(null, bounds[1])
      },
      {
        x: max.apply(null, bounds[0]),
        y: max.apply(null, bounds[1])
      }
    ];
    if (fabric.cachesBoundsOfCurve) {
      fabric.boundsOfCurveCache[argsString] = result;
    }
    return result;
  }

  /**
   * Converts arc to a bunch of bezier curves
   * @param {Number} fx starting point x
   * @param {Number} fy starting point y
   * @param {Array} coords Arc command
   */
  function fromArcToBeziers(fx, fy, coords) {
    var rx = coords[1],
        ry = coords[2],
        rot = coords[3],
        large = coords[4],
        sweep = coords[5],
        tx = coords[6],
        ty = coords[7],
        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segsNorm.length; i < len; i++) {
      segsNorm[i][1] += fx;
      segsNorm[i][2] += fy;
      segsNorm[i][3] += fx;
      segsNorm[i][4] += fy;
      segsNorm[i][5] += fx;
      segsNorm[i][6] += fy;
    }
    return segsNorm;
  };

  /**
   * This function take a parsed SVG path and make it simpler for fabricJS logic.
   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )
   * S converted in C, T converted in Q, A converted in C.
   * @param {Array} path the array of commands of a parsed svg path for fabric.Path
   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path
   */
  function makePathSimpler(path) {
    // x and y represent the last point of the path. the previous command point.
    // we add them to each relative command to make it an absolute comment.
    // we also swap the v V h H with L, because are easier to transform.
    var x = 0, y = 0, len = path.length,
        // x1 and y1 represent the last point of the subpath. the subpath is started with
        // m or M command. When a z or Z command is drawn, x and y need to be resetted to
        // the last x1 and y1.
        x1 = 0, y1 = 0, current, i, converted,
        // previous will host the letter of the previous command, to handle S and T.
        // controlX and controlY will host the previous reflected control point
        destinationPath = [], previous, controlX, controlY;
    for (i = 0; i < len; ++i) {
      converted = false;
      current = path[i].slice(0);
      switch (current[0]) { // first letter
        case 'l': // lineto, relative
          current[0] = 'L';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'L':
          x = current[1];
          y = current[2];
          break;
        case 'h': // horizontal lineto, relative
          current[1] += x;
          // falls through
        case 'H':
          current[0] = 'L';
          current[2] = y;
          x = current[1];
          break;
        case 'v': // vertical lineto, relative
          current[1] += y;
          // falls through
        case 'V':
          current[0] = 'L';
          y = current[1];
          current[1] = x;
          current[2] = y;
          break;
        case 'm': // moveTo, relative
          current[0] = 'M';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'M':
          x = current[1];
          y = current[2];
          x1 = current[1];
          y1 = current[2];
          break;
        case 'c': // bezierCurveTo, relative
          current[0] = 'C';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          current[5] += x;
          current[6] += y;
          // falls through
        case 'C':
          controlX = current[3];
          controlY = current[4];
          x = current[5];
          y = current[6];
          break;
        case 's': // shorthand cubic bezierCurveTo, relative
          current[0] = 'S';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          // falls through
        case 'S':
          // would be sScC but since we are swapping sSc for C, we check just that.
          if (previous === 'C') {
            // calculate reflection of previous control points
            controlX = 2 * x - controlX;
            controlY = 2 * y - controlY;
          }
          else {
            // If there is no previous command or if the previous command was not a C, c, S, or s,
            // the control point is coincident with the current point
            controlX = x;
            controlY = y;
          }
          x = current[3];
          y = current[4];
          current[0] = 'C';
          current[5] = current[3];
          current[6] = current[4];
          current[3] = current[1];
          current[4] = current[2];
          current[1] = controlX;
          current[2] = controlY;
          // current[3] and current[4] are NOW the second control point.
          // we keep it for the next reflection.
          controlX = current[3];
          controlY = current[4];
          break;
        case 'q': // quadraticCurveTo, relative
          current[0] = 'Q';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          // falls through
        case 'Q':
          controlX = current[1];
          controlY = current[2];
          x = current[3];
          y = current[4];
          break;
        case 't': // shorthand quadraticCurveTo, relative
          current[0] = 'T';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'T':
          if (previous === 'Q') {
            // calculate reflection of previous control point
            controlX = 2 * x - controlX;
            controlY = 2 * y - controlY;
          }
          else {
            // If there is no previous command or if the previous command was not a Q, q, T or t,
            // assume the control point is coincident with the current point
            controlX = x;
            controlY = y;
          }
          current[0] = 'Q';
          x = current[1];
          y = current[2];
          current[1] = controlX;
          current[2] = controlY;
          current[3] = x;
          current[4] = y;
          break;
        case 'a':
          current[0] = 'A';
          current[6] += x;
          current[7] += y;
          // falls through
        case 'A':
          converted = true;
          destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));
          x = current[6];
          y = current[7];
          break;
        case 'z':
        case 'Z':
          x = x1;
          y = y1;
          break;
        default:
      }
      if (!converted) {
        destinationPath.push(current);
      }
      previous = current[0];
    }
    return destinationPath;
  };

  /**
   * Calc length from point x1,y1 to x2,y2
   * @param {Number} x1 starting point x
   * @param {Number} y1 starting point y
   * @param {Number} x2 starting point x
   * @param {Number} y2 starting point y
   * @return {Number} length of segment
   */
  function calcLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  // functions for the Cubic beizer
  // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350
  function CB1(t) {
    return t * t * t;
  }
  function CB2(t) {
    return 3 * t * t * (1 - t);
  }
  function CB3(t) {
    return 3 * t * (1 - t) * (1 - t);
  }
  function CB4(t) {
    return (1 - t) * (1 - t) * (1 - t);
  }

  function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    return function(pct) {
      var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);
      return {
        x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
        y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
      };
    };
  }

  function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    return function (pct) {
      var invT = 1 - pct,
          tangentX = (3 * invT * invT * (p2x - p1x)) + (6 * invT * pct * (p3x - p2x)) +
          (3 * pct * pct * (p4x - p3x)),
          tangentY = (3 * invT * invT * (p2y - p1y)) + (6 * invT * pct * (p3y - p2y)) +
          (3 * pct * pct * (p4y - p3y));
      return Math.atan2(tangentY, tangentX);
    };
  }

  function QB1(t) {
    return t * t;
  }

  function QB2(t) {
    return 2 * t * (1 - t);
  }

  function QB3(t) {
    return (1 - t) * (1 - t);
  }

  function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
    return function(pct) {
      var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);
      return {
        x: p3x * c1 + p2x * c2 + p1x * c3,
        y: p3y * c1 + p2y * c2 + p1y * c3
      };
    };
  }

  function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
    return function (pct) {
      var invT = 1 - pct,
          tangentX = (2 * invT * (p2x - p1x)) + (2 * pct * (p3x - p2x)),
          tangentY = (2 * invT * (p2y - p1y)) + (2 * pct * (p3y - p2y));
      return Math.atan2(tangentY, tangentX);
    };
  }


  // this will run over a path segment ( a cubic or quadratic segment) and approximate it
  // with 100 segemnts. This will good enough to calculate the length of the curve
  function pathIterator(iterator, x1, y1) {
    var tempP = { x: x1, y: y1 }, p, tmpLen = 0, perc;
    for (perc = 1; perc <= 100; perc += 1) {
      p = iterator(perc / 100);
      tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);
      tempP = p;
    }
    return tmpLen;
  }

  /**
   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1
   * that correspond to that pixels run over the path.
   * The percentage will be then used to find the correct point on the canvas for the path.
   * @param {Array} segInfo fabricJS collection of information on a parsed path
   * @param {Number} distance from starting point, in pixels.
   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;
   */
  function findPercentageForDistance(segInfo, distance) {
    var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y },
        p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
    // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100
    // the path
    while (tmpLen < distance && nextStep > 0.0001) {
      p = iterator(perc);
      lastPerc = perc;
      nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
      // compare tmpLen each cycle with distance, decide next perc to test.
      if ((nextLen + tmpLen) > distance) {
        // we discard this step and we make smaller steps.
        perc -= nextStep;
        nextStep /= 2;
      }
      else {
        tempP = p;
        perc += nextStep;
        tmpLen += nextLen;
      }
    }
    p.angle = angleFinder(lastPerc);
    return p;
  }

  /**
   * Run over a parsed and simplifed path and extrac some informations.
   * informations are length of each command and starting point
   * @param {Array} path fabricJS parsed path commands
   * @return {Array} path commands informations
   */
  function getPathSegmentsInfo(path) {
    var totalLength = 0, len = path.length, current,
        //x2 and y2 are the coords of segment start
        //x1 and y1 are the coords of the current point
        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;
    for (var i = 0; i < len; i++) {
      current = path[i];
      tempInfo = {
        x: x1,
        y: y1,
        command: current[0],
      };
      switch (current[0]) { //first letter
        case 'M':
          tempInfo.length = 0;
          x2 = x1 = current[1];
          y2 = y1 = current[2];
          break;
        case 'L':
          tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
          x1 = current[1];
          y1 = current[2];
          break;
        case 'C':
          iterator = getPointOnCubicBezierIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4],
            current[5],
            current[6]
          );
          angleFinder = getTangentCubicIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4],
            current[5],
            current[6]
          );
          tempInfo.iterator = iterator;
          tempInfo.angleFinder = angleFinder;
          tempInfo.length = pathIterator(iterator, x1, y1);
          x1 = current[5];
          y1 = current[6];
          break;
        case 'Q':
          iterator = getPointOnQuadraticBezierIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4]
          );
          angleFinder = getTangentQuadraticIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4]
          );
          tempInfo.iterator = iterator;
          tempInfo.angleFinder = angleFinder;
          tempInfo.length = pathIterator(iterator, x1, y1);
          x1 = current[3];
          y1 = current[4];
          break;
        case 'Z':
        case 'z':
          // we add those in order to ease calculations later
          tempInfo.destX = x2;
          tempInfo.destY = y2;
          tempInfo.length = calcLineLength(x1, y1, x2, y2);
          x1 = x2;
          y1 = y2;
          break;
      }
      totalLength += tempInfo.length;
      info.push(tempInfo);
    }
    info.push({ length: totalLength, x: x1, y: y1 });
    return info;
  }

  function getPointOnPath(path, distance, infos) {
    if (!infos) {
      infos = getPathSegmentsInfo(path);
    }
    var i = 0;
    while ((distance - infos[i].length > 0) && i < (infos.length - 2)) {
      distance -= infos[i].length;
      i++;
    }
    // var distance = infos[infos.length - 1] * perc;
    var segInfo = infos[i], segPercent = distance / segInfo.length,
        command = segInfo.command, segment = path[i], info;

    switch (command) {
      case 'M':
        return { x: segInfo.x, y: segInfo.y, angle: 0 };
      case 'Z':
      case 'z':
        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
          new fabric.Point(segInfo.destX, segInfo.destY),
          segPercent
        );
        info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
        return info;
      case 'L':
        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
          new fabric.Point(segment[1], segment[2]),
          segPercent
        );
        info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
        return info;
      case 'C':
        return findPercentageForDistance(segInfo, distance);
      case 'Q':
        return findPercentageForDistance(segInfo, distance);
    }
  }

  /**
   *
   * @param {string} pathString
   * @return {(string|number)[][]} An array of SVG path commands
   * @example <caption>Usage</caption>
   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [
   *   ['M', 3, 4],
   *   ['Q', 3, 5, 2, 1, 4, 0],
   *   ['Q', 9, 12, 2, 1, 4, 0],
   * ];
   *
   */
  function parsePath(pathString) {
    var result = [],
        coords = [],
        currentPath,
        parsed,
        re = fabric.rePathCommand,
        rNumber = '[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*',
        rNumberCommaWsp = '(' + rNumber + ')' + fabric.commaWsp,
        rFlagCommaWsp = '([01])' + fabric.commaWsp + '?',
        rArcSeq = rNumberCommaWsp + '?' + rNumberCommaWsp + '?' + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp +
          rNumberCommaWsp + '?(' + rNumber + ')',
        regArcArgumentSequence = new RegExp(rArcSeq, 'g'),
        match,
        coordsStr,
        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
        path;
    if (!pathString || !pathString.match) {
      return result;
    }
    path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

    for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
      currentPath = path[i];

      coordsStr = currentPath.slice(1).trim();
      coords.length = 0;

      var command = currentPath.charAt(0);
      coordsParsed = [command];

      if (command.toLowerCase() === 'a') {
        // arcs have special flags that apparently don't require spaces so handle special
        for (var args; (args = regArcArgumentSequence.exec(coordsStr));) {
          for (var j = 1; j < args.length; j++) {
            coords.push(args[j]);
          }
        }
      }
      else {
        while ((match = re.exec(coordsStr))) {
          coords.push(match[0]);
        }
      }

      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          coordsParsed.push(parsed);
        }
      }

      var commandLength = commandLengths[command.toLowerCase()],
          repeatedCommand = repeatedCommands[command] || command;

      if (coordsParsed.length - 1 > commandLength) {
        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
          result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
          command = repeatedCommand;
        }
      }
      else {
        result.push(coordsParsed);
      }
    }

    return result;
  };

  /**
   *
   * Converts points to a smooth SVG path
   * @param {{ x: number,y: number }[]} points Array of points
   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.
   * @return {(string|number)[][]} An array of SVG path commands
   */
  function getSmoothPathFromPoints(points, correction) {
    var path = [], i,
        p1 = new fabric.Point(points[0].x, points[0].y),
        p2 = new fabric.Point(points[1].x, points[1].y),
        len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;
    correction = correction || 0;

    if (manyPoints) {
      multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
      multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
    }
    path.push(['M', p1.x - multSignX * correction, p1.y - multSignY * correction]);
    for (i = 1; i < len; i++) {
      if (!p1.eq(p2)) {
        var midPoint = p1.midPointFrom(p2);
        // p1 is our bezier control point
        // midpoint is our endpoint
        // start point is p(i-1) value.
        path.push(['Q', p1.x, p1.y, midPoint.x, midPoint.y]);
      }
      p1 = points[i];
      if ((i + 1) < points.length) {
        p2 = points[i + 1];
      }
    }
    if (manyPoints) {
      multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
      multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
    }
    path.push(['L', p1.x + multSignX * correction, p1.y + multSignY * correction]);
    return path;
  }
  /**
   * Transform a path by transforming each segment.
   * it has to be a simplified path or it won't work.
   * WARNING: this depends from pathOffset for correct operation
   * @param {Array} path fabricJS parsed and simplified path commands
   * @param {Array} transform matrix that represent the transformation
   * @param {Object} [pathOffset] the fabric.Path pathOffset
   * @param {Number} pathOffset.x
   * @param {Number} pathOffset.y
   * @returns {Array} the transformed path
   */
  function transformPath(path, transform, pathOffset) {
    if (pathOffset) {
      transform = fabric.util.multiplyTransformMatrices(
        transform,
        [1, 0, 0, 1, -pathOffset.x, -pathOffset.y]
      );
    }
    return path.map(function(pathSegment) {
      var newSegment = pathSegment.slice(0), point = {};
      for (var i = 1; i < pathSegment.length - 1; i += 2) {
        point.x = pathSegment[i];
        point.y = pathSegment[i + 1];
        point = fabric.util.transformPoint(point, transform);
        newSegment[i] = point.x;
        newSegment[i + 1] = point.y;
      }
      return newSegment;
    });
  }

  /**
   * Join path commands to go back to svg format
   * @param {Array} pathData fabricJS parsed path commands
   * @return {String} joined path 'M 0 0 L 20 30'
   */
  fabric.util.joinPath = function(pathData) {
    return pathData.map(function (segment) { return segment.join(' '); }).join(' ');
  };
  fabric.util.parsePath = parsePath;
  fabric.util.makePathSimpler = makePathSimpler;
  fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;
  fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;
  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
  fabric.util.getPointOnPath = getPointOnPath;
  fabric.util.transformPath = transformPath;
})();
(function() {

  var slice = Array.prototype.slice;

  /**
   * Invokes method on all items in a given array
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} method Name of a method to invoke
   * @return {Array}
   */
  function invoke(array, method) {
    var args = slice.call(arguments, 2), result = [];
    for (var i = 0, len = array.length; i < len; i++) {
      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
    }
    return result;
  }

  /**
   * Finds maximum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function max(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 >= value2;
    });
  }

  /**
   * Finds minimum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function min(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 < value2;
    });
  }

  /**
   * @private
   */
  function fill(array, value) {
    var k = array.length;
    while (k--) {
      array[k] = value;
    }
    return array;
  }

  /**
   * @private
   */
  function find(array, byProperty, condition) {
    if (!array || array.length === 0) {
      return;
    }

    var i = array.length - 1,
        result = byProperty ? array[i][byProperty] : array[i];
    if (byProperty) {
      while (i--) {
        if (condition(array[i][byProperty], result)) {
          result = array[i][byProperty];
        }
      }
    }
    else {
      while (i--) {
        if (condition(array[i], result)) {
          result = array[i];
        }
      }
    }
    return result;
  }

  /**
   * @namespace fabric.util.array
   */
  fabric.util.array = {
    fill: fill,
    invoke: invoke,
    min: min,
    max: max
  };

})();
(function() {
  /**
   * Copies all enumerable properties of one js object to another
   * this does not and cannot compete with generic utils.
   * Does not clone or extend fabric.Object subclasses.
   * This is mostly for internal use and has extra handling for fabricJS objects
   * it skips the canvas and group properties in deep cloning.
   * @memberOf fabric.util.object
   * @param {Object} destination Where to copy to
   * @param {Object} source Where to copy from
   * @param {Boolean} [deep] Whether to extend nested objects
   * @return {Object}
   */

  function extend(destination, source, deep) {
    // JScript DontEnum bug is not taken care of
    // the deep clone is for internal use, is not meant to avoid
    // javascript traps or cloning html element or self referenced objects.
    if (deep) {
      if (!fabric.isLikelyNode && source instanceof Element) {
        // avoid cloning deep images, canvases,
        destination = source;
      }
      else if (source instanceof Array) {
        destination = [];
        for (var i = 0, len = source.length; i < len; i++) {
          destination[i] = extend({ }, source[i], deep);
        }
      }
      else if (source && typeof source === 'object') {
        for (var property in source) {
          if (property === 'canvas' || property === 'group') {
            // we do not want to clone this props at all.
            // we want to keep the keys in the copy
            destination[property] = null;
          }
          else if (source.hasOwnProperty(property)) {
            destination[property] = extend({ }, source[property], deep);
          }
        }
      }
      else {
        // this sounds odd for an extend but is ok for recursive use
        destination = source;
      }
    }
    else {
      for (var property in source) {
        destination[property] = source[property];
      }
    }
    return destination;
  }

  /**
   * Creates an empty object and copies all enumerable properties of another object to it
   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. 
   * @memberOf fabric.util.object
   * @param {Object} object Object to clone
   * @param {Boolean} [deep] Whether to clone nested objects
   * @return {Object}
   */

  //TODO: this function return an empty object if you try to clone null
  function clone(object, deep) {
    return extend({ }, object, deep);
  }

  /** @namespace fabric.util.object */
  fabric.util.object = {
    extend: extend,
    clone: clone
  };
  fabric.util.object.extend(fabric.util, fabric.Observable);
})();
(function() {

  /**
   * Camelizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to camelize
   * @return {String} Camelized version of a string
   */
  function camelize(string) {
    return string.replace(/-+(.)?/g, function(match, character) {
      return character ? character.toUpperCase() : '';
    });
  }

  /**
   * Capitalizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to capitalize
   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
   * and other letters stay untouched, if false first letter is capitalized
   * and other letters are converted to lowercase.
   * @return {String} Capitalized version of a string
   */
  function capitalize(string, firstLetterOnly) {
    return string.charAt(0).toUpperCase() +
      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
  }

  /**
   * Escapes XML in a string
   * @memberOf fabric.util.string
   * @param {String} string String to escape
   * @return {String} Escaped version of a string
   */
  function escapeXml(string) {
    return string.replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  /**
   * Divide a string in the user perceived single units
   * @memberOf fabric.util.string
   * @param {String} textstring String to escape
   * @return {Array} array containing the graphemes
   */
  function graphemeSplit(textstring) {
    var i = 0, chr, graphemes = [];
    for (i = 0, chr; i < textstring.length; i++) {
      if ((chr = getWholeChar(textstring, i)) === false) {
        continue;
      }
      graphemes.push(chr);
    }
    return graphemes;
  }

  // taken from mdn in the charAt doc page.
  function getWholeChar(str, i) {
    var code = str.charCodeAt(i);

    if (isNaN(code)) {
      return ''; // Position not found
    }
    if (code < 0xD800 || code > 0xDFFF) {
      return str.charAt(i);
    }

    // High surrogate (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 <= code && code <= 0xDBFF) {
      if (str.length <= (i + 1)) {
        throw 'High surrogate without following low surrogate';
      }
      var next = str.charCodeAt(i + 1);
      if (0xDC00 > next || next > 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
    }
    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
    if (i === 0) {
      throw 'Low surrogate without preceding high surrogate';
    }
    var prev = str.charCodeAt(i - 1);

    // (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 > prev || prev > 0xDBFF) {
      throw 'Low surrogate without preceding high surrogate';
    }
    // We can pass over low surrogates now as the second component
    // in a pair which we have already processed
    return false;
  }


  /**
   * String utilities
   * @namespace fabric.util.string
   */
  fabric.util.string = {
    camelize: camelize,
    capitalize: capitalize,
    escapeXml: escapeXml,
    graphemeSplit: graphemeSplit
  };
})();
(function() {

  var slice = Array.prototype.slice, emptyFunction = function() { },

      IS_DONTENUM_BUGGY = (function() {
        for (var p in { toString: 1 }) {
          if (p === 'toString') {
            return false;
          }
        }
        return true;
      })(),

      /** @ignore */
      addMethods = function(klass, source, parent) {
        for (var property in source) {

          if (property in klass.prototype &&
              typeof klass.prototype[property] === 'function' &&
              (source[property] + '').indexOf('callSuper') > -1) {

            klass.prototype[property] = (function(property) {
              return function() {

                var superclass = this.constructor.superclass;
                this.constructor.superclass = parent;
                var returnValue = source[property].apply(this, arguments);
                this.constructor.superclass = superclass;

                if (property !== 'initialize') {
                  return returnValue;
                }
              };
            })(property);
          }
          else {
            klass.prototype[property] = source[property];
          }

          if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
              klass.prototype.toString = source.toString;
            }
            if (source.valueOf !== Object.prototype.valueOf) {
              klass.prototype.valueOf = source.valueOf;
            }
          }
        }
      };

  function Subclass() { }

  function callSuper(methodName) {
    var parentMethod = null,
        _this = this;

    // climb prototype chain to find method not equal to callee's method
    while (_this.constructor.superclass) {
      var superClassMethod = _this.constructor.superclass.prototype[methodName];
      if (_this[methodName] !== superClassMethod) {
        parentMethod = superClassMethod;
        break;
      }
      // eslint-disable-next-line
      _this = _this.constructor.superclass.prototype;
    }

    if (!parentMethod) {
      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
    }

    return (arguments.length > 1)
      ? parentMethod.apply(this, slice.call(arguments, 1))
      : parentMethod.call(this);
  }

  /**
   * Helper for creation of "classes".
   * @memberOf fabric.util
   * @param {Function} [parent] optional "Class" to inherit from
   * @param {Object} [properties] Properties shared by all instances of this class
   *                  (be careful modifying objects defined here as this would affect all instances)
   */
  function createClass() {
    var parent = null,
        properties = slice.call(arguments, 0);

    if (typeof properties[0] === 'function') {
      parent = properties.shift();
    }
    function klass() {
      this.initialize.apply(this, arguments);
    }

    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      Subclass.prototype = parent.prototype;
      klass.prototype = new Subclass();
      parent.subclasses.push(klass);
    }
    for (var i = 0, length = properties.length; i < length; i++) {
      addMethods(klass, properties[i], parent);
    }
    if (!klass.prototype.initialize) {
      klass.prototype.initialize = emptyFunction;
    }
    klass.prototype.constructor = klass;
    klass.prototype.callSuper = callSuper;
    return klass;
  }

  fabric.util.createClass = createClass;
})();
(function () {
  // since ie11 can use addEventListener but they do not support options, i need to check
  var couldUseAttachEvent = !!fabric.document.createElement('div').attachEvent,
      touchEvents = ['touchstart', 'touchmove', 'touchend'];
  /**
   * Adds an event listener to an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.addListener = function(element, eventName, handler, options) {
    element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
  };

  /**
   * Removes an event listener from an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.removeListener = function(element, eventName, handler, options) {
    element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
  };

  function getTouchInfo(event) {
    var touchProp = event.changedTouches;
    if (touchProp && touchProp[0]) {
      return touchProp[0];
    }
    return event;
  }

  fabric.util.getPointer = function(event) {
    var element = event.target,
        scroll = fabric.util.getScrollLeftTop(element),
        _evt = getTouchInfo(event);
    return {
      x: _evt.clientX + scroll.left,
      y: _evt.clientY + scroll.top
    };
  };

  fabric.util.isTouchEvent = function(event) {
    return touchEvents.indexOf(event.type) > -1 || event.pointerType === 'touch';
  };
})();
(function () {

  /**
   * Cross-browser wrapper for setting element's style
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {Object} styles
   * @return {HTMLElement} Element that was passed as a first argument
   */
  function setStyle(element, styles) {
    var elementStyle = element.style;
    if (!elementStyle) {
      return element;
    }
    if (typeof styles === 'string') {
      element.style.cssText += ';' + styles;
      return styles.indexOf('opacity') > -1
        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
        : element;
    }
    for (var property in styles) {
      if (property === 'opacity') {
        setOpacity(element, styles[property]);
      }
      else {
        var normalizedProperty = (property === 'float' || property === 'cssFloat')
          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
          : property;
        elementStyle[normalizedProperty] = styles[property];
      }
    }
    return element;
  }

  var parseEl = fabric.document.createElement('div'),
      supportsOpacity = typeof parseEl.style.opacity === 'string',
      supportsFilters = typeof parseEl.style.filter === 'string',
      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

      /** @ignore */
      setOpacity = function (element) { return element; };

  if (supportsOpacity) {
    /** @ignore */
    setOpacity = function(element, value) {
      element.style.opacity = value;
      return element;
    };
  }
  else if (supportsFilters) {
    /** @ignore */
    setOpacity = function(element, value) {
      var es = element.style;
      if (element.currentStyle && !element.currentStyle.hasLayout) {
        es.zoom = 1;
      }
      if (reOpacity.test(es.filter)) {
        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
        es.filter = es.filter.replace(reOpacity, value);
      }
      else {
        es.filter += ' alpha(opacity=' + (value * 100) + ')';
      }
      return element;
    };
  }

  fabric.util.setStyle = setStyle;

})();
(function() {

  var _slice = Array.prototype.slice;

  /**
   * Takes id and returns an element with that id (if one exists in a document)
   * @memberOf fabric.util
   * @param {String|HTMLElement} id
   * @return {HTMLElement|null}
   */
  function getById(id) {
    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
  }

  var sliceCanConvertNodelists,
      /**
       * Converts an array-like object (e.g. arguments or NodeList) to an array
       * @memberOf fabric.util
       * @param {Object} arrayLike
       * @return {Array}
       */
      toArray = function(arrayLike) {
        return _slice.call(arrayLike, 0);
      };

  try {
    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
  }
  catch (err) { }

  if (!sliceCanConvertNodelists) {
    toArray = function(arrayLike) {
      var arr = new Array(arrayLike.length), i = arrayLike.length;
      while (i--) {
        arr[i] = arrayLike[i];
      }
      return arr;
    };
  }

  /**
   * Creates specified element with specified attributes
   * @memberOf fabric.util
   * @param {String} tagName Type of an element to create
   * @param {Object} [attributes] Attributes to set on an element
   * @return {HTMLElement} Newly created element
   */
  function makeElement(tagName, attributes) {
    var el = fabric.document.createElement(tagName);
    for (var prop in attributes) {
      if (prop === 'class') {
        el.className = attributes[prop];
      }
      else if (prop === 'for') {
        el.htmlFor = attributes[prop];
      }
      else {
        el.setAttribute(prop, attributes[prop]);
      }
    }
    return el;
  }

  /**
   * Adds class to an element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to add class to
   * @param {String} className Class to add to an element
   */
  function addClass(element, className) {
    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
      element.className += (element.className ? ' ' : '') + className;
    }
  }

  /**
   * Wraps element with another element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to wrap
   * @param {HTMLElement|String} wrapper Element to wrap with
   * @param {Object} [attributes] Attributes to set on a wrapper
   * @return {HTMLElement} wrapper
   */
  function wrapElement(element, wrapper, attributes) {
    if (typeof wrapper === 'string') {
      wrapper = makeElement(wrapper, attributes);
    }
    if (element.parentNode) {
      element.parentNode.replaceChild(wrapper, element);
    }
    wrapper.appendChild(element);
    return wrapper;
  }

  /**
   * Returns element scroll offsets
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to operate on
   * @return {Object} Object with left/top values
   */
  function getScrollLeftTop(element) {

    var left = 0,
        top = 0,
        docElement = fabric.document.documentElement,
        body = fabric.document.body || {
          scrollLeft: 0, scrollTop: 0
        };

    // While loop checks (and then sets element to) .parentNode OR .host
    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
    //  but the .parentNode of a root ShadowDOM node will always be null, instead
    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
    while (element && (element.parentNode || element.host)) {

      // Set element to element parent, or 'host' in case of ShadowDOM
      element = element.parentNode || element.host;

      if (element === fabric.document) {
        left = body.scrollLeft || docElement.scrollLeft || 0;
        top = body.scrollTop ||  docElement.scrollTop || 0;
      }
      else {
        left += element.scrollLeft || 0;
        top += element.scrollTop || 0;
      }

      if (element.nodeType === 1 && element.style.position === 'fixed') {
        break;
      }
    }

    return { left: left, top: top };
  }

  /**
   * Returns offset for a given element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get offset for
   * @return {Object} Object with "left" and "top" properties
   */
  function getElementOffset(element) {
    var docElem,
        doc = element && element.ownerDocument,
        box = { left: 0, top: 0 },
        offset = { left: 0, top: 0 },
        scrollLeftTop,
        offsetAttributes = {
          borderLeftWidth: 'left',
          borderTopWidth:  'top',
          paddingLeft:     'left',
          paddingTop:      'top'
        };

    if (!doc) {
      return offset;
    }

    for (var attr in offsetAttributes) {
      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
    }

    docElem = doc.documentElement;
    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
      box = element.getBoundingClientRect();
    }

    scrollLeftTop = getScrollLeftTop(element);

    return {
      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
    };
  }

  /**
   * Returns style attribute value of a given element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get style attribute for
   * @param {String} attr Style attribute to get for element
   * @return {String} Style attribute value of the given element.
   */
  var getElementStyle;
  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
    getElementStyle = function(element, attr) {
      var style = fabric.document.defaultView.getComputedStyle(element, null);
      return style ? style[attr] : undefined;
    };
  }
  else {
    getElementStyle = function(element, attr) {
      var value = element.style[attr];
      if (!value && element.currentStyle) {
        value = element.currentStyle[attr];
      }
      return value;
    };
  }

  (function () {
    var style = fabric.document.documentElement.style,
        selectProp = 'userSelect' in style
          ? 'userSelect'
          : 'MozUserSelect' in style
            ? 'MozUserSelect'
            : 'WebkitUserSelect' in style
              ? 'WebkitUserSelect'
              : 'KhtmlUserSelect' in style
                ? 'KhtmlUserSelect'
                : '';

    /**
     * Makes element unselectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make unselectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementUnselectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = fabric.util.falseFunction;
      }
      if (selectProp) {
        element.style[selectProp] = 'none';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = 'on';
      }
      return element;
    }

    /**
     * Makes element selectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make selectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementSelectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = null;
      }
      if (selectProp) {
        element.style[selectProp] = '';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = '';
      }
      return element;
    }

    fabric.util.makeElementUnselectable = makeElementUnselectable;
    fabric.util.makeElementSelectable = makeElementSelectable;
  })();

  function getNodeCanvas(element) {
    var impl = fabric.jsdomImplForWrapper(element);
    return impl._canvas || impl._image;
  };

  function cleanUpJsdomNode(element) {
    if (!fabric.isLikelyNode) {
      return;
    }
    var impl = fabric.jsdomImplForWrapper(element);
    if (impl) {
      impl._image = null;
      impl._canvas = null;
      // unsure if necessary
      impl._currentSrc = null;
      impl._attributes = null;
      impl._classList = null;
    }
  }

  function setImageSmoothing(ctx, value) {
    ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
      || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
    ctx.imageSmoothingEnabled = value;
  }

  /**
   * setImageSmoothing sets the context imageSmoothingEnabled property.
   * Used by canvas and by ImageObject.
   * @memberOf fabric.util
   * @since 4.0.0
   * @param {HTMLRenderingContext2D} ctx to set on
   * @param {Boolean} value true or false
   */
  fabric.util.setImageSmoothing = setImageSmoothing;
  fabric.util.getById = getById;
  fabric.util.toArray = toArray;
  fabric.util.addClass = addClass;
  fabric.util.makeElement = makeElement;
  fabric.util.wrapElement = wrapElement;
  fabric.util.getScrollLeftTop = getScrollLeftTop;
  fabric.util.getElementOffset = getElementOffset;
  fabric.util.getNodeCanvas = getNodeCanvas;
  fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;

})();
(function() {

  function addParamToUrl(url, param) {
    return url + (/\?/.test(url) ? '&' : '?') + param;
  }

  function emptyFn() { }

  /**
   * Cross-browser abstraction for sending XMLHttpRequest
   * @memberOf fabric.util
   * @param {String} url URL to send XMLHttpRequest to
   * @param {Object} [options] Options object
   * @param {String} [options.method="GET"]
   * @param {String} [options.parameters] parameters to append to url in GET or in body
   * @param {String} [options.body] body to send with POST or PUT request
   * @param {Function} options.onComplete Callback to invoke when request is completed
   * @return {XMLHttpRequest} request
   */
  function request(url, options) {
    options || (options = { });

    var method = options.method ? options.method.toUpperCase() : 'GET',
        onComplete = options.onComplete || function() { },
        xhr = new fabric.window.XMLHttpRequest(),
        body = options.body || options.parameters;

    /** @ignore */
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        onComplete(xhr);
        xhr.onreadystatechange = emptyFn;
      }
    };

    if (method === 'GET') {
      body = null;
      if (typeof options.parameters === 'string') {
        url = addParamToUrl(url, options.parameters);
      }
    }

    xhr.open(method, url, true);

    if (method === 'POST' || method === 'PUT') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    xhr.send(body);
    return xhr;
  }

  fabric.util.request = request;
})();
/**
 * Wrapper around `console.log` (when available)
 * @param {*} [values] Values to log
 */
fabric.log = console.log;

/**
 * Wrapper around `console.warn` (when available)
 * @param {*} [values] Values to log as a warning
 */
fabric.warn = console.warn;
(function () {

  var extend = fabric.util.object.extend,
      clone = fabric.util.object.clone;

  /**
   * @typedef {Object} AnimationOptions
   * Animation of a value or list of values.
   * When using lists, think of something like this:
   * fabric.util.animate({
   *   startValue: [1, 2, 3],
   *   endValue: [2, 4, 6],
   *   onChange: function([a, b, c]) {
   *     canvas.zoomToPoint({x: b, y: c}, a)
   *     canvas.renderAll()
   *   }
   * });
   * @example
   * @property {Function} [onChange] Callback; invoked on every value change
   * @property {Function} [onComplete] Callback; invoked when value change is completed
   * @example
   * // Note: startValue, endValue, and byValue must match the type
   * var animationOptions = { startValue: 0, endValue: 1, byValue: 0.25 }
   * var animationOptions = { startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] }
   * @property {number | number[]} [startValue=0] Starting value
   * @property {number | number[]} [endValue=100] Ending value
   * @property {number | number[]} [byValue=100] Value to modify the property by
   * @property {Function} [easing] Easing function
   * @property {Number} [duration=500] Duration of change (in ms)
   * @property {Function} [abort] Additional function with logic. If returns true, animation aborts.
   *
   * @typedef {() => void} CancelFunction
   *
   * @typedef {Object} AnimationCurrentState
   * @property {number | number[]} currentValue value in range [`startValue`, `endValue`]
   * @property {number} completionRate value in range [0, 1]
   * @property {number} durationRate value in range [0, 1]
   *
   * @typedef {(AnimationOptions & AnimationCurrentState & { cancel: CancelFunction }} AnimationContext
   */

  /**
   * Array holding all running animations
   * @memberof fabric
   * @type {AnimationContext[]}
   */
  var RUNNING_ANIMATIONS = [];
  fabric.util.object.extend(RUNNING_ANIMATIONS, {

    /**
     * cancel all running animations at the next requestAnimFrame
     * @returns {AnimationContext[]}
     */
    cancelAll: function () {
      var animations = this.splice(0);
      animations.forEach(function (animation) {
        animation.cancel();
      });
      return animations;
    },

    /**
     * cancel all running animations attached to canvas at the next requestAnimFrame
     * @param {fabric.Canvas} canvas
     * @returns {AnimationContext[]}
     */
    cancelByCanvas: function (canvas) {
      if (!canvas) {
        return [];
      }
      var cancelled = this.filter(function (animation) {
        return typeof animation.target === 'object' && animation.target.canvas === canvas;
      });
      cancelled.forEach(function (animation) {
        animation.cancel();
      });
      return cancelled;
    },

    /**
     * cancel all running animations for target at the next requestAnimFrame
     * @param {*} target
     * @returns {AnimationContext[]}
     */
    cancelByTarget: function (target) {
      var cancelled = this.findAnimationsByTarget(target);
      cancelled.forEach(function (animation) {
        animation.cancel();
      });
      return cancelled;
    },

    /**
     *
     * @param {CancelFunction} cancelFunc the function returned by animate
     * @returns {number}
     */
    findAnimationIndex: function (cancelFunc) {
      return this.indexOf(this.findAnimation(cancelFunc));
    },

    /**
     *
     * @param {CancelFunction} cancelFunc the function returned by animate
     * @returns {AnimationContext | undefined} animation's options object
     */
    findAnimation: function (cancelFunc) {
      return this.find(function (animation) {
        return animation.cancel === cancelFunc;
      });
    },

    /**
     *
     * @param {*} target the object that is assigned to the target property of the animation context
     * @returns {AnimationContext[]} array of animation options object associated with target
     */
    findAnimationsByTarget: function (target) {
      if (!target) {
        return [];
      }
      return this.filter(function (animation) {
        return animation.target === target;
      });
    }
  });

  function noop() {
    return false;
  }

  function defaultEasing(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {AnimationOptions} [options] Animation options
   * @example
   * // Note: startValue, endValue, and byValue must match the type
   * fabric.util.animate({ startValue: 0, endValue: 1, byValue: 0.25 })
   * fabric.util.animate({ startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] })
   * @returns {CancelFunction} cancel function
   */
  function animate(options) {
    options || (options = {});
    var cancel = false,
        context,
        removeFromRegistry = function () {
          var index = fabric.runningAnimations.indexOf(context);
          return index > -1 && fabric.runningAnimations.splice(index, 1)[0];
        };

    context = extend(clone(options), {
      cancel: function () {
        cancel = true;
        return removeFromRegistry();
      },
      currentValue: 'startValue' in options ? options.startValue : 0,
      completionRate: 0,
      durationRate: 0
    });
    fabric.runningAnimations.push(context);

    requestAnimFrame(function(timestamp) {
      var start = timestamp || +new Date(),
          duration = options.duration || 500,
          finish = start + duration, time,
          onChange = options.onChange || noop,
          abort = options.abort || noop,
          onComplete = options.onComplete || noop,
          easing = options.easing || defaultEasing,
          isMany = 'startValue' in options ? options.startValue.length > 0 : false,
          startValue = 'startValue' in options ? options.startValue : 0,
          endValue = 'endValue' in options ? options.endValue : 100,
          byValue = options.byValue || (isMany ? startValue.map(function(value, i) {
            return endValue[i] - startValue[i];
          }) : endValue - startValue);

      options.onStart && options.onStart();

      (function tick(ticktime) {
        time = ticktime || +new Date();
        var currentTime = time > finish ? duration : (time - start),
            timePerc = currentTime / duration,
            current = isMany ? startValue.map(function(_value, i) {
              return easing(currentTime, startValue[i], byValue[i], duration);
            }) : easing(currentTime, startValue, byValue, duration),
            valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0])
              : Math.abs((current - startValue) / byValue);
        //  update context
        context.currentValue = isMany ? current.slice() : current;
        context.completionRate = valuePerc;
        context.durationRate = timePerc;
        if (cancel) {
          return;
        }
        if (abort(current, valuePerc, timePerc)) {
          removeFromRegistry();
          return;
        }
        if (time > finish) {
          //  update context
          context.currentValue = isMany ? endValue.slice() : endValue;
          context.completionRate = 1;
          context.durationRate = 1;
          //  execute callbacks
          onChange(isMany ? endValue.slice() : endValue, 1, 1);
          onComplete(endValue, 1, 1);
          removeFromRegistry();
          return;
        }
        else {
          onChange(current, valuePerc, timePerc);
          requestAnimFrame(tick);
        }
      })(start);
    });

    return context.cancel;
  }

  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                          fabric.window.webkitRequestAnimationFrame ||
                          fabric.window.mozRequestAnimationFrame    ||
                          fabric.window.oRequestAnimationFrame      ||
                          fabric.window.msRequestAnimationFrame     ||
                          function(callback) {
                            return fabric.window.setTimeout(callback, 1000 / 60);
                          };

  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

  /**
   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
   * @memberOf fabric.util
   * @param {Function} callback Callback to invoke
   * @param {DOMElement} element optional Element to associate with animation
   */
  function requestAnimFrame() {
    return _requestAnimFrame.apply(fabric.window, arguments);
  }

  function cancelAnimFrame() {
    return _cancelAnimFrame.apply(fabric.window, arguments);
  }

  fabric.util.animate = animate;
  fabric.util.requestAnimFrame = requestAnimFrame;
  fabric.util.cancelAnimFrame = cancelAnimFrame;
  fabric.runningAnimations = RUNNING_ANIMATIONS;
})();
(function() {
  // Calculate an in-between color. Returns a "rgba()" string.
  // Credit: Edwin Martin <edwin@bitstorm.org>
  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
  function calculateColor(begin, end, pos) {
    var color = 'rgba('
        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
    color += ')';
    return color;
  }

  /**
   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {String} fromColor The starting color in hex or rgb(a) format.
   * @param {String} toColor The starting color in hex or rgb(a) format.
   * @param {Number} [duration] Duration of change (in ms).
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
   * @returns {Function} abort function
   */
  function animateColor(fromColor, toColor, duration, options) {
    var startColor = new fabric.Color(fromColor).getSource(),
        endColor = new fabric.Color(toColor).getSource(),
        originalOnComplete = options.onComplete,
        originalOnChange = options.onChange;
    options = options || {};

    return fabric.util.animate(fabric.util.object.extend(options, {
      duration: duration || 500,
      startValue: startColor,
      endValue: endColor,
      byValue: endColor,
      easing: function (currentTime, startValue, byValue, duration) {
        var posValue = options.colorEasing
          ? options.colorEasing(currentTime, duration)
          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
        return calculateColor(startValue, byValue, posValue);
      },
      // has to take in account for color restoring;
      onComplete: function(current, valuePerc, timePerc) {
        if (originalOnComplete) {
          return originalOnComplete(
            calculateColor(endColor, endColor, 0),
            valuePerc,
            timePerc
          );
        }
      },
      onChange: function(current, valuePerc, timePerc) {
        if (originalOnChange) {
          if (Array.isArray(current)) {
            return originalOnChange(
              calculateColor(current, current, 0),
              valuePerc,
              timePerc
            );
          }
          originalOnChange(current, valuePerc, timePerc);
        }
      }
    }));
  }

  fabric.util.animateColor = animateColor;

})();
(function() {

  function normalize(a, c, p, s) {
    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    }
    else {
      //handle the 0/0 case:
      if (c === 0 && a === 0) {
        s = p / (2 * Math.PI) * Math.asin(1);
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
    }
    return { a: a, c: c, p: p, s: s };
  }

  function elastic(opts, t, d) {
    return opts.a *
      Math.pow(2, 10 * (t -= 1)) *
      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
  }

  /**
   * Cubic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }

  /**
   * Cubic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCubic(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }

  /**
   * Quartic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuart(t, b, c, d) {
    return c * (t /= d) * t * t * t + b;
  }

  /**
   * Quartic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuart(t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  }

  /**
   * Quartic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuart(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t + b;
    }
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }

  /**
   * Quintic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuint(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  }

  /**
   * Quintic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuint(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  }

  /**
   * Quintic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuint(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }

  /**
   * Sinusoidal easing in
   * @memberOf fabric.util.ease
   */
  function easeInSine(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Sinusoidal easing out
   * @memberOf fabric.util.ease
   */
  function easeOutSine(t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  }

  /**
   * Sinusoidal easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutSine(t, b, c, d) {
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  }

  /**
   * Exponential easing in
   * @memberOf fabric.util.ease
   */
  function easeInExpo(t, b, c, d) {
    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
  }

  /**
   * Exponential easing out
   * @memberOf fabric.util.ease
   */
  function easeOutExpo(t, b, c, d) {
    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  }

  /**
   * Exponential easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutExpo(t, b, c, d) {
    if (t === 0) {
      return b;
    }
    if (t === d) {
      return b + c;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    }
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }

  /**
   * Circular easing in
   * @memberOf fabric.util.ease
   */
  function easeInCirc(t, b, c, d) {
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  }

  /**
   * Circular easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCirc(t, b, c, d) {
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  }

  /**
   * Circular easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCirc(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    }
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }

  /**
   * Elastic easing in
   * @memberOf fabric.util.ease
   */
  function easeInElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return -elastic(opts, t, d) + b;
  }

  /**
   * Elastic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
  }

  /**
   * Elastic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d / 2;
    if (t === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    var opts = normalize(a, c, p, s);
    if (t < 1) {
      return -0.5 * elastic(opts, t, d) + b;
    }
    return opts.a * Math.pow(2, -10 * (t -= 1)) *
      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
  }

  /**
   * Backwards easing in
   * @memberOf fabric.util.ease
   */
  function easeInBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  }

  /**
   * Backwards easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  }

  /**
   * Backwards easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
  }

  /**
   * Bouncing easing in
   * @memberOf fabric.util.ease
   */
  function easeInBounce(t, b, c, d) {
    return c - easeOutBounce (d - t, 0, c, d) + b;
  }

  /**
   * Bouncing easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBounce(t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
      return c * (7.5625 * t * t) + b;
    }
    else if (t < (2 / 2.75)) {
      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    }
    else if (t < (2.5 / 2.75)) {
      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    }
    else {
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
  }

  /**
   * Bouncing easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBounce(t, b, c, d) {
    if (t < d / 2) {
      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
    }
    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  }

  /**
   * Easing functions
   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
   * @namespace fabric.util.ease
   */
  fabric.util.ease = {

    /**
     * Quadratic easing in
     * @memberOf fabric.util.ease
     */
    easeInQuad: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },

    /**
     * Quadratic easing out
     * @memberOf fabric.util.ease
     */
    easeOutQuad: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },

    /**
     * Quadratic easing in and out
     * @memberOf fabric.util.ease
     */
    easeInOutQuad: function(t, b, c, d) {
      t /= (d / 2);
      if (t < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },

    /**
     * Cubic easing in
     * @memberOf fabric.util.ease
     */
    easeInCubic: function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },

    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint,
    easeInSine: easeInSine,
    easeOutSine: easeOutSine,
    easeInOutSine: easeInOutSine,
    easeInExpo: easeInExpo,
    easeOutExpo: easeOutExpo,
    easeInOutExpo: easeInOutExpo,
    easeInCirc: easeInCirc,
    easeOutCirc: easeOutCirc,
    easeInOutCirc: easeInOutCirc,
    easeInElastic: easeInElastic,
    easeOutElastic: easeOutElastic,
    easeInOutElastic: easeInOutElastic,
    easeInBack: easeInBack,
    easeOutBack: easeOutBack,
    easeInOutBack: easeInOutBack,
    easeInBounce: easeInBounce,
    easeOutBounce: easeOutBounce,
    easeInOutBounce: easeInOutBounce
  };

})();
(function(global) {

  'use strict';

  /**
   * @name fabric
   * @namespace
   */

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      parseUnit = fabric.util.parseUnit,
      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
        'image', 'text'],
      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
      svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],

      attributesMap = {
        cx:                   'left',
        x:                    'left',
        r:                    'radius',
        cy:                   'top',
        y:                    'top',
        display:              'visible',
        visibility:           'visible',
        transform:            'transformMatrix',
        'fill-opacity':       'fillOpacity',
        'fill-rule':          'fillRule',
        'font-family':        'fontFamily',
        'font-size':          'fontSize',
        'font-style':         'fontStyle',
        'font-weight':        'fontWeight',
        'letter-spacing':     'charSpacing',
        'paint-order':        'paintFirst',
        'stroke-dasharray':   'strokeDashArray',
        'stroke-dashoffset':  'strokeDashOffset',
        'stroke-linecap':     'strokeLineCap',
        'stroke-linejoin':    'strokeLineJoin',
        'stroke-miterlimit':  'strokeMiterLimit',
        'stroke-opacity':     'strokeOpacity',
        'stroke-width':       'strokeWidth',
        'text-decoration':    'textDecoration',
        'text-anchor':        'textAnchor',
        opacity:              'opacity',
        'clip-path':          'clipPath',
        'clip-rule':          'clipRule',
        'vector-effect':      'strokeUniform',
        'image-rendering':    'imageSmoothing',
      },

      colorAttributes = {
        stroke: 'strokeOpacity',
        fill:   'fillOpacity'
      },

      fSize = 'font-size', cPath = 'clip-path';

  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

  fabric.cssRules = { };
  fabric.gradientDefs = { };
  fabric.clipPaths = { };

  function normalizeAttr(attr) {
    // transform attribute names
    if (attr in attributesMap) {
      return attributesMap[attr];
    }
    return attr;
  }

  function normalizeValue(attr, value, parentAttributes, fontSize) {
    var isArray = Array.isArray(value), parsed;

    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
      value = '';
    }
    else if (attr === 'strokeUniform') {
      return (value === 'non-scaling-stroke');
    }
    else if (attr === 'strokeDashArray') {
      if (value === 'none') {
        value = null;
      }
      else {
        value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
      }
    }
    else if (attr === 'transformMatrix') {
      if (parentAttributes && parentAttributes.transformMatrix) {
        value = multiplyTransformMatrices(
          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
      }
      else {
        value = fabric.parseTransformAttribute(value);
      }
    }
    else if (attr === 'visible') {
      value = value !== 'none' && value !== 'hidden';
      // display=none on parent element always takes precedence over child element
      if (parentAttributes && parentAttributes.visible === false) {
        value = false;
      }
    }
    else if (attr === 'opacity') {
      value = parseFloat(value);
      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
        value *= parentAttributes.opacity;
      }
    }
    else if (attr === 'textAnchor' /* text-anchor */) {
      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
    }
    else if (attr === 'charSpacing') {
      // parseUnit returns px and we convert it to em
      parsed = parseUnit(value, fontSize) / fontSize * 1000;
    }
    else if (attr === 'paintFirst') {
      var fillIndex = value.indexOf('fill');
      var strokeIndex = value.indexOf('stroke');
      var value = 'fill';
      if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
        value = 'stroke';
      }
      else if (fillIndex === -1 && strokeIndex > -1) {
        value = 'stroke';
      }
    }
    else if (attr === 'href' || attr === 'xlink:href' || attr === 'font') {
      return value;
    }
    else if (attr === 'imageSmoothing') {
      return (value === 'optimizeQuality');
    }
    else {
      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
    }

    return (!isArray && isNaN(parsed) ? value : parsed);
  }

  /**
    * @private
    */
  function getSvgRegex(arr) {
    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
  }

  /**
   * @private
   * @param {Object} attributes Array of attributes to parse
   */
  function _setStrokeFillOpacity(attributes) {
    for (var attr in colorAttributes) {

      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
        continue;
      }

      if (typeof attributes[attr] === 'undefined') {
        if (!fabric.Object.prototype[attr]) {
          continue;
        }
        attributes[attr] = fabric.Object.prototype[attr];
      }

      if (attributes[attr].indexOf('url(') === 0) {
        continue;
      }

      var color = new fabric.Color(attributes[attr]);
      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
    }
    return attributes;
  }

  /**
   * @private
   */
  function _getMultipleNodes(doc, nodeNames) {
    var nodeName, nodeArray = [], nodeList, i, len;
    for (i = 0, len = nodeNames.length; i < len; i++) {
      nodeName = nodeNames[i];
      nodeList = doc.getElementsByTagName(nodeName);
      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
    }
    return nodeArray;
  }

  /**
   * Parses "transform" attribute, returning an array of values
   * @static
   * @function
   * @memberOf fabric
   * @param {String} attributeValue String containing attribute value
   * @return {Array} Array of 6 elements representing transformation matrix
   */
  fabric.parseTransformAttribute = (function() {
    function rotateMatrix(matrix, args) {
      var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
          x = 0, y = 0;
      if (args.length === 3) {
        x = args[1];
        y = args[2];
      }

      matrix[0] = cos;
      matrix[1] = sin;
      matrix[2] = -sin;
      matrix[3] = cos;
      matrix[4] = x - (cos * x - sin * y);
      matrix[5] = y - (sin * x + cos * y);
    }

    function scaleMatrix(matrix, args) {
      var multiplierX = args[0],
          multiplierY = (args.length === 2) ? args[1] : args[0];

      matrix[0] = multiplierX;
      matrix[3] = multiplierY;
    }

    function skewMatrix(matrix, args, pos) {
      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
    }

    function translateMatrix(matrix, args) {
      matrix[4] = args[0];
      if (args.length === 2) {
        matrix[5] = args[1];
      }
    }

    // identity matrix
    var iMatrix = fabric.iMatrix,

        // == begin transform regexp
        number = fabric.reNum,

        commaWsp = fabric.commaWsp,

        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + ')' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        matrix = '(?:(matrix)\\s*\\(\\s*' +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' +
                  '\\s*\\))',

        transform = '(?:' +
                    matrix + '|' +
                    translate + '|' +
                    scale + '|' +
                    rotate + '|' +
                    skewX + '|' +
                    skewY +
                    ')',

        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

        transformList = '^\\s*(?:' + transforms + '?)\\s*$',

        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
        reTransformList = new RegExp(transformList),
        // == end transform regexp

        reTransform = new RegExp(transform, 'g');

    return function(attributeValue) {

      // start with identity matrix
      var matrix = iMatrix.concat(),
          matrices = [];

      // return if no argument was given or
      // an argument does not match transform attribute regexp
      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
        return matrix;
      }

      attributeValue.replace(reTransform, function(match) {

        var m = new RegExp(transform).exec(match).filter(function (match) {
              // match !== '' && match != null
              return (!!match);
            }),
            operation = m[1],
            args = m.slice(2).map(parseFloat);

        switch (operation) {
          case 'translate':
            translateMatrix(matrix, args);
            break;
          case 'rotate':
            args[0] = fabric.util.degreesToRadians(args[0]);
            rotateMatrix(matrix, args);
            break;
          case 'scale':
            scaleMatrix(matrix, args);
            break;
          case 'skewX':
            skewMatrix(matrix, args, 2);
            break;
          case 'skewY':
            skewMatrix(matrix, args, 1);
            break;
          case 'matrix':
            matrix = args;
            break;
        }

        // snapshot current matrix into matrices array
        matrices.push(matrix.concat());
        // reset
        matrix = iMatrix.concat();
      });

      var combinedMatrix = matrices[0];
      while (matrices.length > 1) {
        matrices.shift();
        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
      }
      return combinedMatrix;
    };
  })();

  /**
   * @private
   */
  function parseStyleString(style, oStyle) {
    var attr, value;
    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
      var pair = chunk.split(':');

      attr = pair[0].trim().toLowerCase();
      value =  pair[1].trim();

      oStyle[attr] = value;
    });
  }

  /**
   * @private
   */
  function parseStyleObject(style, oStyle) {
    var attr, value;
    for (var prop in style) {
      if (typeof style[prop] === 'undefined') {
        continue;
      }

      attr = prop.toLowerCase();
      value = style[prop];

      oStyle[attr] = value;
    }
  }

  /**
   * @private
   */
  function getGlobalStylesForElement(element, svgUid) {
    var styles = { };
    for (var rule in fabric.cssRules[svgUid]) {
      if (elementMatchesRule(element, rule.split(' '))) {
        for (var property in fabric.cssRules[svgUid][rule]) {
          styles[property] = fabric.cssRules[svgUid][rule][property];
        }
      }
    }
    return styles;
  }

  /**
   * @private
   */
  function elementMatchesRule(element, selectors) {
    var firstMatching, parentMatching = true;
    //start from rightmost selector.
    firstMatching = selectorMatches(element, selectors.pop());
    if (firstMatching && selectors.length) {
      parentMatching = doesSomeParentMatch(element, selectors);
    }
    return firstMatching && parentMatching && (selectors.length === 0);
  }

  function doesSomeParentMatch(element, selectors) {
    var selector, parentMatching = true;
    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
      if (parentMatching) {
        selector = selectors.pop();
      }
      element = element.parentNode;
      parentMatching = selectorMatches(element, selector);
    }
    return selectors.length === 0;
  }

  /**
   * @private
   */
  function selectorMatches(element, selector) {
    var nodeName = element.nodeName,
        classNames = element.getAttribute('class'),
        id = element.getAttribute('id'), matcher, i;
    // i check if a selector matches slicing away part from it.
    // if i get empty string i should match
    matcher = new RegExp('^' + nodeName, 'i');
    selector = selector.replace(matcher, '');
    if (id && selector.length) {
      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
      selector = selector.replace(matcher, '');
    }
    if (classNames && selector.length) {
      classNames = classNames.split(' ');
      for (i = classNames.length; i--;) {
        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
    }
    return selector.length === 0;
  }

  /**
   * @private
   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
   */
  function elementById(doc, id) {
    var el;
    doc.getElementById && (el = doc.getElementById(id));
    if (el) {
      return el;
    }
    var node, i, len, nodelist = doc.getElementsByTagName('*');
    for (i = 0, len = nodelist.length; i < len; i++) {
      node = nodelist[i];
      if (id === node.getAttribute('id')) {
        return node;
      }
    }
  }

  /**
   * @private
   */
  function parseUseDirectives(doc) {
    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
    while (nodelist.length && i < nodelist.length) {
      var el = nodelist[i],
          xlinkAttribute = el.getAttribute('xlink:href') || el.getAttribute('href');

      if (xlinkAttribute === null) {
        return;
      }

      var xlink = xlinkAttribute.slice(1),
          x = el.getAttribute('x') || 0,
          y = el.getAttribute('y') || 0,
          el2 = elementById(doc, xlink).cloneNode(true),
          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
          parentNode,
          oldLength = nodelist.length, attr,
          j,
          attrs,
          len,
          namespace = fabric.svgNS;

      applyViewboxTransform(el2);
      if (/^svg$/i.test(el2.nodeName)) {
        var el3 = el2.ownerDocument.createElementNS(namespace, 'g');
        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
        }
        // el2.firstChild != null
        while (el2.firstChild) {
          el3.appendChild(el2.firstChild);
        }
        el2 = el3;
      }

      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
        attr = attrs.item(j);
        if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
          attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
          continue;
        }

        if (attr.nodeName === 'transform') {
          currentTrans = attr.nodeValue + ' ' + currentTrans;
        }
        else {
          el2.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }

      el2.setAttribute('transform', currentTrans);
      el2.setAttribute('instantiated_by_use', '1');
      el2.removeAttribute('id');
      parentNode = el.parentNode;
      parentNode.replaceChild(el2, el);
      // some browsers do not shorten nodelist after replaceChild (IE8)
      if (nodelist.length === oldLength) {
        i++;
      }
    }
  }

  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
  // matches, e.g.: +14.56e-12, etc.
  var reViewBoxAttrValue = new RegExp(
    '^' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*' +
    '$'
  );

  /**
   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
   */
  function applyViewboxTransform(element) {
    if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {
      return {};
    }
    var viewBoxAttr = element.getAttribute('viewBox'),
        scaleX = 1,
        scaleY = 1,
        minX = 0,
        minY = 0,
        viewBoxWidth, viewBoxHeight, matrix, el,
        widthAttr = element.getAttribute('width'),
        heightAttr = element.getAttribute('height'),
        x = element.getAttribute('x') || 0,
        y = element.getAttribute('y') || 0,
        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
        missingViewBox = (!viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
        toBeParsed = missingViewBox && missingDimAttr,
        parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

    parsedDim.width = 0;
    parsedDim.height = 0;
    parsedDim.toBeParsed = toBeParsed;

    if (missingViewBox) {
      if (((x || y) && element.parentNode && element.parentNode.nodeName !== '#document')) {
        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
        matrix = (element.getAttribute('transform') || '') + translateMatrix;
        element.setAttribute('transform', matrix);
        element.removeAttribute('x');
        element.removeAttribute('y');
      }
    }

    if (toBeParsed) {
      return parsedDim;
    }

    if (missingViewBox) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      // set a transform for elements that have x y and are inner(only) SVGs
      return parsedDim;
    }
    minX = -parseFloat(viewBoxAttr[1]);
    minY = -parseFloat(viewBoxAttr[2]);
    viewBoxWidth = parseFloat(viewBoxAttr[3]);
    viewBoxHeight = parseFloat(viewBoxAttr[4]);
    parsedDim.minX = minX;
    parsedDim.minY = minY;
    parsedDim.viewBoxWidth = viewBoxWidth;
    parsedDim.viewBoxHeight = viewBoxHeight;
    if (!missingDimAttr) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      scaleX = parsedDim.width / viewBoxWidth;
      scaleY = parsedDim.height / viewBoxHeight;
    }
    else {
      parsedDim.width = viewBoxWidth;
      parsedDim.height = viewBoxHeight;
    }

    // default is to preserve aspect ratio
    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
    if (preserveAspectRatio.alignX !== 'none') {
      //translate all container for the effect of Mid, Min, Max
      if (preserveAspectRatio.meetOrSlice === 'meet') {
        scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
        // calculate additional translation to move the viewbox
      }
      if (preserveAspectRatio.meetOrSlice === 'slice') {
        scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
        // calculate additional translation to move the viewbox
      }
      widthDiff = parsedDim.width - viewBoxWidth * scaleX;
      heightDiff = parsedDim.height - viewBoxHeight * scaleX;
      if (preserveAspectRatio.alignX === 'Mid') {
        widthDiff /= 2;
      }
      if (preserveAspectRatio.alignY === 'Mid') {
        heightDiff /= 2;
      }
      if (preserveAspectRatio.alignX === 'Min') {
        widthDiff = 0;
      }
      if (preserveAspectRatio.alignY === 'Min') {
        heightDiff = 0;
      }
    }

    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
      return parsedDim;
    }
    if ((x || y) && element.parentNode.nodeName !== '#document') {
      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
    }

    matrix = translateMatrix + ' matrix(' + scaleX +
                  ' 0' +
                  ' 0 ' +
                  scaleY + ' ' +
                  (minX * scaleX + widthDiff) + ' ' +
                  (minY * scaleY + heightDiff) + ') ';
    // seems unused.
    // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
    if (element.nodeName === 'svg') {
      el = element.ownerDocument.createElementNS(fabric.svgNS, 'g');
      // element.firstChild != null
      while (element.firstChild) {
        el.appendChild(element.firstChild);
      }
      element.appendChild(el);
    }
    else {
      el = element;
      el.removeAttribute('x');
      el.removeAttribute('y');
      matrix = el.getAttribute('transform') + matrix;
    }
    el.setAttribute('transform', matrix);
    return parsedDim;
  }

  function hasAncestorWithNodeName(element, nodeName) {
    while (element && (element = element.parentNode)) {
      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
        && !element.getAttribute('instantiated_by_use')) {
        return true;
      }
    }
    return false;
  }

  /**
   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
   * @static
   * @function
   * @memberOf fabric
   * @param {SVGDocument} doc SVG document to parse
   * @param {Function} callback Callback to call when parsing is finished;
   * It's being passed an array of elements (parsed from a document).
   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
   * @param {Object} [parsingOptions] options for parsing document
   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
   */
  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
    if (!doc) {
      return;
    }

    parseUseDirectives(doc);

    var svgUid =  fabric.Object.__uid++, i, len,
        options = applyViewboxTransform(doc),
        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
    options.svgUid = svgUid;

    if (descendants.length === 0 && fabric.isLikelyNode) {
      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
      // https://github.com/ajaxorg/node-o3-xml/issues/21
      descendants = doc.selectNodes('//*[name(.)!="svg"]');
      var arr = [];
      for (i = 0, len = descendants.length; i < len; i++) {
        arr[i] = descendants[i];
      }
      descendants = arr;
    }

    var elements = descendants.filter(function(el) {
      applyViewboxTransform(el);
      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
    });
    if (!elements || (elements && !elements.length)) {
      callback && callback([], {});
      return;
    }
    var clipPaths = { };
    descendants.filter(function(el) {
      return el.nodeName.replace('svg:', '') === 'clipPath';
    }).forEach(function(el) {
      var id = el.getAttribute('id');
      clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
      });
    });
    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
    fabric.clipPaths[svgUid] = clipPaths;
    // Precedence of rules:   style > class > attribute
    fabric.parseElements(elements, function(instances, elements) {
      if (callback) {
        callback(instances, options, elements, descendants);
        delete fabric.gradientDefs[svgUid];
        delete fabric.cssRules[svgUid];
        delete fabric.clipPaths[svgUid];
      }
    }, clone(options), reviver, parsingOptions);
  };

  function recursivelyParseGradientsXlink(doc, gradient) {
    var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
        xlinkAttr = 'xlink:href',
        xLink = gradient.getAttribute(xlinkAttr).slice(1),
        referencedGradient = elementById(doc, xLink);
    if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
      recursivelyParseGradientsXlink(doc, referencedGradient);
    }
    gradientsAttrs.forEach(function(attr) {
      if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
        gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
      }
    });
    if (!gradient.children.length) {
      var referenceClone = referencedGradient.cloneNode(true);
      while (referenceClone.firstChild) {
        gradient.appendChild(referenceClone.firstChild);
      }
    }
    gradient.removeAttribute(xlinkAttr);
  }

  var reFontDeclaration = new RegExp(
    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
      fabric.reNum +
    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

  extend(fabric, {
    /**
     * Parses a short font declaration, building adding its properties to a style object
     * @static
     * @function
     * @memberOf fabric
     * @param {String} value font declaration
     * @param {Object} oStyle definition
     */
    parseFontDeclaration: function(value, oStyle) {
      var match = value.match(reFontDeclaration);

      if (!match) {
        return;
      }
      var fontStyle = match[1],
          // font variant is not used
          // fontVariant = match[2],
          fontWeight = match[3],
          fontSize = match[4],
          lineHeight = match[5],
          fontFamily = match[6];

      if (fontStyle) {
        oStyle.fontStyle = fontStyle;
      }
      if (fontWeight) {
        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
      }
      if (fontSize) {
        oStyle.fontSize = parseUnit(fontSize);
      }
      if (fontFamily) {
        oStyle.fontFamily = fontFamily;
      }
      if (lineHeight) {
        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
      }
    },

    /**
     * Parses an SVG document, returning all of the gradient declarations found in it
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
     */
    getGradientDefs: function(doc) {
      var tagArray = [
            'linearGradient',
            'radialGradient',
            'svg:linearGradient',
            'svg:radialGradient'],
          elList = _getMultipleNodes(doc, tagArray),
          el, j = 0, gradientDefs = { };
      j = elList.length;
      while (j--) {
        el = elList[j];
        if (el.getAttribute('xlink:href')) {
          recursivelyParseGradientsXlink(doc, el);
        }
        gradientDefs[el.getAttribute('id')] = el;
      }
      return gradientDefs;
    },

    /**
     * Returns an object of attributes' name/value, given element and an array of attribute names;
     * Parses parent "g" nodes recursively upwards.
     * @static
     * @memberOf fabric
     * @param {DOMElement} element Element to parse
     * @param {Array} attributes Array of attributes to parse
     * @return {Object} object containing parsed attributes' names/values
     */
    parseAttributes: function(element, attributes, svgUid) {

      if (!element) {
        return;
      }

      var value,
          parentAttributes = { },
          fontSize, parentFontSize;

      if (typeof svgUid === 'undefined') {
        svgUid = element.getAttribute('svgUid');
      }
      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
      if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
      }

      var ownAttributes = attributes.reduce(function(memo, attr) {
        value = element.getAttribute(attr);
        if (value) { // eslint-disable-line
          memo[attr] = value;
        }
        return memo;
      }, { });
      // add values parsed from style, which take precedence over attributes
      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
      var cssAttrs = extend(
        getGlobalStylesForElement(element, svgUid),
        fabric.parseStyleAttribute(element)
      );
      ownAttributes = extend(
        ownAttributes,
        cssAttrs
      );
      if (cssAttrs[cPath]) {
        element.setAttribute(cPath, cssAttrs[cPath]);
      }
      fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
      if (ownAttributes[fSize]) {
        // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
        ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);
      }

      var normalizedAttr, normalizedValue, normalizedStyle = {};
      for (var attr in ownAttributes) {
        normalizedAttr = normalizeAttr(attr);
        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
        normalizedStyle[normalizedAttr] = normalizedValue;
      }
      if (normalizedStyle && normalizedStyle.font) {
        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
      }
      var mergedAttrs = extend(parentAttributes, normalizedStyle);
      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
    },

    /**
     * Transforms an array of svg elements to corresponding fabric.* instances
     * @static
     * @memberOf fabric
     * @param {Array} elements Array of elements to parse
     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
     * @param {Object} [options] Options object
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     */
    parseElements: function(elements, callback, options, reviver, parsingOptions) {
      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
    },

    /**
     * Parses "style" attribute, retuning an object with values
     * @static
     * @memberOf fabric
     * @param {SVGElement} element Element to parse
     * @return {Object} Objects with values parsed from style attribute of an element
     */
    parseStyleAttribute: function(element) {
      var oStyle = { },
          style = element.getAttribute('style');

      if (!style) {
        return oStyle;
      }

      if (typeof style === 'string') {
        parseStyleString(style, oStyle);
      }
      else {
        parseStyleObject(style, oStyle);
      }

      return oStyle;
    },

    /**
     * Parses "points" attribute, returning an array of values
     * @static
     * @memberOf fabric
     * @param {String} points points attribute string
     * @return {Array} array of points
     */
    parsePointsAttribute: function(points) {

      // points attribute is required and must not be empty
      if (!points) {
        return null;
      }

      // replace commas with whitespace and remove bookending whitespace
      points = points.replace(/,/g, ' ').trim();

      points = points.split(/\s+/);
      var parsedPoints = [], i, len;

      for (i = 0, len = points.length; i < len; i += 2) {
        parsedPoints.push({
          x: parseFloat(points[i]),
          y: parseFloat(points[i + 1])
        });
      }

      // odd number of points is an error
      // if (parsedPoints.length % 2 !== 0) {
      //   return null;
      // }

      return parsedPoints;
    },

    /**
     * Returns CSS rules for a given SVG document
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} CSS rules of this document
     */
    getCSSRules: function(doc) {
      var styles = doc.getElementsByTagName('style'), i, len,
          allRules = { }, rules;

      // very crude parsing of style contents
      for (i = 0, len = styles.length; i < len; i++) {
        var styleContents = styles[i].textContent;

        // remove comments
        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
        if (styleContents.trim() === '') {
          continue;
        }
        // recovers all the rule in this form `body { style code... }`
        // rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
        rules = styleContents.split('}');
        // remove empty rules.
        rules = rules.filter(function(rule) { return rule.trim(); });
        // at this point we have hopefully an array of rules `body { style code... `
        // eslint-disable-next-line no-loop-func
        rules.forEach(function(rule) {

          var match = rule.split('{'),
              ruleObj = { }, declaration = match[1].trim(),
              propertyValuePairs = declaration.split(';').filter(function(pair) { return pair.trim(); });

          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
            var pair = propertyValuePairs[i].split(':'),
                property = pair[0].trim(),
                value = pair[1].trim();
            ruleObj[property] = value;
          }
          rule = match[0].trim();
          rule.split(',').forEach(function(_rule) {
            _rule = _rule.replace(/^svg/i, '').trim();
            if (_rule === '') {
              return;
            }
            if (allRules[_rule]) {
              fabric.util.object.extend(allRules[_rule], ruleObj);
            }
            else {
              allRules[_rule] = fabric.util.object.clone(ruleObj);
            }
          });
        });
      }
      return allRules;
    },

    /**
     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
     * @memberOf fabric
     * @param {String} url
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromURL: function(url, callback, reviver, options) {

      url = url.replace(/^\n\s*/, '').trim();
      new fabric.util.request(url, {
        method: 'get',
        onComplete: onComplete
      });

      function onComplete(r) {

        var xml = r.responseXML;
        if (!xml || !xml.documentElement) {
          callback && callback(null);
          return false;
        }

        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
          callback && callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    },

    /**
     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
     * @memberOf fabric
     * @param {String} string
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromString: function(string, callback, reviver, options) {
      var parser = new fabric.window.DOMParser(),
          doc = parser.parseFromString(string.trim(), 'text/xml');
      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
        callback(results, _options, elements, allElements);
      }, reviver, options);
    }
  });

})(typeof exports !== 'undefined' ? exports : this);
fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {
  this.elements = elements;
  this.callback = callback;
  this.options = options;
  this.reviver = reviver;
  this.svgUid = (options && options.svgUid) || 0;
  this.parsingOptions = parsingOptions;
  this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
  this.doc = doc;
};

(function(proto) {
  proto.parse = function() {
    this.instances = new Array(this.elements.length);
    this.numElements = this.elements.length;
    this.createObjects();
  };

  proto.createObjects = function() {
    var _this = this;
    this.elements.forEach(function(element, i) {
      element.setAttribute('svgUid', _this.svgUid);
      _this.createObject(element, i);
    });
  };

  proto.findTag = function(el) {
    return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
  };

  proto.createObject = function(el, index) {
    var klass = this.findTag(el);
    if (klass && klass.fromElement) {
      try {
        klass.fromElement(el, this.createCallback(index, el), this.options);
      }
      catch (err) {
        fabric.log(err);
      }
    }
    else {
      this.checkIfDone();
    }
  };

  proto.createCallback = function(index, el) {
    var _this = this;
    return function(obj) {
      var _options;
      _this.resolveGradient(obj, el, 'fill');
      _this.resolveGradient(obj, el, 'stroke');
      if (obj instanceof fabric.Image && obj._originalElement) {
        _options = obj.parsePreserveAspectRatioAttribute(el);
      }
      obj._removeTransformMatrix(_options);
      _this.resolveClipPath(obj, el);
      _this.reviver && _this.reviver(el, obj);
      _this.instances[index] = obj;
      _this.checkIfDone();
    };
  };

  proto.extractPropertyDefinition = function(obj, property, storage) {
    var value = obj[property], regex = this.regexUrl;
    if (!regex.test(value)) {
      return;
    }
    regex.lastIndex = 0;
    var id = regex.exec(value)[1];
    regex.lastIndex = 0;
    return fabric[storage][this.svgUid][id];
  };

  proto.resolveGradient = function(obj, el, property) {
    var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
    if (gradientDef) {
      var opacityAttr = el.getAttribute(property + '-opacity');
      var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
      obj.set(property, gradient);
    }
  };

  proto.createClipPathCallback = function(obj, container) {
    return function(_newObj) {
      _newObj._removeTransformMatrix();
      _newObj.fillRule = _newObj.clipRule;
      container.push(_newObj);
    };
  };

  proto.resolveClipPath = function(obj, usingElement) {
    var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
        element, klass, objTransformInv, container, gTransform, options;
    if (clipPath) {
      container = [];
      objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
      // move the clipPath tag as sibling to the real element that is using it
      var clipPathTag = clipPath[0].parentNode;
      var clipPathOwner = usingElement;
      while (clipPathOwner.parentNode && clipPathOwner.getAttribute('clip-path') !== obj.clipPath) {
        clipPathOwner = clipPathOwner.parentNode;
      }
      clipPathOwner.parentNode.appendChild(clipPathTag);
      for (var i = 0; i < clipPath.length; i++) {
        element = clipPath[i];
        klass = this.findTag(element);
        klass.fromElement(
          element,
          this.createClipPathCallback(obj, container),
          this.options
        );
      }
      if (container.length === 1) {
        clipPath = container[0];
      }
      else {
        clipPath = new fabric.Group(container);
      }
      gTransform = fabric.util.multiplyTransformMatrices(
        objTransformInv,
        clipPath.calcTransformMatrix()
      );
      if (clipPath.clipPath) {
        this.resolveClipPath(clipPath, clipPathOwner);
      }
      var options = fabric.util.qrDecompose(gTransform);
      clipPath.flipX = false;
      clipPath.flipY = false;
      clipPath.set('scaleX', options.scaleX);
      clipPath.set('scaleY', options.scaleY);
      clipPath.angle = options.angle;
      clipPath.skewX = options.skewX;
      clipPath.skewY = 0;
      clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
      obj.clipPath = clipPath;
    }
    else {
      // if clip-path does not resolve to any element, delete the property.
      delete obj.clipPath;
    }
  };

  proto.checkIfDone = function() {
    if (--this.numElements === 0) {
      this.instances = this.instances.filter(function(el) {
        // eslint-disable-next-line no-eq-null, eqeqeq
        return el != null;
      });
      this.callback(this.instances, this.elements);
    }
  };
})(fabric.ElementsParser.prototype);
(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Point) {
    fabric.warn('fabric.Point is already defined');
    return;
  }

  fabric.Point = Point;

  /**
   * Point class
   * @class fabric.Point
   * @memberOf fabric
   * @constructor
   * @param {Number} x
   * @param {Number} y
   * @return {fabric.Point} thisArg
   */
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.prototype = /** @lends fabric.Point.prototype */ {

    type: 'point',

    constructor: Point,

    /**
     * Adds another point to this one and returns another one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point instance with added values
     */
    add: function (that) {
      return new Point(this.x + that.x, this.y + that.y);
    },

    /**
     * Adds another point to this one
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    addEquals: function (that) {
      this.x += that.x;
      this.y += that.y;
      return this;
    },

    /**
     * Adds value to this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point} new Point with added value
     */
    scalarAdd: function (scalar) {
      return new Point(this.x + scalar, this.y + scalar);
    },

    /**
     * Adds value to this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarAddEquals: function (scalar) {
      this.x += scalar;
      this.y += scalar;
      return this;
    },

    /**
     * Subtracts another point from this point and returns a new one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point object with subtracted values
     */
    subtract: function (that) {
      return new Point(this.x - that.x, this.y - that.y);
    },

    /**
     * Subtracts another point from this point
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    subtractEquals: function (that) {
      this.x -= that.x;
      this.y -= that.y;
      return this;
    },

    /**
     * Subtracts value from this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    scalarSubtract: function (scalar) {
      return new Point(this.x - scalar, this.y - scalar);
    },

    /**
     * Subtracts value from this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarSubtractEquals: function (scalar) {
      this.x -= scalar;
      this.y -= scalar;
      return this;
    },

    /**
     * Multiplies this point by a value and returns a new one
     * TODO: rename in scalarMultiply in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    multiply: function (scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    },

    /**
     * Multiplies this point by a value
     * TODO: rename in scalarMultiplyEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    multiplyEquals: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },

    /**
     * Divides this point by a value and returns a new one
     * TODO: rename in scalarDivide in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    divide: function (scalar) {
      return new Point(this.x / scalar, this.y / scalar);
    },

    /**
     * Divides this point by a value
     * TODO: rename in scalarDivideEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    divideEquals: function (scalar) {
      this.x /= scalar;
      this.y /= scalar;
      return this;
    },

    /**
     * Returns true if this point is equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    eq: function (that) {
      return (this.x === that.x && this.y === that.y);
    },

    /**
     * Returns true if this point is less than another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lt: function (that) {
      return (this.x < that.x && this.y < that.y);
    },

    /**
     * Returns true if this point is less than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lte: function (that) {
      return (this.x <= that.x && this.y <= that.y);
    },

    /**

     * Returns true if this point is greater another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gt: function (that) {
      return (this.x > that.x && this.y > that.y);
    },

    /**
     * Returns true if this point is greater than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gte: function (that) {
      return (this.x >= that.x && this.y >= that.y);
    },

    /**
     * Returns new point which is the result of linear interpolation with this one and another one
     * @param {fabric.Point} that
     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
     * @return {fabric.Point}
     */
    lerp: function (that, t) {
      if (typeof t === 'undefined') {
        t = 0.5;
      }
      t = Math.max(Math.min(1, t), 0);
      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
    },

    /**
     * Returns distance from this point and another one
     * @param {fabric.Point} that
     * @return {Number}
     */
    distanceFrom: function (that) {
      var dx = this.x - that.x,
          dy = this.y - that.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the point between this point and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    midPointFrom: function (that) {
      return this.lerp(that);
    },

    /**
     * Returns a new point which is the min of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    min: function (that) {
      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
    },

    /**
     * Returns a new point which is the max of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    max: function (that) {
      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
    },

    /**
     * Returns string representation of this point
     * @return {String}
     */
    toString: function () {
      return this.x + ',' + this.y;
    },

    /**
     * Sets x/y of this point
     * @param {Number} x
     * @param {Number} y
     * @chainable
     */
    setXY: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets x of this point
     * @param {Number} x
     * @chainable
     */
    setX: function (x) {
      this.x = x;
      return this;
    },

    /**
     * Sets y of this point
     * @param {Number} y
     * @chainable
     */
    setY: function (y) {
      this.y = y;
      return this;
    },

    /**
     * Sets x/y of this point from another point
     * @param {fabric.Point} that
     * @chainable
     */
    setFromPoint: function (that) {
      this.x = that.x;
      this.y = that.y;
      return this;
    },

    /**
     * Swaps x/y of this point and another point
     * @param {fabric.Point} that
     */
    swap: function (that) {
      var x = this.x,
          y = this.y;
      this.x = that.x;
      this.y = that.y;
      that.x = x;
      that.y = y;
    },

    /**
     * return a cloned instance of the point
     * @return {fabric.Point}
     */
    clone: function () {
      return new Point(this.x, this.y);
    }
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Intersection) {
    fabric.warn('fabric.Intersection is already defined');
    return;
  }

  /**
   * Intersection class
   * @class fabric.Intersection
   * @memberOf fabric
   * @constructor
   */
  function Intersection(status) {
    this.status = status;
    this.points = [];
  }

  fabric.Intersection = Intersection;

  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

    constructor: Intersection,

    /**
     * Appends a point to intersection
     * @param {fabric.Point} point
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoint: function (point) {
      this.points.push(point);
      return this;
    },

    /**
     * Appends points to intersection
     * @param {Array} points
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoints: function (points) {
      this.points = this.points.concat(points);
      return this;
    }
  };

  /**
   * Checks if one line intersects another
   * TODO: rename in intersectSegmentSegment
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {fabric.Point} b1
   * @param {fabric.Point} b2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
    var result,
        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if (uB !== 0) {
      var ua = uaT / uB,
          ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        result = new Intersection('Intersection');
        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
      }
      else {
        result = new Intersection();
      }
    }
    else {
      if (uaT === 0 || ubT === 0) {
        result = new Intersection('Coincident');
      }
      else {
        result = new Intersection('Parallel');
      }
    }
    return result;
  };

  /**
   * Checks if line intersects polygon
   * TODO: rename in intersectSegmentPolygon
   * fix detection of coincident
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {Array} points
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
    var result = new Intersection(),
        length = points.length,
        b1, b2, inter, i;

    for (i = 0; i < length; i++) {
      b1 = points[i];
      b2 = points[(i + 1) % length];
      inter = Intersection.intersectLineLine(a1, a2, b1, b2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects another polygon
   * @static
   * @param {Array} points1
   * @param {Array} points2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
    var result = new Intersection(),
        length = points1.length, i;

    for (i = 0; i < length; i++) {
      var a1 = points1[i],
          a2 = points1[(i + 1) % length],
          inter = Intersection.intersectLinePolygon(a1, a2, points2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects rectangle
   * @static
   * @param {Array} points
   * @param {fabric.Point} r1
   * @param {fabric.Point} r2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
    var min = r1.min(r2),
        max = r1.max(r2),
        topRight = new fabric.Point(max.x, min.y),
        bottomLeft = new fabric.Point(min.x, max.y),
        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
        result = new Intersection();

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Color) {
    fabric.warn('fabric.Color is already defined.');
    return;
  }

  /**
   * Color class
   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
   *
   * @class fabric.Color
   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
   * @return {fabric.Color} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
   */
  function Color(color) {
    if (!color) {
      this.setSource([0, 0, 0, 1]);
    }
    else {
      this._tryParsingColor(color);
    }
  }

  fabric.Color = Color;

  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

    /**
     * @private
     * @param {String|Array} color Color value to parse
     */
    _tryParsingColor: function(color) {
      var source;

      if (color in Color.colorNameMap) {
        color = Color.colorNameMap[color];
      }

      if (color === 'transparent') {
        source = [255, 255, 255, 0];
      }

      if (!source) {
        source = Color.sourceFromHex(color);
      }
      if (!source) {
        source = Color.sourceFromRgb(color);
      }
      if (!source) {
        source = Color.sourceFromHsl(color);
      }
      if (!source) {
        //if color is not recognize let's make black as canvas does
        source = [0, 0, 0, 1];
      }
      if (source) {
        this.setSource(source);
      }
    },

    /**
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @private
     * @param {Number} r Red color value
     * @param {Number} g Green color value
     * @param {Number} b Blue color value
     * @return {Array} Hsl color
     */
    _rgbToHsl: function(r, g, b) {
      r /= 255; g /= 255; b /= 255;

      var h, s, l,
          max = fabric.util.array.max([r, g, b]),
          min = fabric.util.array.min([r, g, b]);

      l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      }
      else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    },

    /**
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @return {Array}
     */
    getSource: function() {
      return this._source;
    },

    /**
     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @param {Array} source
     */
    setSource: function(source) {
      this._source = source;
    },

    /**
     * Returns color representation in RGB format
     * @return {String} ex: rgb(0-255,0-255,0-255)
     */
    toRgb: function() {
      var source = this.getSource();
      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
    },

    /**
     * Returns color representation in RGBA format
     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
     */
    toRgba: function() {
      var source = this.getSource();
      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
    },

    /**
     * Returns color representation in HSL format
     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
     */
    toHsl: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
    },

    /**
     * Returns color representation in HSLA format
     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
     */
    toHsla: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
    },

    /**
     * Returns color representation in HEX format
     * @return {String} ex: FF5555
     */
    toHex: function() {
      var source = this.getSource(), r, g, b;

      r = source[0].toString(16);
      r = (r.length === 1) ? ('0' + r) : r;

      g = source[1].toString(16);
      g = (g.length === 1) ? ('0' + g) : g;

      b = source[2].toString(16);
      b = (b.length === 1) ? ('0' + b) : b;

      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
    },

    /**
     * Returns color representation in HEXA format
     * @return {String} ex: FF5555CC
     */
    toHexa: function() {
      var source = this.getSource(), a;

      a = Math.round(source[3] * 255);
      a = a.toString(16);
      a = (a.length === 1) ? ('0' + a) : a;

      return this.toHex() + a.toUpperCase();
    },

    /**
     * Gets value of alpha channel for this color
     * @return {Number} 0-1
     */
    getAlpha: function() {
      return this.getSource()[3];
    },

    /**
     * Sets value of alpha channel for this color
     * @param {Number} alpha Alpha value 0-1
     * @return {fabric.Color} thisArg
     */
    setAlpha: function(alpha) {
      var source = this.getSource();
      source[3] = alpha;
      this.setSource(source);
      return this;
    },

    /**
     * Transforms color to its grayscale representation
     * @return {fabric.Color} thisArg
     */
    toGrayscale: function() {
      var source = this.getSource(),
          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
          currentAlpha = source[3];
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Transforms color to its black and white representation
     * @param {Number} threshold
     * @return {fabric.Color} thisArg
     */
    toBlackWhite: function(threshold) {
      var source = this.getSource(),
          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
          currentAlpha = source[3];

      threshold = threshold || 127;

      average = (Number(average) < Number(threshold)) ? 0 : 255;
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Overlays color with another color
     * @param {String|fabric.Color} otherColor
     * @return {fabric.Color} thisArg
     */
    overlayWith: function(otherColor) {
      if (!(otherColor instanceof Color)) {
        otherColor = new Color(otherColor);
      }

      var result = [],
          alpha = this.getAlpha(),
          otherAlpha = 0.5,
          source = this.getSource(),
          otherSource = otherColor.getSource(), i;

      for (i = 0; i < 3; i++) {
        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
      }

      result[3] = alpha;
      this.setSource(result);
      return this;
    }
  };

  /**
   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  // eslint-disable-next-line max-len
  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

  /**
   * Map of the 148 color names with HEX code
   * @static
   * @field
   * @memberOf fabric.Color
   * @see: https://www.w3.org/TR/css3-color/#svg-color
   */
  fabric.Color.colorNameMap = {
    aliceblue:            '#F0F8FF',
    antiquewhite:         '#FAEBD7',
    aqua:                 '#00FFFF',
    aquamarine:           '#7FFFD4',
    azure:                '#F0FFFF',
    beige:                '#F5F5DC',
    bisque:               '#FFE4C4',
    black:                '#000000',
    blanchedalmond:       '#FFEBCD',
    blue:                 '#0000FF',
    blueviolet:           '#8A2BE2',
    brown:                '#A52A2A',
    burlywood:            '#DEB887',
    cadetblue:            '#5F9EA0',
    chartreuse:           '#7FFF00',
    chocolate:            '#D2691E',
    coral:                '#FF7F50',
    cornflowerblue:       '#6495ED',
    cornsilk:             '#FFF8DC',
    crimson:              '#DC143C',
    cyan:                 '#00FFFF',
    darkblue:             '#00008B',
    darkcyan:             '#008B8B',
    darkgoldenrod:        '#B8860B',
    darkgray:             '#A9A9A9',
    darkgrey:             '#A9A9A9',
    darkgreen:            '#006400',
    darkkhaki:            '#BDB76B',
    darkmagenta:          '#8B008B',
    darkolivegreen:       '#556B2F',
    darkorange:           '#FF8C00',
    darkorchid:           '#9932CC',
    darkred:              '#8B0000',
    darksalmon:           '#E9967A',
    darkseagreen:         '#8FBC8F',
    darkslateblue:        '#483D8B',
    darkslategray:        '#2F4F4F',
    darkslategrey:        '#2F4F4F',
    darkturquoise:        '#00CED1',
    darkviolet:           '#9400D3',
    deeppink:             '#FF1493',
    deepskyblue:          '#00BFFF',
    dimgray:              '#696969',
    dimgrey:              '#696969',
    dodgerblue:           '#1E90FF',
    firebrick:            '#B22222',
    floralwhite:          '#FFFAF0',
    forestgreen:          '#228B22',
    fuchsia:              '#FF00FF',
    gainsboro:            '#DCDCDC',
    ghostwhite:           '#F8F8FF',
    gold:                 '#FFD700',
    goldenrod:            '#DAA520',
    gray:                 '#808080',
    grey:                 '#808080',
    green:                '#008000',
    greenyellow:          '#ADFF2F',
    honeydew:             '#F0FFF0',
    hotpink:              '#FF69B4',
    indianred:            '#CD5C5C',
    indigo:               '#4B0082',
    ivory:                '#FFFFF0',
    khaki:                '#F0E68C',
    lavender:             '#E6E6FA',
    lavenderblush:        '#FFF0F5',
    lawngreen:            '#7CFC00',
    lemonchiffon:         '#FFFACD',
    lightblue:            '#ADD8E6',
    lightcoral:           '#F08080',
    lightcyan:            '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgray:            '#D3D3D3',
    lightgrey:            '#D3D3D3',
    lightgreen:           '#90EE90',
    lightpink:            '#FFB6C1',
    lightsalmon:          '#FFA07A',
    lightseagreen:        '#20B2AA',
    lightskyblue:         '#87CEFA',
    lightslategray:       '#778899',
    lightslategrey:       '#778899',
    lightsteelblue:       '#B0C4DE',
    lightyellow:          '#FFFFE0',
    lime:                 '#00FF00',
    limegreen:            '#32CD32',
    linen:                '#FAF0E6',
    magenta:              '#FF00FF',
    maroon:               '#800000',
    mediumaquamarine:     '#66CDAA',
    mediumblue:           '#0000CD',
    mediumorchid:         '#BA55D3',
    mediumpurple:         '#9370DB',
    mediumseagreen:       '#3CB371',
    mediumslateblue:      '#7B68EE',
    mediumspringgreen:    '#00FA9A',
    mediumturquoise:      '#48D1CC',
    mediumvioletred:      '#C71585',
    midnightblue:         '#191970',
    mintcream:            '#F5FFFA',
    mistyrose:            '#FFE4E1',
    moccasin:             '#FFE4B5',
    navajowhite:          '#FFDEAD',
    navy:                 '#000080',
    oldlace:              '#FDF5E6',
    olive:                '#808000',
    olivedrab:            '#6B8E23',
    orange:               '#FFA500',
    orangered:            '#FF4500',
    orchid:               '#DA70D6',
    palegoldenrod:        '#EEE8AA',
    palegreen:            '#98FB98',
    paleturquoise:        '#AFEEEE',
    palevioletred:        '#DB7093',
    papayawhip:           '#FFEFD5',
    peachpuff:            '#FFDAB9',
    peru:                 '#CD853F',
    pink:                 '#FFC0CB',
    plum:                 '#DDA0DD',
    powderblue:           '#B0E0E6',
    purple:               '#800080',
    rebeccapurple:        '#663399',
    red:                  '#FF0000',
    rosybrown:            '#BC8F8F',
    royalblue:            '#4169E1',
    saddlebrown:          '#8B4513',
    salmon:               '#FA8072',
    sandybrown:           '#F4A460',
    seagreen:             '#2E8B57',
    seashell:             '#FFF5EE',
    sienna:               '#A0522D',
    silver:               '#C0C0C0',
    skyblue:              '#87CEEB',
    slateblue:            '#6A5ACD',
    slategray:            '#708090',
    slategrey:            '#708090',
    snow:                 '#FFFAFA',
    springgreen:          '#00FF7F',
    steelblue:            '#4682B4',
    tan:                  '#D2B48C',
    teal:                 '#008080',
    thistle:              '#D8BFD8',
    tomato:               '#FF6347',
    turquoise:            '#40E0D0',
    violet:               '#EE82EE',
    wheat:                '#F5DEB3',
    white:                '#FFFFFF',
    whitesmoke:           '#F5F5F5',
    yellow:               '#FFFF00',
    yellowgreen:          '#9ACD32'
  };

  /**
   * @private
   * @param {Number} p
   * @param {Number} q
   * @param {Number} t
   * @return {Number}
   */
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }

  /**
   * Returns new color object, when given a color in RGB format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
   * @return {fabric.Color}
   */
  fabric.Color.fromRgb = function(color) {
    return Color.fromSource(Color.sourceFromRgb(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
   * @return {Array} source
   */
  fabric.Color.sourceFromRgb = function(color) {
    var match = color.match(Color.reRGBa);
    if (match) {
      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

      return [
        parseInt(r, 10),
        parseInt(g, 10),
        parseInt(b, 10),
        match[4] ? parseFloat(match[4]) : 1
      ];
    }
  };

  /**
   * Returns new color object, when given a color in RGBA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromRgba = Color.fromRgb;

  /**
   * Returns new color object, when given a color in HSL format
   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
   * @memberOf fabric.Color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsl = function(color) {
    return Color.fromSource(Color.sourceFromHsl(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
   * @memberOf fabric.Color
   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
   * @return {Array} source
   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
   */
  fabric.Color.sourceFromHsl = function(color) {
    var match = color.match(Color.reHSLa);
    if (!match) {
      return;
    }

    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
        r, g, b;

    if (s === 0) {
      r = g = b = l;
    }
    else {
      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
          p = l * 2 - q;

      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255),
      match[4] ? parseFloat(match[4]) : 1
    ];
  };

  /**
   * Returns new color object, when given a color in HSLA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsla = Color.fromHsl;

  /**
   * Returns new color object, when given a color in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color Color value ex: FF5555
   * @return {fabric.Color}
   */
  fabric.Color.fromHex = function(color) {
    return Color.fromSource(Color.sourceFromHex(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
   * @return {Array} source
   */
  fabric.Color.sourceFromHex = function(color) {
    if (color.match(Color.reHex)) {
      var value = color.slice(color.indexOf('#') + 1),
          isShortNotation = (value.length === 3 || value.length === 4),
          isRGBa = (value.length === 8 || value.length === 4),
          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

      return [
        parseInt(r, 16),
        parseInt(g, 16),
        parseInt(b, 16),
        parseFloat((parseInt(a, 16) / 255).toFixed(2))
      ];
    }
  };

  /**
   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
   * @static
   * @memberOf fabric.Color
   * @param {Array} source
   * @return {fabric.Color}
   */
  fabric.Color.fromSource = function(source) {
    var oColor = new Color();
    oColor.setSource(source);
    return oColor;
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      scaleMap = ['e', 'se', 's', 'sw', 'w', 'nw', 'n', 'ne', 'e'],
      skewMap = ['ns', 'nesw', 'ew', 'nwse'],
      controls = {},
      LEFT = 'left', TOP = 'top', RIGHT = 'right', BOTTOM = 'bottom', CENTER = 'center',
      opposite = {
        top: BOTTOM,
        bottom: TOP,
        left: RIGHT,
        right: LEFT,
        center: CENTER,
      }, radiansToDegrees = fabric.util.radiansToDegrees,
      sign = (Math.sign || function(x) { return ((x > 0) - (x < 0)) || +x; });

  /**
   * Combine control position and object angle to find the control direction compared
   * to the object center.
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   * @param {fabric.Control} control the control class
   * @return {Number} 0 - 7 a quadrant number
   */
  function findCornerQuadrant(fabricObject, control) {
    var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;
    return Math.round((cornerAngle % 360) / 45);
  }

  function fireEvent(eventName, options) {
    var target = options.transform.target,
        canvas = target.canvas,
        canvasOptions = fabric.util.object.clone(options);
    canvasOptions.target = target;
    canvas && canvas.fire('object:' + eventName, canvasOptions);
    target.fire(eventName, options);
  }

  /**
   * Inspect event and fabricObject properties to understand if the scaling action
   * @param {Event} eventData from the user action
   * @param {fabric.Object} fabricObject the fabric object about to scale
   * @return {Boolean} true if scale is proportional
   */
  function scaleIsProportional(eventData, fabricObject) {
    var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey,
        uniformIsToggled = eventData[uniScaleKey];
    return (canvas.uniformScaling && !uniformIsToggled) ||
    (!canvas.uniformScaling && uniformIsToggled);
  }

  /**
   * Checks if transform is centered
   * @param {Object} transform transform data
   * @return {Boolean} true if transform is centered
   */
  function isTransformCentered(transform) {
    return transform.originX === CENTER && transform.originY === CENTER;
  }

  /**
   * Inspect fabricObject to understand if the current scaling action is allowed
   * @param {fabric.Object} fabricObject the fabric object about to scale
   * @param {String} by 'x' or 'y' or ''
   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally
   * @return {Boolean} true if scaling is not allowed at current conditions
   */
  function scalingIsForbidden(fabricObject, by, scaleProportionally) {
    var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;
    if (lockX && lockY) {
      return true;
    }
    if (!by && (lockX || lockY) && scaleProportionally) {
      return true;
    }
    if (lockX && by === 'x') {
      return true;
    }
    if (lockY && by === 'y') {
      return true;
    }
    return false;
  }

  /**
   * return the correct cursor style for the scale action
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function scaleCursorStyleHandler(eventData, control, fabricObject) {
    var notAllowed = 'not-allowed',
        scaleProportionally = scaleIsProportional(eventData, fabricObject),
        by = '';
    if (control.x !== 0 && control.y === 0) {
      by = 'x';
    }
    else if (control.x === 0 && control.y !== 0) {
      by = 'y';
    }
    if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {
      return notAllowed;
    }
    var n = findCornerQuadrant(fabricObject, control);
    return scaleMap[n] + '-resize';
  }

  /**
   * return the correct cursor style for the skew action
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function skewCursorStyleHandler(eventData, control, fabricObject) {
    var notAllowed = 'not-allowed';
    if (control.x !== 0 && fabricObject.lockSkewingY) {
      return notAllowed;
    }
    if (control.y !== 0 && fabricObject.lockSkewingX) {
      return notAllowed;
    }
    var n = findCornerQuadrant(fabricObject, control) % 4;
    return skewMap[n] + '-resize';
  }

  /**
   * Combine skew and scale style handlers to cover fabric standard use case
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {
    if (eventData[fabricObject.canvas.altActionKey]) {
      return controls.skewCursorStyleHandler(eventData, control, fabricObject);
    }
    return controls.scaleCursorStyleHandler(eventData, control, fabricObject);
  }

  /**
   * Inspect event, control and fabricObject to return the correct action name
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} an action name
   */
  function scaleOrSkewActionName(eventData, control, fabricObject) {
    var isAlternative = eventData[fabricObject.canvas.altActionKey];
    if (control.x === 0) {
      // then is scaleY or skewX
      return isAlternative ? 'skewX' : 'scaleY';
    }
    if (control.y === 0) {
      // then is scaleY or skewX
      return isAlternative ? 'skewY' : 'scaleX';
    }
  }

  /**
   * Find the correct style for the control that is used for rotation.
   * this function is very simple and it just take care of not-allowed or standard cursor
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function rotationStyleHandler(eventData, control, fabricObject) {
    if (fabricObject.lockRotation) {
      return 'not-allowed';
    }
    return control.cursorStyle;
  }

  function commonEventInfo(eventData, transform, x, y) {
    return {
      e: eventData,
      transform: transform,
      pointer: {
        x: x,
        y: y,
      }
    };
  }

  /**
   * Wrap an action handler with saving/restoring object position on the transform.
   * this is the code that permits to objects to keep their position while transforming.
   * @param {Function} actionHandler the function to wrap
   * @return {Function} a function with an action handler signature
   */
  function wrapWithFixedAnchor(actionHandler) {
    return function(eventData, transform, x, y) {
      var target = transform.target, centerPoint = target.getCenterPoint(),
          constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY),
          actionPerformed = actionHandler(eventData, transform, x, y);
      target.setPositionByOrigin(constraint, transform.originX, transform.originY);
      return actionPerformed;
    };
  }

  /**
   * Wrap an action handler with firing an event if the action is performed
   * @param {Function} actionHandler the function to wrap
   * @return {Function} a function with an action handler signature
   */
  function wrapWithFireEvent(eventName, actionHandler) {
    return function(eventData, transform, x, y) {
      var actionPerformed = actionHandler(eventData, transform, x, y);
      if (actionPerformed) {
        fireEvent(eventName, commonEventInfo(eventData, transform, x, y));
      }
      return actionPerformed;
    };
  }

  /**
   * Transforms a point described by x and y in a distance from the top left corner of the object
   * bounding box.
   * @param {Object} transform
   * @param {String} originX
   * @param {String} originY
   * @param {number} x
   * @param {number} y
   * @return {Fabric.Point} the normalized point
   */
  function getLocalPoint(transform, originX, originY, x, y) {
    var target = transform.target,
        control = target.controls[transform.corner],
        zoom = target.canvas.getZoom(),
        padding = target.padding / zoom,
        localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);
    if (localPoint.x >= padding) {
      localPoint.x -= padding;
    }
    if (localPoint.x <= -padding) {
      localPoint.x += padding;
    }
    if (localPoint.y >= padding) {
      localPoint.y -= padding;
    }
    if (localPoint.y <= padding) {
      localPoint.y += padding;
    }
    localPoint.x -= control.offsetX;
    localPoint.y -= control.offsetY;
    return localPoint;
  }

  /**
   * Detect if the fabric object is flipped on one side.
   * @param {fabric.Object} target
   * @return {Boolean} true if one flip, but not two.
   */
  function targetHasOneFlip(target) {
    return target.flipX !== target.flipY;
  }

  /**
   * Utility function to compensate the scale factor when skew is applied on both axes
   * @private
   */
  function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {
    if (target[oppositeSkew] !== 0) {
      var newDim = target._getTransformedDimensions()[axis];
      var newValue = reference / newDim * target[scaleToCompensate];
      target.set(scaleToCompensate, newValue);
    }
  }

  /**
   * Action handler for skewing on the X axis
   * @private
   */
  function skewObjectX(eventData, transform, x, y) {
    var target = transform.target,
        // find how big the object would be, if there was no skewX. takes in account scaling
        dimNoSkew = target._getTransformedDimensions(0, target.skewY),
        localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        // the mouse is in the center of the object, and we want it to stay there.
        // so the object will grow twice as much as the mouse.
        // this makes the skew growth to localPoint * 2 - dimNoSkew.
        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x,
        currentSkew = target.skewX, newSkew;
    if (totalSkewSize < 2) {
      // let's make it easy to go back to position 0.
      newSkew = 0;
    }
    else {
      newSkew = radiansToDegrees(
        Math.atan2((totalSkewSize / target.scaleX), (dimNoSkew.y / target.scaleY))
      );
      // now we have to find the sign of the skew.
      // it mostly depend on the origin of transformation.
      if (transform.originX === LEFT && transform.originY === BOTTOM) {
        newSkew = -newSkew;
      }
      if (transform.originX === RIGHT && transform.originY === TOP) {
        newSkew = -newSkew;
      }
      if (targetHasOneFlip(target)) {
        newSkew = -newSkew;
      }
    }
    var hasSkewed = currentSkew !== newSkew;
    if (hasSkewed) {
      var dimBeforeSkewing = target._getTransformedDimensions().y;
      target.set('skewX', newSkew);
      compensateScaleForSkew(target, 'skewY', 'scaleY', 'y', dimBeforeSkewing);
    }
    return hasSkewed;
  }

  /**
   * Action handler for skewing on the Y axis
   * @private
   */
  function skewObjectY(eventData, transform, x, y) {
    var target = transform.target,
        // find how big the object would be, if there was no skewX. takes in account scaling
        dimNoSkew = target._getTransformedDimensions(target.skewX, 0),
        localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        // the mouse is in the center of the object, and we want it to stay there.
        // so the object will grow twice as much as the mouse.
        // this makes the skew growth to localPoint * 2 - dimNoSkew.
        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y,
        currentSkew = target.skewY, newSkew;
    if (totalSkewSize < 2) {
      // let's make it easy to go back to position 0.
      newSkew = 0;
    }
    else {
      newSkew = radiansToDegrees(
        Math.atan2((totalSkewSize / target.scaleY), (dimNoSkew.x / target.scaleX))
      );
      // now we have to find the sign of the skew.
      // it mostly depend on the origin of transformation.
      if (transform.originX === LEFT && transform.originY === BOTTOM) {
        newSkew = -newSkew;
      }
      if (transform.originX === RIGHT && transform.originY === TOP) {
        newSkew = -newSkew;
      }
      if (targetHasOneFlip(target)) {
        newSkew = -newSkew;
      }
    }
    var hasSkewed = currentSkew !== newSkew;
    if (hasSkewed) {
      var dimBeforeSkewing = target._getTransformedDimensions().x;
      target.set('skewY', newSkew);
      compensateScaleForSkew(target, 'skewX', 'scaleX', 'x', dimBeforeSkewing);
    }
    return hasSkewed;
  }

  /**
   * Wrapped Action handler for skewing on the Y axis, takes care of the
   * skew direction and determine the correct transform origin for the anchor point
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function skewHandlerX(eventData, transform, x, y) {
    // step1 figure out and change transform origin.
    // if skewX > 0 and originY bottom we anchor on right
    // if skewX > 0 and originY top we anchor on left
    // if skewX < 0 and originY bottom we anchor on left
    // if skewX < 0 and originY top we anchor on right
    // if skewX is 0, we look for mouse position to understand where are we going.
    var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;
    if (target.lockSkewingX) {
      return false;
    }
    if (currentSkew === 0) {
      var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);
      if (localPointFromCenter.x > 0) {
        // we are pulling right, anchor left;
        originX = LEFT;
      }
      else {
        // we are pulling right, anchor right
        originX = RIGHT;
      }
    }
    else {
      if (currentSkew > 0) {
        originX = originY === TOP ? LEFT : RIGHT;
      }
      if (currentSkew < 0) {
        originX = originY === TOP ? RIGHT : LEFT;
      }
      // is the object flipped on one side only? swap the origin.
      if (targetHasOneFlip(target)) {
        originX = originX === LEFT ? RIGHT : LEFT;
      }
    }

    // once we have the origin, we find the anchor point
    transform.originX = originX;
    var finalHandler = wrapWithFireEvent('skewing', wrapWithFixedAnchor(skewObjectX));
    return finalHandler(eventData, transform, x, y);
  }

  /**
   * Wrapped Action handler for skewing on the Y axis, takes care of the
   * skew direction and determine the correct transform origin for the anchor point
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function skewHandlerY(eventData, transform, x, y) {
    // step1 figure out and change transform origin.
    // if skewY > 0 and originX left we anchor on top
    // if skewY > 0 and originX right we anchor on bottom
    // if skewY < 0 and originX left we anchor on bottom
    // if skewY < 0 and originX right we anchor on top
    // if skewY is 0, we look for mouse position to understand where are we going.
    var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;
    if (target.lockSkewingY) {
      return false;
    }
    if (currentSkew === 0) {
      var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);
      if (localPointFromCenter.y > 0) {
        // we are pulling down, anchor up;
        originY = TOP;
      }
      else {
        // we are pulling up, anchor down
        originY = BOTTOM;
      }
    }
    else {
      if (currentSkew > 0) {
        originY = originX === LEFT ? TOP : BOTTOM;
      }
      if (currentSkew < 0) {
        originY = originX === LEFT ? BOTTOM : TOP;
      }
      // is the object flipped on one side only? swap the origin.
      if (targetHasOneFlip(target)) {
        originY = originY === TOP ? BOTTOM : TOP;
      }
    }

    // once we have the origin, we find the anchor point
    transform.originY = originY;
    var finalHandler = wrapWithFireEvent('skewing', wrapWithFixedAnchor(skewObjectY));
    return finalHandler(eventData, transform, x, y);
  }

  /**
   * Action handler for rotation and snapping, without anchor point.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   * @private
   */
  function rotationWithSnapping(eventData, transform, x, y) {
    var t = transform,
        target = t.target,
        pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

    if (target.lockRotation) {
      return false;
    }

    var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x),
        curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x),
        angle = radiansToDegrees(curAngle - lastAngle + t.theta),
        hasRotated = true;

    if (target.snapAngle > 0) {
      var snapAngle  = target.snapAngle,
          snapThreshold  = target.snapThreshold || snapAngle,
          rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
          leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

      if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
        angle = leftAngleLocked;
      }
      else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
        angle = rightAngleLocked;
      }
    }

    // normalize angle to positive value
    if (angle < 0) {
      angle = 360 + angle;
    }
    angle %= 360;

    hasRotated = target.angle !== angle;
    target.angle = angle;
    return hasRotated;
  }

  /**
   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @param {Object} options additional information for scaling
   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling
   * @return {Boolean} true if some change happened
   * @private
   */
  function scaleObject(eventData, transform, x, y, options) {
    options = options || {};
    var target = transform.target,
        lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY,
        by = options.by, newPoint, scaleX, scaleY, dim,
        scaleProportionally = scaleIsProportional(eventData, target),
        forbidScaling = scalingIsForbidden(target, by, scaleProportionally),
        signX, signY, gestureScale = transform.gestureScale;

    if (forbidScaling) {
      return false;
    }
    if (gestureScale) {
      scaleX = transform.scaleX * gestureScale;
      scaleY = transform.scaleY * gestureScale;
    }
    else {
      newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);
      // use of sign: We use sign to detect change of direction of an action. sign usually change when
      // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling
      // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily
      // cross many time the origin point and flip the object. so we need a way to filter out the noise.
      // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.
      signX = by !== 'y' ? sign(newPoint.x) : 1;
      signY = by !== 'x' ? sign(newPoint.y) : 1;
      if (!transform.signX) {
        transform.signX = signX;
      }
      if (!transform.signY) {
        transform.signY = signY;
      }

      if (target.lockScalingFlip &&
        (transform.signX !== signX || transform.signY !== signY)
      ) {
        return false;
      }

      dim = target._getTransformedDimensions();
      // missing detection of flip and logic to switch the origin
      if (scaleProportionally && !by) {
        // uniform scaling
        var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y),
            original = transform.original,
            originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) +
              Math.abs(dim.y * original.scaleY / target.scaleY),
            scale = distance / originalDistance;
        scaleX = original.scaleX * scale;
        scaleY = original.scaleY * scale;
      }
      else {
        scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);
        scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);
      }
      // if we are scaling by center, we need to double the scale
      if (isTransformCentered(transform)) {
        scaleX *= 2;
        scaleY *= 2;
      }
      if (transform.signX !== signX && by !== 'y') {
        transform.originX = opposite[transform.originX];
        scaleX *= -1;
        transform.signX = signX;
      }
      if (transform.signY !== signY && by !== 'x') {
        transform.originY = opposite[transform.originY];
        scaleY *= -1;
        transform.signY = signY;
      }
    }
    // minScale is taken are in the setter.
    var oldScaleX = target.scaleX, oldScaleY = target.scaleY;
    if (!by) {
      !lockScalingX && target.set('scaleX', scaleX);
      !lockScalingY && target.set('scaleY', scaleY);
    }
    else {
      // forbidden cases already handled on top here.
      by === 'x' && target.set('scaleX', scaleX);
      by === 'y' && target.set('scaleY', scaleY);
    }
    return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;
  }

  /**
   * Generic scaling logic, to scale from corners either equally or freely.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectFromCorner(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y);
  }

  /**
   * Scaling logic for the X axis.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectX(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y , { by: 'x' });
  }

  /**
   * Scaling logic for the Y axis.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectY(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y , { by: 'y' });
  }

  /**
   * Composed action handler to either scale Y or skew X
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scalingYOrSkewingX(eventData, transform, x, y) {
    // ok some safety needed here.
    if (eventData[transform.target.canvas.altActionKey]) {
      return controls.skewHandlerX(eventData, transform, x, y);
    }
    return controls.scalingY(eventData, transform, x, y);
  }

  /**
   * Composed action handler to either scale X or skew Y
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scalingXOrSkewingY(eventData, transform, x, y) {
    // ok some safety needed here.
    if (eventData[transform.target.canvas.altActionKey]) {
      return controls.skewHandlerY(eventData, transform, x, y);
    }
    return controls.scalingX(eventData, transform, x, y);
  }

  /**
   * Action handler to change textbox width
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function changeWidth(eventData, transform, x, y) {
    var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1),
        multiplier = isTransformCentered(transform) ? 2 : 1,
        oldWidth = target.width,
        newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;
    target.set('width', Math.max(newWidth, 0));
    return oldWidth !== newWidth;
  }

  /**
   * Action handler
   * @private
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if the translation occurred
   */
  function dragHandler(eventData, transform, x, y) {
    var target = transform.target,
        newLeft = x - transform.offsetX,
        newTop = y - transform.offsetY,
        moveX = !target.get('lockMovementX') && target.left !== newLeft,
        moveY = !target.get('lockMovementY') && target.top !== newTop;
    moveX && target.set('left', newLeft);
    moveY && target.set('top', newTop);
    if (moveX || moveY) {
      fireEvent('moving', commonEventInfo(eventData, transform, x, y));
    }
    return moveX || moveY;
  }

  controls.scaleCursorStyleHandler = scaleCursorStyleHandler;
  controls.skewCursorStyleHandler = skewCursorStyleHandler;
  controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;
  controls.rotationWithSnapping = wrapWithFireEvent('rotating', wrapWithFixedAnchor(rotationWithSnapping));
  controls.scalingEqually = wrapWithFireEvent('scaling', wrapWithFixedAnchor( scaleObjectFromCorner));
  controls.scalingX = wrapWithFireEvent('scaling', wrapWithFixedAnchor(scaleObjectX));
  controls.scalingY = wrapWithFireEvent('scaling', wrapWithFixedAnchor(scaleObjectY));
  controls.scalingYOrSkewingX = scalingYOrSkewingX;
  controls.scalingXOrSkewingY = scalingXOrSkewingY;
  controls.changeWidth = wrapWithFireEvent('resizing', wrapWithFixedAnchor(changeWidth));
  controls.skewHandlerX = skewHandlerX;
  controls.skewHandlerY = skewHandlerY;
  controls.dragHandler = dragHandler;
  controls.scaleOrSkewActionName = scaleOrSkewActionName;
  controls.rotationStyleHandler = rotationStyleHandler;
  controls.fireEvent = fireEvent;
  controls.wrapWithFixedAnchor = wrapWithFixedAnchor;
  controls.wrapWithFireEvent = wrapWithFireEvent;
  controls.getLocalPoint = getLocalPoint;
  fabric.controlsUtils = controls;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      degreesToRadians = fabric.util.degreesToRadians,
      controls = fabric.controlsUtils;

  /**
   * Render a round control, as per fabric features.
   * This function is written to respect object properties like transparentCorners, cornerSize
   * cornerColor, cornerStrokeColor
   * plus the addition of offsetY and offsetX.
   * @param {CanvasRenderingContext2D} ctx context to render on
   * @param {Number} left x coordinate where the control center should be
   * @param {Number} top y coordinate where the control center should be
   * @param {Object} styleOverride override for fabric.Object controls style
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   */
  function renderCircleControl (ctx, left, top, styleOverride, fabricObject) {
    styleOverride = styleOverride || {};
    var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,
        ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,
        transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
          styleOverride.transparentCorners : fabricObject.transparentCorners,
        methodName = transparentCorners ? 'stroke' : 'fill',
        stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor),
        myLeft = left,
        myTop = top, size;
    ctx.save();
    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
    ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
    // as soon as fabric react v5, remove ie11, use proper ellipse code.
    if (xSize > ySize) {
      size = xSize;
      ctx.scale(1.0, ySize / xSize);
      myTop = top * xSize / ySize;
    }
    else if (ySize > xSize) {
      size = ySize;
      ctx.scale(xSize / ySize, 1.0);
      myLeft = left * ySize / xSize;
    }
    else {
      size = xSize;
    }
    // this is still wrong
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);
    ctx[methodName]();
    if (stroke) {
      ctx.stroke();
    }
    ctx.restore();
  }

  /**
   * Render a square control, as per fabric features.
   * This function is written to respect object properties like transparentCorners, cornerSize
   * cornerColor, cornerStrokeColor
   * plus the addition of offsetY and offsetX.
   * @param {CanvasRenderingContext2D} ctx context to render on
   * @param {Number} left x coordinate where the control center should be
   * @param {Number} top y coordinate where the control center should be
   * @param {Object} styleOverride override for fabric.Object controls style
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   */
  function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {
    styleOverride = styleOverride || {};
    var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,
        ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,
        transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
          styleOverride.transparentCorners : fabricObject.transparentCorners,
        methodName = transparentCorners ? 'stroke' : 'fill',
        stroke = !transparentCorners && (
          styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor
        ), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;
    ctx.save();
    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
    ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
    // this is still wrong
    ctx.lineWidth = 1;
    ctx.translate(left, top);
    ctx.rotate(degreesToRadians(fabricObject.angle));
    // this does not work, and fixed with ( && ) does not make sense.
    // to have real transparent corners we need the controls on upperCanvas
    // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
    ctx[methodName + 'Rect'](-xSizeBy2, -ySizeBy2, xSize, ySize);
    if (stroke) {
      ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
    }
    ctx.restore();
  }

  controls.renderCircleControl = renderCircleControl;
  controls.renderSquareControl = renderSquareControl;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  function Control(options) {
    for (var i in options) {
      this[i] = options[i];
    }
  }

  fabric.Control = Control;

  fabric.Control.prototype = /** @lends fabric.Control.prototype */ {

    /**
     * keep track of control visibility.
     * mainly for backward compatibility.
     * if you do not want to see a control, you can remove it
     * from the controlset.
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * Name of the action that the control will likely execute.
     * This is optional. FabricJS uses to identify what the user is doing for some
     * extra optimizations. If you are writing a custom control and you want to know
     * somewhere else in the code what is going on, you can use this string here.
     * you can also provide a custom getActionName if your control run multiple actions
     * depending on some external state.
     * default to scale since is the most common, used on 4 corners by default
     * @type {String}
     * @default 'scale'
     */
    actionName: 'scale',

    /**
     * Drawing angle of the control.
     * NOT used for now, but name marked as needed for internal logic
     * example: to reuse the same drawing function for different rotated controls
     * @type {Number}
     * @default 0
     */
    angle: 0,

    /**
     * Relative position of the control. X
     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    x: 0,

    /**
     * Relative position of the control. Y
     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    y: 0,

    /**
     * Horizontal offset of the control from the defined position. In pixels
     * Positive offset moves the control to the right, negative to the left.
     * It used when you want to have position of control that does not scale with
     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on
     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will
     * stay 30 pixels no matter how the object is big. Another example is having 2
     * controls in the corner, that stay in the same position when the object scale.
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset of the control from the defined position. In pixels
     * Positive offset moves the control to the bottom, negative to the top.
     * @type {Number}
     * @default 0
     */
    offsetY: 0,

    /**
     * Sets the length of the control. If null, defaults to object's cornerSize.
     * Expects both sizeX and sizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    sizeX: null,

    /**
     * Sets the height of the control. If null, defaults to object's cornerSize.
     * Expects both sizeX and sizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    sizeY: null,

    /**
     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.
     * Expects both touchSizeX and touchSizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    touchSizeX: null,

    /**
     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.
     * Expects both touchSizeX and touchSizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    touchSizeY: null,

    /**
     * Css cursor style to display when the control is hovered.
     * if the method `cursorStyleHandler` is provided, this property is ignored.
     * @type {String}
     * @default 'crosshair'
     */
    cursorStyle: 'crosshair',

    /**
     * If controls has an offsetY or offsetX, draw a line that connects
     * the control to the bounding box
     * @type {Boolean}
     * @default false
     */
    withConnection: false,

    /**
     * The control actionHandler, provide one to handle action ( control being moved )
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    actionHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * The control handler for mouse down, provide one to handle mouse down on control
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    mouseDownHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * The control mouseUpHandler, provide one to handle an effect on mouse up.
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    mouseUpHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * Returns control actionHandler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getActionHandler: function(/* eventData, fabricObject, control */) {
      return this.actionHandler;
    },

    /**
     * Returns control mouseDown handler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getMouseDownHandler: function(/* eventData, fabricObject, control */) {
      return this.mouseDownHandler;
    },

    /**
     * Returns control mouseUp handler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getMouseUpHandler: function(/* eventData, fabricObject, control */) {
      return this.mouseUpHandler;
    },

    /**
     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate
     * function you can pass one in the constructor
     * the cursorStyle property
     * @param {Event} eventData the native mouse event
     * @param {fabric.Control} control the current control ( likely this)
     * @param {fabric.Object} object on which the control is displayed
     * @return {String}
     */
    cursorStyleHandler: function(eventData, control /* fabricObject */) {
      return control.cursorStyle;
    },

    /**
     * Returns the action name. The basic implementation just return the actionName property.
     * @param {Event} eventData the native mouse event
     * @param {fabric.Control} control the current control ( likely this)
     * @param {fabric.Object} object on which the control is displayed
     * @return {String}
     */
    getActionName: function(eventData, control /* fabricObject */) {
      return control.actionName;
    },

    /**
     * Returns controls visibility
     * @param {fabric.Object} object on which the control is displayed
     * @param {String} controlKey key where the control is memorized on the
     * @return {Boolean}
     */
    getVisibility: function(fabricObject, controlKey) {
      var objectVisibility = fabricObject._controlsVisibility;
      if (objectVisibility && typeof objectVisibility[controlKey] !== 'undefined') {
        return objectVisibility[controlKey];
      }
      return this.visible;
    },

    /**
     * Sets controls visibility
     * @param {Boolean} visibility for the object
     * @return {Void}
     */
    setVisibility: function(visibility /* name, fabricObject */) {
      this.visible = visibility;
    },


    positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */) {
      var point = fabric.util.transformPoint({
        x: this.x * dim.x + this.offsetX,
        y: this.y * dim.y + this.offsetY }, finalMatrix);
      return point;
    },

    /**
     * Returns the coords for this control based on object values.
     * @param {Number} objectAngle angle from the fabric object holding the control
     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if
     *   isTouch is true)
     * @param {Number} centerX x coordinate where the control center should be
     * @param {Number} centerY y coordinate where the control center should be
     * @param {boolean} isTouch true if touch corner, false if normal corner
     */
    calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {
      var cosHalfOffset,
          sinHalfOffset,
          cosHalfOffsetComp,
          sinHalfOffsetComp,
          xSize = (isTouch) ? this.touchSizeX : this.sizeX,
          ySize = (isTouch) ? this.touchSizeY : this.sizeY;
      if (xSize && ySize && xSize !== ySize) {
        // handle rectangular corners
        var controlTriangleAngle = Math.atan2(ySize, xSize);
        var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;
        var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);
        var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);
        cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);
        sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);
        // use complementary angle for two corners
        cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);
        sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);
      }
      else {
        // handle square corners
        // use default object corner size unless size is defined
        var cornerSize = (xSize && ySize) ? xSize : objectCornerSize;
        /* 0.7071067812 stands for sqrt(2)/2 */
        cornerHypotenuse = cornerSize * 0.7071067812;
        // complementary angles are equal since they're both 45 degrees
        var newTheta = fabric.util.degreesToRadians(45 - objectAngle);
        cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);
        sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);
      }

      return {
        tl: {
          x: centerX - sinHalfOffsetComp,
          y: centerY - cosHalfOffsetComp,
        },
        tr: {
          x: centerX + cosHalfOffset,
          y: centerY - sinHalfOffset,
        },
        bl: {
          x: centerX - cosHalfOffset,
          y: centerY + sinHalfOffset,
        },
        br: {
          x: centerX + sinHalfOffsetComp,
          y: centerY + cosHalfOffsetComp,
        },
      };
    },

    /**
    * Render function for the control.
    * When this function runs the context is unscaled. unrotate. Just retina scaled.
    * all the functions will have to translate to the point left,top before starting Drawing
    * if they want to draw a control where the position is detected.
    * left and top are the result of the positionHandler function
    * @param {RenderingContext2D} ctx the context where the control will be drawn
    * @param {Number} left position of the canvas where we are about to render the control.
    * @param {Number} top position of the canvas where we are about to render the control.
    * @param {Object} styleOverride
    * @param {fabric.Object} fabricObject the object where the control is about to be rendered
    */
    render: function(ctx, left, top, styleOverride, fabricObject) {
      styleOverride = styleOverride || {};
      switch (styleOverride.cornerStyle || fabricObject.cornerStyle) {
        case 'circle':
          fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);
          break;
        default:
          fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);
      }
    },
  };

})(typeof exports !== 'undefined' ? exports : this);
(function() {

  /* _FROM_SVG_START_ */
  function getColorStop(el, multiplier) {
    var style = el.getAttribute('style'),
        offset = el.getAttribute('offset') || 0,
        color, colorAlpha, opacity, i;

    // convert percents to absolute values
    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
    if (style) {
      var keyValuePairs = style.split(/\s*;\s*/);

      if (keyValuePairs[keyValuePairs.length - 1] === '') {
        keyValuePairs.pop();
      }

      for (i = keyValuePairs.length; i--; ) {

        var split = keyValuePairs[i].split(/\s*:\s*/),
            key = split[0].trim(),
            value = split[1].trim();

        if (key === 'stop-color') {
          color = value;
        }
        else if (key === 'stop-opacity') {
          opacity = value;
        }
      }
    }

    if (!color) {
      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
    }
    if (!opacity) {
      opacity = el.getAttribute('stop-opacity');
    }

    color = new fabric.Color(color);
    colorAlpha = color.getAlpha();
    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
    opacity *= colorAlpha * multiplier;

    return {
      offset: offset,
      color: color.toRgb(),
      opacity: opacity
    };
  }

  function getLinearCoords(el) {
    return {
      x1: el.getAttribute('x1') || 0,
      y1: el.getAttribute('y1') || 0,
      x2: el.getAttribute('x2') || '100%',
      y2: el.getAttribute('y2') || 0
    };
  }

  function getRadialCoords(el) {
    return {
      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
      r1: 0,
      x2: el.getAttribute('cx') || '50%',
      y2: el.getAttribute('cy') || '50%',
      r2: el.getAttribute('r') || '50%'
    };
  }
  /* _FROM_SVG_END_ */

  var clone = fabric.util.object.clone;

  /**
   * Gradient class
   * @class fabric.Gradient
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
   * @see {@link fabric.Gradient#initialize} for constructor definition
   */
  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

    /**
     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetY: 0,

    /**
     * A transform matrix to apply to the gradient before painting.
     * Imported from svg gradients, is not applied with the current transform in the center.
     * Before this transform is applied, the origin point is at the top left corner of the object
     * plus the addition of offsetY and offsetX.
     * @type Number[]
     * @default null
     */
    gradientTransform: null,

    /**
     * coordinates units for coords.
     * If `pixels`, the number of coords are in the same unit of width / height.
     * If set as `percentage` the coords are still a number, but 1 means 100% of width
     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.
     * allowed values pixels or percentage.
     * @type String
     * @default 'pixels'
     */
    gradientUnits: 'pixels',

    /**
     * Gradient type linear or radial
     * @type String
     * @default 'pixels'
     */
    type: 'linear',

    /**
     * Constructor
     * @param {Object} options Options object with type, coords, gradientUnits and colorStops
     * @param {Object} [options.type] gradient type linear or radial
     * @param {Object} [options.gradientUnits] gradient units
     * @param {Object} [options.offsetX] SVG import compatibility
     * @param {Object} [options.offsetY] SVG import compatibility
     * @param {Object[]} options.colorStops contains the colorstops.
     * @param {Object} options.coords contains the coords of the gradient
     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial
     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial
     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial
     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial
     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle
     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle
     * @return {fabric.Gradient} thisArg
     */
    initialize: function(options) {
      options || (options = { });
      options.coords || (options.coords = { });

      var coords, _this = this;

      // sets everything, then coords and colorstops get sets again
      Object.keys(options).forEach(function(option) {
        _this[option] = options[option];
      });

      if (this.id) {
        this.id += '_' + fabric.Object.__uid++;
      }
      else {
        this.id = fabric.Object.__uid++;
      }

      coords = {
        x1: options.coords.x1 || 0,
        y1: options.coords.y1 || 0,
        x2: options.coords.x2 || 0,
        y2: options.coords.y2 || 0
      };

      if (this.type === 'radial') {
        coords.r1 = options.coords.r1 || 0;
        coords.r2 = options.coords.r2 || 0;
      }

      this.coords = coords;
      this.colorStops = options.colorStops.slice();
    },

    /**
     * Adds another colorStop
     * @param {Object} colorStop Object with offset and color
     * @return {fabric.Gradient} thisArg
     */
    addColorStop: function(colorStops) {
      for (var position in colorStops) {
        var color = new fabric.Color(colorStops[position]);
        this.colorStops.push({
          offset: parseFloat(position),
          color: color.toRgb(),
          opacity: color.getAlpha()
        });
      }
      return this;
    },

    /**
     * Returns object representation of a gradient
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object}
     */
    toObject: function(propertiesToInclude) {
      var object = {
        type: this.type,
        coords: this.coords,
        colorStops: this.colorStops,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        gradientUnits: this.gradientUnits,
        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an gradient
     * @param {Object} object Object to create a gradient for
     * @return {String} SVG representation of an gradient (linear/radial)
     */
    toSVG: function(object, options) {
      var coords = clone(this.coords, true), i, len, options = options || {},
          markup, commonAttributes, colorStops = clone(this.colorStops, true),
          needsSwap = coords.r1 > coords.r2,
          transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(),
          offsetX = -this.offsetX, offsetY = -this.offsetY,
          withViewport = !!options.additionalTransform,
          gradientUnits = this.gradientUnits === 'pixels' ? 'userSpaceOnUse' : 'objectBoundingBox';
      // colorStops must be sorted ascending
      colorStops.sort(function(a, b) {
        return a.offset - b.offset;
      });

      if (gradientUnits === 'objectBoundingBox') {
        offsetX /= object.width;
        offsetY /= object.height;
      }
      else {
        offsetX += object.width / 2;
        offsetY += object.height / 2;
      }
      if (object.type === 'path' && this.gradientUnits !== 'percentage') {
        offsetX -= object.pathOffset.x;
        offsetY -= object.pathOffset.y;
      }


      transform[4] -= offsetX;
      transform[5] -= offsetY;

      commonAttributes = 'id="SVGID_' + this.id +
                     '" gradientUnits="' + gradientUnits + '"';
      commonAttributes += ' gradientTransform="' + (withViewport ?
        options.additionalTransform + ' ' : '') + fabric.util.matrixToSVG(transform) + '" ';

      if (this.type === 'linear') {
        markup = [
          '<linearGradient ',
          commonAttributes,
          ' x1="', coords.x1,
          '" y1="', coords.y1,
          '" x2="', coords.x2,
          '" y2="', coords.y2,
          '">\n'
        ];
      }
      else if (this.type === 'radial') {
        // svg radial gradient has just 1 radius. the biggest.
        markup = [
          '<radialGradient ',
          commonAttributes,
          ' cx="', needsSwap ? coords.x1 : coords.x2,
          '" cy="', needsSwap ? coords.y1 : coords.y2,
          '" r="', needsSwap ? coords.r1 : coords.r2,
          '" fx="', needsSwap ? coords.x2 : coords.x1,
          '" fy="', needsSwap ? coords.y2 : coords.y1,
          '">\n'
        ];
      }

      if (this.type === 'radial') {
        if (needsSwap) {
          // svg goes from internal to external radius. if radius are inverted, swap color stops.
          colorStops = colorStops.concat();
          colorStops.reverse();
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset = 1 - colorStops[i].offset;
          }
        }
        var minRadius = Math.min(coords.r1, coords.r2);
        if (minRadius > 0) {
          // i have to shift all colorStops and add new one in 0.
          var maxRadius = Math.max(coords.r1, coords.r2),
              percentageShift = minRadius / maxRadius;
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
          }
        }
      }

      for (i = 0, len = colorStops.length; i < len; i++) {
        var colorStop = colorStops[i];
        markup.push(
          '<stop ',
          'offset="', (colorStop.offset * 100) + '%',
          '" style="stop-color:', colorStop.color,
          (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
          '"/>\n'
        );
      }

      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

      return markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns an instance of CanvasGradient
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {CanvasGradient}
     */
    toLive: function(ctx) {
      var gradient, coords = fabric.util.object.clone(this.coords), i, len;

      if (!this.type) {
        return;
      }

      if (this.type === 'linear') {
        gradient = ctx.createLinearGradient(
          coords.x1, coords.y1, coords.x2, coords.y2);
      }
      else if (this.type === 'radial') {
        gradient = ctx.createRadialGradient(
          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
      }

      for (i = 0, len = this.colorStops.length; i < len; i++) {
        var color = this.colorStops[i].color,
            opacity = this.colorStops[i].opacity,
            offset = this.colorStops[i].offset;

        if (typeof opacity !== 'undefined') {
          color = new fabric.Color(color).setAlpha(opacity).toRgba();
        }
        gradient.addColorStop(offset, color);
      }

      return gradient;
    }
  });

  fabric.util.object.extend(fabric.Gradient, {

    /* _FROM_SVG_START_ */
    /**
     * Returns {@link fabric.Gradient} instance from an SVG element
     * @static
     * @memberOf fabric.Gradient
     * @param {SVGGradientElement} el SVG gradient element
     * @param {fabric.Object} instance
     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.
     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients
     * that uses gradientUnits as 'userSpaceOnUse' and percentages.
     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg
     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg
     * @param {Object.number} width width part of the svg tag if viewBox is not specified
     * @param {Object.number} height height part of the svg tag if viewBox is not specified
     * @return {fabric.Gradient} Gradient instance
     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
     */
    fromElement: function(el, instance, opacityAttr, svgOptions) {
      /**
       *  @example:
       *
       *  <linearGradient id="linearGrad1">
       *    <stop offset="0%" stop-color="white"/>
       *    <stop offset="100%" stop-color="black"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <linearGradient id="linearGrad2">
       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad1">
       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
       *  </radialGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad2">
       *    <stop offset="0" stop-color="rgb(255,255,255)" />
       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
       *    <stop offset="1" stop-color="rgb(255,255,255)" />
       *  </radialGradient>
       *
       */

      var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);
      multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;
      if (isNaN(multiplier)) {
        multiplier = 1;
      }

      var colorStopEls = el.getElementsByTagName('stop'),
          type,
          gradientUnits = el.getAttribute('gradientUnits') === 'userSpaceOnUse' ?
            'pixels' : 'percentage',
          gradientTransform = el.getAttribute('gradientTransform') || '',
          colorStops = [],
          coords, i, offsetX = 0, offsetY = 0,
          transformMatrix;
      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
        type = 'linear';
        coords = getLinearCoords(el);
      }
      else {
        type = 'radial';
        coords = getRadialCoords(el);
      }

      for (i = colorStopEls.length; i--; ) {
        colorStops.push(getColorStop(colorStopEls[i], multiplier));
      }

      transformMatrix = fabric.parseTransformAttribute(gradientTransform);

      __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);

      if (gradientUnits === 'pixels') {
        offsetX = -instance.left;
        offsetY = -instance.top;
      }

      var gradient = new fabric.Gradient({
        id: el.getAttribute('id'),
        type: type,
        coords: coords,
        colorStops: colorStops,
        gradientUnits: gradientUnits,
        gradientTransform: transformMatrix,
        offsetX: offsetX,
        offsetY: offsetY,
      });

      return gradient;
    }
    /* _FROM_SVG_END_ */
  });

  /**
   * @private
   */
  function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {
    var propValue, finalValue;
    Object.keys(options).forEach(function(prop) {
      propValue = options[prop];
      if (propValue === 'Infinity') {
        finalValue = 1;
      }
      else if (propValue === '-Infinity') {
        finalValue = 0;
      }
      else {
        finalValue = parseFloat(options[prop], 10);
        if (typeof propValue === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(propValue)) {
          finalValue *= 0.01;
          if (gradientUnits === 'pixels') {
            // then we need to fix those percentages here in svg parsing
            if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
              finalValue *= svgOptions.viewBoxWidth || svgOptions.width;
            }
            if (prop === 'y1' || prop === 'y2') {
              finalValue *= svgOptions.viewBoxHeight || svgOptions.height;
            }
          }
        }
      }
      options[prop] = finalValue;
    });
  }
})();
(function() {

  'use strict';

  var toFixed = fabric.util.toFixed;

  /**
   * Pattern class
   * @class fabric.Pattern
   * @see {@link http://fabricjs.com/patterns|Pattern demo}
   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
   * @see {@link fabric.Pattern#initialize} for constructor definition
   */


  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

    /**
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @type String
     * @default
     */
    repeat: 'repeat',

    /**
     * Pattern horizontal offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Pattern vertical offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @type String
     * @default
     */
    crossOrigin: '',

    /**
     * transform matrix to change the pattern, imported from svgs.
     * @type Array
     * @default
     */
    patternTransform: null,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @param {Function} [callback] function to invoke after callback init.
     * @return {fabric.Pattern} thisArg
     */
    initialize: function(options, callback) {
      options || (options = { });

      this.id = fabric.Object.__uid++;
      this.setOptions(options);
      if (!options.source || (options.source && typeof options.source !== 'string')) {
        callback && callback(this);
        return;
      }
      else {
        // img src string
        var _this = this;
        this.source = fabric.util.createImage();
        fabric.util.loadImage(options.source, function(img, isError) {
          _this.source = img;
          callback && callback(_this, isError);
        }, null, this.crossOrigin);
      }
    },

    /**
     * Returns object representation of a pattern
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of a pattern instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          source, object;

      // <img> element
      if (typeof this.source.src === 'string') {
        source = this.source.src;
      }
      // <canvas> element
      else if (typeof this.source === 'object' && this.source.toDataURL) {
        source = this.source.toDataURL();
      }

      object = {
        type: 'pattern',
        source: source,
        repeat: this.repeat,
        crossOrigin: this.crossOrigin,
        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
        patternTransform: this.patternTransform ? this.patternTransform.concat() : null
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a pattern
     * @param {fabric.Object} object
     * @return {String} SVG representation of a pattern
     */
    toSVG: function(object) {
      var patternSource = typeof this.source === 'function' ? this.source() : this.source,
          patternWidth = patternSource.width / object.width,
          patternHeight = patternSource.height / object.height,
          patternOffsetX = this.offsetX / object.width,
          patternOffsetY = this.offsetY / object.height,
          patternImgSrc = '';
      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
        patternHeight = 1;
        if (patternOffsetY) {
          patternHeight += Math.abs(patternOffsetY);
        }
      }
      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
        patternWidth = 1;
        if (patternOffsetX) {
          patternWidth += Math.abs(patternOffsetX);
        }

      }
      if (patternSource.src) {
        patternImgSrc = patternSource.src;
      }
      else if (patternSource.toDataURL) {
        patternImgSrc = patternSource.toDataURL();
      }

      return '<pattern id="SVGID_' + this.id +
                    '" x="' + patternOffsetX +
                    '" y="' + patternOffsetY +
                    '" width="' + patternWidth +
                    '" height="' + patternHeight + '">\n' +
               '<image x="0" y="0"' +
                      ' width="' + patternSource.width +
                      '" height="' + patternSource.height +
                      '" xlink:href="' + patternImgSrc +
               '"></image>\n' +
             '</pattern>\n';
    },
    /* _TO_SVG_END_ */

    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Returns an instance of CanvasPattern
     * @param {CanvasRenderingContext2D} ctx Context to create pattern
     * @return {CanvasPattern}
     */
    toLive: function(ctx) {
      var source = this.source;
      // if the image failed to load, return, and allow rest to continue loading
      if (!source) {
        return '';
      }

      // if an image
      if (typeof source.src !== 'undefined') {
        if (!source.complete) {
          return '';
        }
        if (source.naturalWidth === 0 || source.naturalHeight === 0) {
          return '';
        }
      }
      return ctx.createPattern(source, this.repeat);
    }
  });
})();
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      toFixed = fabric.util.toFixed;

  if (fabric.Shadow) {
    fabric.warn('fabric.Shadow is already defined.');
    return;
  }

  /**
   * Shadow class
   * @class fabric.Shadow
   * @see {@link http://fabricjs.com/shadows|Shadow demo}
   * @see {@link fabric.Shadow#initialize} for constructor definition
   */
  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

    /**
     * Shadow color
     * @type String
     * @default
     */
    color: 'rgb(0,0,0)',

    /**
     * Shadow blur
     * @type Number
     */
    blur: 0,

    /**
     * Shadow horizontal offset
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Shadow vertical offset
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * Whether the shadow should affect stroke operations
     * @type Boolean
     * @default
     */
    affectStroke: false,

    /**
     * Indicates whether toObject should include default values
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * When `false`, the shadow will scale with the object.
     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.
     * default to false
     * @type Boolean
     * @default
     */
    nonScaling: false,

    /**
     * Constructor
     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
     * @return {fabric.Shadow} thisArg
     */
    initialize: function(options) {

      if (typeof options === 'string') {
        options = this._parseShadow(options);
      }

      for (var prop in options) {
        this[prop] = options[prop];
      }

      this.id = fabric.Object.__uid++;
    },

    /**
     * @private
     * @param {String} shadow Shadow value to parse
     * @return {Object} Shadow object with color, offsetX, offsetY and blur
     */
    _parseShadow: function(shadow) {
      var shadowStr = shadow.trim(),
          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

      return {
        color: color.trim(),
        offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,
        offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,
        blur: parseFloat(offsetsAndBlur[3], 10) || 0
      };
    },

    /**
     * Returns a string representation of an instance
     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
     * @return {String} Returns CSS3 text-shadow declaration
     */
    toString: function() {
      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a shadow
     * @param {fabric.Object} object
     * @return {String} SVG representation of a shadow
     */
    toSVG: function(object) {
      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          offset = fabric.util.rotateVector(
            { x: this.offsetX, y: this.offsetY },
            fabric.util.degreesToRadians(-object.angle)),
          BLUR_BOX = 20, color = new fabric.Color(this.color);

      if (object.width && object.height) {
        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
        // we add some extra space to filter box to contain the blur ( 20 )
        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
      }
      if (object.flipX) {
        offset.x *= -1;
      }
      if (object.flipY) {
        offset.y *= -1;
      }

      return (
        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
          '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
          '\t<feComposite in2="oBlur" operator="in" />\n' +
          '\t<feMerge>\n' +
            '\t\t<feMergeNode></feMergeNode>\n' +
            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
          '\t</feMerge>\n' +
        '</filter>\n');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns object representation of a shadow
     * @return {Object} Object representation of a shadow instance
     */
    toObject: function() {
      if (this.includeDefaultValues) {
        return {
          color: this.color,
          blur: this.blur,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          affectStroke: this.affectStroke,
          nonScaling: this.nonScaling
        };
      }
      var obj = { }, proto = fabric.Shadow.prototype;

      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke', 'nonScaling'].forEach(function(prop) {
        if (this[prop] !== proto[prop]) {
          obj[prop] = this[prop];
        }
      }, this);

      return obj;
    }
  });

  /**
   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
   * @static
   * @field
   * @memberOf fabric.Shadow
   */
  // eslint-disable-next-line max-len
  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/;

})(typeof exports !== 'undefined' ? exports : this);
(function () {

  'use strict';

  if (fabric.StaticCanvas) {
    fabric.warn('fabric.StaticCanvas is already defined.');
    return;
  }

  // aliases for faster resolution
  var extend = fabric.util.object.extend,
      getElementOffset = fabric.util.getElementOffset,
      removeFromArray = fabric.util.removeFromArray,
      toFixed = fabric.util.toFixed,
      transformPoint = fabric.util.transformPoint,
      invertTransform = fabric.util.invertTransform,
      getNodeCanvas = fabric.util.getNodeCanvas,
      createCanvasElement = fabric.util.createCanvasElement,

      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

  /**
   * Static canvas class
   * @class fabric.StaticCanvas
   * @mixes fabric.Collection
   * @mixes fabric.Observable
   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
   * @fires before:render
   * @fires after:render
   * @fires canvas:cleared
   * @fires object:added
   * @fires object:removed
   */
  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
    },

    /**
     * Background color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
     * @type {(String|fabric.Pattern)}
     * @default
     */
    backgroundColor: '',

    /**
     * Background image of canvas instance.
     * since 2.4.0 image caching is active, please when putting an image as background, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    backgroundImage: null,

    /**
     * Overlay color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
     * @since 1.3.9
     * @type {(String|fabric.Pattern)}
     * @default
     */
    overlayColor: '',

    /**
     * Overlay image of canvas instance.
     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    overlayImage: null,

    /**
     * Indicates whether toObject/toDatalessObject should include default values
     * if set to false, takes precedence over the object value.
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Indicates whether objects' state should be saved
     * @type Boolean
     * @default
     */
    stateful: false,

    /**
     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
     * since the renders are quequed and executed one per frame.
     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
     * Left default to true to do not break documentation and old app, fiddles.
     * @type Boolean
     * @default
     */
    renderOnAddRemove: true,

    /**
     * Indicates whether object controls (borders/controls) are rendered above overlay image
     * @type Boolean
     * @default
     */
    controlsAboveOverlay: false,

    /**
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
     * @type Boolean
     * @default
     */
    allowTouchScrolling: false,

    /**
     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
     * @type Boolean
     * @default
     */
    imageSmoothingEnabled: true,

    /**
     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport
     * @type Array
     * @example <caption>Default transform</caption>
     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>
     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];
     * @default
     */
    viewportTransform: fabric.iMatrix.concat(),

    /**
     * if set to false background image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    backgroundVpt: true,

    /**
     * if set to false overlya image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    overlayVpt: true,

    /**
     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
     * @type Boolean
     * @default
     */
    enableRetinaScaling: true,

    /**
     * Describe canvas element extension over design
     * properties are tl,tr,bl,br.
     * if canvas is not zoomed/panned those points are the four corner of canvas
     * if canvas is viewportTransformed you those points indicate the extension
     * of canvas element in plain untrasformed coordinates
     * The coordinates get updated with @method calcViewportBoundaries.
     * @memberOf fabric.StaticCanvas.prototype
     */
    vptCoords: { },

    /**
     * Based on vptCoords and object.aCoords, skip rendering of objects that
     * are not included in current viewport.
     * May greatly help in applications with crowded canvas and use of zoom/pan
     * If One of the corner of the bounding box of the object is on the canvas
     * the objects get rendered.
     * @memberOf fabric.StaticCanvas.prototype
     * @type Boolean
     * @default
     */
    skipOffscreen: true,

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the canvas has rendered, and the context is placed in the
     * top left corner of the canvas.
     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * @private
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     */
    _initStatic: function(el, options) {
      var cb = this.requestRenderAllBound;
      this._objects = [];
      this._createLowerCanvas(el);
      this._initOptions(options);
      // only initialize retina scaling once
      if (!this.interactive) {
        this._initRetinaScaling();
      }

      if (options.overlayImage) {
        this.setOverlayImage(options.overlayImage, cb);
      }
      if (options.backgroundImage) {
        this.setBackgroundImage(options.backgroundImage, cb);
      }
      if (options.backgroundColor) {
        this.setBackgroundColor(options.backgroundColor, cb);
      }
      if (options.overlayColor) {
        this.setOverlayColor(options.overlayColor, cb);
      }
      this.calcOffset();
    },

    /**
     * @private
     */
    _isRetinaScaling: function() {
      return (fabric.devicePixelRatio > 1 && this.enableRetinaScaling);
    },

    /**
     * @private
     * @return {Number} retinaScaling if applied, otherwise 1;
     */
    getRetinaScaling: function() {
      return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1;
    },

    /**
     * @private
     */
    _initRetinaScaling: function() {
      if (!this._isRetinaScaling()) {
        return;
      }
      var scaleRatio = fabric.devicePixelRatio;
      this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);
      if (this.upperCanvasEl) {
        this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);
      }
    },

    __initRetinaScaling: function(scaleRatio, canvas, context) {
      canvas.setAttribute('width', this.width * scaleRatio);
      canvas.setAttribute('height', this.height * scaleRatio);
      context.scale(scaleRatio, scaleRatio);
    },


    /**
     * Calculates canvas element offset relative to the document
     * This method is also attached as "resize" event handler of window
     * @return {fabric.Canvas} instance
     * @chainable
     */
    calcOffset: function () {
      this._offset = getElementOffset(this.lowerCanvasEl);
      return this;
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
     * @example <caption>Normal overlayImage with left/top = 0</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage with different properties</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage loaded from cross-origin</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    setOverlayImage: function (image, callback, options) {
      return this.__setBgOverlayImage('overlayImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
     * @param {Function} callback Callback to invoke when image is loaded and set as background
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
     * @example <caption>Normal backgroundImage with left/top = 0</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage with different properties</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage loaded from cross-origin</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    // TODO: fix stretched examples
    setBackgroundImage: function (image, callback, options) {
      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
     * @param {Function} callback Callback to invoke when foreground color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
     * @example <caption>Normal overlayColor - color value</caption>
     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setOverlayColor: function(overlayColor, callback) {
      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
     * @param {Function} callback Callback to invoke when background color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
     * @example <caption>Normal backgroundColor - color value</caption>
     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setBackgroundColor: function(backgroundColor, callback) {
      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
     */
    __setBgOverlayImage: function(property, image, callback, options) {
      if (typeof image === 'string') {
        fabric.util.loadImage(image, function(img, isError) {
          if (img) {
            var instance = new fabric.Image(img, options);
            this[property] = instance;
            instance.canvas = this;
          }
          callback && callback(img, isError);
        }, this, options && options.crossOrigin);
      }
      else {
        options && image.setOptions(options);
        this[property] = image;
        image && (image.canvas = this);
        callback && callback(image, false);
      }

      return this;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
     * @param {(Object|String|null)} color Object with pattern information, color value or null
     * @param {Function} [callback] Callback is invoked when color is set
     */
    __setBgOverlayColor: function(property, color, callback) {
      this[property] = color;
      this._initGradient(color, property);
      this._initPattern(color, property, callback);
      return this;
    },

    /**
     * @private
     */
    _createCanvasElement: function() {
      var element = createCanvasElement();
      if (!element) {
        throw CANVAS_INIT_ERROR;
      }
      if (!element.style) {
        element.style = { };
      }
      if (typeof element.getContext === 'undefined') {
        throw CANVAS_INIT_ERROR;
      }
      return element;
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initOptions: function (options) {
      var lowerCanvasEl = this.lowerCanvasEl;
      this._setOptions(options);

      this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
      this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;

      if (!this.lowerCanvasEl.style) {
        return;
      }

      lowerCanvasEl.width = this.width;
      lowerCanvasEl.height = this.height;

      lowerCanvasEl.style.width = this.width + 'px';
      lowerCanvasEl.style.height = this.height + 'px';

      this.viewportTransform = this.viewportTransform.slice();
    },

    /**
     * Creates a bottom canvas
     * @private
     * @param {HTMLElement} [canvasEl]
     */
    _createLowerCanvas: function (canvasEl) {
      // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
      if (canvasEl && canvasEl.getContext) {
        this.lowerCanvasEl = canvasEl;
      }
      else {
        this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
      }

      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');
      this._originalCanvasStyle = this.lowerCanvasEl.style;
      if (this.interactive) {
        this._applyCanvasStyle(this.lowerCanvasEl);
      }

      this.contextContainer = this.lowerCanvasEl.getContext('2d');
    },

    /**
     * Returns canvas width (in px)
     * @return {Number}
     */
    getWidth: function () {
      return this.width;
    },

    /**
     * Returns canvas height (in px)
     * @return {Number}
     */
    getHeight: function () {
      return this.height;
    },

    /**
     * Sets width of this canvas instance
     * @param {Number|String} value                         Value to set width to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setWidth: function (value, options) {
      return this.setDimensions({ width: value }, options);
    },

    /**
     * Sets height of this canvas instance
     * @param {Number|String} value                         Value to set height to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setHeight: function (value, options) {
      return this.setDimensions({ height: value }, options);
    },

    /**
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
     * @param {Object}        dimensions                    Object with width/height properties
     * @param {Number|String} [dimensions.width]            Width of canvas element
     * @param {Number|String} [dimensions.height]           Height of canvas element
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setDimensions: function (dimensions, options) {
      var cssValue;

      options = options || {};

      for (var prop in dimensions) {
        cssValue = dimensions[prop];

        if (!options.cssOnly) {
          this._setBackstoreDimension(prop, dimensions[prop]);
          cssValue += 'px';
          this.hasLostContext = true;
        }

        if (!options.backstoreOnly) {
          this._setCssDimension(prop, cssValue);
        }
      }
      if (this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
      }
      this._initRetinaScaling();
      this.calcOffset();

      if (!options.cssOnly) {
        this.requestRenderAll();
      }

      return this;
    },

    /**
     * Helper for setting width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {Number} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setBackstoreDimension: function (prop, value) {
      this.lowerCanvasEl[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl[prop] = value;
      }

      if (this.cacheCanvasEl) {
        this.cacheCanvasEl[prop] = value;
      }

      this[prop] = value;

      return this;
    },

    /**
     * Helper for setting css width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {String} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setCssDimension: function (prop, value) {
      this.lowerCanvasEl.style[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl.style[prop] = value;
      }

      if (this.wrapperEl) {
        this.wrapperEl.style[prop] = value;
      }

      return this;
    },

    /**
     * Returns canvas zoom level
     * @return {Number}
     */
    getZoom: function () {
      return this.viewportTransform[0];
    },

    /**
     * Sets viewport transformation of this canvas instance
     * @param {Array} vpt a Canvas 2D API transform matrix
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setViewportTransform: function (vpt) {
      var activeObject = this._activeObject,
          backgroundObject = this.backgroundImage,
          overlayObject = this.overlayImage,
          object, i, len;
      this.viewportTransform = vpt;
      for (i = 0, len = this._objects.length; i < len; i++) {
        object = this._objects[i];
        object.group || object.setCoords(true);
      }
      if (activeObject) {
        activeObject.setCoords();
      }
      if (backgroundObject) {
        backgroundObject.setCoords(true);
      }
      if (overlayObject) {
        overlayObject.setCoords(true);
      }
      this.calcViewportBoundaries();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Sets zoom level of this canvas instance, the zoom centered around point
     * meaning that following zoom to point with the same point will have the visual
     * effect of the zoom originating from that point. The point won't move.
     * It has nothing to do with canvas center or visual center of the viewport.
     * @param {fabric.Point} point to zoom with respect to
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    zoomToPoint: function (point, value) {
      // TODO: just change the scale, preserve other transformations
      var before = point, vpt = this.viewportTransform.slice(0);
      point = transformPoint(point, invertTransform(this.viewportTransform));
      vpt[0] = value;
      vpt[3] = value;
      var after = transformPoint(point, vpt);
      vpt[4] += before.x - after.x;
      vpt[5] += before.y - after.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Sets zoom level of this canvas instance
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setZoom: function (value) {
      this.zoomToPoint(new fabric.Point(0, 0), value);
      return this;
    },

    /**
     * Pan viewport so as to place point at top left corner of canvas
     * @param {fabric.Point} point to move to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    absolutePan: function (point) {
      var vpt = this.viewportTransform.slice(0);
      vpt[4] = -point.x;
      vpt[5] = -point.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Pans viewpoint relatively
     * @param {fabric.Point} point (position vector) to move by
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    relativePan: function (point) {
      return this.absolutePan(new fabric.Point(
        -point.x - this.viewportTransform[4],
        -point.y - this.viewportTransform[5]
      ));
    },

    /**
     * Returns &lt;canvas> element corresponding to this instance
     * @return {HTMLCanvasElement}
     */
    getElement: function () {
      return this.lowerCanvasEl;
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was added
     */
    _onObjectAdded: function(obj) {
      this.stateful && obj.setupState();
      obj._set('canvas', this);
      obj.setCoords();
      this.fire('object:added', { target: obj });
      obj.fire('added');
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      this.fire('object:removed', { target: obj });
      obj.fire('removed');
      delete obj.canvas;
    },

    /**
     * Clears specified context of canvas element
     * @param {CanvasRenderingContext2D} ctx Context to clear
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clearContext: function(ctx) {
      ctx.clearRect(0, 0, this.width, this.height);
      return this;
    },

    /**
     * Returns context of canvas where objects are drawn
     * @return {CanvasRenderingContext2D}
     */
    getContext: function () {
      return this.contextContainer;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      this.remove.apply(this, this.getObjects());
      this.backgroundImage = null;
      this.overlayImage = null;
      this.backgroundColor = '';
      this.overlayColor = '';
      if (this._hasITextHandlers) {
        this.off('mouse:up', this._mouseUpITextHandler);
        this._iTextInstances = null;
        this._hasITextHandlers = false;
      }
      this.clearContext(this.contextContainer);
      this.fire('canvas:cleared');
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Renders the canvas
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._objects);
      return this;
    },

    /**
     * Function created to be instance bound at initialization
     * used in requestAnimationFrame rendering
     * Let the fabricJS call it. If you call it manually you could have more
     * animationFrame stacking on to of each other
     * for an imperative rendering, use canvas.renderAll
     * @private
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAndReset: function() {
      this.isRendering = 0;
      this.renderAll();
    },

    /**
     * Append a renderAll request to next animation frame.
     * unless one is already in progress, in that case nothing is done
     * a boolean flag will avoid appending more.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    requestRenderAll: function () {
      if (!this.isRendering) {
        this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
      }
      return this;
    },

    /**
     * Calculate the position of the 4 corner of canvas with current viewportTransform.
     * helps to determinate when an object is in the current rendering viewport using
     * object absolute coordinates ( aCoords )
     * @return {Object} points.tl
     * @chainable
     */
    calcViewportBoundaries: function() {
      var points = { }, width = this.width, height = this.height,
          iVpt = invertTransform(this.viewportTransform);
      points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
      points.br = transformPoint({ x: width, y: height }, iVpt);
      points.tr = new fabric.Point(points.br.x, points.tl.y);
      points.bl = new fabric.Point(points.tl.x, points.br.y);
      this.vptCoords = points;
      return points;
    },

    cancelRequestedRender: function() {
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
    },

    /**
     * Renders background, objects, overlay and controls.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} objects to render
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderCanvas: function(ctx, objects) {
      var v = this.viewportTransform, path = this.clipPath;
      this.cancelRequestedRender();
      this.calcViewportBoundaries();
      this.clearContext(ctx);
      fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);
      this.fire('before:render', { ctx: ctx, });
      this._renderBackground(ctx);

      ctx.save();
      //apply viewport transform once for all rendering process
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this._renderObjects(ctx, objects);
      ctx.restore();
      if (!this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      if (path) {
        path.canvas = this;
        // needed to setup a couple of variables
        path.shouldCache();
        path._transformDone = true;
        path.renderCache({ forClipping: true });
        this.drawClipPathOnCanvas(ctx);
      }
      this._renderOverlay(ctx);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      this.fire('after:render', { ctx: ctx, });
    },

    /**
     * Paint the cached clipPath on the lowerCanvasEl
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCanvas: function(ctx) {
      var v = this.viewportTransform, path = this.clipPath;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4;
      ctx.globalCompositeOperation = 'destination-in';
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} objects to render
     */
    _renderObjects: function(ctx, objects) {
      var i, len;
      for (i = 0, len = objects.length; i < len; ++i) {
        objects[i] && objects[i].render(ctx);
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {string} property 'background' or 'overlay'
     */
    _renderBackgroundOrOverlay: function(ctx, property) {
      var fill = this[property + 'Color'], object = this[property + 'Image'],
          v = this.viewportTransform, needsVpt = this[property + 'Vpt'];
      if (!fill && !object) {
        return;
      }
      if (fill) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.width, 0);
        ctx.lineTo(this.width, this.height);
        ctx.lineTo(0, this.height);
        ctx.closePath();
        ctx.fillStyle = fill.toLive
          ? fill.toLive(ctx, this)
          : fill;
        if (needsVpt) {
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);
        var m = fill.gradientTransform || fill.patternTransform;
        m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        ctx.fill();
        ctx.restore();
      }
      if (object) {
        ctx.save();
        if (needsVpt) {
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        object.render(ctx);
        ctx.restore();
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'background');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderOverlay: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'overlay');
    },

    /**
     * Returns coordinates of a center of canvas.
     * Returned value is an object with top and left properties
     * @return {Object} object with "top" and "left" number values
     * @deprecated migrate to `getCenterPoint`
     */
    getCenter: function () {
      return {
        top: this.height / 2,
        left: this.width / 2
      };
    },

    /**
     * Returns coordinates of a center of canvas.
     * @return {fabric.Point} 
     */
    getCenterPoint: function () {
      return new fabric.Point(this.width / 2, this.height / 2);
    },

    /**
     * Centers object horizontally in the canvas
     * @param {fabric.Object} object Object to center horizontally
     * @return {fabric.Canvas} thisArg
     */
    centerObjectH: function (object) {
      return this._centerObject(object, new fabric.Point(this.getCenterPoint().x, object.getCenterPoint().y));
    },

    /**
     * Centers object vertically in the canvas
     * @param {fabric.Object} object Object to center vertically
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObjectV: function (object) {
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenterPoint().y));
    },

    /**
     * Centers object vertically and horizontally in the canvas
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObject: function(object) {
      var center = this.getCenterPoint();
      return this._centerObject(object, center);
    },

    /**
     * Centers object vertically and horizontally in the viewport
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObject: function(object) {
      var vpCenter = this.getVpCenter();
      return this._centerObject(object, vpCenter);
    },

    /**
     * Centers object horizontally in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectH: function(object) {
      var vpCenter = this.getVpCenter();
      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
      return this;
    },

    /**
     * Centers object Vertically in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectV: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
    },

    /**
     * Calculate the point in canvas that correspond to the center of actual viewport.
     * @return {fabric.Point} vpCenter, viewport center
     * @chainable
     */
    getVpCenter: function() {
      var center = this.getCenterPoint(),
          iVpt = invertTransform(this.viewportTransform);
      return transformPoint(center, iVpt);
    },

    /**
     * @private
     * @param {fabric.Object} object Object to center
     * @param {fabric.Point} center Center point
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    _centerObject: function(object, center) {
      object.setPositionByOrigin(center, 'center', 'center');
      object.setCoords();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Returns dataless JSON representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} json string
     */
    toDatalessJSON: function (propertiesToInclude) {
      return this.toDatalessObject(propertiesToInclude);
    },

    /**
     * Returns object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function (propertiesToInclude) {
      return this._toObjectMethod('toObject', propertiesToInclude);
    },

    /**
     * Returns dataless object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function (propertiesToInclude) {
      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
    },

    /**
     * @private
     */
    _toObjectMethod: function (methodName, propertiesToInclude) {

      var clipPath = this.clipPath, data = {
        version: fabric.version,
        objects: this._toObjects(methodName, propertiesToInclude),
      };
      if (clipPath && !clipPath.excludeFromExport) {
        data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
      }
      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

      fabric.util.populateWithProperties(this, data, propertiesToInclude);

      return data;
    },

    /**
     * @private
     */
    _toObjects: function(methodName, propertiesToInclude) {
      return this._objects.filter(function(object) {
        return !object.excludeFromExport;
      }).map(function(instance) {
        return this._toObject(instance, methodName, propertiesToInclude);
      }, this);
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      var originalValue;

      if (!this.includeDefaultValues) {
        originalValue = instance.includeDefaultValues;
        instance.includeDefaultValues = false;
      }

      var object = instance[methodName](propertiesToInclude);
      if (!this.includeDefaultValues) {
        instance.includeDefaultValues = originalValue;
      }
      return object;
    },

    /**
     * @private
     */
    __serializeBgOverlay: function(methodName, propertiesToInclude) {
      var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage,
          bgColor = this.backgroundColor, overlayColor = this.overlayColor;

      if (bgColor && bgColor.toObject) {
        if (!bgColor.excludeFromExport) {
          data.background = bgColor.toObject(propertiesToInclude);
        }
      }
      else if (bgColor) {
        data.background = bgColor;
      }

      if (overlayColor && overlayColor.toObject) {
        if (!overlayColor.excludeFromExport) {
          data.overlay = overlayColor.toObject(propertiesToInclude);
        }
      }
      else if (overlayColor) {
        data.overlay = overlayColor;
      }

      if (bgImage && !bgImage.excludeFromExport) {
        data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
      }
      if (overlayImage && !overlayImage.excludeFromExport) {
        data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);
      }

      return data;
    },

    /* _TO_SVG_START_ */
    /**
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
     * a zoomed canvas will then produce zoomed SVG output.
     * @type Boolean
     * @default
     */
    svgViewportTransformation: true,

    /**
     * Returns SVG representation of canvas
     * @function
     * @param {Object} [options] Options object for SVG output
     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
     * @param {Object} [options.viewBox] SVG viewbox object
     * @param {Number} [options.viewBox.x] x-coordinate of viewbox
     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
     * @param {Number} [options.viewBox.width] Width of viewbox
     * @param {Number} [options.viewBox.height] Height of viewbox
     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
     * @param {String} [options.width] desired width of svg with or without units
     * @param {String} [options.height] desired height of svg with or without units
     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
     * @return {String} SVG string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
     * @example <caption>Normal SVG output</caption>
     * var svg = canvas.toSVG();
     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
     * var svg = canvas.toSVG({suppressPreamble: true});
     * @example <caption>SVG output with viewBox attribute</caption>
     * var svg = canvas.toSVG({
     *   viewBox: {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 300
     *   }
     * });
     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
     * @example <caption>Modify SVG output with reviver function</caption>
     * var svg = canvas.toSVG(null, function(svg) {
     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
     * });
     */
    toSVG: function(options, reviver) {
      options || (options = { });
      options.reviver = reviver;
      var markup = [];

      this._setSVGPreamble(markup, options);
      this._setSVGHeader(markup, options);
      if (this.clipPath) {
        markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
      }
      this._setSVGBgOverlayColor(markup, 'background');
      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
      this._setSVGObjects(markup, reviver);
      if (this.clipPath) {
        markup.push('</g>\n');
      }
      this._setSVGBgOverlayColor(markup, 'overlay');
      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

      markup.push('</svg>');

      return markup.join('');
    },

    /**
     * @private
     */
    _setSVGPreamble: function(markup, options) {
      if (options.suppressPreamble) {
        return;
      }
      markup.push(
        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
        '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      );
    },

    /**
     * @private
     */
    _setSVGHeader: function(markup, options) {
      var width = options.width || this.width,
          height = options.height || this.height,
          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      if (options.viewBox) {
        viewBox = 'viewBox="' +
                options.viewBox.x + ' ' +
                options.viewBox.y + ' ' +
                options.viewBox.width + ' ' +
                options.viewBox.height + '" ';
      }
      else {
        if (this.svgViewportTransformation) {
          vpt = this.viewportTransform;
          viewBox = 'viewBox="' +
                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
        }
      }

      markup.push(
        '<svg ',
        'xmlns="http://www.w3.org/2000/svg" ',
        'xmlns:xlink="http://www.w3.org/1999/xlink" ',
        'version="1.1" ',
        'width="', width, '" ',
        'height="', height, '" ',
        viewBox,
        'xml:space="preserve">\n',
        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
        '<defs>\n',
        this.createSVGFontFacesMarkup(),
        this.createSVGRefElementsMarkup(),
        this.createSVGClipPathMarkup(options),
        '</defs>\n'
      );
    },

    createSVGClipPathMarkup: function(options) {
      var clipPath = this.clipPath;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        return  '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          this.clipPath.toClipPathSVG(options.reviver) +
          '</clipPath>\n';
      }
      return '';
    },

    /**
     * Creates markup containing SVG referenced elements like patterns, gradients etc.
     * @return {String}
     */
    createSVGRefElementsMarkup: function() {
      var _this = this,
          markup = ['background', 'overlay'].map(function(prop) {
            var fill = _this[prop + 'Color'];
            if (fill && fill.toLive) {
              var shouldTransform = _this[prop + 'Vpt'], vpt = _this.viewportTransform,
                  object = {
                    width: _this.width / (shouldTransform ? vpt[0] : 1),
                    height: _this.height / (shouldTransform ? vpt[3] : 1)
                  };
              return fill.toSVG(
                object,
                { additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : '' }
              );
            }
          });
      return markup.join('');
    },

    /**
     * Creates markup containing SVG font faces,
     * font URLs for font faces must be collected by developers
     * and are not extracted from the DOM by fabricjs
     * @param {Array} objects Array of fabric objects
     * @return {String}
     */
    createSVGFontFacesMarkup: function() {
      var markup = '', fontList = { }, obj, fontFamily,
          style, row, rowIndex, _char, charIndex, i, len,
          fontPaths = fabric.fontPaths, objects = [];

      this._objects.forEach(function add(object) {
        objects.push(object);
        if (object._objects) {
          object._objects.forEach(add);
        }
      });

      for (i = 0, len = objects.length; i < len; i++) {
        obj = objects[i];
        fontFamily = obj.fontFamily;
        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
          continue;
        }
        fontList[fontFamily] = true;
        if (!obj.styles) {
          continue;
        }
        style = obj.styles;
        for (rowIndex in style) {
          row = style[rowIndex];
          for (charIndex in row) {
            _char = row[charIndex];
            fontFamily = _char.fontFamily;
            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
              fontList[fontFamily] = true;
            }
          }
        }
      }

      for (var j in fontList) {
        markup += [
          '\t\t@font-face {\n',
          '\t\t\tfont-family: \'', j, '\';\n',
          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
          '\t\t}\n'
        ].join('');
      }

      if (markup) {
        markup = [
          '\t<style type="text/css">',
          '<![CDATA[\n',
          markup,
          ']]>',
          '</style>\n'
        ].join('');
      }

      return markup;
    },

    /**
     * @private
     */
    _setSVGObjects: function(markup, reviver) {
      var instance, i, len, objects = this._objects;
      for (i = 0, len = objects.length; i < len; i++) {
        instance = objects[i];
        if (instance.excludeFromExport) {
          continue;
        }
        this._setSVGObject(markup, instance, reviver);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      markup.push(instance.toSVG(reviver));
    },

    /**
     * @private
     */
    _setSVGBgOverlayImage: function(markup, property, reviver) {
      if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
        markup.push(this[property].toSVG(reviver));
      }
    },

    /**
     * @private
     */
    _setSVGBgOverlayColor: function(markup, property) {
      var filler = this[property + 'Color'], vpt = this.viewportTransform, finalWidth = this.width,
          finalHeight = this.height;
      if (!filler) {
        return;
      }
      if (filler.toLive) {
        var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + 'Vpt'],
            additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : '';
        markup.push(
          '<rect transform="' + additionalTransform + ' translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
          ' x="', filler.offsetX - finalWidth / 2,
          '" y="', filler.offsetY - finalHeight / 2, '" ',
          'width="',
          (repeat === 'repeat-y' || repeat === 'no-repeat'
            ? filler.source.width
            : finalWidth ),
          '" height="',
          (repeat === 'repeat-x' || repeat === 'no-repeat'
            ? filler.source.height
            : finalHeight),
          '" fill="url(#SVGID_' + filler.id + ')"',
          '></rect>\n'
        );
      }
      else {
        markup.push(
          '<rect x="0" y="0" width="100%" height="100%" ',
          'fill="', filler, '"',
          '></rect>\n'
        );
      }
    },
    /* _TO_SVG_END_ */

    /**
     * Moves an object or the objects of a multiple selection
     * to the bottom of the stack of drawn objects
     * @param {fabric.Object} object Object to send to back
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendToBack: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.unshift(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.unshift(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or the objects of a multiple selection
     * to the top of the stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringToFront: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.push(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.push(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or a selection down in stack of drawn objects
     * An optional parameter, intersecting allows to move the object in behind
     * the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendBackwards: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx > 0 + objsMoved) {
            newIdx = idx - 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== 0) {
          // if object is not on the bottom of stack
          newIdx = this._findNewLowerIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewLowerIndex: function(object, idx, intersecting) {
      var newIdx, i;

      if (intersecting) {
        newIdx = idx;

        // traverse down the stack looking for the nearest intersecting object
        for (i = idx - 1; i >= 0; --i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx - 1;
      }

      return newIdx;
    },

    /**
     * Moves an object or a selection up in stack of drawn objects
     * An optional parameter, intersecting allows to move the object in front
     * of the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringForward: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx < this._objects.length - 1 - objsMoved) {
            newIdx = idx + 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== this._objects.length - 1) {
          // if object is not on top of stack (last item in an array)
          newIdx = this._findNewUpperIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewUpperIndex: function(object, idx, intersecting) {
      var newIdx, i, len;

      if (intersecting) {
        newIdx = idx;

        // traverse up the stack looking for the nearest intersecting object
        for (i = idx + 1, len = this._objects.length; i < len; ++i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx + 1;
      }

      return newIdx;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Number} index Position to move to
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    moveTo: function (object, index) {
      removeFromArray(this._objects, object);
      this._objects.splice(index, 0, object);
      return this.renderOnAddRemove && this.requestRenderAll();
    },

    /**
     * Clears a canvas element and dispose objects
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      // cancel eventually ongoing renders
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
      this.forEachObject(function(object) {
        object.dispose && object.dispose();
      });
      this._objects = [];
      if (this.backgroundImage && this.backgroundImage.dispose) {
        this.backgroundImage.dispose();
      }
      this.backgroundImage = null;
      if (this.overlayImage && this.overlayImage.dispose) {
        this.overlayImage.dispose();
      }
      this.overlayImage = null;
      this._iTextInstances = null;
      this.contextContainer = null;
      // restore canvas style
      this.lowerCanvasEl.classList.remove('lower-canvas');
      fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);
      delete this._originalCanvasStyle;
      // restore canvas size to original size in case retina scaling was applied
      this.lowerCanvasEl.setAttribute('width', this.width);
      this.lowerCanvasEl.setAttribute('height', this.height);
      fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);
      this.lowerCanvasEl = undefined;
      return this;
    },

    /**
     * Returns a string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function () {
      return '#<fabric.Canvas (' + this.complexity() + '): ' +
               '{ objects: ' + this._objects.length + ' }>';
    }
  });

  extend(fabric.StaticCanvas.prototype, fabric.Observable);
  extend(fabric.StaticCanvas.prototype, fabric.Collection);
  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

    /**
     * @static
     * @type String
     * @default
     */
    EMPTY_JSON: '{"objects": [], "background": "white"}',

    /**
     * Provides a way to check support of some of the canvas methods
     * (either those of HTMLCanvasElement itself, or rendering context)
     *
     * @param {String} methodName Method to check support for;
     *                            Could be one of "setLineDash"
     * @return {Boolean | null} `true` if method is supported (or at least exists),
     *                          `null` if canvas element or context can not be initialized
     */
    supports: function (methodName) {
      var el = createCanvasElement();

      if (!el || !el.getContext) {
        return null;
      }

      var ctx = el.getContext('2d');
      if (!ctx) {
        return null;
      }

      switch (methodName) {

        case 'setLineDash':
          return typeof ctx.setLineDash !== 'undefined';

        default:
          return null;
      }
    }
  });

  /**
   * Returns Object representation of canvas
   * this alias is provided because if you call JSON.stringify on an instance,
   * the toJSON object will be invoked if it exists.
   * Having a toJSON method means you can do JSON.stringify(myCanvas)
   * @function
   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
   * @return {Object} JSON compatible object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
   * @example <caption>JSON without additional properties</caption>
   * var json = canvas.toJSON();
   * @example <caption>JSON with additional properties included</caption>
   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);
   * @example <caption>JSON without default values</caption>
   * canvas.includeDefaultValues = false;
   * var json = canvas.toJSON();
   */
  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

  if (fabric.isLikelyNode) {
    fabric.StaticCanvas.prototype.createPNGStream = function() {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createPNGStream();
    };
    fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createJPEGStream(opts);
    };
  }
})();
/**
 * BaseBrush class
 * @class fabric.BaseBrush
 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
 */
fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

  /**
   * Color of a brush
   * @type String
   * @default
   */
  color: 'rgb(0, 0, 0)',

  /**
   * Width of a brush, has to be a Number, no string literals
   * @type Number
   * @default
   */
  width: 1,

  /**
   * Shadow object representing shadow of this shape.
   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
   * @type fabric.Shadow
   * @default
   */
  shadow: null,

  /**
   * Line endings style of a brush (one of "butt", "round", "square")
   * @type String
   * @default
   */
  strokeLineCap: 'round',

  /**
   * Corner style of a brush (one of "bevel", "round", "miter")
   * @type String
   * @default
   */
  strokeLineJoin: 'round',

  /**
   * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
   * @type Number
   * @default
   */
  strokeMiterLimit:         10,

  /**
   * Stroke Dash Array.
   * @type Array
   * @default
   */
  strokeDashArray: null,

  /**
   * When `true`, the free drawing is limited to the whiteboard size. Default to false.
   * @type Boolean
   * @default false
  */

  limitedToCanvasSize: false,


  /**
   * Sets brush styles
   * @private
   * @param {CanvasRenderingContext2D} ctx
   */
  _setBrushStyles: function (ctx) {
    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.width;
    ctx.lineCap = this.strokeLineCap;
    ctx.miterLimit = this.strokeMiterLimit;
    ctx.lineJoin = this.strokeLineJoin;
    ctx.setLineDash(this.strokeDashArray || []);
  },

  /**
   * Sets the transformation on given context
   * @param {RenderingContext2d} ctx context to render on
   * @private
   */
  _saveAndTransform: function(ctx) {
    var v = this.canvas.viewportTransform;
    ctx.save();
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
  },

  /**
   * Sets brush shadow styles
   * @private
   */
  _setShadow: function() {
    if (!this.shadow) {
      return;
    }

    var canvas = this.canvas,
        shadow = this.shadow,
        ctx = canvas.contextTop,
        zoom = canvas.getZoom();
    if (canvas && canvas._isRetinaScaling()) {
      zoom *= fabric.devicePixelRatio;
    }

    ctx.shadowColor = shadow.color;
    ctx.shadowBlur = shadow.blur * zoom;
    ctx.shadowOffsetX = shadow.offsetX * zoom;
    ctx.shadowOffsetY = shadow.offsetY * zoom;
  },

  needsFullRender: function() {
    var color = new fabric.Color(this.color);
    return color.getAlpha() < 1 || !!this.shadow;
  },

  /**
   * Removes brush shadow styles
   * @private
   */
  _resetShadow: function() {
    var ctx = this.canvas.contextTop;

    ctx.shadowColor = '';
    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
  },

  /**
   * Check is pointer is outside canvas boundaries
   * @param {Object} pointer
   * @private
  */
  _isOutSideCanvas: function(pointer) {
    return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();
  }
});
(function() {
  /**
   * PencilBrush class
   * @class fabric.PencilBrush
   * @extends fabric.BaseBrush
   */
  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

    /**
     * Discard points that are less than `decimate` pixel distant from each other
     * @type Number
     * @default 0.4
     */
    decimate: 0.4,

    /**
     * Draws a straight line between last recorded point to current pointer
     * Used for `shift` functionality
     *
     * @type boolean
     * @default false
     */
    drawStraightLine: false,

    /**
     * The event modifier key that makes the brush draw a straight line.
     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.
     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}
     */
    straightLineKey: 'shiftKey',

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.PencilBrush} Instance of a pencil brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this._points = [];
    },

    needsFullRender: function () {
      return this.callSuper('needsFullRender') || this._hasStraightLine;
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    _drawSegment: function (ctx, p1, p2) {
      var midPoint = p1.midPointFrom(p2);
      ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
      return midPoint;
    },

    /**
     * Invoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer, options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return;
      }
      this.drawStraightLine = options.e[this.straightLineKey];
      this._prepareForDrawing(pointer);
      // capture coordinates immediately
      // this allows to draw dots (when movement never occurs)
      this._captureDrawingPath(pointer);
      this._render();
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer, options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return;
      }
      this.drawStraightLine = options.e[this.straightLineKey];
      if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
        return;
      }
      if (this._captureDrawingPath(pointer) && this._points.length > 1) {
        if (this.needsFullRender()) {
          // redraw curve
          // clear top canvas
          this.canvas.clearContext(this.canvas.contextTop);
          this._render();
        }
        else {
          var points = this._points, length = points.length, ctx = this.canvas.contextTop;
          // draw the curve update
          this._saveAndTransform(ctx);
          if (this.oldEnd) {
            ctx.beginPath();
            ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
          }
          this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
          ctx.stroke();
          ctx.restore();
        }
      }
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function(options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return true;
      }
      this.drawStraightLine = false;
      this.oldEnd = undefined;
      this._finalizeAndAddPath();
      return false;
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _prepareForDrawing: function(pointer) {

      var p = new fabric.Point(pointer.x, pointer.y);

      this._reset();
      this._addPoint(p);
      this.canvas.contextTop.moveTo(p.x, p.y);
    },

    /**
     * @private
     * @param {fabric.Point} point Point to be added to points array
     */
    _addPoint: function(point) {
      if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
        return false;
      }
      if (this.drawStraightLine && this._points.length > 1) {
        this._hasStraightLine = true;
        this._points.pop();
      }
      this._points.push(point);
      return true;
    },

    /**
     * Clear points array and set contextTop canvas style.
     * @private
     */
    _reset: function() {
      this._points = [];
      this._setBrushStyles(this.canvas.contextTop);
      this._setShadow();
      this._hasStraightLine = false;
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _captureDrawingPath: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
      return this._addPoint(pointerPoint);
    },

    /**
     * Draw a smooth path on the topCanvas using quadraticCurveTo
     * @private
     * @param {CanvasRenderingContext2D} [ctx]
     */
    _render: function(ctx) {
      var i, len,
          p1 = this._points[0],
          p2 = this._points[1];
      ctx = ctx || this.canvas.contextTop;
      this._saveAndTransform(ctx);
      ctx.beginPath();
      //if we only have 2 points in the path and they are the same
      //it means that the user only clicked the canvas without moving the mouse
      //then we should be drawing a dot. A path isn't drawn between two identical dots
      //that's why we set them apart a bit
      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
        var width = this.width / 1000;
        p1 = new fabric.Point(p1.x, p1.y);
        p2 = new fabric.Point(p2.x, p2.y);
        p1.x -= width;
        p2.x += width;
      }
      ctx.moveTo(p1.x, p1.y);

      for (i = 1, len = this._points.length; i < len; i++) {
        // we pick the point between pi + 1 & pi + 2 as the
        // end point and p1 as our control point.
        this._drawSegment(ctx, p1, p2);
        p1 = this._points[i];
        p2 = this._points[i + 1];
      }
      // Draw last line as a straight line while
      // we wait for the next point to be able to calculate
      // the bezier control point
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * Converts points to SVG path
     * @param {Array} points Array of points
     * @return {(string|number)[][]} SVG path commands
     */
    convertPointsToSVGPath: function (points) {
      var correction = this.width / 1000;
      return fabric.util.getSmoothPathFromPoints(points, correction);
    },

    /**
     * @private
     * @param {(string|number)[][]} pathData SVG path commands
     * @returns {boolean}
     */
    _isEmptySVGPath: function (pathData) {
      var pathString = fabric.util.joinPath(pathData);
      return pathString === 'M 0 0 Q 0 0 0 0 L 0 0';
    },

    /**
     * Creates fabric.Path object to add on canvas
     * @param {(string|number)[][]} pathData Path data
     * @return {fabric.Path} Path to add on canvas
     */
    createPath: function(pathData) {
      var path = new fabric.Path(pathData, {
        fill: null,
        stroke: this.color,
        strokeWidth: this.width,
        strokeLineCap: this.strokeLineCap,
        strokeMiterLimit: this.strokeMiterLimit,
        strokeLineJoin: this.strokeLineJoin,
        strokeDashArray: this.strokeDashArray,
      });
      if (this.shadow) {
        this.shadow.affectStroke = true;
        path.shadow = new fabric.Shadow(this.shadow);
      }

      return path;
    },

    /**
     * Decimate points array with the decimate value
     */
    decimatePoints: function(points, distance) {
      if (points.length <= 2) {
        return points;
      }
      var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2),
          i, l = points.length - 1, lastPoint = points[0], newPoints = [lastPoint],
          cDistance;
      for (i = 1; i < l - 1; i++) {
        cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);
        if (cDistance >= adjustedDistance) {
          lastPoint = points[i];
          newPoints.push(lastPoint);
        }
      }
      /**
       * Add the last point from the original line to the end of the array.
       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.
       */
      newPoints.push(points[l]);
      return newPoints;
    },

    /**
     * On mouseup after drawing the path on contextTop canvas
     * we use the points captured to create an new fabric path object
     * and add it to the fabric canvas.
     */
    _finalizeAndAddPath: function() {
      var ctx = this.canvas.contextTop;
      ctx.closePath();
      if (this.decimate) {
        this._points = this.decimatePoints(this._points, this.decimate);
      }
      var pathData = this.convertPointsToSVGPath(this._points);
      if (this._isEmptySVGPath(pathData)) {
        // do not create 0 width/height paths, as they are
        // rendered inconsistently across browsers
        // Firefox 4, for example, renders a dot,
        // whereas Chrome 10 renders nothing
        this.canvas.requestRenderAll();
        return;
      }

      var path = this.createPath(pathData);
      this.canvas.clearContext(this.canvas.contextTop);
      this.canvas.fire('before:path:created', { path: path });
      this.canvas.add(path);
      this.canvas.requestRenderAll();
      path.setCoords();
      this._resetShadow();


      // fire event 'path' created
      this.canvas.fire('path:created', { path: path });
    }
  });
})();
/**
 * CircleBrush class
 * @class fabric.CircleBrush
 */
fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

  /**
   * Width of a brush
   * @type Number
   * @default
   */
  width: 10,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.CircleBrush} Instance of a circle brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.points = [];
  },

  /**
   * Invoked inside on mouse down and mouse move
   * @param {Object} pointer
   */
  drawDot: function(pointer) {
    var point = this.addPoint(pointer),
        ctx = this.canvas.contextTop;
    this._saveAndTransform(ctx);
    this.dot(ctx, point);
    ctx.restore();
  },

  dot: function(ctx, point) {
    ctx.fillStyle = point.fill;
    ctx.beginPath();
    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();
  },

  /**
   * Invoked on mouse down
   */
  onMouseDown: function(pointer) {
    this.points.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();
    this.drawDot(pointer);
  },

  /**
   * Render the full state of the brush
   * @private
   */
  _render: function() {
    var ctx  = this.canvas.contextTop, i, len,
        points = this.points;
    this._saveAndTransform(ctx);
    for (i = 0, len = points.length; i < len; i++) {
      this.dot(ctx, points[i]);
    }
    ctx.restore();
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
      return;
    }
    if (this.needsFullRender()) {
      this.canvas.clearContext(this.canvas.contextTop);
      this.addPoint(pointer);
      this._render();
    }
    else {
      this.drawDot(pointer);
    }
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
    this.canvas.renderOnAddRemove = false;

    var circles = [];

    for (i = 0, len = this.points.length; i < len; i++) {
      var point = this.points[i],
          circle = new fabric.Circle({
            radius: point.radius,
            left: point.x,
            top: point.y,
            originX: 'center',
            originY: 'center',
            fill: point.fill
          });

      this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));

      circles.push(circle);
    }
    var group = new fabric.Group(circles);
    group.canvas = this.canvas;

    this.canvas.fire('before:path:created', { path: group });
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @param {Object} pointer
   * @return {fabric.Point} Just added pointer point
   */
  addPoint: function(pointer) {
    var pointerPoint = new fabric.Point(pointer.x, pointer.y),

        circleRadius = fabric.util.getRandomInt(
          Math.max(0, this.width - 20), this.width + 20) / 2,

        circleColor = new fabric.Color(this.color)
          .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
          .toRgba();

    pointerPoint.radius = circleRadius;
    pointerPoint.fill = circleColor;

    this.points.push(pointerPoint);

    return pointerPoint;
  }
});
/**
 * SprayBrush class
 * @class fabric.SprayBrush
 */
fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

  /**
   * Width of a spray
   * @type Number
   * @default
   */
  width:              10,

  /**
   * Density of a spray (number of dots per chunk)
   * @type Number
   * @default
   */
  density:            20,

  /**
   * Width of spray dots
   * @type Number
   * @default
   */
  dotWidth:           1,

  /**
   * Width variance of spray dots
   * @type Number
   * @default
   */
  dotWidthVariance:   1,

  /**
   * Whether opacity of a dot should be random
   * @type Boolean
   * @default
   */
  randomOpacity:        false,

  /**
   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
   * @type Boolean
   * @default
   */
  optimizeOverlapping:  true,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.SprayBrush} Instance of a spray brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.sprayChunks = [];
  },

  /**
   * Invoked on mouse down
   * @param {Object} pointer
   */
  onMouseDown: function(pointer) {
    this.sprayChunks.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();

    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
      return;
    }
    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;

    var rects = [];

    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      var sprayChunk = this.sprayChunks[i];

      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

        var rect = new fabric.Rect({
          width: sprayChunk[j].width,
          height: sprayChunk[j].width,
          left: sprayChunk[j].x + 1,
          top: sprayChunk[j].y + 1,
          originX: 'center',
          originY: 'center',
          fill: this.color
        });
        rects.push(rect);
      }
    }

    if (this.optimizeOverlapping) {
      rects = this._getOptimizedRects(rects);
    }

    var group = new fabric.Group(rects);
    this.shadow && group.set('shadow', new fabric.Shadow(this.shadow));
    this.canvas.fire('before:path:created', { path: group });
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @private
   * @param {Array} rects
   */
  _getOptimizedRects: function(rects) {

    // avoid creating duplicate rects at the same coordinates
    var uniqueRects = { }, key, i, len;

    for (i = 0, len = rects.length; i < len; i++) {
      key = rects[i].left + '' + rects[i].top;
      if (!uniqueRects[key]) {
        uniqueRects[key] = rects[i];
      }
    }
    var uniqueRectsArray = [];
    for (key in uniqueRects) {
      uniqueRectsArray.push(uniqueRects[key]);
    }

    return uniqueRectsArray;
  },

  /**
   * Render new chunk of spray brush
   */
  render: function(sprayChunk) {
    var ctx = this.canvas.contextTop, i, len;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, len = sprayChunk.length; i < len; i++) {
      var point = sprayChunk[i];
      if (typeof point.opacity !== 'undefined') {
        ctx.globalAlpha = point.opacity;
      }
      ctx.fillRect(point.x, point.y, point.width, point.width);
    }
    ctx.restore();
  },

  /**
   * Render all spray chunks
   */
  _render: function() {
    var ctx = this.canvas.contextTop, i, ilen;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      this.render(this.sprayChunks[i]);
    }
    ctx.restore();
  },

  /**
   * @param {Object} pointer
   */
  addSprayChunk: function(pointer) {
    this.sprayChunkPoints = [];

    var x, y, width, radius = this.width / 2, i;

    for (i = 0; i < this.density; i++) {

      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

      if (this.dotWidthVariance) {
        width = fabric.util.getRandomInt(
          // bottom clamp width to 1
          Math.max(1, this.dotWidth - this.dotWidthVariance),
          this.dotWidth + this.dotWidthVariance);
      }
      else {
        width = this.dotWidth;
      }

      var point = new fabric.Point(x, y);
      point.width = width;

      if (this.randomOpacity) {
        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
      }

      this.sprayChunkPoints.push(point);
    }

    this.sprayChunks.push(this.sprayChunkPoints);
  }
});
/**
 * PatternBrush class
 * @class fabric.PatternBrush
 * @extends fabric.BaseBrush
 */
fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

  getPatternSrc: function() {

    var dotWidth = 20,
        dotDistance = 5,
        patternCanvas = fabric.util.createCanvasElement(),
        patternCtx = patternCanvas.getContext('2d');

    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

    patternCtx.fillStyle = this.color;
    patternCtx.beginPath();
    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
    patternCtx.closePath();
    patternCtx.fill();

    return patternCanvas;
  },

  getPatternSrcFunction: function() {
    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
  },

  /**
   * Creates "pattern" instance property
   * @param {CanvasRenderingContext2D} ctx
   */
  getPattern: function(ctx) {
    return ctx.createPattern(this.source || this.getPatternSrc(), 'repeat');
  },

  /**
   * Sets brush styles
   * @param {CanvasRenderingContext2D} ctx
   */
  _setBrushStyles: function(ctx) {
    this.callSuper('_setBrushStyles', ctx);
    ctx.strokeStyle = this.getPattern(ctx);
  },

  /**
   * Creates path
   */
  createPath: function(pathData) {
    var path = this.callSuper('createPath', pathData),
        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

    path.stroke = new fabric.Pattern({
      source: this.source || this.getPatternSrcFunction(),
      offsetX: -topLeft.x,
      offsetY: -topLeft.y
    });
    return path;
  }
});
(function() {

  var getPointer = fabric.util.getPointer,
      degreesToRadians = fabric.util.degreesToRadians,
      isTouchEvent = fabric.util.isTouchEvent;

  /**
   * Canvas class
   * @class fabric.Canvas
   * @extends fabric.StaticCanvas
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
   * @see {@link fabric.Canvas#initialize} for constructor definition
   *
   * @fires object:modified at the end of a transform or any change when statefull is true
   * @fires object:rotating while an object is being rotated from the control
   * @fires object:scaling while an object is being scaled by controls
   * @fires object:moving while an object is being dragged
   * @fires object:skewing while an object is being skewed from the controls
   *
   * @fires before:transform before a transform is is started
   * @fires before:selection:cleared
   * @fires selection:cleared
   * @fires selection:updated
   * @fires selection:created
   *
   * @fires path:created after a drawing operation ends and the path is added
   * @fires mouse:down
   * @fires mouse:move
   * @fires mouse:up
   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs
   * @fires mouse:move:before on mouse move, before the inner fabric logic runs
   * @fires mouse:up:before on mouse up, before the inner fabric logic runs
   * @fires mouse:over
   * @fires mouse:out
   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop:before before drop event. same native event. This is added to handle edge cases
   * @fires drop
   * @fires after:render at the end of the render process, receives the context in the callback
   * @fires before:render at start the render process, receives the context in the callback
   *
   */
  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
      this._initInteractive();
      this._createCacheCanvas();
    },

    /**
     * When true, objects can be transformed by one side (unproportionally)
     * when dragged on the corners that normally would not do that.
     * @type Boolean
     * @default
     * @since fabric 4.0 // changed name and default value
     */
    uniformScaling:      true,

    /**
     * Indicates which key switches uniform scaling.
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * totally wrong named. this sounds like `uniform scaling`
     * if Canvas.uniformScaling is true, pressing this will set it to false
     * and viceversa.
     * @since 1.6.2
     * @type String
     * @default
     */
    uniScaleKey:           'shiftKey',

    /**
     * When true, objects use center point as the origin of scale transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:        false,

    /**
     * When true, objects use center point as the origin of rotate transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:       false,

    /**
     * Indicates which key enable centered Transform
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    centeredKey:           'altKey',

    /**
     * Indicates which key enable alternate action on corner
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    altActionKey:           'shiftKey',

    /**
     * Indicates that canvas is interactive. This property should not be changed.
     * @type Boolean
     * @default
     */
    interactive:            true,

    /**
     * Indicates whether group selection should be enabled
     * @type Boolean
     * @default
     */
    selection:              true,

    /**
     * Indicates which key or keys enable multiple click selection
     * Pass value as a string or array of strings
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or empty or containing any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.2
     * @type String|Array
     * @default
     */
    selectionKey:           'shiftKey',

    /**
     * Indicates which key enable alternative selection
     * in case of target overlapping with active object
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * For a series of reason that come from the general expectations on how
     * things should work, this feature works only for preserveObjectStacking true.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.5
     * @type null|String
     * @default
     */
    altSelectionKey:           null,

    /**
     * Color of selection
     * @type String
     * @default
     */
    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

    /**
     * Default dash array pattern
     * If not empty the selection border is dashed
     * @type Array
     */
    selectionDashArray:     [],

    /**
     * Color of the border of selection (usually slightly darker than color of selection itself)
     * @type String
     * @default
     */
    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

    /**
     * Width of a line used in object/group selection
     * @type Number
     * @default
     */
    selectionLineWidth:     1,

    /**
     * Select only shapes that are fully contained in the dragged selection rectangle.
     * @type Boolean
     * @default
     */
    selectionFullyContained: false,

    /**
     * Default cursor value used when hovering over an object on canvas
     * @type String
     * @default
     */
    hoverCursor:            'move',

    /**
     * Default cursor value used when moving an object on canvas
     * @type String
     * @default
     */
    moveCursor:             'move',

    /**
     * Default cursor value used for the entire canvas
     * @type String
     * @default
     */
    defaultCursor:          'default',

    /**
     * Cursor value used during free drawing
     * @type String
     * @default
     */
    freeDrawingCursor:      'crosshair',

    /**
     * Cursor value used for disabled elements ( corners with disabled action )
     * @type String
     * @since 2.0.0
     * @default
     */
    notAllowedCursor:         'not-allowed',

    /**
     * Default element class that's given to wrapper (div) element of canvas
     * @type String
     * @default
     */
    containerClass:         'canvas-container',

    /**
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:     false,

    /**
     * Number of pixels around target pixel to tolerate (consider active) during object detection
     * @type Number
     * @default
     */
    targetFindTolerance:    0,

    /**
     * When true, target detection is skipped. Target detection will return always undefined.
     * click selection won't work anymore, events will fire with no targets.
     * if something is selected before setting it to true, it will be deselected at the first click.
     * area selection will still work. check the `selection` property too.
     * if you deactivate both, you should look into staticCanvas.
     * @type Boolean
     * @default
     */
    skipTargetFind:         false,

    /**
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
     * After mousedown, mousemove creates a shape,
     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
     * @type Boolean
     * @default
     */
    isDrawingMode:          false,

    /**
     * Indicates whether objects should remain in current stack position when selected.
     * When false objects are brought to top and rendered as part of the selection group
     * @type Boolean
     * @default
     */
    preserveObjectStacking: false,

    /**
     * Indicates the angle that an object will lock to while rotating.
     * @type Number
     * @since 1.6.7
     * @default
     */
    snapAngle: 0,

    /**
     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
     * When `null`, the snapThreshold will default to the snapAngle.
     * @type null|Number
     * @since 1.6.7
     * @default
     */
    snapThreshold: null,

    /**
     * Indicates if the right click on canvas can output the context menu or not
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    stopContextMenu: false,

    /**
     * Indicates if the canvas can fire right click events
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    fireRightClick: false,

    /**
     * Indicates if the canvas can fire middle click events
     * @type Boolean
     * @since 1.7.8
     * @default
     */
    fireMiddleClick: false,

    /**
     * Keep track of the subTargets for Mouse Events
     * @type fabric.Object[]
     */
    targets: [],

    /**
     * When the option is enabled, PointerEvent is used instead of MouseEvent.
     * @type Boolean
     * @default
     */
    enablePointerEvents: false,

    /**
     * Keep track of the hovered target
     * @type fabric.Object
     * @private
     */
    _hoveredTarget: null,

    /**
     * hold the list of nested targets hovered
     * @type fabric.Object[]
     * @private
     */
    _hoveredTargets: [],

    /**
     * @private
     */
    _initInteractive: function() {
      this._currentTransform = null;
      this._groupSelector = null;
      this._initWrapperElement();
      this._createUpperCanvas();
      this._initEventListeners();

      this._initRetinaScaling();

      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

      this.calcOffset();
    },

    /**
     * Divides objects in two groups, one to render immediately
     * and one to render as activeGroup.
     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
     */
    _chooseObjectsToRender: function() {
      var activeObjects = this.getActiveObjects(),
          object, objsToRender, activeGroupObjects;

      if (activeObjects.length > 0 && !this.preserveObjectStacking) {
        objsToRender = [];
        activeGroupObjects = [];
        for (var i = 0, length = this._objects.length; i < length; i++) {
          object = this._objects[i];
          if (activeObjects.indexOf(object) === -1 ) {
            objsToRender.push(object);
          }
          else {
            activeGroupObjects.push(object);
          }
        }
        if (activeObjects.length > 1) {
          this._activeObject._objects = activeGroupObjects;
        }
        objsToRender.push.apply(objsToRender, activeGroupObjects);
      }
      else {
        objsToRender = this._objects;
      }
      return objsToRender;
    },

    /**
     * Renders both the top canvas and the secondary container canvas.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
        this.clearContext(this.contextTop);
        this.contextTopDirty = false;
      }
      if (this.hasLostContext) {
        this.renderTopLayer(this.contextTop);
        this.hasLostContext = false;
      }
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
      return this;
    },

    renderTopLayer: function(ctx) {
      ctx.save();
      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._render();
        this.contextTopDirty = true;
      }
      // we render the top context - last object
      if (this.selection && this._groupSelector) {
        this._drawSelection(ctx);
        this.contextTopDirty = true;
      }
      ctx.restore();
    },

    /**
     * Method to render only the top canvas.
     * Also used to render the group selection box.
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    renderTop: function () {
      var ctx = this.contextTop;
      this.clearContext(ctx);
      this.renderTopLayer(ctx);
      this.fire('after:render');
      return this;
    },

    /**
     * @private
     */
    _normalizePointer: function (object, pointer) {
      var m = object.calcTransformMatrix(),
          invertedM = fabric.util.invertTransform(m),
          vptPointer = this.restorePointerVpt(pointer);
      return fabric.util.transformPoint(vptPointer, invertedM);
    },

    /**
     * Returns true if object is transparent at a certain location
     * @param {fabric.Object} target Object to check
     * @param {Number} x Left coordinate
     * @param {Number} y Top coordinate
     * @return {Boolean}
     */
    isTargetTransparent: function (target, x, y) {
      // in case the target is the activeObject, we cannot execute this optimization
      // because we need to draw controls too.
      if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
        var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
            targetRelativeX = Math.max(target.cacheTranslationX + (normalizedPointer.x * target.zoomX), 0),
            targetRelativeY = Math.max(target.cacheTranslationY + (normalizedPointer.y * target.zoomY), 0);

        var isTransparent = fabric.util.isTransparent(
          target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);

        return isTransparent;
      }

      var ctx = this.contextCache,
          originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

      target.selectionBackgroundColor = '';

      this.clearContext(ctx);

      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      target.render(ctx);
      ctx.restore();

      target.selectionBackgroundColor = originalColor;

      var isTransparent = fabric.util.isTransparent(
        ctx, x, y, this.targetFindTolerance);

      return isTransparent;
    },

    /**
     * takes an event and determines if selection key has been pressed
     * @private
     * @param {Event} e Event object
     */
    _isSelectionKeyPressed: function(e) {
      var selectionKeyPressed = false;

      if (Array.isArray(this.selectionKey)) {
        selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
      }
      else {
        selectionKeyPressed = e[this.selectionKey];
      }

      return selectionKeyPressed;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _shouldClearSelection: function (e, target) {
      var activeObjects = this.getActiveObjects(),
          activeObject = this._activeObject;

      return (
        !target
        ||
        (target &&
          activeObject &&
          activeObjects.length > 1 &&
          activeObjects.indexOf(target) === -1 &&
          activeObject !== target &&
          !this._isSelectionKeyPressed(e))
        ||
        (target && !target.evented)
        ||
        (target &&
          !target.selectable &&
          activeObject &&
          activeObject !== target)
      );
    },

    /**
     * centeredScaling from object can't override centeredScaling from canvas.
     * this should be fixed, since object setting should take precedence over canvas.
     * also this should be something that will be migrated in the control properties.
     * as ability to define the origin of the transformation that the control provide.
     * @private
     * @param {fabric.Object} target
     * @param {String} action
     * @param {Boolean} altKey
     */
    _shouldCenterTransform: function (target, action, altKey) {
      if (!target) {
        return;
      }

      var centerTransform;

      if (action === 'scale' || action === 'scaleX' || action === 'scaleY' || action === 'resizing') {
        centerTransform = this.centeredScaling || target.centeredScaling;
      }
      else if (action === 'rotate') {
        centerTransform = this.centeredRotation || target.centeredRotation;
      }

      return centerTransform ? !altKey : altKey;
    },

    /**
     * should disappear before release 4.0
     * @private
     */
    _getOriginFromCorner: function(target, corner) {
      var origin = {
        x: target.originX,
        y: target.originY
      };

      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
        origin.x = 'right';
      }
      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
        origin.x = 'left';
      }

      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
        origin.y = 'bottom';
      }
      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
        origin.y = 'top';
      }
      return origin;
    },

    /**
     * @private
     * @param {Boolean} alreadySelected true if target is already selected
     * @param {String} corner a string representing the corner ml, mr, tl ...
     * @param {Event} e Event object
     * @param {fabric.Object} [target] inserted back to help overriding. Unused
     */
    _getActionFromCorner: function(alreadySelected, corner, e, target) {
      if (!corner || !alreadySelected) {
        return 'drag';
      }
      var control = target.controls[corner];
      return control.getActionName(e, control, target);
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _setupCurrentTransform: function (e, target, alreadySelected) {
      if (!target) {
        return;
      }

      var pointer = this.getPointer(e), corner = target.__corner,
          control = target.controls[corner],
          actionHandler = (alreadySelected && corner) ?
            control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler,
          action = this._getActionFromCorner(alreadySelected, corner, e, target),
          origin = this._getOriginFromCorner(target, corner),
          altKey = e[this.centeredKey],
          transform = {
            target: target,
            action: action,
            actionHandler: actionHandler,
            corner: corner,
            scaleX: target.scaleX,
            scaleY: target.scaleY,
            skewX: target.skewX,
            skewY: target.skewY,
            // used by transation
            offsetX: pointer.x - target.left,
            offsetY: pointer.y - target.top,
            originX: origin.x,
            originY: origin.y,
            ex: pointer.x,
            ey: pointer.y,
            lastX: pointer.x,
            lastY: pointer.y,
            // unsure they are useful anymore.
            // left: target.left,
            // top: target.top,
            theta: degreesToRadians(target.angle),
            // end of unsure
            width: target.width * target.scaleX,
            shiftKey: e.shiftKey,
            altKey: altKey,
            original: fabric.util.saveObjectTransform(target),
          };

      if (this._shouldCenterTransform(target, action, altKey)) {
        transform.originX = 'center';
        transform.originY = 'center';
      }
      transform.original.originX = origin.x;
      transform.original.originY = origin.y;
      this._currentTransform = transform;
      this._beforeTransform(e);
    },

    /**
     * Set the cursor type of the canvas element
     * @param {String} value Cursor type of the canvas element.
     * @see http://www.w3.org/TR/css3-ui/#cursor
     */
    setCursor: function (value) {
      this.upperCanvasEl.style.cursor = value;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx to draw the selection on
     */
    _drawSelection: function (ctx) {
      var selector = this._groupSelector,
          viewportStart = new fabric.Point(selector.ex, selector.ey),
          start = fabric.util.transformPoint(viewportStart, this.viewportTransform),
          viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top),
          extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform),
          minX = Math.min(start.x, extent.x),
          minY = Math.min(start.y, extent.y),
          maxX = Math.max(start.x, extent.x),
          maxY = Math.max(start.y, extent.y),
          strokeOffset = this.selectionLineWidth / 2;

      if (this.selectionColor) {
        ctx.fillStyle = this.selectionColor;
        ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
      }

      if (!this.selectionLineWidth || !this.selectionBorderColor) {
        return;
      }
      ctx.lineWidth = this.selectionLineWidth;
      ctx.strokeStyle = this.selectionBorderColor;

      minX += strokeOffset;
      minY += strokeOffset;
      maxX -= strokeOffset;
      maxY -= strokeOffset;
      // selection border
      fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
      ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
    },

    /**
     * Method that determines what object we are clicking on
     * the skipGroup parameter is for internal use, is needed for shift+click action
     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
     * or the outside part of the corner.
     * @param {Event} e mouse event
     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
     * @return {fabric.Object} the target found
     */
    findTarget: function (e, skipGroup) {
      if (this.skipTargetFind) {
        return;
      }

      var ignoreZoom = true,
          pointer = this.getPointer(e, ignoreZoom),
          activeObject = this._activeObject,
          aObjects = this.getActiveObjects(),
          activeTarget, activeTargetSubs,
          isTouch = isTouchEvent(e),
          shouldLookForActive = (aObjects.length > 1 && !skipGroup) || aObjects.length === 1;

      // first check current group (if one exists)
      // active group does not check sub targets like normal groups.
      // if active group just exits.
      this.targets = [];

      // if we hit the corner of an activeObject, let's return that.
      if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {
        return activeObject;
      }
      if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        return activeObject;
      }
      if (aObjects.length === 1 &&
        activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        if (!this.preserveObjectStacking) {
          return activeObject;
        }
        else {
          activeTarget = activeObject;
          activeTargetSubs = this.targets;
          this.targets = [];
        }
      }
      var target = this._searchPossibleTargets(this._objects, pointer);
      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
        target = activeTarget;
        this.targets = activeTargetSubs;
      }
      return target;
    },

    /**
     * Checks point is inside the object.
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @param {fabric.Object} obj Object to test against
     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
     * @return {Boolean} true if point is contained within an area of given object
     * @private
     */
    _checkTarget: function(pointer, obj, globalPointer) {
      if (obj &&
          obj.visible &&
          obj.evented &&
          // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
          // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
          obj.containsPoint(pointer)
      ) {
        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
          var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
          if (!isTransparent) {
            return true;
          }
        }
        else {
          return true;
        }
      }
    },

    /**
     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
     * @param {Array} [objects] objects array to look into
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @return {fabric.Object} object that contains pointer
     * @private
     */
    _searchPossibleTargets: function(objects, pointer) {
      // Cache all targets where their bounding box contains point.
      var target, i = objects.length, subTarget;
      // Do not check for currently grouped objects, since we check the parent group itself.
      // until we call this function specifically to search inside the activeGroup
      while (i--) {
        var objToCheck = objects[i];
        var pointerToUse = objToCheck.group ?
          this._normalizePointer(objToCheck.group, pointer) : pointer;
        if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
          target = objects[i];
          if (target.subTargetCheck && target instanceof fabric.Group) {
            subTarget = this._searchPossibleTargets(target._objects, pointer);
            subTarget && this.targets.push(subTarget);
          }
          break;
        }
      }
      return target;
    },

    /**
     * Returns pointer coordinates without the effect of the viewport
     * @param {Object} pointer with "x" and "y" number values
     * @return {Object} object with "x" and "y" number values
     */
    restorePointerVpt: function(pointer) {
      return fabric.util.transformPoint(
        pointer,
        fabric.util.invertTransform(this.viewportTransform)
      );
    },

    /**
     * Returns pointer coordinates relative to canvas.
     * Can return coordinates with or without viewportTransform.
     * ignoreZoom false gives back coordinates that represent
     * the point clicked on canvas element.
     * ignoreZoom true gives back coordinates after being processed
     * by the viewportTransform ( sort of coordinates of what is displayed
     * on the canvas where you are clicking.
     * ignoreZoom true = HTMLElement coordinates relative to top,left
     * ignoreZoom false, default = fabric space coordinates, the same used for shape position
     * To interact with your shapes top and left you want to use ignoreZoom true
     * most of the time, while ignoreZoom false will give you coordinates
     * compatible with the object.oCoords system.
     * of the time.
     * @param {Event} e
     * @param {Boolean} ignoreZoom
     * @return {Object} object with "x" and "y" number values
     */
    getPointer: function (e, ignoreZoom) {
      // return cached values if we are in the event processing chain
      if (this._absolutePointer && !ignoreZoom) {
        return this._absolutePointer;
      }
      if (this._pointer && ignoreZoom) {
        return this._pointer;
      }

      var pointer = getPointer(e),
          upperCanvasEl = this.upperCanvasEl,
          bounds = upperCanvasEl.getBoundingClientRect(),
          boundsWidth = bounds.width || 0,
          boundsHeight = bounds.height || 0,
          cssScale;

      if (!boundsWidth || !boundsHeight ) {
        if ('top' in bounds && 'bottom' in bounds) {
          boundsHeight = Math.abs( bounds.top - bounds.bottom );
        }
        if ('right' in bounds && 'left' in bounds) {
          boundsWidth = Math.abs( bounds.right - bounds.left );
        }
      }

      this.calcOffset();
      pointer.x = pointer.x - this._offset.left;
      pointer.y = pointer.y - this._offset.top;
      if (!ignoreZoom) {
        pointer = this.restorePointerVpt(pointer);
      }

      var retinaScaling = this.getRetinaScaling();
      if (retinaScaling !== 1) {
        pointer.x /= retinaScaling;
        pointer.y /= retinaScaling;
      }

      if (boundsWidth === 0 || boundsHeight === 0) {
        // If bounds are not available (i.e. not visible), do not apply scale.
        cssScale = { width: 1, height: 1 };
      }
      else {
        cssScale = {
          width: upperCanvasEl.width / boundsWidth,
          height: upperCanvasEl.height / boundsHeight
        };
      }

      return {
        x: pointer.x * cssScale.width,
        y: pointer.y * cssScale.height
      };
    },

    /**
     * @private
     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
     */
    _createUpperCanvas: function () {
      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ''),
          lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;

      // there is no need to create a new upperCanvas element if we have already one.
      if (upperCanvasEl) {
        upperCanvasEl.className = '';
      }
      else {
        upperCanvasEl = this._createCanvasElement();
        this.upperCanvasEl = upperCanvasEl;
      }
      fabric.util.addClass(upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

      this.wrapperEl.appendChild(upperCanvasEl);

      this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);
      this._applyCanvasStyle(upperCanvasEl);
      this.contextTop = upperCanvasEl.getContext('2d');
    },

    /**
     * Returns context of top canvas where interactions are drawn
     * @returns {CanvasRenderingContext2D}
     */
    getTopContext: function () {
      return this.contextTop;
    },

    /**
     * @private
     */
    _createCacheCanvas: function () {
      this.cacheCanvasEl = this._createCanvasElement();
      this.cacheCanvasEl.setAttribute('width', this.width);
      this.cacheCanvasEl.setAttribute('height', this.height);
      this.contextCache = this.cacheCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _initWrapperElement: function () {
      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
        'class': this.containerClass
      });
      fabric.util.setStyle(this.wrapperEl, {
        width: this.width + 'px',
        height: this.height + 'px',
        position: 'relative'
      });
      fabric.util.makeElementUnselectable(this.wrapperEl);
    },

    /**
     * @private
     * @param {HTMLElement} element canvas element to apply styles on
     */
    _applyCanvasStyle: function (element) {
      var width = this.width || element.width,
          height = this.height || element.height;

      fabric.util.setStyle(element, {
        position: 'absolute',
        width: width + 'px',
        height: height + 'px',
        left: 0,
        top: 0,
        'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none',
        '-ms-touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
      });
      element.width = width;
      element.height = height;
      fabric.util.makeElementUnselectable(element);
    },

    /**
     * Copy the entire inline style from one element (fromEl) to another (toEl)
     * @private
     * @param {Element} fromEl Element style is copied from
     * @param {Element} toEl Element copied style is applied to
     */
    _copyCanvasStyle: function (fromEl, toEl) {
      toEl.style.cssText = fromEl.style.cssText;
    },

    /**
     * Returns context of canvas where object selection is drawn
     * @return {CanvasRenderingContext2D}
     */
    getSelectionContext: function() {
      return this.contextTop;
    },

    /**
     * Returns &lt;canvas> element on which object selection is drawn
     * @return {HTMLCanvasElement}
     */
    getSelectionElement: function () {
      return this.upperCanvasEl;
    },

    /**
     * Returns currently active object
     * @return {fabric.Object} active object
     */
    getActiveObject: function () {
      return this._activeObject;
    },

    /**
     * Returns an array with the current selected objects
     * @return {fabric.Object} active object
     */
    getActiveObjects: function () {
      var active = this._activeObject;
      if (active) {
        if (active.type === 'activeSelection' && active._objects) {
          return active._objects.slice(0);
        }
        else {
          return [active];
        }
      }
      return [];
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      // removing active object should fire "selection:cleared" events
      if (obj === this._activeObject) {
        this.fire('before:selection:cleared', { target: obj });
        this._discardActiveObject();
        this.fire('selection:cleared', { target: obj });
        obj.fire('deselected');
      }
      if (obj === this._hoveredTarget){
        this._hoveredTarget = null;
        this._hoveredTargets = [];
      }
      this.callSuper('_onObjectRemoved', obj);
    },

    /**
     * @private
     * Compares the old activeObject with the current one and fires correct events
     * @param {fabric.Object} obj old activeObject
     */
    _fireSelectionEvents: function(oldObjects, e) {
      var somethingChanged = false, objects = this.getActiveObjects(),
          added = [], removed = [];
      oldObjects.forEach(function(oldObject) {
        if (objects.indexOf(oldObject) === -1) {
          somethingChanged = true;
          oldObject.fire('deselected', {
            e: e,
            target: oldObject
          });
          removed.push(oldObject);
        }
      });
      objects.forEach(function(object) {
        if (oldObjects.indexOf(object) === -1) {
          somethingChanged = true;
          object.fire('selected', {
            e: e,
            target: object
          });
          added.push(object);
        }
      });
      if (oldObjects.length > 0 && objects.length > 0) {
        somethingChanged && this.fire('selection:updated', {
          e: e,
          selected: added,
          deselected: removed,
        });
      }
      else if (objects.length > 0) {
        this.fire('selection:created', {
          e: e,
          selected: added,
        });
      }
      else if (oldObjects.length > 0) {
        this.fire('selection:cleared', {
          e: e,
          deselected: removed,
        });
      }
    },

    /**
     * Sets given object as the only active object on canvas
     * @param {fabric.Object} object Object to set as an active one
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setActiveObject: function (object, e) {
      var currentActives = this.getActiveObjects();
      this._setActiveObject(object, e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * This is a private method for now.
     * This is supposed to be equivalent to setActiveObject but without firing
     * any event. There is commitment to have this stay this way.
     * This is the functional part of setActiveObject.
     * @private
     * @param {Object} object to set as active
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {Boolean} true if the selection happened
     */
    _setActiveObject: function(object, e) {
      if (this._activeObject === object) {
        return false;
      }
      if (!this._discardActiveObject(e, object)) {
        return false;
      }
      if (object.onSelect({ e: e })) {
        return false;
      }
      this._activeObject = object;
      return true;
    },

    /**
     * This is a private method for now.
     * This is supposed to be equivalent to discardActiveObject but without firing
     * any events. There is commitment to have this stay this way.
     * This is the functional part of discardActiveObject.
     * @param {Event} [e] Event (passed along when firing "object:deselected")
     * @param {Object} object to set as active
     * @return {Boolean} true if the selection happened
     * @private
     */
    _discardActiveObject: function(e, object) {
      var obj = this._activeObject;
      if (obj) {
        // onDeselect return TRUE to cancel selection;
        if (obj.onDeselect({ e: e, object: object })) {
          return false;
        }
        this._activeObject = null;
      }
      return true;
    },

    /**
     * Discards currently active object and fire events. If the function is called by fabric
     * as a consequence of a mouse event, the event is passed as a parameter and
     * sent to the fire function for the custom events. When used as a method the
     * e param does not have any application.
     * @param {event} e
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    discardActiveObject: function (e) {
      var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();
      if (currentActives.length) {
        this.fire('before:selection:cleared', { target: activeObject, e: e });
      }
      this._discardActiveObject(e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * Clears a canvas element and removes all event listeners
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      var wrapper = this.wrapperEl;
      this.removeListeners();
      wrapper.removeChild(this.upperCanvasEl);
      wrapper.removeChild(this.lowerCanvasEl);
      this.contextCache = null;
      this.contextTop = null;
      ['upperCanvasEl', 'cacheCanvasEl'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
      if (wrapper.parentNode) {
        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
      }
      delete this.wrapperEl;
      fabric.StaticCanvas.prototype.dispose.call(this);
      return this;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      // this.discardActiveGroup();
      this.discardActiveObject();
      this.clearContext(this.contextTop);
      return this.callSuper('clear');
    },

    /**
     * Draws objects' controls (borders/controls)
     * @param {CanvasRenderingContext2D} ctx Context to render controls on
     */
    drawControls: function(ctx) {
      var activeObject = this._activeObject;

      if (activeObject) {
        activeObject._renderControls(ctx);
      }
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      //If the object is part of the current selection group, it should
      //be transformed appropriately
      //i.e. it should be serialised as it would appear if the selection group
      //were to be destroyed.
      var originalProperties = this._realizeGroupTransformOnObject(instance),
          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
      //Undo the damage we did by changing all of its properties
      this._unwindGroupTransformOnObject(instance, originalProperties);
      return object;
    },

    /**
     * Realises an object's group transformation on it
     * @private
     * @param {fabric.Object} [instance] the object to transform (gets mutated)
     * @returns the original values of instance which were changed
     */
    _realizeGroupTransformOnObject: function(instance) {
      if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
        var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
        //Copy all the positionally relevant properties across now
        var originalValues = {};
        layoutProps.forEach(function(prop) {
          originalValues[prop] = instance[prop];
        });
        fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());
        return originalValues;
      }
      else {
        return null;
      }
    },

    /**
     * Restores the changed properties of instance
     * @private
     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
     */
    _unwindGroupTransformOnObject: function(instance, originalValues) {
      if (originalValues) {
        instance.set(originalValues);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      //If the object is in a selection group, simulate what would happen to that
      //object when the group is deselected
      var originalProperties = this._realizeGroupTransformOnObject(instance);
      this.callSuper('_setSVGObject', markup, instance, reviver);
      this._unwindGroupTransformOnObject(instance, originalProperties);
    },

    setViewportTransform: function (vpt) {
      if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
        this._activeObject.clearContextTop();
      }
      fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
    }
  });

  // copying static properties manually to work around Opera's bug,
  // where "prototype" property is enumerable and overrides existing prototype
  for (var prop in fabric.StaticCanvas) {
    if (prop !== 'prototype') {
      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
    }
  }
})();
(function() {

  var addListener = fabric.util.addListener,
      removeListener = fabric.util.removeListener,
      RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
      addEventOptions = { passive: false };

  function checkClick(e, value) {
    return e.button && (e.button === value - 1);
  }

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * Contains the id of the touch event that owns the fabric transform
     * @type Number
     * @private
     */
    mainTouchId: null,

    /**
     * Adds mouse listeners to canvas
     * @private
     */
    _initEventListeners: function () {
      // in case we initialized the class twice. This should not happen normally
      // but in some kind of applications where the canvas element may be changed
      // this is a workaround to having double listeners.
      this.removeListeners();
      this._bindEvents();
      this.addOrRemove(addListener, 'add');
    },

    /**
     * return an event prefix pointer or mouse.
     * @private
     */
    _getEventPrefix: function () {
      return this.enablePointerEvents ? 'pointer' : 'mouse';
    },

    addOrRemove: function(functor, eventjsFunctor) {
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      functor(fabric.window, 'resize', this._onResize);
      functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
      functor(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      functor(canvasElement, eventTypePrefix + 'out', this._onMouseOut);
      functor(canvasElement, eventTypePrefix + 'enter', this._onMouseEnter);
      functor(canvasElement, 'wheel', this._onMouseWheel);
      functor(canvasElement, 'contextmenu', this._onContextMenu);
      functor(canvasElement, 'dblclick', this._onDoubleClick);
      functor(canvasElement, 'dragover', this._onDragOver);
      functor(canvasElement, 'dragenter', this._onDragEnter);
      functor(canvasElement, 'dragleave', this._onDragLeave);
      functor(canvasElement, 'drop', this._onDrop);
      if (!this.enablePointerEvents) {
        functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);
      }
      if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
        eventjs[eventjsFunctor](canvasElement, 'gesture', this._onGesture);
        eventjs[eventjsFunctor](canvasElement, 'drag', this._onDrag);
        eventjs[eventjsFunctor](canvasElement, 'orientation', this._onOrientationChange);
        eventjs[eventjsFunctor](canvasElement, 'shake', this._onShake);
        eventjs[eventjsFunctor](canvasElement, 'longpress', this._onLongPress);
      }
    },

    /**
     * Removes all event listeners
     */
    removeListeners: function() {
      this.addOrRemove(removeListener, 'remove');
      // if you dispose on a mouseDown, before mouse up, you need to clean document to...
      var eventTypePrefix = this._getEventPrefix();
      removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
      removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     */
    _bindEvents: function() {
      if (this.eventsBound) {
        // for any reason we pass here twice we do not want to bind events twice.
        return;
      }
      this._onMouseDown = this._onMouseDown.bind(this);
      this._onTouchStart = this._onTouchStart.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      this._onMouseUp = this._onMouseUp.bind(this);
      this._onTouchEnd = this._onTouchEnd.bind(this);
      this._onResize = this._onResize.bind(this);
      this._onGesture = this._onGesture.bind(this);
      this._onDrag = this._onDrag.bind(this);
      this._onShake = this._onShake.bind(this);
      this._onLongPress = this._onLongPress.bind(this);
      this._onOrientationChange = this._onOrientationChange.bind(this);
      this._onMouseWheel = this._onMouseWheel.bind(this);
      this._onMouseOut = this._onMouseOut.bind(this);
      this._onMouseEnter = this._onMouseEnter.bind(this);
      this._onContextMenu = this._onContextMenu.bind(this);
      this._onDoubleClick = this._onDoubleClick.bind(this);
      this._onDragOver = this._onDragOver.bind(this);
      this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
      this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
      this._onDrop = this._onDrop.bind(this);
      this.eventsBound = true;
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js gesture
     * @param {Event} [self] Inner Event object
     */
    _onGesture: function(e, self) {
      this.__onTransformGesture && this.__onTransformGesture(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js drag
     * @param {Event} [self] Inner Event object
     */
    _onDrag: function(e, self) {
      this.__onDrag && this.__onDrag(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on wheel event
     */
    _onMouseWheel: function(e) {
      this.__onMouseWheel(e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseOut: function(e) {
      var target = this._hoveredTarget;
      this.fire('mouse:out', { target: target, e: e });
      this._hoveredTarget = null;
      target && target.fire('mouseout', { e: e });

      var _this = this;
      this._hoveredTargets.forEach(function(_target){
        _this.fire('mouse:out', { target: target, e: e });
        _target && target.fire('mouseout', { e: e });
      });
      this._hoveredTargets = [];

      if (this._iTextInstances) {
        this._iTextInstances.forEach(function(obj) {
          if (obj.isEditing) {
            obj.hiddenTextarea.focus();
          }
        });
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseenter
     */
    _onMouseEnter: function(e) {
      // This find target and consequent 'mouse:over' is used to
      // clear old instances on hovered target.
      // calling findTarget has the side effect of killing target.__corner.
      // as a short term fix we are not firing this if we are currently transforming.
      // as a long term fix we need to separate the action of finding a target with the
      // side effects we added to it.
      if (!this._currentTransform && !this.findTarget(e)) {
        this.fire('mouse:over', { target: null, e: e });
        this._hoveredTarget = null;
        this._hoveredTargets = [];
      }
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js orientation change
     * @param {Event} [self] Inner Event object
     */
    _onOrientationChange: function(e, self) {
      this.__onOrientationChange && this.__onOrientationChange(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onShake: function(e, self) {
      this.__onShake && this.__onShake(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onLongPress: function(e, self) {
      this.__onLongPress && this.__onLongPress(e, self);
    },

    /**
     * prevent default to allow drop event to be fired
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     */
    _onDragOver: function(e) {
      e.preventDefault();
      var target = this._simpleEventHandler('dragover', e);
      this._fireEnterLeaveEvents(target, e);
    },

    /**
     * `drop:before` is a an event that allow you to schedule logic
     * before the `drop` event. Prefer `drop` event always, but if you need
     * to run some drop-disabling logic on an event, since there is no way
     * to handle event handlers ordering, use `drop:before`
     * @param {Event} e
     */
    _onDrop: function (e) {
      this._simpleEventHandler('drop:before', e);
      return this._simpleEventHandler('drop', e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onContextMenu: function (e) {
      if (this.stopContextMenu) {
        e.stopPropagation();
        e.preventDefault();
      }
      return false;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onDoubleClick: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'dblclick');
      this._resetTransformEventData(e);
    },

    /**
     * Return a the id of an event.
     * returns either the pointerId or the identifier or 0 for the mouse event
     * @private
     * @param {Event} evt Event object
     */
    getPointerId: function(evt) {
      var changedTouches = evt.changedTouches;

      if (changedTouches) {
        return changedTouches[0] && changedTouches[0].identifier;
      }

      if (this.enablePointerEvents) {
        return evt.pointerId;
      }

      return -1;
    },

    /**
     * Determines if an event has the id of the event that is considered main
     * @private
     * @param {evt} event Event object
     */
    _isMainEvent: function(evt) {
      if (evt.isPrimary === true) {
        return true;
      }
      if (evt.isPrimary === false) {
        return false;
      }
      if (evt.type === 'touchend' && evt.touches.length === 0) {
        return true;
      }
      if (evt.changedTouches) {
        return evt.changedTouches[0].identifier === this.mainTouchId;
      }
      return true;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onTouchStart: function(e) {
      e.preventDefault();
      if (this.mainTouchId === null) {
        this.mainTouchId = this.getPointerId(e);
      }
      this.__onMouseDown(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      addListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      // Unbind mousedown to prevent double triggers from touch devices
      removeListener(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDown: function (e) {
      this.__onMouseDown(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      removeListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      addListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
      addListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onTouchEnd: function(e) {
      if (e.touches.length > 0) {
        // if there are still touches stop here
        return;
      }
      this.__onMouseUp(e);
      this._resetTransformEventData();
      this.mainTouchId = null;
      var eventTypePrefix = this._getEventPrefix();
      removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      var _this = this;
      if (this._willAddMouseDown) {
        clearTimeout(this._willAddMouseDown);
      }
      this._willAddMouseDown = setTimeout(function() {
        // Wait 400ms before rebinding mousedown to prevent double triggers
        // from touch devices
        addListener(_this.upperCanvasEl, eventTypePrefix + 'down', _this._onMouseDown);
        _this._willAddMouseDown = 0;
      }, 400);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUp: function (e) {
      this.__onMouseUp(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      if (this._isMainEvent(e)) {
        removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
        removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        addListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMove: function (e) {
      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
      this.__onMouseMove(e);
    },

    /**
     * @private
     */
    _onResize: function () {
      this.calcOffset();
    },

    /**
     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
     * @private
     * @param {Object} target
     */
    _shouldRender: function(target) {
      var activeObject = this._activeObject;

      if (
        !!activeObject !== !!target ||
        (activeObject && target && (activeObject !== target))
      ) {
        // this covers: switch of target, from target to no target, selection of target
        // multiSelection with key and mouse
        return true;
      }
      else if (activeObject && activeObject.isEditing) {
        // if we mouse up/down over a editing textbox a cursor change,
        // there is no need to re render
        return false;
      }
      return false;
    },

    /**
     * Method that defines the actions when mouse is released on canvas.
     * The method resets the currentTransform parameters, store the image corner
     * position in the image object and render the canvas on top.
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseUp: function (e) {
      var target, transform = this._currentTransform,
          groupSelector = this._groupSelector, shouldRender = false,
          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
      this._cacheTransformEventData(e);
      target = this._target;
      this._handleEvent(e, 'up:before');
      // if right/middle click just fire events and return
      // target undefined will make the _handleEvent search the target
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
        }
        this._resetTransformEventData();
        return;
      }

      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this._onMouseUpInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }
      if (transform) {
        this._finalizeCurrentTransform(e);
        shouldRender = transform.actionPerformed;
      }
      if (!isClick) {
        var targetWasActive = target === this._activeObject;
        this._maybeGroupObjects(e);
        if (!shouldRender) {
          shouldRender = (
            this._shouldRender(target) ||
            (!targetWasActive && target === this._activeObject)
          );
        }
      }
      var corner, pointer;
      if (target) {
        corner = target._findTargetCorner(
          this.getPointer(e, true),
          fabric.util.isTouchEvent(e)
        );
        if (target.selectable && target !== this._activeObject && target.activeOn === 'up') {
          this.setActiveObject(target, e);
          shouldRender = true;
        }
        else {
          var control = target.controls[corner],
              mouseUpHandler = control && control.getMouseUpHandler(e, target, control);
          if (mouseUpHandler) {
            pointer = this.getPointer(e);
            mouseUpHandler(e, transform, pointer.x, pointer.y);
          }
        }
        target.isMoving = false;
      }
      // if we are ending up a transform on a different control or a new object
      // fire the original mouse up from the corner that started the transform
      if (transform && (transform.target !== target || transform.corner !== corner)) {
        var originalControl = transform.target && transform.target.controls[transform.corner],
            originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e, target, control);
        pointer = pointer || this.getPointer(e);
        originalMouseUpHandler && originalMouseUpHandler(e, transform, pointer.x, pointer.y);
      }
      this._setCursorFromEvent(e, target);
      this._handleEvent(e, 'up', LEFT_CLICK, isClick);
      this._groupSelector = null;
      this._currentTransform = null;
      // reset the target information about which corner is selected
      target && (target.__corner = 0);
      if (shouldRender) {
        this.requestRenderAll();
      }
      else if (!isClick) {
        this.renderTop();
      }
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @return {Fabric.Object} target return the the target found, for internal reasons.
     */
    _simpleEventHandler: function(eventType, e) {
      var target = this.findTarget(e),
          targets = this.targets,
          options = {
            e: e,
            target: target,
            subTargets: targets,
          };
      this.fire(eventType, options);
      target && target.fire(eventType, options);
      if (!targets) {
        return target;
      }
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(eventType, options);
      }
      return target;
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @param {fabric.Object} targetObj receiving event
     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
     */
    _handleEvent: function(e, eventType, button, isClick) {
      var target = this._target,
          targets = this.targets || [],
          options = {
            e: e,
            target: target,
            subTargets: targets,
            button: button || LEFT_CLICK,
            isClick: isClick || false,
            pointer: this._pointer,
            absolutePointer: this._absolutePointer,
            transform: this._currentTransform
          };
      if (eventType === 'up') {
        options.currentTarget = this.findTarget(e);
        options.currentSubTargets = this.targets;
      }
      this.fire('mouse:' + eventType, options);
      target && target.fire('mouse' + eventType, options);
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire('mouse' + eventType, options);
      }
    },

    /**
     * @private
     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
     */
    _finalizeCurrentTransform: function(e) {

      var transform = this._currentTransform,
          target = transform.target,
          options = {
            e: e,
            target: target,
            transform: transform,
            action: transform.action,
          };

      if (target._scaling) {
        target._scaling = false;
      }

      target.setCoords();

      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
        this._fire('modified', options);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDownInDrawingMode: function(e) {
      this._isCurrentlyDrawing = true;
      if (this.getActiveObject()) {
        this.discardActiveObject(e).requestRenderAll();
      }
      var pointer = this.getPointer(e);
      this.freeDrawingBrush.onMouseDown(pointer, { e: e, pointer: pointer });
      this._handleEvent(e, 'down');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMoveInDrawingMode: function(e) {
      if (this._isCurrentlyDrawing) {
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseMove(pointer, { e: e, pointer: pointer });
      }
      this.setCursor(this.freeDrawingCursor);
      this._handleEvent(e, 'move');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUpInDrawingMode: function(e) {
      var pointer = this.getPointer(e);
      this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e, pointer: pointer });
      this._handleEvent(e, 'up');
    },

    /**
     * Method that defines the actions when mouse is clicked on canvas.
     * The method inits the currentTransform parameters and renders all the
     * canvas so the current image can be placed on the top canvas and the rest
     * in on the container one.
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    __onMouseDown: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'down:before');
      var target = this._target;
      // if right click just fire events
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'down', RIGHT_CLICK);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'down', MIDDLE_CLICK);
        }
        return;
      }

      if (this.isDrawingMode) {
        this._onMouseDownInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }

      // ignore if some object is being transformed at this moment
      if (this._currentTransform) {
        return;
      }

      var pointer = this._pointer;
      // save pointer for check in __onMouseUp event
      this._previousPointer = pointer;
      var shouldRender = this._shouldRender(target),
          shouldGroup = this._shouldGroup(e, target);
      if (this._shouldClearSelection(e, target)) {
        this.discardActiveObject(e);
      }
      else if (shouldGroup) {
        this._handleGrouping(e, target);
        target = this._activeObject;
      }

      if (this.selection && (!target ||
        (!target.selectable && !target.isEditing && target !== this._activeObject))) {
        this._groupSelector = {
          ex: this._absolutePointer.x,
          ey: this._absolutePointer.y,
          top: 0,
          left: 0
        };
      }

      if (target) {
        var alreadySelected = target === this._activeObject;
        if (target.selectable && target.activeOn === 'down') {
          this.setActiveObject(target, e);
        }
        var corner = target._findTargetCorner(
          this.getPointer(e, true),
          fabric.util.isTouchEvent(e)
        );
        target.__corner = corner;
        if (target === this._activeObject && (corner || !shouldGroup)) {
          this._setupCurrentTransform(e, target, alreadySelected);
          var control = target.controls[corner],
              pointer = this.getPointer(e),
              mouseDownHandler = control && control.getMouseDownHandler(e, target, control);
          if (mouseDownHandler) {
            mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);
          }
        }
      }
      this._handleEvent(e, 'down');
      // we must renderAll so that we update the visuals
      (shouldRender || shouldGroup) && this.requestRenderAll();
    },

    /**
     * reset cache form common information needed during event processing
     * @private
     */
    _resetTransformEventData: function() {
      this._target = null;
      this._pointer = null;
      this._absolutePointer = null;
    },

    /**
     * Cache common information needed during event processing
     * @private
     * @param {Event} e Event object fired on event
     */
    _cacheTransformEventData: function(e) {
      // reset in order to avoid stale caching
      this._resetTransformEventData();
      this._pointer = this.getPointer(e, true);
      this._absolutePointer = this.restorePointerVpt(this._pointer);
      this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
    },

    /**
     * @private
     */
    _beforeTransform: function(e) {
      var t = this._currentTransform;
      this.stateful && t.target.saveState();
      this.fire('before:transform', {
        e: e,
        transform: t,
      });
    },

    /**
     * Method that defines the actions when mouse is hovering the canvas.
     * The currentTransform parameter will define whether the user is rotating/scaling/translating
     * an image or neither of them (only hovering). A group selection is also possible and would cancel
     * all any other type of action.
     * In case of an image transformation only the top canvas will be rendered.
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    __onMouseMove: function (e) {
      this._handleEvent(e, 'move:before');
      this._cacheTransformEventData(e);
      var target, pointer;

      if (this.isDrawingMode) {
        this._onMouseMoveInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }

      var groupSelector = this._groupSelector;

      // We initially clicked in an empty area, so we draw a box for multiple selection
      if (groupSelector) {
        pointer = this._absolutePointer;

        groupSelector.left = pointer.x - groupSelector.ex;
        groupSelector.top = pointer.y - groupSelector.ey;

        this.renderTop();
      }
      else if (!this._currentTransform) {
        target = this.findTarget(e) || null;
        this._setCursorFromEvent(e, target);
        this._fireOverOutEvents(target, e);
      }
      else {
        this._transformObject(e);
      }
      this._handleEvent(e, 'move');
      this._resetTransformEventData();
    },

    /**
     * Manage the mouseout, mouseover events for the fabric object on the canvas
     * @param {Fabric.Object} target the target where the target from the mousemove event
     * @param {Event} e Event object fired on mousemove
     * @private
     */
    _fireOverOutEvents: function(target, e) {
      var _hoveredTarget = this._hoveredTarget,
          _hoveredTargets = this._hoveredTargets, targets = this.targets,
          length = Math.max(_hoveredTargets.length, targets.length);

      this.fireSyntheticInOutEvents(target, e, {
        oldTarget: _hoveredTarget,
        evtOut: 'mouseout',
        canvasEvtOut: 'mouse:out',
        evtIn: 'mouseover',
        canvasEvtIn: 'mouse:over',
      });
      for (var i = 0; i < length; i++){
        this.fireSyntheticInOutEvents(targets[i], e, {
          oldTarget: _hoveredTargets[i],
          evtOut: 'mouseout',
          evtIn: 'mouseover',
        });
      }
      this._hoveredTarget = target;
      this._hoveredTargets = this.targets.concat();
    },

    /**
     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the onDrag event
     * @param {Event} e Event object fired on ondrag
     * @private
     */
    _fireEnterLeaveEvents: function(target, e) {
      var _draggedoverTarget = this._draggedoverTarget,
          _hoveredTargets = this._hoveredTargets, targets = this.targets,
          length = Math.max(_hoveredTargets.length, targets.length);

      this.fireSyntheticInOutEvents(target, e, {
        oldTarget: _draggedoverTarget,
        evtOut: 'dragleave',
        evtIn: 'dragenter',
      });
      for (var i = 0; i < length; i++) {
        this.fireSyntheticInOutEvents(targets[i], e, {
          oldTarget: _hoveredTargets[i],
          evtOut: 'dragleave',
          evtIn: 'dragenter',
        });
      }
      this._draggedoverTarget = target;
    },

    /**
     * Manage the synthetic in/out events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the supported events
     * @param {Event} e Event object fired
     * @param {Object} config configuration for the function to work
     * @param {String} config.targetName property on the canvas where the old target is stored
     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
     * @param {String} config.evtOut name of the event to fire for out
     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
     * @param {String} config.evtIn name of the event to fire for in
     * @private
     */
    fireSyntheticInOutEvents: function(target, e, config) {
      var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires,
          targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
      if (targetChanged) {
        inOpt = { e: e, target: target, previousTarget: oldTarget };
        outOpt = { e: e, target: oldTarget, nextTarget: target };
      }
      inFires = target && targetChanged;
      outFires = oldTarget && targetChanged;
      if (outFires) {
        canvasEvtOut && this.fire(canvasEvtOut, outOpt);
        oldTarget.fire(config.evtOut, outOpt);
      }
      if (inFires) {
        canvasEvtIn && this.fire(canvasEvtIn, inOpt);
        target.fire(config.evtIn, inOpt);
      }
    },

    /**
     * Method that defines actions when an Event Mouse Wheel
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseWheel: function(e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'wheel');
      this._resetTransformEventData();
    },

    /**
     * @private
     * @param {Event} e Event fired on mousemove
     */
    _transformObject: function(e) {
      var pointer = this.getPointer(e),
          transform = this._currentTransform;

      transform.reset = false;
      transform.shiftKey = e.shiftKey;
      transform.altKey = e[this.centeredKey];

      this._performTransformAction(e, transform, pointer);
      transform.actionPerformed && this.requestRenderAll();
    },

    /**
     * @private
     */
    _performTransformAction: function(e, transform, pointer) {
      var x = pointer.x,
          y = pointer.y,
          action = transform.action,
          actionPerformed = false,
          actionHandler = transform.actionHandler;
          // this object could be created from the function in the control handlers


      if (actionHandler) {
        actionPerformed = actionHandler(e, transform, x, y);
      }
      if (action === 'drag' && actionPerformed) {
        transform.target.isMoving = true;
        this.setCursor(transform.target.moveCursor || this.moveCursor);
      }
      transform.actionPerformed = transform.actionPerformed || actionPerformed;
    },

    /**
     * @private
     */
    _fire: fabric.controlsUtils.fireEvent,

    /**
     * Sets the cursor depending on where the canvas is being hovered.
     * Note: very buggy in Opera
     * @param {Event} e Event object
     * @param {Object} target Object that the mouse is hovering, if so.
     */
    _setCursorFromEvent: function (e, target) {
      if (!target) {
        this.setCursor(this.defaultCursor);
        return false;
      }
      var hoverCursor = target.hoverCursor || this.hoverCursor,
          activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
            this._activeObject : null,
          // only show proper corner when group selection is not active
          corner = (!activeSelection || !activeSelection.contains(target))
          // here we call findTargetCorner always with undefined for the touch parameter.
          // we assume that if you are using a cursor you do not need to interact with
          // the bigger touch area.
                    && target._findTargetCorner(this.getPointer(e, true));

      if (!corner) {
        if (target.subTargetCheck){
          // hoverCursor should come from top-most subTarget,
          // so we walk the array backwards
          this.targets.concat().reverse().map(function(_target){
            hoverCursor = _target.hoverCursor || hoverCursor;
          });
        }
        this.setCursor(hoverCursor);
      }
      else {
        this.setCursor(this.getCornerCursor(corner, target, e));
      }
    },

    /**
     * @private
     */
    getCornerCursor: function(corner, target, e) {
      var control = target.controls[corner];
      return control.cursorStyleHandler(e, control, target);
    }
  });
})();
(function() {

  var min = Math.min,
      max = Math.max;

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     * @return {Boolean}
     */
    _shouldGroup: function(e, target) {
      var activeObject = this._activeObject;
      return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
            (activeObject !== target || activeObject.type === 'activeSelection') && !target.onSelect({ e: e });
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _handleGrouping: function (e, target) {
      var activeObject = this._activeObject;
      // avoid multi select when shift click on a corner
      if (activeObject.__corner) {
        return;
      }
      if (target === activeObject) {
        // if it's a group, find target again, using activeGroup objects
        target = this.findTarget(e, true);
        // if even object is not found or we are on activeObjectCorner, bail out
        if (!target || !target.selectable) {
          return;
        }
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        this._updateActiveSelection(target, e);
      }
      else {
        this._createActiveSelection(target, e);
      }
    },

    /**
     * @private
     */
    _updateActiveSelection: function(target, e) {
      var activeSelection = this._activeObject,
          currentActiveObjects = activeSelection._objects.slice(0);
      if (activeSelection.contains(target)) {
        activeSelection.removeWithUpdate(target);
        this._hoveredTarget = target;
        this._hoveredTargets = this.targets.concat();
        if (activeSelection.size() === 1) {
          // activate last remaining object
          this._setActiveObject(activeSelection.item(0), e);
        }
      }
      else {
        activeSelection.addWithUpdate(target);
        this._hoveredTarget = activeSelection;
        this._hoveredTargets = this.targets.concat();
      }
      this._fireSelectionEvents(currentActiveObjects, e);
    },

    /**
     * @private
     */
    _createActiveSelection: function(target, e) {
      var currentActives = this.getActiveObjects(), group = this._createGroup(target);
      this._hoveredTarget = group;
      // ISSUE 4115: should we consider subTargets here?
      // this._hoveredTargets = [];
      // this._hoveredTargets = this.targets.concat();
      this._setActiveObject(group, e);
      this._fireSelectionEvents(currentActives, e);
    },

    /**
     * @private
     * @param {Object} target
     */
    _createGroup: function(target) {
      var objects = this._objects,
          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
          groupObjects = isActiveLower
            ? [this._activeObject, target]
            : [target, this._activeObject];
      this._activeObject.isEditing && this._activeObject.exitEditing();
      return new fabric.ActiveSelection(groupObjects, {
        canvas: this
      });
    },

    /**
     * @private
     * @param {Event} e mouse event
     */
    _groupSelectedObjects: function (e) {

      var group = this._collectObjects(e),
          aGroup;

      // do not create group for 1 element only
      if (group.length === 1) {
        this.setActiveObject(group[0], e);
      }
      else if (group.length > 1) {
        aGroup = new fabric.ActiveSelection(group.reverse(), {
          canvas: this
        });
        this.setActiveObject(aGroup, e);
      }
    },

    /**
     * @private
     */
    _collectObjects: function(e) {
      var group = [],
          currentObject,
          x1 = this._groupSelector.ex,
          y1 = this._groupSelector.ey,
          x2 = x1 + this._groupSelector.left,
          y2 = y1 + this._groupSelector.top,
          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
          allowIntersect = !this.selectionFullyContained,
          isClick = x1 === x2 && y1 === y2;
      // we iterate reverse order to collect top first in case of click.
      for (var i = this._objects.length; i--; ) {
        currentObject = this._objects[i];

        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
          continue;
        }

        if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true)) ||
            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) ||
            (allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true)) ||
            (allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true))
        ) {
          group.push(currentObject);
          // only add one object if it's a click
          if (isClick) {
            break;
          }
        }
      }

      if (group.length > 1) {
        group = group.filter(function(object) {
          return !object.onSelect({ e: e });
        });
      }

      return group;
    },

    /**
     * @private
     */
    _maybeGroupObjects: function(e) {
      if (this.selection && this._groupSelector) {
        this._groupSelectedObjects(e);
      }
      this.setCursor(this.defaultCursor);
      // clear selection and current transformation
      this._groupSelector = null;
    }
  });

})();
(function () {
  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
     * @param {Object} [options] Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
     * @example <caption>Generate jpeg dataURL with lower quality</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'jpeg',
     *   quality: 0.8
     * });
     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   left: 100,
     *   top: 100,
     *   width: 200,
     *   height: 200
     * });
     * @example <caption>Generate double scaled png dataURL</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   multiplier: 2
     * });
     */
    toDataURL: function (options) {
      options || (options = { });

      var format = options.format || 'png',
          quality = options.quality || 1,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1),
          canvasEl = this.toCanvasElement(multiplier, options);
      return fabric.util.toDataURL(canvasEl, format, quality);
    },

    /**
     * Create a new HTMLCanvas element painted with the current canvas content.
     * No need to resize the actual one or repaint it.
     * Will transfer object ownership to a new canvas, paint it, and set everything back.
     * This is an intermediary step used to get to a dataUrl but also it is useful to
     * create quick image copies of a canvas without passing for the dataUrl string
     * @param {Number} [multiplier] a zoom factor.
     * @param {Object} [cropping] Cropping informations
     * @param {Number} [cropping.left] Cropping left offset.
     * @param {Number} [cropping.top] Cropping top offset.
     * @param {Number} [cropping.width] Cropping width.
     * @param {Number} [cropping.height] Cropping height.
     */
    toCanvasElement: function(multiplier, cropping) {
      multiplier = multiplier || 1;
      cropping = cropping || { };
      var scaledWidth = (cropping.width || this.width) * multiplier,
          scaledHeight = (cropping.height || this.height) * multiplier,
          zoom = this.getZoom(),
          originalWidth = this.width,
          originalHeight = this.height,
          newZoom = zoom * multiplier,
          vp = this.viewportTransform,
          translateX = (vp[4] - (cropping.left || 0)) * multiplier,
          translateY = (vp[5] - (cropping.top || 0)) * multiplier,
          originalInteractive = this.interactive,
          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
          originalRetina = this.enableRetinaScaling,
          canvasEl = fabric.util.createCanvasElement(),
          originalContextTop = this.contextTop;
      canvasEl.width = scaledWidth;
      canvasEl.height = scaledHeight;
      this.contextTop = null;
      this.enableRetinaScaling = false;
      this.interactive = false;
      this.viewportTransform = newVp;
      this.width = scaledWidth;
      this.height = scaledHeight;
      this.calcViewportBoundaries();
      this.renderCanvas(canvasEl.getContext('2d'), this._objects);
      this.viewportTransform = vp;
      this.width = originalWidth;
      this.height = originalHeight;
      this.calcViewportBoundaries();
      this.interactive = originalInteractive;
      this.enableRetinaScaling = originalRetina;
      this.contextTop = originalContextTop;
      return canvasEl;
    },
  });

})();
fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
  /**
   * Populates canvas with data from the specified JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
   * @example <caption>loadFromJSON</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
   * @example <caption>loadFromJSON with reviver</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
   *   // `o` = json object
   *   // `object` = fabric.Object instance
   *   // ... do some stuff ...
   * });
   */
  loadFromJSON: function (json, callback, reviver) {
    if (!json) {
      return;
    }

    // serialize if it wasn't already
    var serialized = (typeof json === 'string')
      ? JSON.parse(json)
      : fabric.util.object.clone(json);

    var _this = this,
        clipPath = serialized.clipPath,
        renderOnAddRemove = this.renderOnAddRemove;

    this.renderOnAddRemove = false;

    delete serialized.clipPath;

    this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
      _this.clear();
      _this._setBgOverlay(serialized, function () {
        if (clipPath) {
          _this._enlivenObjects([clipPath], function (enlivenedCanvasClip) {
            _this.clipPath = enlivenedCanvasClip[0];
            _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
          });
        }
        else {
          _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
        }
      });
    }, reviver);
    return this;
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Array} restored canvas objects
   * @param {Function} cached renderOnAddRemove callback
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {
    var _this = this;
    enlivenedObjects.forEach(function(obj, index) {
      // we splice the array just in case some custom classes restored from JSON
      // will add more object to canvas at canvas init.
      _this.insertAt(obj, index);
    });
    this.renderOnAddRemove = renderOnAddRemove;
    // remove parts i cannot set as options
    delete serialized.objects;
    delete serialized.backgroundImage;
    delete serialized.overlayImage;
    delete serialized.background;
    delete serialized.overlay;
    // this._initOptions does too many things to just
    // call it. Normally loading an Object from JSON
    // create the Object instance. Here the Canvas is
    // already an instance and we are just loading things over it
    this._setOptions(serialized);
    this.renderAll();
    callback && callback();
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  _setBgOverlay: function(serialized, callback) {
    var loaded = {
      backgroundColor: false,
      overlayColor: false,
      backgroundImage: false,
      overlayImage: false
    };

    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
      callback && callback();
      return;
    }

    var cbIfLoaded = function () {
      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
        callback && callback();
      }
    };

    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
  },

  /**
   * @private
   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
   * @param {(Object|String)} value Value to set
   * @param {Object} loaded Set loaded property to true if property is set
   * @param {Object} callback Callback function to invoke after property is set
   */
  __setBgOverlay: function(property, value, loaded, callback) {
    var _this = this;

    if (!value) {
      loaded[property] = true;
      callback && callback();
      return;
    }

    if (property === 'backgroundImage' || property === 'overlayImage') {
      fabric.util.enlivenObjects([value], function(enlivedObject){
        _this[property] = enlivedObject[0];
        loaded[property] = true;
        callback && callback();
      });
    }
    else {
      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
        loaded[property] = true;
        callback && callback();
      });
    }
  },

  /**
   * @private
   * @param {Array} objects
   * @param {Function} callback
   * @param {Function} [reviver]
   */
  _enlivenObjects: function (objects, callback, reviver) {
    if (!objects || objects.length === 0) {
      callback && callback([]);
      return;
    }

    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      callback && callback(enlivenedObjects);
    }, null, reviver);
  },

  /**
   * @private
   * @param {String} format
   * @param {Function} callback
   */
  _toDataURL: function (format, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURL(format));
    });
  },

  /**
   * @private
   * @param {String} format
   * @param {Number} multiplier
   * @param {Function} callback
   */
  _toDataURLWithMultiplier: function (format, multiplier, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURLWithMultiplier(format, multiplier));
    });
  },

  /**
   * Clones canvas instance
   * @param {Object} [callback] Receives cloned instance as a first argument
   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
   */
  clone: function (callback, properties) {
    var data = JSON.stringify(this.toJSON(properties));
    this.cloneWithoutData(function(clone) {
      clone.loadFromJSON(data, function() {
        callback && callback(clone);
      });
    });
  },

  /**
   * Clones canvas instance without cloning existing data.
   * This essentially copies canvas dimensions, clipping properties, etc.
   * but leaves data empty (so that you can populate it with your own)
   * @param {Object} [callback] Receives cloned instance as a first argument
   */
  cloneWithoutData: function(callback) {
    var el = fabric.util.createCanvasElement();

    el.width = this.width;
    el.height = this.height;

    var clone = new fabric.Canvas(el);
    if (this.backgroundImage) {
      clone.setBackgroundImage(this.backgroundImage.src, function() {
        clone.renderAll();
        callback && callback(clone);
      });
      clone.backgroundImageOpacity = this.backgroundImageOpacity;
      clone.backgroundImageStretch = this.backgroundImageStretch;
    }
    else {
      callback && callback(clone);
    }
  }
});
/**
 * Adds support for multi-touch gestures using the Event.js library.
 * Fires the following custom events:
 * - touch:gesture
 * - touch:drag
 * - touch:orientation
 * - touch:shake
 * - touch:longpress
 */
(function() {

  var degreesToRadians = fabric.util.degreesToRadians,
      radiansToDegrees = fabric.util.radiansToDegrees;

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
    /**
     * Method that defines actions when an Event.js gesture is detected on an object. Currently only supports
     * 2 finger gestures.
     * @param {Event} e Event object by Event.js
     * @param {Event} self Event proxy object by Event.js
     */
    __onTransformGesture: function(e, self) {

      if (this.isDrawingMode || !e.touches || e.touches.length !== 2 || 'gesture' !== self.gesture) {
        return;
      }

      var target = this.findTarget(e);
      if ('undefined' !== typeof target) {
        this.__gesturesParams = {
          e: e,
          self: self,
          target: target
        };

        this.__gesturesRenderer();
      }

      this.fire('touch:gesture', {
        target: target, e: e, self: self
      });
    },
    __gesturesParams: null,
    __gesturesRenderer: function() {

      if (this.__gesturesParams === null || this._currentTransform === null) {
        return;
      }

      var self = this.__gesturesParams.self,
          t = this._currentTransform,
          e = this.__gesturesParams.e;

      t.action = 'scale';
      t.originX = t.originY = 'center';

      this._scaleObjectBy(self.scale, e);

      if (self.rotation !== 0) {
        t.action = 'rotate';
        this._rotateObjectByAngle(self.rotation, e);
      }

      this.requestRenderAll();

      t.action = 'drag';
    },

    /**
     * Method that defines actions when an Event.js drag is detected.
     *
     * @param {Event} e Event object by Event.js
     * @param {Event} self Event proxy object by Event.js
     */
    __onDrag: function(e, self) {
      this.fire('touch:drag', {
        e: e, self: self
      });
    },

    /**
     * Method that defines actions when an Event.js orientation event is detected.
     *
     * @param {Event} e Event object by Event.js
     * @param {Event} self Event proxy object by Event.js
     */
    __onOrientationChange: function(e, self) {
      this.fire('touch:orientation', {
        e: e, self: self
      });
    },

    /**
     * Method that defines actions when an Event.js shake event is detected.
     *
     * @param {Event} e Event object by Event.js
     * @param {Event} self Event proxy object by Event.js
     */
    __onShake: function(e, self) {
      this.fire('touch:shake', {
        e: e, self: self
      });
    },

    /**
     * Method that defines actions when an Event.js longpress event is detected.
     *
     * @param {Event} e Event object by Event.js
     * @param {Event} self Event proxy object by Event.js
     */
    __onLongPress: function(e, self) {
      this.fire('touch:longpress', {
        e: e, self: self
      });
    },

    /**
     * Scales an object by a factor
     * @param {Number} s The scale factor to apply to the current scale level
     * @param {Event} e Event object by Event.js
     */
    _scaleObjectBy: function(s, e) {
      var t = this._currentTransform,
          target = t.target;
      t.gestureScale = s;
      target._scaling = true;
      return fabric.controlsUtils.scalingEqually(e, t, 0, 0);
    },

    /**
     * Rotates object by an angle
     * @param {Number} curAngle The angle of rotation in degrees
     * @param {Event} e Event object by Event.js
     */
    _rotateObjectByAngle: function(curAngle, e) {
      var t = this._currentTransform;

      if (t.target.get('lockRotation')) {
        return;
      }
      t.target.rotate(radiansToDegrees(degreesToRadians(curAngle) + t.theta));
      this._fire('rotating', {
        target: t.target,
        e: e,
        transform: t,
      });
    }
  });
})();
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      capitalize = fabric.util.string.capitalize,
      degreesToRadians = fabric.util.degreesToRadians,
      objectCaching = !fabric.isLikelyNode,
      ALIASING_LIMIT = 2;

  if (fabric.Object) {
    return;
  }

  /**
   * Root object class from which all 2d shape classes inherit from
   * @class fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
   * @see {@link fabric.Object#initialize} for constructor definition
   *
   * @fires added
   * @fires removed
   *
   * @fires selected
   * @fires deselected
   * @fires modified
   * @fires modified
   * @fires moved
   * @fires scaled
   * @fires rotated
   * @fires skewed
   *
   * @fires rotating
   * @fires scaling
   * @fires moving
   * @fires skewing
   *
   * @fires mousedown
   * @fires mouseup
   * @fires mouseover
   * @fires mouseout
   * @fires mousewheel
   * @fires mousedblclick
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   */
  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

    /**
     * Type of an object (rect, circle, path, etc.).
     * Note that this property is meant to be read-only and not meant to be modified.
     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
     * @type String
     * @default
     */
    type:                     'object',

    /**
     * Horizontal origin of transformation of an object (one of "left", "right", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originX:                  'left',

    /**
     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originY:                  'top',

    /**
     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
     * @type Number
     * @default
     */
    top:                      0,

    /**
     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
     * @type Number
     * @default
     */
    left:                     0,

    /**
     * Object width
     * @type Number
     * @default
     */
    width:                    0,

    /**
     * Object height
     * @type Number
     * @default
     */
    height:                   0,

    /**
     * Object scale factor (horizontal)
     * @type Number
     * @default
     */
    scaleX:                   1,

    /**
     * Object scale factor (vertical)
     * @type Number
     * @default
     */
    scaleY:                   1,

    /**
     * When true, an object is rendered as flipped horizontally
     * @type Boolean
     * @default
     */
    flipX:                    false,

    /**
     * When true, an object is rendered as flipped vertically
     * @type Boolean
     * @default
     */
    flipY:                    false,

    /**
     * Opacity of an object
     * @type Number
     * @default
     */
    opacity:                  1,

    /**
     * Angle of rotation of an object (in degrees)
     * @type Number
     * @default
     */
    angle:                    0,

    /**
     * Angle of skew on x axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewX:                    0,

    /**
     * Angle of skew on y axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewY:                    0,

    /**
     * Size of object's controlling corners (in pixels)
     * @type Number
     * @default
     */
    cornerSize:               13,

    /**
     * Size of object's controlling corners when touch interaction is detected
     * @type Number
     * @default
     */
    touchCornerSize:               24,

    /**
     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
     * @type Boolean
     * @default
     */
    transparentCorners:       true,

    /**
     * Default cursor value used when hovering over this object on canvas
     * @type String
     * @default
     */
    hoverCursor:              null,

    /**
     * Default cursor value used when moving this object on canvas
     * @type String
     * @default
     */
    moveCursor:               null,

    /**
     * Padding between object and its controlling borders (in pixels)
     * @type Number
     * @default
     */
    padding:                  0,

    /**
     * Color of controlling borders of an object (when it's active)
     * @type String
     * @default
     */
    borderColor:              'rgb(178,204,255)',

    /**
     * Array specifying dash pattern of an object's borders (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    borderDashArray:          null,

    /**
     * Color of controlling corners of an object (when it's active)
     * @type String
     * @default
     */
    cornerColor:              'rgb(178,204,255)',

    /**
     * Color of controlling corners of an object (when it's active and transparentCorners false)
     * @since 1.6.2
     * @type String
     * @default
     */
    cornerStrokeColor:        null,

    /**
     * Specify style of control, 'rect' or 'circle'
     * @since 1.6.2
     * @type String
     */
    cornerStyle:          'rect',

    /**
     * Array specifying dash pattern of an object's control (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    cornerDashArray:          null,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being scaled via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:          false,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being rotated via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:         true,

    /**
     * Color of object's fill
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    fill:                     'rgb(0,0,0)',

    /**
     * Fill rule used to fill an object
     * accepted values are nonzero, evenodd
     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
     * @type String
     * @default
     */
    fillRule:                 'nonzero',

    /**
     * Composite rule used for canvas globalCompositeOperation
     * @type String
     * @default
     */
    globalCompositeOperation: 'source-over',

    /**
     * Background color of an object.
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    backgroundColor:          '',

    /**
     * Selection Background color of an object. colored layer behind the object when it is active.
     * does not mix good with globalCompositeOperation methods.
     * @type String
     * @default
     */
    selectionBackgroundColor:          '',

    /**
     * When defined, an object is rendered via stroke and this property specifies its color
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    stroke:                   null,

    /**
     * Width of a stroke used to render this object
     * @type Number
     * @default
     */
    strokeWidth:              1,

    /**
     * Array specifying dash pattern of an object's stroke (stroke must be defined)
     * @type Array
     */
    strokeDashArray:          null,

    /**
     * Line offset of an object's stroke
     * @type Number
     * @default
     */
    strokeDashOffset: 0,

    /**
     * Line endings style of an object's stroke (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap:            'butt',

    /**
     * Corner style of an object's stroke (one of "bevel", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin:           'miter',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
     * @type Number
     * @default
     */
    strokeMiterLimit:         4,

    /**
     * Shadow object representing shadow of this shape
     * @type fabric.Shadow
     * @default
     */
    shadow:                   null,

    /**
     * Opacity of object's controlling borders when object is active and moving
     * @type Number
     * @default
     */
    borderOpacityWhenMoving:  0.4,

    /**
     * Scale factor of object's controlling borders
     * bigger number will make a thicker border
     * border is 1, so this is basically a border thickness
     * since there is no way to change the border itself.
     * @type Number
     * @default
     */
    borderScaleFactor:        1,

    /**
     * Minimum allowed scale value of an object
     * @type Number
     * @default
     */
    minScaleLimit:            0,

    /**
     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
     * But events still fire on it.
     * @type Boolean
     * @default
     */
    selectable:               true,

    /**
     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
     * @type Boolean
     * @default
     */
    evented:                  true,

    /**
     * When set to `false`, an object is not rendered on canvas
     * @type Boolean
     * @default
     */
    visible:                  true,

    /**
     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
     * @type Boolean
     * @default
     */
    hasControls:              true,

    /**
     * When set to `false`, object's controlling borders are not rendered
     * @type Boolean
     * @default
     */
    hasBorders:               true,

    /**
     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:       false,

    /**
     * When `false`, default object's values are not included in its serialization
     * @type Boolean
     * @default
     */
    includeDefaultValues:     true,

    /**
     * When `true`, object horizontal movement is locked
     * @type Boolean
     * @default
     */
    lockMovementX:            false,

    /**
     * When `true`, object vertical movement is locked
     * @type Boolean
     * @default
     */
    lockMovementY:            false,

    /**
     * When `true`, object rotation is locked
     * @type Boolean
     * @default
     */
    lockRotation:             false,

    /**
     * When `true`, object horizontal scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingX:             false,

    /**
     * When `true`, object vertical scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingY:             false,

    /**
     * When `true`, object horizontal skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingX:             false,

    /**
     * When `true`, object vertical skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingY:             false,

    /**
     * When `true`, object cannot be flipped by scaling into negative values
     * @type Boolean
     * @default
     */
    lockScalingFlip:          false,

    /**
     * When `true`, object is not exported in OBJECT/JSON
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    excludeFromExport:        false,

    /**
     * When `true`, object is cached on an additional canvas.
     * When `false`, object is not cached unless necessary ( clipPath )
     * default to true
     * @since 1.7.0
     * @type Boolean
     * @default true
     */
    objectCaching:            objectCaching,

    /**
     * When `true`, object properties are checked for cache invalidation. In some particular
     * situation you may want this to be disabled ( spray brush, very big, groups)
     * or if your application does not allow you to modify properties for groups child you want
     * to disable it for groups.
     * default to false
     * since 1.7.0
     * @type Boolean
     * @default false
     */
    statefullCache:            false,

    /**
     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
     * too much and will be redrawn with correct details at the end of scaling.
     * this setting is performance and application dependant.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    noScaleCache:              true,

    /**
     * When `false`, the stoke width will scale with the object.
     * When `true`, the stroke will always match the exact pixel size entered for stroke width.
     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods
     * default to false
     * @since 2.6.0
     * @type Boolean
     * @default false
     * @type Boolean
     * @default false
     */
    strokeUniform:              false,

    /**
     * When set to `true`, object's cache will be rerendered next render call.
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    dirty:                true,

    /**
     * keeps the value of the last hovered corner during mouse move.
     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
     * It should be private, but there is no harm in using it as
     * a read-only property.
     * @type number|string|any
     * @default 0
     */
    __corner: 0,

    /**
     * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
     * @type String
     * @default
     */
    paintFirst:           'fill',

    /**
     * When 'down', object is set to active on mousedown/touchstart
     * When 'up', object is set to active on mouseup/touchend
     * Experimental. Let's see if this breaks anything before supporting officially
     * @private
     * since 4.4.0
     * @type String
     * @default 'down'
     */
    activeOn:           'down',

    /**
     * List of properties to consider when checking if state
     * of an object is changed (fabric.Object#hasStateChanged)
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: (
      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
      'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
      'angle opacity fill globalCompositeOperation shadow visible backgroundColor ' +
      'skewX skewY fillRule paintFirst clipPath strokeUniform'
    ).split(' '),

    /**
     * List of properties to consider when checking if cache needs refresh
     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
     * and refreshed at the next render
     * @type Array
     */
    cacheProperties: (
      'fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform' +
      ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
    ).split(' '),

    /**
     * List of properties to consider for animating colors.
     * @type Array
     */
    colorProperties: (
      'fill stroke backgroundColor'
    ).split(' '),

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the object has rendered, and the context is placed in the center
     * of the object cacheCanvas.
     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will make the object clip to the outside of the clipPath
     * since 2.4.0
     * @type boolean
     * @default false
     */
    inverted: false,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will have its top and left relative to canvas, and will
     * not be influenced by the object transform. This will make the clipPath relative
     * to the canvas, but clipping just a particular object.
     * WARNING this is beta, this feature may change or be renamed.
     * since 2.4.0
     * @type boolean
     * @default false
     */
    absolutePositioned: false,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Create a the canvas used to keep the cached copy of the object
     * @private
     */
    _createCacheCanvas: function() {
      this._cacheProperties = {};
      this._cacheCanvas = fabric.util.createCanvasElement();
      this._cacheContext = this._cacheCanvas.getContext('2d');
      this._updateCacheCanvas();
      // if canvas gets created, is empty, so dirty.
      this.dirty = true;
    },

    /**
     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
     * and each side do not cross fabric.cacheSideLimit
     * those numbers are configurable so that you can get as much detail as you want
     * making bargain with performances.
     * @param {Object} dims
     * @param {Object} dims.width width of canvas
     * @param {Object} dims.height height of canvas
     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _limitCacheSize: function(dims) {
      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
          width = dims.width, height = dims.height,
          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
      if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
        if (width < min) {
          dims.width = min;
        }
        if (height < min) {
          dims.height = min;
        }
        return dims;
      }
      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
          capValue = fabric.util.capValue,
          x = capValue(min, limitedDims.x, max),
          y = capValue(min, limitedDims.y, max);
      if (width > x) {
        dims.zoomX /= width / x;
        dims.width = x;
        dims.capped = true;
      }
      if (height > y) {
        dims.zoomY /= height / y;
        dims.height = y;
        dims.capped = true;
      }
      return dims;
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @return {Object}.x width of object to be cached
     * @return {Object}.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var objectScale = this.getTotalObjectScaling(),
          // caculate dimensions without skewing
          dim = this._getTransformedDimensions(0, 0),
          neededX = dim.x * objectScale.scaleX / this.scaleX,
          neededY = dim.y * objectScale.scaleY / this.scaleY;
      return {
        // for sure this ALIASING_LIMIT is slightly creating problem
        // in situation in which the cache canvas gets an upper limit
        // also objectScale contains already scaleX and scaleY
        width: neededX + ALIASING_LIMIT,
        height: neededY + ALIASING_LIMIT,
        zoomX: objectScale.scaleX,
        zoomY: objectScale.scaleY,
        x: neededX,
        y: neededY
      };
    },

    /**
     * Update width and height of the canvas for cache
     * returns true or false if canvas needed resize.
     * @private
     * @return {Boolean} true if the canvas has been resized
     */
    _updateCacheCanvas: function() {
      var targetCanvas = this.canvas;
      if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
        var target = targetCanvas._currentTransform.target,
            action = targetCanvas._currentTransform.action;
        if (this === target && action.slice && action.slice(0, 5) === 'scale') {
          return false;
        }
      }
      var canvas = this._cacheCanvas,
          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          minCacheSize = fabric.minCacheSideLimit,
          width = dims.width, height = dims.height, drawingWidth, drawingHeight,
          zoomX = dims.zoomX, zoomY = dims.zoomY,
          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
          shouldRedraw = dimensionsChanged || zoomChanged,
          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
      if (dimensionsChanged) {
        var canvasWidth = this._cacheCanvas.width,
            canvasHeight = this._cacheCanvas.height,
            sizeGrowing = width > canvasWidth || height > canvasHeight,
            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
        shouldResizeCanvas = sizeGrowing || sizeShrinking;
        if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
          additionalWidth = width * 0.1;
          additionalHeight = height * 0.1;
        }
      }
      if (this instanceof fabric.Text && this.path) {
        shouldRedraw = true;
        shouldResizeCanvas = true;
        additionalWidth += this.getHeightOfLine(0) * this.zoomX;
        additionalHeight += this.getHeightOfLine(0) * this.zoomY;
      }
      if (shouldRedraw) {
        if (shouldResizeCanvas) {
          canvas.width = Math.ceil(width + additionalWidth);
          canvas.height = Math.ceil(height + additionalHeight);
        }
        else {
          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
        }
        drawingWidth = dims.x / 2;
        drawingHeight = dims.y / 2;
        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
        this.cacheWidth = width;
        this.cacheHeight = height;
        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
        this._cacheContext.scale(zoomX, zoomY);
        this.zoomX = zoomX;
        this.zoomY = zoomY;
        return true;
      }
      return false;
    },

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      this._setOptions(options);
      this._initGradient(options.fill, 'fill');
      this._initGradient(options.stroke, 'stroke');
      this._initPattern(options.fill, 'fill');
      this._initPattern(options.stroke, 'stroke');
    },

    /**
     * Transforms context when rendering an object
     * @param {CanvasRenderingContext2D} ctx Context
     */
    transform: function(ctx) {
      var needFullTransform = (this.group && !this.group._transformDone) ||
         (this.group && this.canvas && ctx === this.canvas.contextTop);
      var m = this.calcTransformMatrix(!needFullTransform);
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    },

    /**
     * Returns an object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

          object = {
            type:                     this.type,
            version:                  fabric.version,
            originX:                  this.originX,
            originY:                  this.originY,
            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
            strokeLineCap:            this.strokeLineCap,
            strokeDashOffset:         this.strokeDashOffset,
            strokeLineJoin:           this.strokeLineJoin,
            strokeUniform:            this.strokeUniform,
            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
            flipX:                    this.flipX,
            flipY:                    this.flipY,
            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
            visible:                  this.visible,
            backgroundColor:          this.backgroundColor,
            fillRule:                 this.fillRule,
            paintFirst:               this.paintFirst,
            globalCompositeOperation: this.globalCompositeOperation,
            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
          };

      if (this.clipPath && !this.clipPath.excludeFromExport) {
        object.clipPath = this.clipPath.toObject(propertiesToInclude);
        object.clipPath.inverted = this.clipPath.inverted;
        object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
      }

      fabric.util.populateWithProperties(this, object, propertiesToInclude);
      if (!this.includeDefaultValues) {
        object = this._removeDefaultValues(object);
      }

      return object;
    },

    /**
     * Returns (dataless) object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      // will be overwritten by subclasses
      return this.toObject(propertiesToInclude);
    },

    /**
     * @private
     * @param {Object} object
     */
    _removeDefaultValues: function(object) {
      var prototype = fabric.util.getKlass(object.type).prototype,
          stateProperties = prototype.stateProperties;
      stateProperties.forEach(function(prop) {
        if (prop === 'left' || prop === 'top') {
          return;
        }
        if (object[prop] === prototype[prop]) {
          delete object[prop];
        }
        // basically a check for [] === []
        if (Array.isArray(object[prop]) && Array.isArray(prototype[prop])
          && object[prop].length === 0 && prototype[prop].length === 0) {
          delete object[prop];
        }
      });

      return object;
    },

    /**
     * Returns a string representation of an instance
     * @return {String}
     */
    toString: function() {
      return '#<fabric.' + capitalize(this.type) + '>';
    },

    /**
     * Return the object scale factor counting also the group scaling
     * @return {Object} object with scaleX and scaleY properties
     */
    getObjectScaling: function() {
      // if the object is a top level one, on the canvas, we go for simple aritmetic
      // otherwise the complex method with angles will return approximations and decimals
      // and will likely kill the cache when not needed
      // https://github.com/fabricjs/fabric.js/issues/7157
      if (!this.group) {
        return {
          scaleX: this.scaleX,
          scaleY: this.scaleY,
        };
      }
      // if we are inside a group total zoom calculation is complex, we defer to generic matrices
      var options = fabric.util.qrDecompose(this.calcTransformMatrix());
      return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
    },

    /**
     * Return the object scale factor counting also the group scaling, zoom and retina
     * @return {Object} object with scaleX and scaleY properties
     */
    getTotalObjectScaling: function() {
      var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
      if (this.canvas) {
        var zoom = this.canvas.getZoom();
        var retina = this.canvas.getRetinaScaling();
        scaleX *= zoom * retina;
        scaleY *= zoom * retina;
      }
      return { scaleX: scaleX, scaleY: scaleY };
    },

    /**
     * Return the object opacity counting also the group property
     * @return {Number}
     */
    getObjectOpacity: function() {
      var opacity = this.opacity;
      if (this.group) {
        opacity *= this.group.getObjectOpacity();
      }
      return opacity;
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Object} thisArg
     */
    _set: function(key, value) {
      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
          isChanged = this[key] !== value, groupNeedsUpdate = false;

      if (shouldConstrainValue) {
        value = this._constrainScale(value);
      }
      if (key === 'scaleX' && value < 0) {
        this.flipX = !this.flipX;
        value *= -1;
      }
      else if (key === 'scaleY' && value < 0) {
        this.flipY = !this.flipY;
        value *= -1;
      }
      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
        value = new fabric.Shadow(value);
      }
      else if (key === 'dirty' && this.group) {
        this.group.set('dirty', value);
      }

      this[key] = value;

      if (isChanged) {
        groupNeedsUpdate = this.group && this.group.isOnACache();
        if (this.cacheProperties.indexOf(key) > -1) {
          this.dirty = true;
          groupNeedsUpdate && this.group.set('dirty', true);
        }
        else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
          this.group.set('dirty', true);
        }
      }
      return this;
    },

    /**
     * This callback function is called by the parent group of an object every
     * time a non-delegated property changes on the group. It is passed the key
     * and value as parameters. Not adding in this function's signature to avoid
     * Travis build error about unused variables.
     */
    setOnGroup: function() {
      // implemented by sub-classes, as needed.
    },

    /**
     * Retrieves viewportTransform from Object's canvas if possible
     * @method getViewportTransform
     * @memberOf fabric.Object.prototype
     * @return {Array}
     */
    getViewportTransform: function() {
      if (this.canvas && this.canvas.viewportTransform) {
        return this.canvas.viewportTransform;
      }
      return fabric.iMatrix.concat();
    },

    /*
     * @private
     * return if the object would be visible in rendering
     * @memberOf fabric.Object.prototype
     * @return {Boolean}
     */
    isNotVisible: function() {
      return this.opacity === 0 ||
        (!this.width && !this.height && this.strokeWidth === 0) ||
        !this.visible;
    },

    /**
     * Renders an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if width/height are zeros or object is not visible
      if (this.isNotVisible()) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      ctx.save();
      this._setupCompositeOperation(ctx);
      this.drawSelectionBackground(ctx);
      this.transform(ctx);
      this._setOpacity(ctx);
      this._setShadow(ctx, this);
      if (this.shouldCache()) {
        this.renderCache();
        this.drawCacheOnCanvas(ctx);
      }
      else {
        this._removeCacheCanvas();
        this.dirty = false;
        this.drawObject(ctx);
        if (this.objectCaching && this.statefullCache) {
          this.saveState({ propertySet: 'cacheProperties' });
        }
      }
      ctx.restore();
    },

    renderCache: function(options) {
      options = options || {};
      if (!this._cacheCanvas || !this._cacheContext) {
        this._createCacheCanvas();
      }
      if (this.isCacheDirty()) {
        this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
        this.drawObject(this._cacheContext, options.forClipping);
        this.dirty = false;
      }
    },

    /**
     * Remove cacheCanvas and its dimensions from the objects
     */
    _removeCacheCanvas: function() {
      this._cacheCanvas = null;
      this._cacheContext = null;
      this.cacheWidth = 0;
      this.cacheHeight = 0;
    },

    /**
     * return true if the object will draw a stroke
     * Does not consider text styles. This is just a shortcut used at rendering time
     * We want it to be an approximation and be fast.
     * wrote to avoid extra caching, it has to return true when stroke happens,
     * can guess when it will not happen at 100% chance, does not matter if it misses
     * some use case where the stroke is invisible.
     * @since 3.0.0
     * @returns Boolean
     */
    hasStroke: function() {
      return this.stroke && this.stroke !== 'transparent' && this.strokeWidth !== 0;
    },

    /**
     * return true if the object will draw a fill
     * Does not consider text styles. This is just a shortcut used at rendering time
     * We want it to be an approximation and be fast.
     * wrote to avoid extra caching, it has to return true when fill happens,
     * can guess when it will not happen at 100% chance, does not matter if it misses
     * some use case where the fill is invisible.
     * @since 3.0.0
     * @returns Boolean
     */
    hasFill: function() {
      return this.fill && this.fill !== 'transparent';
    },

    /**
     * When set to `true`, force the object to have its own cache, even if it is inside a group
     * it may be needed when your object behave in a particular way on the cache and always needs
     * its own isolated canvas to render correctly.
     * Created to be overridden
     * since 1.7.12
     * @returns Boolean
     */
    needsItsOwnCache: function() {
      if (this.paintFirst === 'stroke' &&
        this.hasFill() && this.hasStroke() && typeof this.shadow === 'object') {
        return true;
      }
      if (this.clipPath) {
        return true;
      }
      return false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
     * @return {Boolean}
     */
    shouldCache: function() {
      this.ownCaching = this.needsItsOwnCache() || (
        this.objectCaching &&
        (!this.group || !this.group.isOnACache())
      );
      return this.ownCaching;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * used by Group.shouldCache to know if child has a shadow recursively
     * @return {Boolean}
     */
    willDrawShadow: function() {
      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
    },

    /**
     * Execute the drawing operation for an object clipPath
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {fabric.Object} clipPath
     */
    drawClipPathOnCache: function(ctx, clipPath) {
      ctx.save();
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4
      if (clipPath.inverted) {
        ctx.globalCompositeOperation = 'destination-out';
      }
      else {
        ctx.globalCompositeOperation = 'destination-in';
      }
      //ctx.scale(1 / 2, 1 / 2);
      if (clipPath.absolutePositioned) {
        var m = fabric.util.invertTransform(this.calcTransformMatrix());
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }
      clipPath.transform(ctx);
      ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);
      ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);
      ctx.restore();
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx, forClipping) {
      var originalFill = this.fill, originalStroke = this.stroke;
      if (forClipping) {
        this.fill = 'black';
        this.stroke = '';
        this._setClippingProperties(ctx);
      }
      else {
        this._renderBackground(ctx);
      }
      this._render(ctx);
      this._drawClipPath(ctx, this.clipPath);
      this.fill = originalFill;
      this.stroke = originalStroke;
    },

    /**
     * Prepare clipPath state and cache and draw it on instance's cache
     * @param {CanvasRenderingContext2D} ctx
     * @param {fabric.Object} clipPath
     */
    _drawClipPath: function (ctx, clipPath) {
      if (!clipPath) { return; }
      // needed to setup a couple of variables
      // path canvas gets overridden with this one.
      // TODO find a better solution?
      clipPath.canvas = this.canvas;
      clipPath.shouldCache();
      clipPath._transformDone = true;
      clipPath.renderCache({ forClipping: true });
      this.drawClipPathOnCache(ctx, clipPath);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    },

    /**
     * Check if cache is dirty
     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
     * on parent canvas.
     */
    isCacheDirty: function(skipCanvas) {
      if (this.isNotVisible()) {
        return false;
      }
      if (this._cacheCanvas && this._cacheContext && !skipCanvas && this._updateCacheCanvas()) {
        // in this case the context is already cleared.
        return true;
      }
      else {
        if (this.dirty ||
          (this.clipPath && this.clipPath.absolutePositioned) ||
          (this.statefullCache && this.hasStateChanged('cacheProperties'))
        ) {
          if (this._cacheCanvas && this._cacheContext && !skipCanvas) {
            var width = this.cacheWidth / this.zoomX;
            var height = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Draws a background for the object big as its untransformed dimensions
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      if (!this.backgroundColor) {
        return;
      }
      var dim = this._getNonTransformedDimensions();
      ctx.fillStyle = this.backgroundColor;

      ctx.fillRect(
        -dim.x / 2,
        -dim.y / 2,
        dim.x,
        dim.y
      );
      // if there is background color no other shadows
      // should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setOpacity: function(ctx) {
      if (this.group && !this.group._transformDone) {
        ctx.globalAlpha = this.getObjectOpacity();
      }
      else {
        ctx.globalAlpha *= this.opacity;
      }
    },

    _setStrokeStyles: function(ctx, decl) {
      var stroke = decl.stroke;
      if (stroke) {
        ctx.lineWidth = decl.strokeWidth;
        ctx.lineCap = decl.strokeLineCap;
        ctx.lineDashOffset = decl.strokeDashOffset;
        ctx.lineJoin = decl.strokeLineJoin;
        ctx.miterLimit = decl.strokeMiterLimit;
        if (stroke.toLive) {
          if (stroke.gradientUnits === 'percentage' || stroke.gradientTransform || stroke.patternTransform) {
            // need to transform gradient in a pattern.
            // this is a slow process. If you are hitting this codepath, and the object
            // is not using caching, you should consider switching it on.
            // we need a canvas as big as the current object caching canvas.
            this._applyPatternForTransformedGradient(ctx, stroke);
          }
          else {
            // is a simple gradient or pattern
            ctx.strokeStyle = stroke.toLive(ctx, this);
            this._applyPatternGradientTransform(ctx, stroke);
          }
        }
        else {
          // is a color
          ctx.strokeStyle = decl.stroke;
        }
      }
    },

    _setFillStyles: function(ctx, decl) {
      var fill = decl.fill;
      if (fill) {
        if (fill.toLive) {
          ctx.fillStyle = fill.toLive(ctx, this);
          this._applyPatternGradientTransform(ctx, decl.fill);
        }
        else {
          ctx.fillStyle = fill;
        }
      }
    },

    _setClippingProperties: function(ctx) {
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'transparent';
      ctx.fillStyle = '#000000';
    },

    /**
     * @private
     * Sets line dash
     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
     * @param {Array} dashArray array representing dashes
     */
    _setLineDash: function(ctx, dashArray) {
      if (!dashArray || dashArray.length === 0) {
        return;
      }
      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
      if (1 & dashArray.length) {
        dashArray.push.apply(dashArray, dashArray);
      }
      ctx.setLineDash(dashArray);
    },

    /**
     * Renders controls and borders for the object
     * the context here is not transformed
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     */
    _renderControls: function(ctx, styleOverride) {
      var vpt = this.getViewportTransform(),
          matrix = this.calcTransformMatrix(),
          options, drawBorders, drawControls;
      styleOverride = styleOverride || { };
      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
      options = fabric.util.qrDecompose(matrix);
      ctx.save();
      ctx.translate(options.translateX, options.translateY);
      ctx.lineWidth = 1 * this.borderScaleFactor;
      if (!this.group) {
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      }
      if (this.flipX) {
        options.angle -= 180;
      }
      ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));
      if (styleOverride.forActiveSelection || this.group) {
        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
      }
      else {
        drawBorders && this.drawBorders(ctx, styleOverride);
      }
      drawControls && this.drawControls(ctx, styleOverride);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      var shadow = this.shadow, canvas = this.canvas, scaling,
          multX = (canvas && canvas.viewportTransform[0]) || 1,
          multY = (canvas && canvas.viewportTransform[3]) || 1;
      if (shadow.nonScaling) {
        scaling = { scaleX: 1, scaleY: 1 };
      }
      else {
        scaling = this.getObjectScaling();
      }
      if (canvas && canvas._isRetinaScaling()) {
        multX *= fabric.devicePixelRatio;
        multY *= fabric.devicePixelRatio;
      }
      ctx.shadowColor = shadow.color;
      ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
      ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
      ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _removeShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} filler fabric.Pattern or fabric.Gradient
     * @return {Object} offset.offsetX offset for text rendering
     * @return {Object} offset.offsetY offset for text rendering
     */
    _applyPatternGradientTransform: function(ctx, filler) {
      if (!filler || !filler.toLive) {
        return { offsetX: 0, offsetY: 0 };
      }
      var t = filler.gradientTransform || filler.patternTransform;
      var offsetX = -this.width / 2 + filler.offsetX || 0,
          offsetY = -this.height / 2 + filler.offsetY || 0;

      if (filler.gradientUnits === 'percentage') {
        ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
      }
      else {
        ctx.transform(1, 0, 0, 1, offsetX, offsetY);
      }
      if (t) {
        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
      }
      return { offsetX: offsetX, offsetY: offsetY };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderPaintInOrder: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderStroke(ctx);
        this._renderFill(ctx);
      }
      else {
        this._renderFill(ctx);
        this._renderStroke(ctx);
      }
    },

    /**
     * @private
     * function that actually render something on the context.
     * empty here to allow Obects to work on tests to benchmark fabric functionalites
     * not related to rendering
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(/* ctx */) {

    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderFill: function(ctx) {
      if (!this.fill) {
        return;
      }

      ctx.save();
      this._setFillStyles(ctx, this);
      if (this.fillRule === 'evenodd') {
        ctx.fill('evenodd');
      }
      else {
        ctx.fill();
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderStroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      if (this.strokeUniform && this.group) {
        var scaling = this.getObjectScaling();
        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
      }
      else if (this.strokeUniform) {
        ctx.scale(1 / this.scaleX, 1 / this.scaleY);
      }
      this._setLineDash(ctx, this.strokeDashArray);
      this._setStrokeStyles(ctx, this);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * This function try to patch the missing gradientTransform on canvas gradients.
     * transforming a context to transform the gradient, is going to transform the stroke too.
     * we want to transform the gradient but not the stroke operation, so we create
     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
     * is limited.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {fabric.Gradient} filler a fabric gradient instance
     */
    _applyPatternForTransformedGradient: function(ctx, filler) {
      var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(),
          width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx = pCanvas.getContext('2d');
      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
      pCtx.lineTo(0, height); pCtx.closePath();
      pCtx.translate(width / 2, height / 2);
      pCtx.scale(
        dims.zoomX / this.scaleX / retinaScaling,
        dims.zoomY / this.scaleY / retinaScaling
      );
      this._applyPatternGradientTransform(pCtx, filler);
      pCtx.fillStyle = filler.toLive(ctx);
      pCtx.fill();
      ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
      ctx.scale(
        retinaScaling * this.scaleX / dims.zoomX,
        retinaScaling * this.scaleY / dims.zoomY
      );
      ctx.strokeStyle = pCtx.createPattern(pCanvas, 'no-repeat');
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
    },

    /**
     * This function is an helper for svg import. it decompose the transformMatrix
     * and assign properties to object.
     * untransformed coordinates
     * @private
     * @chainable
     */
    _assignTransformMatrixProps: function() {
      if (this.transformMatrix) {
        var options = fabric.util.qrDecompose(this.transformMatrix);
        this.flipX = false;
        this.flipY = false;
        this.set('scaleX', options.scaleX);
        this.set('scaleY', options.scaleY);
        this.angle = options.angle;
        this.skewX = options.skewX;
        this.skewY = 0;
      }
    },

    /**
     * This function is an helper for svg import. it removes the transform matrix
     * and set to object properties that fabricjs can handle
     * @private
     * @param {Object} preserveAspectRatioOptions
     * @return {thisArg}
     */
    _removeTransformMatrix: function(preserveAspectRatioOptions) {
      var center = this._findCenterFromElement();
      if (this.transformMatrix) {
        this._assignTransformMatrixProps();
        center = fabric.util.transformPoint(center, this.transformMatrix);
      }
      this.transformMatrix = null;
      if (preserveAspectRatioOptions) {
        this.scaleX *= preserveAspectRatioOptions.scaleX;
        this.scaleY *= preserveAspectRatioOptions.scaleY;
        this.cropX = preserveAspectRatioOptions.cropX;
        this.cropY = preserveAspectRatioOptions.cropY;
        center.x += preserveAspectRatioOptions.offsetLeft;
        center.y += preserveAspectRatioOptions.offsetTop;
        this.width = preserveAspectRatioOptions.width;
        this.height = preserveAspectRatioOptions.height;
      }
      this.setPositionByOrigin(center, 'center', 'center');
    },

    /**
     * Clones an instance, using a callback method will work for every object.
     * @param {Function} callback Callback is invoked with a clone as a first argument
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     */
    clone: function(callback, propertiesToInclude) {
      var objectForm = this.toObject(propertiesToInclude);
      if (this.constructor.fromObject) {
        this.constructor.fromObject(objectForm, callback);
      }
      else {
        fabric.Object._fromObject('Object', objectForm, callback);
      }
    },

    /**
     * Creates an instance of fabric.Image out of an object
     * makes use of toCanvasElement.
     * Once this method was based on toDataUrl and loadImage, so it also had a quality
     * and format option. toCanvasElement is faster and produce no loss of quality.
     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
     * toCanvasElement and then toBlob from the obtained canvas is also a good option.
     * This method is sync now, but still support the callback because we did not want to break.
     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
     * @param {Function} callback callback, invoked with an instance as a first argument
     * @param {Object} [options] for clone as image, passed to toDataURL
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {fabric.Object} thisArg
     */
    cloneAsImage: function(callback, options) {
      var canvasEl = this.toCanvasElement(options);
      if (callback) {
        callback(new fabric.Image(canvasEl));
      }
      return this;
    },

    /**
     * Converts an object into a HTMLCanvas element
     * @param {Object} options Options object
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
     */
    toCanvasElement: function(options) {
      options || (options = { });

      var utils = fabric.util, origParams = utils.saveObjectTransform(this),
          originalGroup = this.group,
          originalShadow = this.shadow, abs = Math.abs,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);
      delete this.group;
      if (options.withoutTransform) {
        utils.resetObjectTransform(this);
      }
      if (options.withoutShadow) {
        this.shadow = null;
      }

      var el = fabric.util.createCanvasElement(),
          // skip canvas zoom and calculate with setCoords now.
          boundingRect = this.getBoundingRect(true, true),
          shadow = this.shadow, scaling,
          shadowOffset = { x: 0, y: 0 }, shadowBlur,
          width, height;

      if (shadow) {
        shadowBlur = shadow.blur;
        if (shadow.nonScaling) {
          scaling = { scaleX: 1, scaleY: 1 };
        }
        else {
          scaling = this.getObjectScaling();
        }
        // consider non scaling shadow.
        shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * (abs(scaling.scaleX));
        shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * (abs(scaling.scaleY));
      }
      width = boundingRect.width + shadowOffset.x;
      height = boundingRect.height + shadowOffset.y;
      // if the current width/height is not an integer
      // we need to make it so.
      el.width = Math.ceil(width);
      el.height = Math.ceil(height);
      var canvas = new fabric.StaticCanvas(el, {
        enableRetinaScaling: false,
        renderOnAddRemove: false,
        skipOffscreen: false,
      });
      if (options.format === 'jpeg') {
        canvas.backgroundColor = '#fff';
      }
      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

      var originalCanvas = this.canvas;
      canvas.add(this);
      var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
      this.shadow = originalShadow;
      this.set('canvas', originalCanvas);
      if (originalGroup) {
        this.group = originalGroup;
      }
      this.set(origParams).setCoords();
      // canvas.dispose will call image.dispose that will nullify the elements
      // since this canvas is a simple element for the process, we remove references
      // to objects in this way in order to avoid object trashing.
      canvas._objects = [];
      canvas.dispose();
      canvas = null;

      return canvasEl;
    },

    /**
     * Converts an object into a data-url-like string
     * @param {Object} options Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     */
    toDataURL: function(options) {
      options || (options = { });
      return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
    },

    /**
     * Returns true if specified type is identical to the type of an instance
     * @param {String} type Type to check against
     * @return {Boolean}
     */
    isType: function(type) {
      return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === type;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance (is 1 unless subclassed)
     */
    complexity: function() {
      return 1;
    },

    /**
     * Returns a JSON representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} JSON
     */
    toJSON: function(propertiesToInclude) {
      // delegate, not alias
      return this.toObject(propertiesToInclude);
    },

    /**
     * Sets "angle" of an instance with centered rotation
     * @param {Number} angle Angle value (in degrees)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    rotate: function(angle) {
      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

      if (shouldCenterOrigin) {
        this._setOriginToCenter();
      }

      this.set('angle', angle);

      if (shouldCenterOrigin) {
        this._resetOrigin();
      }

      return this;
    },

    /**
     * Centers object horizontally on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerH: function () {
      this.canvas && this.canvas.centerObjectH(this);
      return this;
    },

    /**
     * Centers object horizontally on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterH: function () {
      this.canvas && this.canvas.viewportCenterObjectH(this);
      return this;
    },

    /**
     * Centers object vertically on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerV: function () {
      this.canvas && this.canvas.centerObjectV(this);
      return this;
    },

    /**
     * Centers object vertically on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterV: function () {
      this.canvas && this.canvas.viewportCenterObjectV(this);
      return this;
    },

    /**
     * Centers object vertically and horizontally on canvas to which is was added last
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    center: function () {
      this.canvas && this.canvas.centerObject(this);
      return this;
    },

    /**
     * Centers object on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenter: function () {
      this.canvas && this.canvas.viewportCenterObject(this);
      return this;
    },

    /**
     * Returns coordinates of a pointer relative to an object
     * @param {Event} e Event to operate upon
     * @param {Object} [pointer] Pointer to operate upon (instead of event)
     * @return {Object} Coordinates of a pointer (x, y)
     */
    getLocalPointer: function(e, pointer) {
      pointer = pointer || this.canvas.getPointer(e);
      var pClicked = new fabric.Point(pointer.x, pointer.y),
          objectLeftTop = this._getLeftTopCoords();
      if (this.angle) {
        pClicked = fabric.util.rotatePoint(
          pClicked, objectLeftTop, degreesToRadians(-this.angle));
      }
      return {
        x: pClicked.x - objectLeftTop.x,
        y: pClicked.y - objectLeftTop.y
      };
    },

    /**
     * Sets canvas globalCompositeOperation for specific object
     * custom composition operation for the particular object can be specified using globalCompositeOperation property
     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
     */
    _setupCompositeOperation: function (ctx) {
      if (this.globalCompositeOperation) {
        ctx.globalCompositeOperation = this.globalCompositeOperation;
      }
    },

    /**
     * cancel instance's running animations
     * override if necessary to dispose artifacts such as `clipPath`
     */
    dispose: function () {
      if (fabric.runningAnimations) {
        fabric.runningAnimations.cancelByTarget(this);
      }
    }
  });

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

  extend(fabric.Object.prototype, fabric.Observable);

  /**
   * Defines the number of fraction digits to use when serializing object values.
   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
   * @static
   * @memberOf fabric.Object
   * @constant
   * @type Number
   */
  fabric.Object.NUM_FRACTION_DIGITS = 2;

  /**
   * Defines which properties should be enlivened from the object passed to {@link fabric.Object._fromObject}
   * @static
   * @memberOf fabric.Object
   * @constant
   * @type string[]
   */
  fabric.Object.ENLIVEN_PROPS = ['clipPath'];

  fabric.Object._fromObject = function(className, object, callback, extraParam) {
    var klass = fabric[className];
    object = clone(object, true);
    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
      if (typeof patterns[0] !== 'undefined') {
        object.fill = patterns[0];
      }
      if (typeof patterns[1] !== 'undefined') {
        object.stroke = patterns[1];
      }
      fabric.util.enlivenObjectEnlivables(object, object, function () {
        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
        callback && callback(instance);
      });
    });
  };

  /**
   * Unique id used internally when creating SVG elements
   * @static
   * @memberOf fabric.Object
   * @type Number
   */
  fabric.Object.__uid = 0;
})(typeof exports !== 'undefined' ? exports : this);
(function() {

  var degreesToRadians = fabric.util.degreesToRadians,
      originXOffset = {
        left: -0.5,
        center: 0,
        right: 0.5
      },
      originYOffset = {
        top: -0.5,
        center: 0,
        bottom: 0.5
      };

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
      var x = point.x,
          y = point.y,
          offsetX, offsetY, dim;

      if (typeof fromOriginX === 'string') {
        fromOriginX = originXOffset[fromOriginX];
      }
      else {
        fromOriginX -= 0.5;
      }

      if (typeof toOriginX === 'string') {
        toOriginX = originXOffset[toOriginX];
      }
      else {
        toOriginX -= 0.5;
      }

      offsetX = toOriginX - fromOriginX;

      if (typeof fromOriginY === 'string') {
        fromOriginY = originYOffset[fromOriginY];
      }
      else {
        fromOriginY -= 0.5;
      }

      if (typeof toOriginY === 'string') {
        toOriginY = originYOffset[toOriginY];
      }
      else {
        toOriginY -= 0.5;
      }

      offsetY = toOriginY - fromOriginY;

      if (offsetX || offsetY) {
        dim = this._getTransformedDimensions();
        x = point.x + offsetX * dim.x;
        y = point.y + offsetY * dim.y;
      }

      return new fabric.Point(x, y);
    },

    /**
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToCenterPoint: function(point, originX, originY) {
      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
      if (this.angle) {
        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
     * @param {fabric.Point} center The point which corresponds to center of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToOriginPoint: function(center, originX, originY) {
      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      if (this.angle) {
        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Returns the real center coordinates of the object
     * @return {fabric.Point}
     */
    getCenterPoint: function() {
      var leftTop = new fabric.Point(this.left, this.top);
      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
    },

    /**
     * Returns the coordinates of the object based on center coordinates
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @return {fabric.Point}
     */
    // getOriginPoint: function(center) {
    //   return this.translateToOriginPoint(center, this.originX, this.originY);
    // },

    /**
     * Returns the coordinates of the object as if it has a different origin
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    getPointByOrigin: function(originX, originY) {
      var center = this.getCenterPoint();
      return this.translateToOriginPoint(center, originX, originY);
    },

    /**
     * Returns the point in local coordinates
     * @param {fabric.Point} point The point relative to the global coordinate system
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    toLocalPoint: function(point, originX, originY) {
      var center = this.getCenterPoint(),
          p, p2;

      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      }
      else {
        p = new fabric.Point(this.left, this.top);
      }

      p2 = new fabric.Point(point.x, point.y);
      if (this.angle) {
        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
      }
      return p2.subtractEquals(p);
    },

    /**
     * Returns the point in global coordinates
     * @param {fabric.Point} The point relative to the local coordinate system
     * @return {fabric.Point}
     */
    // toGlobalPoint: function(point) {
    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
    // },

    /**
     * Sets the position of the object taking into consideration the object's origin
     * @param {fabric.Point} pos The new position of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {void}
     */
    setPositionByOrigin: function(pos, originX, originY) {
      var center = this.translateToCenterPoint(pos, originX, originY),
          position = this.translateToOriginPoint(center, this.originX, this.originY);
      this.set('left', position.x);
      this.set('top', position.y);
    },

    /**
     * @param {String} to One of 'left', 'center', 'right'
     */
    adjustPosition: function(to) {
      var angle = degreesToRadians(this.angle),
          hypotFull = this.getScaledWidth(),
          xFull = fabric.util.cos(angle) * hypotFull,
          yFull = fabric.util.sin(angle) * hypotFull,
          offsetFrom, offsetTo;

      //TODO: this function does not consider mixed situation like top, center.
      if (typeof this.originX === 'string') {
        offsetFrom = originXOffset[this.originX];
      }
      else {
        offsetFrom = this.originX - 0.5;
      }
      if (typeof to === 'string') {
        offsetTo = originXOffset[to];
      }
      else {
        offsetTo = to - 0.5;
      }
      this.left += xFull * (offsetTo - offsetFrom);
      this.top += yFull * (offsetTo - offsetFrom);
      this.setCoords();
      this.originX = to;
    },

    /**
     * Sets the origin/position of the object to it's center point
     * @private
     * @return {void}
     */
    _setOriginToCenter: function() {
      this._originalOriginX = this.originX;
      this._originalOriginY = this.originY;

      var center = this.getCenterPoint();

      this.originX = 'center';
      this.originY = 'center';

      this.left = center.x;
      this.top = center.y;
    },

    /**
     * Resets the origin/position of the object to it's original origin
     * @private
     * @return {void}
     */
    _resetOrigin: function() {
      var originPoint = this.translateToOriginPoint(
        this.getCenterPoint(),
        this._originalOriginX,
        this._originalOriginY);

      this.originX = this._originalOriginX;
      this.originY = this._originalOriginY;

      this.left = originPoint.x;
      this.top = originPoint.y;

      this._originalOriginX = null;
      this._originalOriginY = null;
    },

    /**
     * @private
     */
    _getLeftTopCoords: function() {
      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
    },
  });

})();
(function() {

  function arrayFromCoords(coords) {
    return [
      new fabric.Point(coords.tl.x, coords.tl.y),
      new fabric.Point(coords.tr.x, coords.tr.y),
      new fabric.Point(coords.br.x, coords.br.y),
      new fabric.Point(coords.bl.x, coords.bl.y)
    ];
  }

  var util = fabric.util,
      degreesToRadians = util.degreesToRadians,
      multiplyMatrices = util.multiplyTransformMatrices,
      transformPoint = util.transformPoint;

  util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Describe object's corner position in canvas element coordinates.
     * properties are depending on control keys and padding the main controls.
     * each property is an object with x, y and corner.
     * The `corner` property contains in a similar manner the 4 points of the
     * interactive area of the corner.
     * The coordinates depends from the controls positionHandler and are used
     * to draw and locate controls
     * @memberOf fabric.Object.prototype
     */
    oCoords: null,

    /**
     * Describe object's corner position in canvas object absolute coordinates
     * properties are tl,tr,bl,br and describe the four main corner.
     * each property is an object with x, y, instance of Fabric.Point.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, top, left.
     * Those coordinates are useful to understand where an object is. They get updated
     * with oCoords but they do not need to be updated when zoom or panning change.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcACoords();
     * @memberOf fabric.Object.prototype
     */
    aCoords: null,

    /**
     * Describe object's corner position in canvas element coordinates.
     * includes padding. Used of object detection.
     * set and refreshed with setCoords.
     * @memberOf fabric.Object.prototype
     */
    lineCoords: null,

    /**
     * storage for object transform matrix
     */
    ownMatrixCache: null,

    /**
     * storage for object full transform matrix
     */
    matrixCache: null,

    /**
     * custom controls interface
     * controls are added by default_controls.js
     */
    controls: { },

    /**
     * return correct set of coordinates for intersection
     * this will return either aCoords or lineCoords.
     * @param {Boolean} absolute will return aCoords if true or lineCoords
     * @return {Object} {tl, tr, br, bl} points
     */
    _getCoords: function(absolute, calculate) {
      if (calculate) {
        return (absolute ? this.calcACoords() : this.calcLineCoords());
      }
      if (!this.aCoords || !this.lineCoords) {
        this.setCoords(true);
      }
      return (absolute ? this.aCoords : this.lineCoords);
    },

    /**
     * return correct set of coordinates for intersection
     * this will return either aCoords or lineCoords.
     * The coords are returned in an array.
     * @return {Array} [tl, tr, br, bl] of points
     */
    getCoords: function(absolute, calculate) {
      return arrayFromCoords(this._getCoords(absolute, calculate));
    },

    /**
     * Checks if object intersects with an area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with an area formed by 2 points
     */
    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
      var coords = this.getCoords(absolute, calculate),
          intersection = fabric.Intersection.intersectPolygonRectangle(
            coords,
            pointTL,
            pointBR
          );
      return intersection.status === 'Intersection';
    },

    /**
     * Checks if object intersects with another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with another object
     */
    intersectsWithObject: function(other, absolute, calculate) {
      var intersection = fabric.Intersection.intersectPolygonPolygon(
        this.getCoords(absolute, calculate),
        other.getCoords(absolute, calculate)
      );

      return intersection.status === 'Intersection'
        || other.isContainedWithinObject(this, absolute, calculate)
        || this.isContainedWithinObject(other, absolute, calculate);
    },

    /**
     * Checks if object is fully contained within area of another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area of another object
     */
    isContainedWithinObject: function(other, absolute, calculate) {
      var points = this.getCoords(absolute, calculate),
          otherCoords = absolute ? other.aCoords : other.lineCoords,
          i = 0, lines = other._getImageLines(otherCoords);
      for (; i < 4; i++) {
        if (!other.containsPoint(points[i], lines)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Checks if object is fully contained within area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area formed by 2 points
     */
    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
      var boundingRect = this.getBoundingRect(absolute, calculate);

      return (
        boundingRect.left >= pointTL.x &&
        boundingRect.left + boundingRect.width <= pointBR.x &&
        boundingRect.top >= pointTL.y &&
        boundingRect.top + boundingRect.height <= pointBR.y
      );
    },

    /**
     * Checks if point is inside the object
     * @param {fabric.Point} point Point to check against
     * @param {Object} [lines] object returned from @method _getImageLines
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if point is inside the object
     */
    containsPoint: function(point, lines, absolute, calculate) {
      var coords = this._getCoords(absolute, calculate),
          lines = lines || this._getImageLines(coords),
          xPoints = this._findCrossPoints(point, lines);
      // if xPoints is odd then point is inside the object
      return (xPoints !== 0 && xPoints % 2 === 1);
    },

    /**
     * Checks if object is contained within the canvas with current viewportTransform
     * the check is done stopping at first point that appears on screen
     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
     * @return {Boolean} true if object is fully or partially contained within canvas
     */
    isOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      var points = this.getCoords(true, calculate);
      // if some point is on screen, the object is on screen.
      if (points.some(function(point) {
        return point.x <= pointBR.x && point.x >= pointTL.x &&
        point.y <= pointBR.y && point.y >= pointTL.y;
      })) {
        return true;
      }
      // no points on screen, check intersection with absolute coordinates
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Checks if the object contains the midpoint between canvas extremities
     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
     * @private
     * @param {Fabric.Point} pointTL Top Left point
     * @param {Fabric.Point} pointBR Top Right point
     * @param {Boolean} calculate use coordinates of current position instead of .oCoords
     * @return {Boolean} true if the object contains the point
     */
    _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
      // worst case scenario the object is so big that contains the screen
      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
      if (this.containsPoint(centerPoint, null, true, calculate)) {
        return true;
      }
      return false;
    },

    /**
     * Checks if object is partially contained within the canvas with current viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is partially contained within canvas
     */
    isPartiallyOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {
        return (point.x >= pointBR.x || point.x <= pointTL.x) &&
        (point.y >= pointBR.y || point.y <= pointTL.y);
      });
      return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Method that returns an object with the object edges in it, given the coordinates of the corners
     * @private
     * @param {Object} oCoords Coordinates of the object corners
     */
    _getImageLines: function(oCoords) {

      var lines = {
        topline: {
          o: oCoords.tl,
          d: oCoords.tr
        },
        rightline: {
          o: oCoords.tr,
          d: oCoords.br
        },
        bottomline: {
          o: oCoords.br,
          d: oCoords.bl
        },
        leftline: {
          o: oCoords.bl,
          d: oCoords.tl
        }
      };

      // // debugging
      // if (this.canvas.contextTop) {
      //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
      // }

      return lines;
    },

    /**
     * Helper method to determine how many cross points are between the 4 object edges
     * and the horizontal line determined by a point on canvas
     * @private
     * @param {fabric.Point} point Point to check
     * @param {Object} lines Coordinates of the object being evaluated
     */
    // remove yi, not used but left code here just in case.
    _findCrossPoints: function(point, lines) {
      var b1, b2, a1, a2, xi, // yi,
          xcount = 0,
          iLine;

      for (var lineKey in lines) {
        iLine = lines[lineKey];
        // optimisation 1: line below point. no cross
        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
          continue;
        }
        // optimisation 2: line above point. no cross
        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
          continue;
        }
        // optimisation 3: vertical line case
        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
          xi = iLine.o.x;
          // yi = point.y;
        }
        // calculate the intersection point
        else {
          b1 = 0;
          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
          a1 = point.y - b1 * point.x;
          a2 = iLine.o.y - b2 * iLine.o.x;

          xi = -(a1 - a2) / (b1 - b2);
          // yi = a1 + b1 * xi;
        }
        // dont count xi < point.x cases
        if (xi >= point.x) {
          xcount += 1;
        }
        // optimisation 4: specific for square images
        if (xcount === 2) {
          break;
        }
      }
      return xcount;
    },

    /**
     * Returns coordinates of object's bounding rectangle (left, top, width, height)
     * the box is intended as aligned to axis of canvas.
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
     * @return {Object} Object with left, top, width, height properties
     */
    getBoundingRect: function(absolute, calculate) {
      var coords = this.getCoords(absolute, calculate);
      return util.makeBoundingBoxFromPoints(coords);
    },

    /**
     * Returns width of an object's bounding box counting transformations
     * before 2.0 it was named getWidth();
     * @return {Number} width value
     */
    getScaledWidth: function() {
      return this._getTransformedDimensions().x;
    },

    /**
     * Returns height of an object bounding box counting transformations
     * before 2.0 it was named getHeight();
     * @return {Number} height value
     */
    getScaledHeight: function() {
      return this._getTransformedDimensions().y;
    },

    /**
     * Makes sure the scale is valid and modifies it if necessary
     * @private
     * @param {Number} value
     * @return {Number}
     */
    _constrainScale: function(value) {
      if (Math.abs(value) < this.minScaleLimit) {
        if (value < 0) {
          return -this.minScaleLimit;
        }
        else {
          return this.minScaleLimit;
        }
      }
      else if (value === 0) {
        return 0.0001;
      }
      return value;
    },

    /**
     * Scales an object (equally by x and y)
     * @param {Number} value Scale factor
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scale: function(value) {
      this._set('scaleX', value);
      this._set('scaleY', value);
      return this.setCoords();
    },

    /**
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New width value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToWidth: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
      return this.scale(value / this.width / boundingRectFactor);
    },

    /**
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New height value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToHeight: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
      return this.scale(value / this.height / boundingRectFactor);
    },

    calcLineCoords: function() {
      var vpt = this.getViewportTransform(),
          padding = this.padding, angle = degreesToRadians(this.angle),
          cos = util.cos(angle), sin = util.sin(angle),
          cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
          cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();

      var lineCoords = {
        tl: transformPoint(aCoords.tl, vpt),
        tr: transformPoint(aCoords.tr, vpt),
        bl: transformPoint(aCoords.bl, vpt),
        br: transformPoint(aCoords.br, vpt),
      };

      if (padding) {
        lineCoords.tl.x -= cosPMinusSinP;
        lineCoords.tl.y -= cosPSinP;
        lineCoords.tr.x += cosPSinP;
        lineCoords.tr.y -= cosPMinusSinP;
        lineCoords.bl.x -= cosPSinP;
        lineCoords.bl.y += cosPMinusSinP;
        lineCoords.br.x += cosPMinusSinP;
        lineCoords.br.y += cosPSinP;
      }

      return lineCoords;
    },

    calcOCoords: function() {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          vpt = this.getViewportTransform(),
          startMatrix = multiplyMatrices(vpt, translateMatrix),
          finalMatrix = multiplyMatrices(startMatrix, rotateMatrix),
          finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]),
          dim = this._calculateCurrentDimensions(),
          coords = {};
      this.forEachControl(function(control, key, fabricObject) {
        coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
      });

      // debug code
      // var canvas = this.canvas;
      // setTimeout(function() {
      //   canvas.contextTop.clearRect(0, 0, 700, 700);
      //   canvas.contextTop.fillStyle = 'green';
      //   Object.keys(coords).forEach(function(key) {
      //     var control = coords[key];
      //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);
      //   });
      // }, 50);
      return coords;
    },

    calcACoords: function() {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
          dim = this._getTransformedDimensions(),
          w = dim.x / 2, h = dim.y / 2;
      return {
        // corners
        tl: transformPoint({ x: -w, y: -h }, finalMatrix),
        tr: transformPoint({ x: w, y: -h }, finalMatrix),
        bl: transformPoint({ x: -w, y: h }, finalMatrix),
        br: transformPoint({ x: w, y: h }, finalMatrix)
      };
    },

    /**
     * Sets corner and controls position coordinates based on current angle, width and height, left and top.
     * oCoords are used to find the corners
     * aCoords are used to quickly find an object on the canvas
     * lineCoords are used to quickly find object during pointer events.
     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}
     *
     * @param {Boolean} [skipCorners] skip calculation of oCoords.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setCoords: function(skipCorners) {
      this.aCoords = this.calcACoords();
      // in case we are in a group, for how the inner group target check works,
      // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.
      this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
      if (skipCorners) {
        return this;
      }
      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
      this.oCoords = this.calcOCoords();
      this._setCornerCoords && this._setCornerCoords();
      return this;
    },

    /**
     * calculate rotation matrix of an object
     * @return {Array} rotation matrix for the object
     */
    _calcRotateMatrix: function() {
      return util.calcRotateMatrix(this);
    },

    /**
     * calculate the translation matrix for an object transform
     * @return {Array} rotation matrix for the object
     */
    _calcTranslateMatrix: function() {
      var center = this.getCenterPoint();
      return [1, 0, 0, 1, center.x, center.y];
    },

    transformMatrixKey: function(skipGroup) {
      var sep = '_', prefix = '';
      if (!skipGroup && this.group) {
        prefix = this.group.transformMatrixKey(skipGroup) + sep;
      };
      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
        sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
    },

    /**
     * calculate transform matrix that represents the current transformations from the
     * object's properties.
     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
     * There are some situation in which this is useful to avoid the fake rotation.
     * @return {Array} transform matrix for the object
     */
    calcTransformMatrix: function(skipGroup) {
      var matrix = this.calcOwnMatrix();
      if (skipGroup || !this.group) {
        return matrix;
      }
      var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      if (this.group) {
        matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);
      }
      cache.key = key;
      cache.value = matrix;
      return matrix;
    },

    /**
     * calculate transform matrix that represents the current transformations from the
     * object's properties, this matrix does not include the group transformation
     * @return {Array} transform matrix for the object
     */
    calcOwnMatrix: function() {
      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      var tMatrix = this._calcTranslateMatrix(),
          options = {
            angle: this.angle,
            translateX: tMatrix[4],
            translateY: tMatrix[5],
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            flipX: this.flipX,
            flipY: this.flipY,
          };
      cache.key = key;
      cache.value = util.composeMatrix(options);
      return cache.value;
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getNonTransformedDimensions: function() {
      var strokeWidth = this.strokeWidth,
          w = this.width + strokeWidth,
          h = this.height + strokeWidth;
      return { x: w, y: h };
    },

    /*
     * Calculate object bounding box dimensions from its properties scale, skew.
     * @param {Number} skewX, a value to override current skewX
     * @param {Number} skewY, a value to override current skewY
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getTransformedDimensions: function(skewX, skewY) {
      if (typeof skewX === 'undefined') {
        skewX = this.skewX;
      }
      if (typeof skewY === 'undefined') {
        skewY = this.skewY;
      }
      var dimensions, dimX, dimY,
          noSkew = skewX === 0 && skewY === 0;

      if (this.strokeUniform) {
        dimX = this.width;
        dimY = this.height;
      }
      else {
        dimensions = this._getNonTransformedDimensions();
        dimX = dimensions.x;
        dimY = dimensions.y;
      }
      if (noSkew) {
        return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
      }
      var bbox = util.sizeAfterTransform(dimX, dimY, {
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        skewX: skewX,
        skewY: skewY,
      });
      return this._finalizeDimensions(bbox.x, bbox.y);
    },

    /*
     * Calculate object bounding box dimensions from its properties scale, skew.
     * @param Number width width of the bbox
     * @param Number height height of the bbox
     * @private
     * @return {Object} .x finalized width dimension
     * @return {Object} .y finalized height dimension
     */
    _finalizeDimensions: function(width, height) {
      return this.strokeUniform ?
        { x: width + this.strokeWidth, y: height + this.strokeWidth }
        :
        { x: width, y: height };
    },

    /*
     * Calculate object dimensions for controls box, including padding and canvas zoom.
     * and active selection
     * private
     */
    _calculateCurrentDimensions: function()  {
      var vpt = this.getViewportTransform(),
          dim = this._getTransformedDimensions(),
          p = transformPoint(dim, vpt, true);
      return p.scalarAdd(2 * this.padding);
    },
  });
})();
fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * Moves an object to the bottom of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendToBack: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
    }
    else if (this.canvas) {
      this.canvas.sendToBack(this);
    }
    return this;
  },

  /**
   * Moves an object to the top of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringToFront: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
    }
    else if (this.canvas) {
      this.canvas.bringToFront(this);
    }
    return this;
  },

  /**
   * Moves an object down in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendBackwards: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
    }
    else if (this.canvas) {
      this.canvas.sendBackwards(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object up in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringForward: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
    }
    else if (this.canvas) {
      this.canvas.bringForward(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object to specified level in stack of drawn objects
   * @param {Number} index New position of object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  moveTo: function(index) {
    if (this.group && this.group.type !== 'activeSelection') {
      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
    }
    else if (this.canvas) {
      this.canvas.moveTo(this, index);
    }
    return this;
  }
});
/* _TO_SVG_START_ */
(function() {
  function getSvgColorString(prop, value) {
    if (!value) {
      return prop + ': none; ';
    }
    else if (value.toLive) {
      return prop + ': url(#SVGID_' + value.id + '); ';
    }
    else {
      var color = new fabric.Color(value),
          str = prop + ': ' + color.toRgb() + '; ',
          opacity = color.getAlpha();
      if (opacity !== 1) {
        //change the color in rgb + opacity
        str += prop + '-opacity: ' + opacity.toString() + '; ';
      }
      return str;
    }
  }

  var toFixed = fabric.util.toFixed;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {

      var fillRule = this.fillRule ? this.fillRule : 'nonzero',
          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
          strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
          visibility = this.visible ? '' : ' visibility: hidden;',
          filter = skipShadow ? '' : this.getSvgFilter(),
          fill = getSvgColorString('fill', this.fill),
          stroke = getSvgColorString('stroke', this.stroke);

      return [
        stroke,
        'stroke-width: ', strokeWidth, '; ',
        'stroke-dasharray: ', strokeDashArray, '; ',
        'stroke-linecap: ', strokeLineCap, '; ',
        'stroke-dashoffset: ', strokeDashOffset, '; ',
        'stroke-linejoin: ', strokeLineJoin, '; ',
        'stroke-miterlimit: ', strokeMiterLimit, '; ',
        fill,
        'fill-rule: ', fillRule, '; ',
        'opacity: ', opacity, ';',
        filter,
        visibility
      ].join('');
    },

    /**
     * Returns styles-string for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
     * @return {String}
     */
    getSvgSpanStyles: function(style, useWhiteSpace) {
      var term = '; ';
      var fontFamily = style.fontFamily ?
        'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
          '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
          fontFamily = fontFamily,
          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
          textDecoration = this.getSvgTextDecoration(style),
          deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
      if (textDecoration) {
        textDecoration = 'text-decoration: ' + textDecoration + term;
      }

      return [
        stroke,
        strokeWidth,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        textDecoration,
        fill,
        deltaY,
        useWhiteSpace ? 'white-space: pre; ' : ''
      ].join('');
    },

    /**
     * Returns text-decoration property for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @return {String}
     */
    getSvgTextDecoration: function(style) {
      return ['overline', 'underline', 'line-through'].filter(function(decoration) {
        return style[decoration.replace('-', '')];
      }).join(' ');
    },

    /**
     * Returns filter for svg shadow
     * @return {String}
     */
    getSvgFilter: function() {
      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
    },

    /**
     * Returns id attribute for svg output
     * @return {String}
     */
    getSvgCommons: function() {
      return [
        this.id ? 'id="' + this.id + '" ' : '',
        this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
      ].join('');
    },

    /**
     * Returns transform-string for svg-export
     * @param {Boolean} use the full transform or the single object one.
     * @return {String}
     */
    getSvgTransform: function(full, additionalTransform) {
      var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
          svgTransform = 'transform="' + fabric.util.matrixToSVG(transform);
      return svgTransform +
        (additionalTransform || '') + '" ';
    },

    _setSVGBg: function(textBgRects) {
      if (this.backgroundColor) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(this.backgroundColor),
          ' x="',
          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(this.width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(this.height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      }
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver: reviver });
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver: reviver });
    },

    /**
     * @private
     */
    _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var reviver = options.reviver,
          additionalTransform = options.additionalTransform || '',
          commonPieces = [
            this.getSvgTransform(true, additionalTransform),
            this.getSvgCommons(),
          ].join(''),
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS');
      objectMarkup[index] = commonPieces;
      return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
    },

    /**
     * @private
     */
    _createBaseSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var noStyle = options.noStyle,
          reviver = options.reviver,
          styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
          shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
          clipPath = this.clipPath,
          vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : '',
          absoluteClipPath = clipPath && clipPath.absolutePositioned,
          stroke = this.stroke, fill = this.fill, shadow = this.shadow,
          commonPieces, markup = [], clipPathMarkup,
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS'),
          additionalTransform = options.additionalTransform;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          clipPath.toClipPathSVG(reviver) +
          '</clipPath>\n';
      }
      if (absoluteClipPath) {
        markup.push(
          '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
        );
      }
      markup.push(
        '<g ',
        this.getSvgTransform(false),
        !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
        ' >\n'
      );
      commonPieces = [
        styleInfo,
        vectorEffect,
        noStyle ? '' : this.addPaintOrder(), ' ',
        additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
      ].join('');
      objectMarkup[index] = commonPieces;
      if (fill && fill.toLive) {
        markup.push(fill.toSVG(this));
      }
      if (stroke && stroke.toLive) {
        markup.push(stroke.toSVG(this));
      }
      if (shadow) {
        markup.push(shadow.toSVG(this));
      }
      if (clipPath) {
        markup.push(clipPathMarkup);
      }
      markup.push(objectMarkup.join(''));
      markup.push('</g>\n');
      absoluteClipPath && markup.push('</g>\n');
      return reviver ? reviver(markup.join('')) : markup.join('');
    },

    addPaintOrder: function() {
      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
    }
  });
})();
/* _TO_SVG_END_ */
(function() {

  var extend = fabric.util.object.extend,
      originalSet = 'stateProperties';

  /*
    Depends on `stateProperties`
  */
  function saveProps(origin, destination, props) {
    var tmpObj = { }, deep = true;
    props.forEach(function(prop) {
      tmpObj[prop] = origin[prop];
    });

    extend(origin[destination], tmpObj, deep);
  }

  function _isEqual(origValue, currentValue, firstPass) {
    if (origValue === currentValue) {
      // if the objects are identical, return
      return true;
    }
    else if (Array.isArray(origValue)) {
      if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
        return false;
      }
      for (var i = 0, len = origValue.length; i < len; i++) {
        if (!_isEqual(origValue[i], currentValue[i])) {
          return false;
        }
      }
      return true;
    }
    else if (origValue && typeof origValue === 'object') {
      var keys = Object.keys(origValue), key;
      if (!currentValue ||
          typeof currentValue !== 'object' ||
          (!firstPass && keys.length !== Object.keys(currentValue).length)
      ) {
        return false;
      }
      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        // since clipPath is in the statefull cache list and the clipPath objects
        // would be iterated as an object, this would lead to possible infinite recursion
        // we do not want to compare those.
        if (key === 'canvas' || key === 'group') {
          continue;
        }
        if (!_isEqual(origValue[key], currentValue[key])) {
          return false;
        }
      }
      return true;
    }
  }


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Returns true if object state (one of its state properties) was changed
     * @param {String} [propertySet] optional name for the set of property we want to save
     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
     */
    hasStateChanged: function(propertySet) {
      propertySet = propertySet || originalSet;
      var dashedPropertySet = '_' + propertySet;
      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
        return true;
      }
      return !_isEqual(this[dashedPropertySet], this, true);
    },

    /**
     * Saves state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    saveState: function(options) {
      var propertySet = options && options.propertySet || originalSet,
          destination = '_' + propertySet;
      if (!this[destination]) {
        return this.setupState(options);
      }
      saveProps(this, destination, this[propertySet]);
      if (options && options.stateProperties) {
        saveProps(this, destination, options.stateProperties);
      }
      return this;
    },

    /**
     * Setups state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    setupState: function(options) {
      options = options || { };
      var propertySet = options.propertySet || originalSet;
      options.propertySet = propertySet;
      this['_' + propertySet] = { };
      this.saveState(options);
      return this;
    }
  });
})();
(function() {

  var degreesToRadians = fabric.util.degreesToRadians;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Determines which corner has been clicked
     * @private
     * @param {Object} pointer The pointer indicating the mouse position
     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
     */
    _findTargetCorner: function(pointer, forTouch) {
      // objects in group, anykind, are not self modificable,
      // must not return an hovered corner.
      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
        return false;
      }

      var ex = pointer.x,
          ey = pointer.y,
          xPoints,
          lines, keys = Object.keys(this.oCoords),
          j = keys.length - 1, i;
      this.__corner = 0;

      // cycle in reverse order so we pick first the one on top
      for (; j >= 0; j--) {
        i = keys[j];
        if (!this.isControlVisible(i)) {
          continue;
        }

        lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);
        // // debugging
        //
        // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
        if (xPoints !== 0 && xPoints % 2 === 1) {
          this.__corner = i;
          return i;
        }
      }
      return false;
    },

    /**
     * Calls a function for each control. The function gets called,
     * with the control, the object that is calling the iterator and the control's key
     * @param {Function} fn function to iterate over the controls over
     */
    forEachControl: function(fn) {
      for (var i in this.controls) {
        fn(this.controls[i], i, this);
      };
    },

    /**
     * Sets the coordinates of the draggable boxes in the corners of
     * the image used to scale/rotate it.
     * note: if we would switch to ROUND corner area, all of this would disappear.
     * everything would resolve to a single point and a pythagorean theorem for the distance
     * @private
     */
    _setCornerCoords: function() {
      var coords = this.oCoords;

      for (var control in coords) {
        var controlObject = this.controls[control];
        coords[control].corner = controlObject.calcCornerCoords(
          this.angle, this.cornerSize, coords[control].x, coords[control].y, false);
        coords[control].touchCorner = controlObject.calcCornerCoords(
          this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);
      }
    },

    /**
     * Draws a colored layer behind the object, inside its selection borders.
     * Requires public options: padding, selectionBackgroundColor
     * this function is called when the context is transformed
     * has checks to be skipped when the object is on a staticCanvas
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawSelectionBackground: function(ctx) {
      if (!this.selectionBackgroundColor ||
        (this.canvas && !this.canvas.interactive) ||
        (this.canvas && this.canvas._activeObject !== this)
      ) {
        return this;
      }
      ctx.save();
      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
          vpt = this.canvas.viewportTransform;
      ctx.translate(center.x, center.y);
      ctx.scale(1 / vpt[0], 1 / vpt[3]);
      ctx.rotate(degreesToRadians(this.angle));
      ctx.fillStyle = this.selectionBackgroundColor;
      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBorders: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          strokeWidth = this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth,
          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
            styleOverride.hasControls : this.hasControls,
          shouldStroke = false;

      ctx.save();
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      if (hasControls) {
        ctx.beginPath();
        this.forEachControl(function(control, key, fabricObject) {
          // in this moment, the ctx is centered on the object.
          // width and height of the above function are the size of the bbox.
          if (control.withConnection && control.getVisibility(fabricObject, key)) {
            // reset movement for each control
            shouldStroke = true;
            ctx.moveTo(control.x * width, control.y * height);
            ctx.lineTo(
              control.x * width + control.offsetX,
              control.y * height + control.offsetY
            );
          }
        });
        if (shouldStroke) {
          ctx.stroke();
        }
      }
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box when it is inside a group.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {object} options object representing current object parameters
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBordersInGroup: function(ctx, options, styleOverride) {
      styleOverride = styleOverride || {};
      var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options),
          strokeWidth = this.strokeWidth,
          strokeUniform = this.strokeUniform,
          borderScaleFactor = this.borderScaleFactor,
          width =
            bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor,
          height =
            bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
      ctx.save();
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      ctx.restore();
      return this;
    },

    /**
     * Draws corners of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: cornerSize, padding
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawControls: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      ctx.save();
      var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;
      ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);
      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
      if (!this.transparentCorners) {
        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
      }
      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);
      this.setCoords();
      if (this.group) {
        // fabricJS does not really support drawing controls inside groups,
        // this piece of code here helps having at least the control in places.
        // If an application needs to show some objects as selected because of some UI state
        // can still call Object._renderControls() on any object they desire, independently of groups.
        // using no padding, circular controls and hiding the rotating cursor is higly suggested,
        matrix = this.group.calcTransformMatrix();
      }
      this.forEachControl(function(control, key, fabricObject) {
        p = fabricObject.oCoords[key];
        if (control.getVisibility(fabricObject, key)) {
          if (matrix) {
            p = fabric.util.transformPoint(p, matrix);
          }
          control.render(ctx, p.x, p.y, styleOverride, fabricObject);
        }
      });
      ctx.restore();

      return this;
    },

    /**
     * Returns true if the specified control is visible, false otherwise.
     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @returns {Boolean} true if the specified control is visible, false otherwise
     */
    isControlVisible: function(controlKey) {
      return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
    },

    /**
     * Sets the visibility of the specified control.
     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @param {Boolean} visible true to set the specified control visible, false otherwise
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlVisible: function(controlKey, visible) {
      if (!this._controlsVisibility) {
        this._controlsVisibility = {};
      }
      this._controlsVisibility[controlKey] = visible;
      return this;
    },

    /**
     * Sets the visibility state of object controls.
     * @param {Object} [options] Options object
     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlsVisibility: function(options) {
      options || (options = { });

      for (var p in options) {
        this.setControlVisible(p, options[p]);
      }
      return this;
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to deselect this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onDeselect: function() {
      // implemented by sub-classes, as needed.
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to select this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onSelect: function() {
      // implemented by sub-classes, as needed.
    }
  });
})();
fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Animation duration (in ms) for fx* methods
   * @type Number
   * @default
   */
  FX_DURATION: 500,

  /**
   * Centers object horizontally with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.AnimationContext} context
   */
  fxCenterObjectH: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    return fabric.util.animate({
      target: this,
      startValue: object.left,
      endValue: this.getCenterPoint().x,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('left', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });
  },

  /**
   * Centers object vertically with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.AnimationContext} context
   */
  fxCenterObjectV: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    return fabric.util.animate({
      target: this,
      startValue: object.top,
      endValue: this.getCenterPoint().y,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('top', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });
  },

  /**
   * Same as `fabric.Canvas#remove` but animated
   * @param {fabric.Object} object Object to remove
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.AnimationContext} context
   */
  fxRemove: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    return fabric.util.animate({
      target: this,
      startValue: object.opacity,
      endValue: 0,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('opacity', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function () {
        _this.remove(object);
        onComplete();
      }
    });
  }
});

fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
  /**
   * Animates object's properties
   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
   * @return {fabric.Object} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
   * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)
   *
   * As object  multiple properties
   *
   * object.animate({ left: ..., top: ... });
   * object.animate({ left: ..., top: ... }, { duration: ... });
   *
   * As string  one property
   *
   * object.animate('left', ...);
   * object.animate('left', { duration: ... });
   *
   */
  animate: function () {
    if (arguments[0] && typeof arguments[0] === 'object') {
      var propsToAnimate = [], prop, skipCallbacks, out = [];
      for (prop in arguments[0]) {
        propsToAnimate.push(prop);
      }
      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
        prop = propsToAnimate[i];
        skipCallbacks = i !== len - 1;
        out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));
      }
      return out;
    }
    else {
      return this._animate.apply(this, arguments);
    }
  },

  /**
   * @private
   * @param {String} property Property to animate
   * @param {String} to Value to animate to
   * @param {Object} [options] Options object
   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
   */
  _animate: function(property, to, options, skipCallbacks) {
    var _this = this, propPair;

    to = to.toString();

    if (!options) {
      options = { };
    }
    else {
      options = fabric.util.object.clone(options);
    }

    if (~property.indexOf('.')) {
      propPair = property.split('.');
    }

    var propIsColor =
      _this.colorProperties.indexOf(property) > -1 ||
      (propPair && _this.colorProperties.indexOf(propPair[1]) > -1);

    var currentValue = propPair
      ? this.get(propPair[0])[propPair[1]]
      : this.get(property);

    if (!('from' in options)) {
      options.from = currentValue;
    }

    if (!propIsColor) {
      if (~to.indexOf('=')) {
        to = currentValue + parseFloat(to.replace('=', ''));
      }
      else {
        to = parseFloat(to);
      }
    }

    var _options = {
      target: this,
      startValue: options.from,
      endValue: to,
      byValue: options.by,
      easing: options.easing,
      duration: options.duration,
      abort: options.abort && function(value, valueProgress, timeProgress) {
        return options.abort.call(_this, value, valueProgress, timeProgress);
      },
      onChange: function (value, valueProgress, timeProgress) {
        if (propPair) {
          _this[propPair[0]][propPair[1]] = value;
        }
        else {
          _this.set(property, value);
        }
        if (skipCallbacks) {
          return;
        }
        options.onChange && options.onChange(value, valueProgress, timeProgress);
      },
      onComplete: function (value, valueProgress, timeProgress) {
        if (skipCallbacks) {
          return;
        }

        _this.setCoords();
        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
      }
    };

    if (propIsColor) {
      return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
    }
    else {
      return fabric.util.animate(_options);
    }
  }
});
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 };

  if (fabric.Line) {
    fabric.warn('fabric.Line is already defined');
    return;
  }

  /**
   * Line class
   * @class fabric.Line
   * @extends fabric.Object
   * @see {@link fabric.Line#initialize} for constructor definition
   */
  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'line',

    /**
     * x value or first line edge
     * @type Number
     * @default
     */
    x1: 0,

    /**
     * y value or first line edge
     * @type Number
     * @default
     */
    y1: 0,

    /**
     * x value or second line edge
     * @type Number
     * @default
     */
    x2: 0,

    /**
     * y value or second line edge
     * @type Number
     * @default
     */
    y2: 0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

    /**
     * Constructor
     * @param {Array} [points] Array of points
     * @param {Object} [options] Options object
     * @return {fabric.Line} thisArg
     */
    initialize: function(points, options) {
      if (!points) {
        points = [0, 0, 0, 0];
      }

      this.callSuper('initialize', options);

      this.set('x1', points[0]);
      this.set('y1', points[1]);
      this.set('x2', points[2]);
      this.set('y2', points[3]);

      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Object} [options] Options
     */
    _setWidthHeight: function(options) {
      options || (options = { });

      this.width = Math.abs(this.x2 - this.x1);
      this.height = Math.abs(this.y2 - this.y1);

      this.left = 'left' in options
        ? options.left
        : this._getLeftToOriginX();

      this.top = 'top' in options
        ? options.top
        : this._getTopToOriginY();
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      if (typeof coordProps[key] !== 'undefined') {
        this._setWidthHeight();
      }
      return this;
    },

    /**
     * @private
     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
     */
    _getLeftToOriginX: makeEdgeToOriginGetter(
      { // property names
        origin: 'originX',
        axis1: 'x1',
        axis2: 'x2',
        dimension: 'width'
      },
      { // possible values of origin
        nearest: 'left',
        center: 'center',
        farthest: 'right'
      }
    ),

    /**
     * @private
     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
     */
    _getTopToOriginY: makeEdgeToOriginGetter(
      { // property names
        origin: 'originY',
        axis1: 'y1',
        axis2: 'y2',
        dimension: 'height'
      },
      { // possible values of origin
        nearest: 'top',
        center: 'center',
        farthest: 'bottom'
      }
    ),

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();


      var p = this.calcLinePoints();
      ctx.moveTo(p.x1, p.y1);
      ctx.lineTo(p.x2, p.y2);

      ctx.lineWidth = this.strokeWidth;

      // TODO: test this
      // make sure setting "fill" changes color of a line
      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
      var origStrokeStyle = ctx.strokeStyle;
      ctx.strokeStyle = this.stroke || ctx.fillStyle;
      this.stroke && this._renderStroke(ctx);
      ctx.strokeStyle = origStrokeStyle;
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return {
        x: (this.x1 + this.x2) / 2,
        y: (this.y1 + this.y2) / 2,
      };
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     */
    _getNonTransformedDimensions: function() {
      var dim = this.callSuper('_getNonTransformedDimensions');
      if (this.strokeLineCap === 'butt') {
        if (this.width === 0) {
          dim.y -= this.strokeWidth;
        }
        if (this.height === 0) {
          dim.x -= this.strokeWidth;
        }
      }
      return dim;
    },

    /**
     * Recalculates line points given width and height
     * @private
     */
    calcLinePoints: function() {
      var xMult = this.x1 <= this.x2 ? -1 : 1,
          yMult = this.y1 <= this.y2 ? -1 : 1,
          x1 = (xMult * this.width * 0.5),
          y1 = (yMult * this.height * 0.5),
          x2 = (xMult * this.width * -0.5),
          y2 = (yMult * this.height * -0.5);

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2
      };
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var p = this.calcLinePoints();
      return [
        '<line ', 'COMMON_PARTS',
        'x1="', p.x1,
        '" y1="', p.y1,
        '" x2="', p.x2,
        '" y2="', p.y2,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
   * @static
   * @memberOf fabric.Line
   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
   */
  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

  /**
   * Returns fabric.Line instance from an SVG element
   * @static
   * @memberOf fabric.Line
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] callback function invoked after parsing
   */
  fabric.Line.fromElement = function(element, callback, options) {
    options = options || { };
    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
        points = [
          parsedAttributes.x1 || 0,
          parsedAttributes.y1 || 0,
          parsedAttributes.x2 || 0,
          parsedAttributes.y2 || 0
        ];
    callback(new fabric.Line(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Line instance from an object representation
   * @static
   * @memberOf fabric.Line
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Line.fromObject = function(object, callback) {
    function _callback(instance) {
      delete instance.points;
      callback && callback(instance);
    };
    var options = clone(object, true);
    options.points = [object.x1, object.y1, object.x2, object.y2];
    fabric.Object._fromObject('Line', options, _callback, 'points');
  };

  /**
   * Produces a function that calculates distance from canvas edge to Line origin.
   */
  function makeEdgeToOriginGetter(propertyNames, originValues) {
    var origin = propertyNames.origin,
        axis1 = propertyNames.axis1,
        axis2 = propertyNames.axis2,
        dimension = propertyNames.dimension,
        nearest = originValues.nearest,
        center = originValues.center,
        farthest = originValues.farthest;

    return function() {
      switch (this.get(origin)) {
        case nearest:
          return Math.min(this.get(axis1), this.get(axis2));
        case center:
          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
        case farthest:
          return Math.max(this.get(axis1), this.get(axis2));
      }
    };

  }

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      degreesToRadians = fabric.util.degreesToRadians;

  if (fabric.Circle) {
    fabric.warn('fabric.Circle is already defined.');
    return;
  }

  /**
   * Circle class
   * @class fabric.Circle
   * @extends fabric.Object
   * @see {@link fabric.Circle#initialize} for constructor definition
   */
  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'circle',

    /**
     * Radius of this circle
     * @type Number
     * @default
     */
    radius: 0,

    /**
     * degrees of start of the circle.
     * probably will change to degrees in next major version
     * @type Number 0 - 359
     * @default 0
     */
    startAngle: 0,

    /**
     * End angle of the circle
     * probably will change to degrees in next major version
     * @type Number 1 - 360
     * @default 360
     */
    endAngle: 360,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Circle} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);

      if (key === 'radius') {
        this.setRadius(value);
      }

      return this;
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */

    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString, x = 0, y = 0,
          angle = (this.endAngle - this.startAngle) % 360;

      if (angle === 0) {
        svgString = [
          '<circle ', 'COMMON_PARTS',
          'cx="' + x + '" cy="' + y + '" ',
          'r="', this.radius,
          '" />\n'
        ];
      }
      else {
        var start = degreesToRadians(this.startAngle),
            end = degreesToRadians(this.endAngle),
            radius = this.radius,
            startX = fabric.util.cos(start) * radius,
            startY = fabric.util.sin(start) * radius,
            endX = fabric.util.cos(end) * radius,
            endY = fabric.util.sin(end) * radius,
            largeFlag = angle > 180 ? '1' : '0';
        svgString = [
          '<path d="M ' + startX + ' ' + startY,
          ' A ' + radius + ' ' + radius,
          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
          '" ', 'COMMON_PARTS', ' />\n'
        ];
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.arc(
        0,
        0,
        this.radius,
        degreesToRadians(this.startAngle),
        degreesToRadians(this.endAngle),
        false
      );
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusX: function() {
      return this.get('radius') * this.get('scaleX');
    },

    /**
     * Returns vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusY: function() {
      return this.get('radius') * this.get('scaleY');
    },

    /**
     * Sets radius of an object (and updates width accordingly)
     * @return {fabric.Circle} thisArg
     */
    setRadius: function(value) {
      this.radius = value;
      return this.set('width', value * 2).set('height', value * 2);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
   * @static
   * @memberOf fabric.Circle
   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
   */
  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

  /**
   * Returns {@link fabric.Circle} instance from an SVG element
   * @static
   * @memberOf fabric.Circle
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @param {Object} [options] Options object
   * @throws {Error} If value of `r` attribute is missing or invalid
   */
  fabric.Circle.fromElement = function(element, callback) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

    if (!isValidRadius(parsedAttributes)) {
      throw new Error('value of `r` attribute is required and can not be negative');
    }

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
    callback(new fabric.Circle(parsedAttributes));
  };

  /**
   * @private
   */
  function isValidRadius(attributes) {
    return (('radius' in attributes) && (attributes.radius >= 0));
  }
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Circle} instance from an object representation
   * @static
   * @memberOf fabric.Circle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {void}
   */
  fabric.Circle.fromObject = function(object, callback) {
    fabric.Object._fromObject('Circle', object, callback);
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Triangle) {
    fabric.warn('fabric.Triangle is already defined');
    return;
  }

  /**
   * Triangle class
   * @class fabric.Triangle
   * @extends fabric.Object
   * @return {fabric.Triangle} thisArg
   * @see {@link fabric.Triangle#initialize} for constructor definition
   */
  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'triangle',

    /**
     * Width is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    width: 100,

    /**
     * Height is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    height: 100,

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      ctx.moveTo(-widthBy2, heightBy2);
      ctx.lineTo(0, -heightBy2);
      ctx.lineTo(widthBy2, heightBy2);
      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2,
          points = [
            -widthBy2 + ' ' + heightBy2,
            '0 ' + -heightBy2,
            widthBy2 + ' ' + heightBy2
          ].join(',');
      return [
        '<polygon ', 'COMMON_PARTS',
        'points="', points,
        '" />'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Triangle} instance from an object representation
   * @static
   * @memberOf fabric.Triangle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Triangle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Triangle', object, callback);
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      piBy2   = Math.PI * 2;

  if (fabric.Ellipse) {
    fabric.warn('fabric.Ellipse is already defined.');
    return;
  }

  /**
   * Ellipse class
   * @class fabric.Ellipse
   * @extends fabric.Object
   * @return {fabric.Ellipse} thisArg
   * @see {@link fabric.Ellipse#initialize} for constructor definition
   */
  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'ellipse',

    /**
     * Horizontal radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {fabric.Ellipse} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('rx', options && options.rx || 0);
      this.set('ry', options && options.ry || 0);
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Ellipse} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      switch (key) {

        case 'rx':
          this.rx = value;
          this.set('width', value * 2);
          break;

        case 'ry':
          this.ry = value;
          this.set('height', value * 2);
          break;

      }
      return this;
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRx: function() {
      return this.get('rx') * this.get('scaleX');
    },

    /**
     * Returns Vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRy: function() {
      return this.get('ry') * this.get('scaleY');
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      return [
        '<ellipse ', 'COMMON_PARTS',
        'cx="0" cy="0" ',
        'rx="', this.rx,
        '" ry="', this.ry,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.save();
      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
      ctx.arc(
        0,
        0,
        this.rx,
        0,
        piBy2,
        false);
      ctx.restore();
      this._renderPaintInOrder(ctx);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
   * @static
   * @memberOf fabric.Ellipse
   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
   */
  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

  /**
   * Returns {@link fabric.Ellipse} instance from an SVG element
   * @static
   * @memberOf fabric.Ellipse
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromElement = function(element, callback) {

    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
    callback(new fabric.Ellipse(parsedAttributes));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Ellipse} instance from an object representation
   * @static
   * @memberOf fabric.Ellipse
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {void}
   */
  fabric.Ellipse.fromObject = function(object, callback) {
    fabric.Object._fromObject('Ellipse', object, callback);
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Rect) {
    fabric.warn('fabric.Rect is already defined');
    return;
  }

  /**
   * Rectangle class
   * @class fabric.Rect
   * @extends fabric.Object
   * @return {fabric.Rect} thisArg
   * @see {@link fabric.Rect#initialize} for constructor definition
   */
  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

    /**
     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'rect',

    /**
     * Horizontal border radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical border radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this._initRxRy();
    },

    /**
     * Initializes rx/ry attributes
     * @private
     */
    _initRxRy: function() {
      if (this.rx && !this.ry) {
        this.ry = this.rx;
      }
      else if (this.ry && !this.rx) {
        this.rx = this.ry;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {

      // 1x1 case (used in spray brush) optimization was removed because
      // with caching and higher zoom level this makes more damage than help

      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
          w = this.width,
          h = this.height,
          x = -this.width / 2,
          y = -this.height / 2,
          isRounded = rx !== 0 || ry !== 0,
          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
          k = 1 - 0.5522847498;
      ctx.beginPath();

      ctx.moveTo(x + rx, y);

      ctx.lineTo(x + w - rx, y);
      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

      ctx.lineTo(x + w, y + h - ry);
      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

      ctx.lineTo(x + rx, y + h);
      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

      ctx.lineTo(x, y + ry);
      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var x = -this.width / 2, y = -this.height / 2;
      return [
        '<rect ', 'COMMON_PARTS',
        'x="', x, '" y="', y,
        '" rx="', this.rx, '" ry="', this.ry,
        '" width="', this.width, '" height="', this.height,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
   * @static
   * @memberOf fabric.Rect
   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
   */
  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

  /**
   * Returns {@link fabric.Rect} instance from an SVG element
   * @static
   * @memberOf fabric.Rect
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Rect.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options = options || { };

    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
    parsedAttributes.left = parsedAttributes.left || 0;
    parsedAttributes.top  = parsedAttributes.top  || 0;
    parsedAttributes.height  = parsedAttributes.height || 0;
    parsedAttributes.width  = parsedAttributes.width || 0;
    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
    callback(rect);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Rect} instance from an object representation
   * @static
   * @memberOf fabric.Rect
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
   */
  fabric.Rect.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Rect', object, callback);
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      toFixed = fabric.util.toFixed,
      projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;

  if (fabric.Polyline) {
    fabric.warn('fabric.Polyline is already defined');
    return;
  }

  /**
   * Polyline class
   * @class fabric.Polyline
   * @extends fabric.Object
   * @see {@link fabric.Polyline#initialize} for constructor definition
   */
  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polyline',

    /**
     * Points array
     * @type Array
     * @default
     */
    points: null,

    /**
     * WARNING: Feature in progress
     * Calculate the exact bounding box taking in account strokeWidth on acute angles
     * this will be turned to true by default on fabric 6.0
     * maybe will be left in as an optimization since calculations may be slow
     * @deprecated
     * @type Boolean
     * @default false
     */
    exactBoundingBox: false,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

    /**
     * Constructor
     * @param {Array} points Array of points (where each point is an object with x and y)
     * @param {Object} [options] Options object
     * @return {fabric.Polyline} thisArg
     * @example
     * var poly = new fabric.Polyline([
     *     { x: 10, y: 10 },
     *     { x: 50, y: 30 },
     *     { x: 40, y: 70 },
     *     { x: 60, y: 50 },
     *     { x: 100, y: 150 },
     *     { x: 40, y: 100 }
     *   ], {
     *   stroke: 'red',
     *   left: 100,
     *   top: 100
     * });
     */
    initialize: function(points, options) {
      options = options || {};
      this.points = points || [];
      this.callSuper('initialize', options);
      this._setPositionDimensions(options);
    },

    /**
     * @private
     */
    _projectStrokeOnPoints: function () {
      return projectStrokeOnPoints(this.points, this, true);
    },

    _setPositionDimensions: function(options) {
      var calcDim = this._calcDimensions(options), correctLeftTop,
          correctSize = this.exactBoundingBox ? this.strokeWidth : 0;
      this.width = calcDim.width - correctSize;
      this.height = calcDim.height - correctSize;
      if (!options.fromSVG) {
        correctLeftTop = this.translateToGivenOrigin(
          {
            // this looks bad, but is one way to keep it optional for now.
            x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,
            y: calcDim.top - this.strokeWidth / 2 + correctSize / 2
          },
          'left',
          'top',
          this.originX,
          this.originY
        );
      }
      if (typeof options.left === 'undefined') {
        this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
      }
      if (typeof options.top === 'undefined') {
        this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
      }
      this.pathOffset = {
        x: calcDim.left + this.width / 2 + correctSize / 2,
        y: calcDim.top + this.height / 2 + correctSize / 2
      };
    },

    /**
     * Calculate the polygon min and max point from points array,
     * returning an object with left, top, width, height to measure the
     * polygon size
     * @return {Object} object.left X coordinate of the polygon leftmost point
     * @return {Object} object.top Y coordinate of the polygon topmost point
     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
     * @private
     */
    _calcDimensions: function() {

      var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points,
          minX = min(points, 'x') || 0,
          minY = min(points, 'y') || 0,
          maxX = max(points, 'x') || 0,
          maxY = max(points, 'y') || 0,
          width = (maxX - minX),
          height = (maxY - minY);

      return {
        left: minX,
        top: minY,
        width: width,
        height: height,
      };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        points: this.points.concat()
      });
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      for (var i = 0, len = this.points.length; i < len; i++) {
        points.push(
          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
        );
      }
      return [
        '<' + this.type + ' ', 'COMMON_PARTS',
        'points="', points.join(''),
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */


    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    commonRender: function(ctx) {
      var point, len = this.points.length,
          x = this.pathOffset.x,
          y = this.pathOffset.y;

      if (!len || isNaN(this.points[len - 1].y)) {
        // do not draw if no points or odd points
        // NaN comes from parseFloat of a empty string in parser
        return false;
      }
      ctx.beginPath();
      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
      for (var i = 0; i < len; i++) {
        point = this.points[i];
        ctx.lineTo(point.x - x, point.y - y);
      }
      return true;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.get('points').length;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
   * @static
   * @memberOf fabric.Polyline
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
   */
  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns fabric.Polyline instance from an SVG element
   * @static
   * @memberOf fabric.Polyline
   * @param {SVGElement} element Element to parser
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polyline.fromElementGenerator = function(_class) {
    return function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);
      parsedAttributes.fromSVG = true;
      callback(new fabric[_class](points, extend(parsedAttributes, options)));
    };
  };

  fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator('Polyline');

  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polyline instance from an object representation
   * @static
   * @memberOf fabric.Polyline
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polyline.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polyline', object, callback, 'points');
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = {}),
      projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;

  if (fabric.Polygon) {
    fabric.warn('fabric.Polygon is already defined');
    return;
  }

  /**
   * Polygon class
   * @class fabric.Polygon
   * @extends fabric.Polyline
   * @see {@link fabric.Polygon#initialize} for constructor definition
   */
  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polygon',

    /**
     * @private
     */
    _projectStrokeOnPoints: function () {
      return projectStrokeOnPoints(this.points, this);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx);
    },

  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
   * @static
   * @memberOf fabric.Polygon
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
   */
  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns {@link fabric.Polygon} instance from an SVG element
   * @static
   * @memberOf fabric.Polygon
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator('Polygon');
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polygon instance from an object representation
   * @static
   * @memberOf fabric.Polygon
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   * @return {void}
   */
  fabric.Polygon.fromObject = function(object, callback) {
    fabric.Object._fromObject('Polygon', object, callback, 'points');
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed;

  if (fabric.Path) {
    fabric.warn('fabric.Path is already defined');
    return;
  }

  /**
   * Path class
   * @class fabric.Path
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
   * @see {@link fabric.Path#initialize} for constructor definition
   */
  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'path',

    /**
     * Array of path points
     * @type Array
     * @default
     */
    path: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

    /**
     * Constructor
     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
     * @param {Object} [options] Options object
     * @return {fabric.Path} thisArg
     */
    initialize: function (path, options) {
      options = clone(options || {});
      delete options.path;
      this.callSuper('initialize', options);
      this._setPath(path || [], options);
    },

    /**
    * @private
    * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
    * @param {Object} [options] Options object
    */
    _setPath: function (path, options) {
      this.path = fabric.util.makePathSimpler(
        Array.isArray(path) ? path : fabric.util.parsePath(path)
      );

      fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _renderPathCommands: function(ctx) {
      var current, // current instruction
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          l = -this.pathOffset.x,
          t = -this.pathOffset.y;

      ctx.beginPath();

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'C': // bezierCurveTo, absolute
            x = current[5];
            y = current[6];
            controlX = current[3];
            controlY = current[4];
            ctx.bezierCurveTo(
              current[1] + l,
              current[2] + t,
              controlX + l,
              controlY + t,
              x + l,
              y + t
            );
            break;

          case 'Q': // quadraticCurveTo, absolute
            ctx.quadraticCurveTo(
              current[1] + l,
              current[2] + t,
              current[3] + l,
              current[4] + t
            );
            x = current[3];
            y = current[4];
            controlX = current[1];
            controlY = current[2];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            ctx.closePath();
            break;
        }
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _render: function(ctx) {
      this._renderPathCommands(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function() {
      return '#<fabric.Path (' + this.complexity() +
        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        path: this.path.map(function(item) { return item.slice(); }),
      });
    },

    /**
     * Returns dataless object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
      if (o.sourcePath) {
        delete o.path;
      }
      return o;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var path = fabric.util.joinPath(this.path);
      return [
        '<path ', 'COMMON_PARTS',
        'd="', path,
        '" stroke-linecap="round" ',
        '/>\n'
      ];
    },

    _getOffsetTransform: function() {
      var digits = fabric.Object.NUM_FRACTION_DIGITS;
      return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
          toFixed(-this.pathOffset.y, digits) + ')';
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return '\t' + this._createBaseClipPathSVGMarkup(
        this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
      );
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
    },
    /* _TO_SVG_END_ */

    /**
     * Returns number representation of an instance complexity
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.path.length;
    },

    /**
     * @private
     */
    _calcDimensions: function() {

      var aX = [],
          aY = [],
          current, // current instruction
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          bounds;

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            bounds = [];
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'C': // bezierCurveTo, absolute
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6]
            );
            x = current[5];
            y = current[6];
            break;

          case 'Q': // quadraticCurveTo, absolute
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              current[1],
              current[2],
              current[3],
              current[4]
            );
            x = current[3];
            y = current[4];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            break;
        }
        bounds.forEach(function (point) {
          aX.push(point.x);
          aY.push(point.y);
        });
        aX.push(x);
        aY.push(y);
      }

      var minX = min(aX) || 0,
          minY = min(aY) || 0,
          maxX = max(aX) || 0,
          maxY = max(aY) || 0,
          deltaX = maxX - minX,
          deltaY = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: deltaX,
        height: deltaY
      };
    }
  });

  /**
   * Creates an instance of fabric.Path from an object
   * @static
   * @memberOf fabric.Path
   * @param {Object} object
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Path.fromObject = function(object, callback) {
    if (typeof object.sourcePath === 'string') {
      var pathUrl = object.sourcePath;
      fabric.loadSVGFromURL(pathUrl, function (elements) {
        var path = elements[0];
        path.setOptions(object);
        callback && callback(path);
      });
    }
    else {
      fabric.Object._fromObject('Path', object, callback, 'path');
    }
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
   * @static
   * @memberOf fabric.Path
   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
   */
  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

  /**
   * Creates an instance of fabric.Path from an SVG <path> element
   * @static
   * @memberOf fabric.Path
   * @param {SVGElement} element to parse
   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   */
  fabric.Path.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
    parsedAttributes.fromSVG = true;
    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max;

  if (fabric.Group) {
    return;
  }

  /**
   * Group class
   * @class fabric.Group
   * @extends fabric.Object
   * @mixes fabric.Collection
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.Group#initialize} for constructor definition
   */
  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'group',

    /**
     * Width of stroke
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
     * @type Boolean
     * @default
     */
    subTargetCheck: false,

    /**
     * Groups are container, do not render anything on theyr own, ence no cache properties
     * @type Array
     * @default
     */
    cacheProperties: [],

    /**
     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
     * available setting this boolean to true.
     * @type Boolean
     * @since 2.0.0
     * @default
     */
    useSetOnGroup: false,

    /**
     * Constructor
     * @param {Object} objects Group objects
     * @param {Object} [options] Options object
     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
     * @return {Object} thisArg
     */
    initialize: function(objects, options, isAlreadyGrouped) {
      options = options || {};
      this._objects = [];
      // if objects enclosed in a group have been grouped already,
      // we cannot change properties of objects.
      // Thus we need to set options to group without objects,
      isAlreadyGrouped && this.callSuper('initialize', options);
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (!isAlreadyGrouped) {
        var center = options && options.centerPoint;
        // we want to set origins before calculating the bounding box.
        // so that the topleft can be set with that in mind.
        // if specific top and left are passed, are overwritten later
        // with the callSuper('initialize', options)
        if (options.originX !== undefined) {
          this.originX = options.originX;
        }
        if (options.originY !== undefined) {
          this.originY = options.originY;
        }
        // if coming from svg i do not want to calc bounds.
        // i assume width and height are passed along options
        center || this._calcBounds();
        this._updateObjectsCoords(center);
        delete options.centerPoint;
        this.callSuper('initialize', options);
      }
      else {
        this._updateObjectsACoords();
      }

      this.setCoords();
    },

    /**
     * @private
     */
    _updateObjectsACoords: function() {
      var skipControls = true;
      for (var i = this._objects.length; i--; ){
        this._objects[i].setCoords(skipControls);
      }
    },

    /**
     * @private
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
     */
    _updateObjectsCoords: function(center) {
      var center = center || this.getCenterPoint();
      for (var i = this._objects.length; i--; ){
        this._updateObjectCoords(this._objects[i], center);
      }
    },

    /**
     * @private
     * @param {Object} object
     * @param {fabric.Point} center, current center of group.
     */
    _updateObjectCoords: function(object, center) {
      var objectLeft = object.left,
          objectTop = object.top,
          skipControls = true;

      object.set({
        left: objectLeft - center.x,
        top: objectTop - center.y
      });
      object.group = this;
      object.setCoords(skipControls);
    },

    /**
     * Returns string represenation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.Group: (' + this.complexity() + ')>';
    },

    /**
     * Adds an object to a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    addWithUpdate: function(object) {
      var nested = !!this.group;
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);
      if (object) {
        if (nested) {
          // if this group is inside another group, we need to pre transform the object
          fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());
        }
        this._objects.push(object);
        object.group = this;
        object._set('canvas', this.canvas);
      }
      this._calcBounds();
      this._updateObjectsCoords();
      this.dirty = true;
      if (nested) {
        this.group.addWithUpdate();
      }
      else {
        this.setCoords();
      }
      return this;
    },

    /**
     * Removes an object from a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    removeWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);

      this.remove(object);
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * @private
     */
    _onObjectAdded: function(object) {
      this.dirty = true;
      object.group = this;
      object._set('canvas', this.canvas);
    },

    /**
     * @private
     */
    _onObjectRemoved: function(object) {
      this.dirty = true;
      delete object.group;
    },

    /**
     * @private
     */
    _set: function(key, value) {
      var i = this._objects.length;
      if (this.useSetOnGroup) {
        while (i--) {
          this._objects[i].setOnGroup(key, value);
        }
      }
      if (key === 'canvas') {
        while (i--) {
          this._objects[i]._set(key, value);
        }
      }
      fabric.Object.prototype._set.call(this, key, value);
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var _includeDefaultValues = this.includeDefaultValues;
      var objsToObject = this._objects
        .filter(function (obj) {
          return !obj.excludeFromExport;
        })
        .map(function (obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = _includeDefaultValues;
          var _obj = obj.toObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
      var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Returns object representation of an instance, in dataless mode.
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var objsToObject, sourcePath = this.sourcePath;
      if (sourcePath) {
        objsToObject = sourcePath;
      }
      else {
        var _includeDefaultValues = this.includeDefaultValues;
        objsToObject = this._objects.map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = _includeDefaultValues;
          var _obj = obj.toDatalessObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
      }
      var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Renders instance on a given context
     * @param {CanvasRenderingContext2D} ctx context to render instance on
     */
    render: function(ctx) {
      this._transformDone = true;
      this.callSuper('render', ctx);
      this._transformDone = false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group is already cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      var ownCache = fabric.Object.prototype.shouldCache.call(this);
      if (ownCache) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            this.ownCaching = false;
            return false;
          }
        }
      }
      return ownCache;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * @return {Boolean}
     */
    willDrawShadow: function() {
      if (fabric.Object.prototype.willDrawShadow.call(this)) {
        return true;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].willDrawShadow()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return this.ownCaching || (this.group && this.group.isOnACache());
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx) {
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i].render(ctx);
      }
      this._drawClipPath(ctx, this.clipPath);
    },

    /**
     * Check if cache is dirty
     */
    isCacheDirty: function(skipCanvas) {
      if (this.callSuper('isCacheDirty', skipCanvas)) {
        return true;
      }
      if (!this.statefullCache) {
        return false;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].isCacheDirty(true)) {
          if (this._cacheCanvas) {
            // if this group has not a cache canvas there is nothing to clean
            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Restores original state of each of group objects (original state is that which was before group was created).
     * if the nested boolean is true, the original state will be restored just for the
     * first group and not for all the group chain
     * @private
     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more
     * @return {fabric.Group} thisArg
     * @chainable
     */
    _restoreObjectsState: function() {
      var groupMatrix = this.calcOwnMatrix();
      this._objects.forEach(function(object) {
        // instead of using _this = this;
        fabric.util.addTransformToObject(object, groupMatrix);
        delete object.group;
        object.setCoords();
      });
      return this;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    destroy: function() {
      // when group is destroyed objects needs to get a repaint to be eventually
      // displayed on canvas.
      this._objects.forEach(function(object) {
        object.set('dirty', true);
      });
      return this._restoreObjectsState();
    },

    dispose: function () {
      this.callSuper('dispose');
      this.forEachObject(function (object) {
        object.dispose && object.dispose();
      });
      this._objects = [];
    },

    /**
     * make a group an active selection, remove the group from canvas
     * the group has to be on canvas for this to work.
     * @return {fabric.ActiveSelection} thisArg
     * @chainable
     */
    toActiveSelection: function() {
      if (!this.canvas) {
        return;
      }
      var objects = this._objects, canvas = this.canvas;
      this._objects = [];
      var options = this.toObject();
      delete options.objects;
      var activeSelection = new fabric.ActiveSelection([]);
      activeSelection.set(options);
      activeSelection.type = 'activeSelection';
      canvas.remove(this);
      objects.forEach(function(object) {
        object.group = activeSelection;
        object.dirty = true;
        canvas.add(object);
      });
      activeSelection.canvas = canvas;
      activeSelection._objects = objects;
      canvas._activeObject = activeSelection;
      activeSelection.setCoords();
      return activeSelection;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    ungroupOnCanvas: function() {
      return this._restoreObjectsState();
    },

    /**
     * Sets coordinates of all objects inside group
     * @return {fabric.Group} thisArg
     * @chainable
     */
    setObjectsCoords: function() {
      var skipControls = true;
      this.forEachObject(function(object) {
        object.setCoords(skipControls);
      });
      return this;
    },

    /**
     * @private
     */
    _calcBounds: function(onlyWidthHeight) {
      var aX = [],
          aY = [],
          o, prop, coords,
          props = ['tr', 'br', 'bl', 'tl'],
          i = 0, iLen = this._objects.length,
          j, jLen = props.length;

      for ( ; i < iLen; ++i) {
        o = this._objects[i];
        coords = o.calcACoords();
        for (j = 0; j < jLen; j++) {
          prop = props[j];
          aX.push(coords[prop].x);
          aY.push(coords[prop].y);
        }
        o.aCoords = coords;
      }

      this._getBounds(aX, aY, onlyWidthHeight);
    },

    /**
     * @private
     */
    _getBounds: function(aX, aY, onlyWidthHeight) {
      var minXY = new fabric.Point(min(aX), min(aY)),
          maxXY = new fabric.Point(max(aX), max(aY)),
          top = minXY.y || 0, left = minXY.x || 0,
          width = (maxXY.x - minXY.x) || 0,
          height = (maxXY.y - minXY.y) || 0;
      this.width = width;
      this.height = height;
      if (!onlyWidthHeight) {
        // the bounding box always finds the topleft most corner.
        // whatever is the group origin, we set up here the left/top position.
        this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
      }
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function(reviver) {
      var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t\t', this._objects[i].toSVG(reviver));
      }
      svgString.push('</g>\n');
      return svgString;
    },

    /**
     * Returns styles-string for svg-export, specific version for group
     * @return {String}
     */
    getSvgStyles: function() {
      var opacity = typeof this.opacity !== 'undefined' && this.opacity !== 1 ?
            'opacity: ' + this.opacity + ';' : '',
          visibility = this.visible ? '' : ' visibility: hidden;';
      return [
        opacity,
        this.getSvgFilter(),
        visibility
      ].join('');
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var svgString = [];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
      }

      return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Group} instance from an object representation
   * @static
   * @memberOf fabric.Group
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an group instance is created
   */
  fabric.Group.fromObject = function(object, callback) {
    var objects = object.objects,
        options = fabric.util.object.clone(object, true);
    delete options.objects;
    if (typeof objects === 'string') {
      // it has to be an url or something went wrong.
      fabric.loadSVGFromURL(objects, function (elements) {
        var group = fabric.util.groupSVGElements(elements, object, objects);
        group.set(options);
        callback && callback(group);
      });
      return;
    }
    fabric.util.enlivenObjects(objects, function (enlivenedObjects) {
      var options = fabric.util.object.clone(object, true);
      delete options.objects;
      fabric.util.enlivenObjectEnlivables(object, options, function () {
        callback && callback(new fabric.Group(enlivenedObjects, options, true));
      });
    });
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.ActiveSelection) {
    return;
  }

  /**
   * Group class
   * @class fabric.ActiveSelection
   * @extends fabric.Group
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
   */
  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'activeSelection',

    /**
     * Constructor
     * @param {Object} objects ActiveSelection objects
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(objects, options) {
      options = options || {};
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (options.originX) {
        this.originX = options.originX;
      }
      if (options.originY) {
        this.originY = options.originY;
      }
      this._calcBounds();
      this._updateObjectsCoords();
      fabric.Object.prototype.initialize.call(this, options);
      this.setCoords();
    },

    /**
     * Change te activeSelection to a normal group,
     * High level function that automatically adds it to canvas as
     * active object. no events fired.
     * @since 2.0.0
     * @return {fabric.Group}
     */
    toGroup: function() {
      var objects = this._objects.concat();
      this._objects = [];
      var options = fabric.Object.prototype.toObject.call(this);
      var newGroup = new fabric.Group([]);
      delete options.type;
      newGroup.set(options);
      objects.forEach(function(object) {
        object.canvas.remove(object);
        object.group = newGroup;
      });
      newGroup._objects = objects;
      if (!this.canvas) {
        return newGroup;
      }
      var canvas = this.canvas;
      canvas.add(newGroup);
      canvas._activeObject = newGroup;
      newGroup.setCoords();
      return newGroup;
    },

    /**
     * If returns true, deselection is cancelled.
     * @since 2.0.0
     * @return {Boolean} [cancel]
     */
    onDeselect: function() {
      this.destroy();
      return false;
    },

    /**
     * Returns string representation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return false;
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     * @param {Object} [childrenOverride] properties to override the children overrides
     */
    _renderControls: function(ctx, styleOverride, childrenOverride) {
      ctx.save();
      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      this.callSuper('_renderControls', ctx, styleOverride);
      childrenOverride = childrenOverride || { };
      if (typeof childrenOverride.hasControls === 'undefined') {
        childrenOverride.hasControls = false;
      }
      childrenOverride.forActiveSelection = true;
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i]._renderControls(ctx, childrenOverride);
      }
      ctx.restore();
    },
  });

  /**
   * Returns {@link fabric.ActiveSelection} instance from an object representation
   * @static
   * @memberOf fabric.ActiveSelection
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
   */
  fabric.ActiveSelection.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      delete object.objects;
      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
    });
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var extend = fabric.util.object.extend;

  if (!global.fabric) {
    global.fabric = { };
  }

  if (global.fabric.Image) {
    fabric.warn('fabric.Image is already defined.');
    return;
  }

  /**
   * Image class
   * @class fabric.Image
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
   * @see {@link fabric.Image#initialize} for constructor definition
   */
  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'image',

    /**
     * Width of a stroke.
     * For image quality a stroke multiple of 2 gives better results.
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.
     * This allows for relative urls as image src.
     * @since 2.7.0
     * @type Boolean
     * @default
     */
    srcFromAttribute: false,

    /**
     * private
     * contains last value of scaleX to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleX: 1,

    /**
     * private
     * contains last value of scaleY to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleY: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingX: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingY: 1,

    /**
     * minimum scale factor under which any resizeFilter is triggered to resize the image
     * 0 will disable the automatic resize. 1 will trigger automatically always.
     * number bigger than 1 are not implemented yet.
     * @type Number
     */
    minimumScaleTrigger: 0.5,

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

    /**
     * List of properties to consider when checking if cache needs refresh
     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
     * and refreshed at the next render
     * @type Array
     */
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('cropX', 'cropY'),

    /**
     * key used to retrieve the texture representing this image
     * @since 2.0.0
     * @type String
     * @default
     */
    cacheKey: '',

    /**
     * Image crop in pixels from original image size.
     * @since 2.0.0
     * @type Number
     * @default
     */
    cropX: 0,

    /**
     * Image crop in pixels from original image size.
     * @since 2.0.0
     * @type Number
     * @default
     */
    cropY: 0,

    /**
     * Indicates whether this canvas will use image smoothing when painting this image.
     * Also influence if the cacheCanvas for this image uses imageSmoothing
     * @since 4.0.0-beta.11
     * @type Boolean
     * @default
     */
    imageSmoothing: true,

    /**
     * Constructor
     * Image can be initialized with any canvas drawable or a string.
     * The string should be a url and will be loaded as an image.
     * Canvas and Image element work out of the box, while videos require extra code to work.
     * Please check video element events for seeking.
     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element
     * @param {Object} [options] Options object
     * @param {function} [callback] callback function to call after eventual filters applied.
     * @return {fabric.Image} thisArg
     */
    initialize: function(element, options) {
      options || (options = { });
      this.filters = [];
      this.cacheKey = 'texture' + fabric.Object.__uid++;
      this.callSuper('initialize', options);
      this._initElement(element, options);
    },

    /**
     * Returns image element which this instance if based on
     * @return {HTMLImageElement} Image element
     */
    getElement: function() {
      return this._element || {};
    },

    /**
     * Sets image element for this instance to a specified one.
     * If filters defined they are applied to new image.
     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
     * @param {HTMLImageElement} element
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setElement: function(element, options) {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._element = element;
      this._originalElement = element;
      this._initConfig(options);
      if (this.filters.length !== 0) {
        this.applyFilters();
      }
      // resizeFilters work on the already filtered copy.
      // we need to apply resizeFilters AFTER normal filters.
      // applyResizeFilters is run more often than normal filters
      // and is triggered by user interactions rather than dev code
      if (this.resizeFilter) {
        this.applyResizeFilters();
      }
      return this;
    },

    /**
     * Delete a single texture if in webgl mode
     */
    removeTexture: function(key) {
      var backend = fabric.filterBackend;
      if (backend && backend.evictCachesForKey) {
        backend.evictCachesForKey(key);
      }
    },

    /**
     * Delete textures, reference to elements and eventually JSDOM cleanup
     */
    dispose: function () {
      this.callSuper('dispose');
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._cacheContext = undefined;
      ['_originalElement', '_element', '_filteredEl', '_cacheCanvas'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
    },

    /**
     * Get the crossOrigin value (of the corresponding image element)
     */
    getCrossOrigin: function() {
      return this._originalElement && (this._originalElement.crossOrigin || null);
    },

    /**
     * Returns original size of an image
     * @return {Object} Object with "width" and "height" properties
     */
    getOriginalSize: function() {
      var element = this.getElement();
      return {
        width: element.naturalWidth || element.width,
        height: element.naturalHeight || element.height
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _stroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }
      var w = this.width / 2, h = this.height / 2;
      ctx.beginPath();
      ctx.moveTo(-w, -h);
      ctx.lineTo(w, -h);
      ctx.lineTo(w, h);
      ctx.lineTo(-w, h);
      ctx.lineTo(-w, -h);
      ctx.closePath();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var filters = [];

      this.filters.forEach(function(filterObj) {
        if (filterObj) {
          filters.push(filterObj.toObject());
        }
      });
      var object = extend(
        this.callSuper(
          'toObject',
          ['cropX', 'cropY'].concat(propertiesToInclude)
        ), {
          src: this.getSrc(),
          crossOrigin: this.getCrossOrigin(),
          filters: filters,
        });
      if (this.resizeFilter) {
        object.resizeFilter = this.resizeFilter.toObject();
      }
      return object;
    },

    /**
     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.
     * @return {Boolean}
     */
    hasCrop: function() {
      return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString = [], imageMarkup = [], strokeSvg, element = this._element,
          x = -this.width / 2, y = -this.height / 2, clipPath = '', imageRendering = '';
      if (!element) {
        return [];
      }
      if (this.hasCrop()) {
        var clipPathId = fabric.Object.__uid++;
        svgString.push(
          '<clipPath id="imageCrop_' + clipPathId + '">\n',
          '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
          '</clipPath>\n'
        );
        clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
      }
      if (!this.imageSmoothing) {
        imageRendering = '" image-rendering="optimizeSpeed';
      }
      imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(true),
        '" x="', x - this.cropX, '" y="', y - this.cropY,
        // we're essentially moving origin of transformation from top/left corner to the center of the shape
        // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
        // so that object's center aligns with container's left/top
        '" width="', element.width || element.naturalWidth,
        '" height="', element.height || element.height,
        imageRendering,
        '"', clipPath,
        '></image>\n');

      if (this.stroke || this.strokeDashArray) {
        var origFill = this.fill;
        this.fill = null;
        strokeSvg = [
          '\t<rect ',
          'x="', x, '" y="', y,
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '"/>\n'
        ];
        this.fill = origFill;
      }
      if (this.paintFirst !== 'fill') {
        svgString = svgString.concat(strokeSvg, imageMarkup);
      }
      else {
        svgString = svgString.concat(imageMarkup, strokeSvg);
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * Returns source of an image
     * @param {Boolean} filtered indicates if the src is needed for svg
     * @return {String} Source of an image
     */
    getSrc: function(filtered) {
      var element = filtered ? this._element : this._originalElement;
      if (element) {
        if (element.toDataURL) {
          return element.toDataURL();
        }

        if (this.srcFromAttribute) {
          return element.getAttribute('src');
        }
        else {
          return element.src;
        }
      }
      else {
        return this.src || '';
      }
    },

    /**
     * Sets source of an image
     * @param {String} src Source string (URL)
     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
     * @param {Object} [options] Options object
     * @param {String} [options.crossOrigin] crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setSrc: function(src, callback, options) {
      fabric.util.loadImage(src, function(img, isError) {
        this.setElement(img, options);
        this._setWidthHeight();
        callback && callback(this, isError);
      }, this, options && options.crossOrigin);
      return this;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of an instance
     */
    toString: function() {
      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
    },

    applyResizeFilters: function() {
      var filter = this.resizeFilter,
          minimumScale = this.minimumScaleTrigger,
          objectScale = this.getTotalObjectScaling(),
          scaleX = objectScale.scaleX,
          scaleY = objectScale.scaleY,
          elementToFilter = this._filteredEl || this._originalElement;
      if (this.group) {
        this.set('dirty', true);
      }
      if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
        this._element = elementToFilter;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        this._lastScaleX = scaleX;
        this._lastScaleY = scaleY;
        return;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      var canvasEl = fabric.util.createCanvasElement(),
          cacheKey = this._filteredEl ? (this.cacheKey + '_filtered') : this.cacheKey,
          sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
      canvasEl.width = sourceWidth;
      canvasEl.height = sourceHeight;
      this._element = canvasEl;
      this._lastScaleX = filter.scaleX = scaleX;
      this._lastScaleY = filter.scaleY = scaleY;
      fabric.filterBackend.applyFilters(
        [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
      this._filterScalingX = canvasEl.width / this._originalElement.width;
      this._filterScalingY = canvasEl.height / this._originalElement.height;
    },

    /**
     * Applies filters assigned to this image (from "filters" array) or from filter param
     * @method applyFilters
     * @param {Array} filters to be applied
     * @param {Boolean} forResizing specify if the filter operation is a resize operation
     * @return {thisArg} return the fabric.Image object
     * @chainable
     */
    applyFilters: function(filters) {

      filters = filters || this.filters || [];
      filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
      this.set('dirty', true);

      // needs to clear out or WEBGL will not resize correctly
      this.removeTexture(this.cacheKey + '_filtered');

      if (filters.length === 0) {
        this._element = this._originalElement;
        this._filteredEl = null;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        return this;
      }

      var imgElement = this._originalElement,
          sourceWidth = imgElement.naturalWidth || imgElement.width,
          sourceHeight = imgElement.naturalHeight || imgElement.height;

      if (this._element === this._originalElement) {
        // if the element is the same we need to create a new element
        var canvasEl = fabric.util.createCanvasElement();
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        this._filteredEl = canvasEl;
      }
      else {
        // clear the existing element to get new filter data
        // also dereference the eventual resized _element
        this._element = this._filteredEl;
        this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
        // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y
        this._lastScaleX = 1;
        this._lastScaleY = 1;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      fabric.filterBackend.applyFilters(
        filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
      if (this._originalElement.width !== this._element.width ||
        this._originalElement.height !== this._element.height) {
        this._filterScalingX = this._element.width / this._originalElement.width;
        this._filterScalingY = this._element.height / this._originalElement.height;
      }
      return this;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
      if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
        this.applyResizeFilters();
      }
      this._stroke(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * it will set the imageSmoothing for the draw operation
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
      fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * This is the special image version where we would like to avoid caching where possible.
     * Essentially images do not benefit from caching. They may require caching, and in that
     * case we do it. Also caching an image usually ends in a loss of details.
     * A full performance audit should be done.
     * @return {Boolean}
     */
    shouldCache: function() {
      return this.needsItsOwnCache();
    },

    _renderFill: function(ctx) {
      var elementToDraw = this._element;
      if (!elementToDraw) {
        return;
      }
      var scaleX = this._filterScalingX, scaleY = this._filterScalingY,
          w = this.width, h = this.height, min = Math.min, max = Math.max,
          // crop values cannot be lesser than 0.
          cropX = max(this.cropX, 0), cropY = max(this.cropY, 0),
          elWidth = elementToDraw.naturalWidth || elementToDraw.width,
          elHeight = elementToDraw.naturalHeight || elementToDraw.height,
          sX = cropX * scaleX,
          sY = cropY * scaleY,
          // the width height cannot exceed element width/height, starting from the crop offset.
          sW = min(w * scaleX, elWidth - sX),
          sH = min(h * scaleY, elHeight - sY),
          x = -w / 2, y = -h / 2,
          maxDestW = min(w, elWidth / scaleX - cropX),
          maxDestH = min(h, elHeight / scaleY - cropY);

      elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);
    },

    /**
     * needed to check if image needs resize
     * @private
     */
    _needsResize: function() {
      var scale = this.getTotalObjectScaling();
      return (scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY);
    },

    /**
     * @private
     */
    _resetWidthHeight: function() {
      this.set(this.getOriginalSize());
    },

    /**
     * The Image class's initialization method. This method is automatically
     * called by the constructor.
     * @private
     * @param {HTMLImageElement|String} element The element representing the image
     * @param {Object} [options] Options object
     */
    _initElement: function(element, options) {
      this.setElement(fabric.util.getById(element), options);
      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initConfig: function(options) {
      options || (options = { });
      this.setOptions(options);
      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Array} filters to be initialized
     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
     */
    _initFilters: function(filters, callback) {
      if (filters && filters.length) {
        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
          callback && callback(enlivenedObjects);
        }, 'fabric.Image.filters');
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * Set the width and the height of the image object, using the element or the
     * options.
     * @param {Object} [options] Object with width/height properties
     */
    _setWidthHeight: function(options) {
      options || (options = { });
      var el = this.getElement();
      this.width = options.width || el.naturalWidth || el.width || 0;
      this.height = options.height || el.naturalHeight || el.height || 0;
    },

    /**
     * Calculate offset for center and scale factor for the image in order to respect
     * the preserveAspectRatio attribute
     * @private
     * @return {Object}
     */
    parsePreserveAspectRatioAttribute: function() {
      var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
          rWidth = this._element.width, rHeight = this._element.height,
          scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
          offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
      if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
        if (pAR.meetOrSlice === 'meet') {
          scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
          offset = (pWidth - rWidth * scaleX) / 2;
          if (pAR.alignX === 'Min') {
            offsetLeft = -offset;
          }
          if (pAR.alignX === 'Max') {
            offsetLeft = offset;
          }
          offset = (pHeight - rHeight * scaleY) / 2;
          if (pAR.alignY === 'Min') {
            offsetTop = -offset;
          }
          if (pAR.alignY === 'Max') {
            offsetTop = offset;
          }
        }
        if (pAR.meetOrSlice === 'slice') {
          scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
          offset = rWidth - pWidth / scaleX;
          if (pAR.alignX === 'Mid') {
            cropX = offset / 2;
          }
          if (pAR.alignX === 'Max') {
            cropX = offset;
          }
          offset = rHeight - pHeight / scaleY;
          if (pAR.alignY === 'Mid') {
            cropY = offset / 2;
          }
          if (pAR.alignY === 'Max') {
            cropY = offset;
          }
          rWidth = pWidth / scaleX;
          rHeight = pHeight / scaleY;
        }
      }
      else {
        scaleX = pWidth / rWidth;
        scaleY = pHeight / rHeight;
      }
      return {
        width: rWidth,
        height: rHeight,
        scaleX: scaleX,
        scaleY: scaleY,
        offsetLeft: offsetLeft,
        offsetTop: offsetTop,
        cropX: cropX,
        cropY: cropY
      };
    }
  });

  /**
   * Default CSS class name for canvas
   * @static
   * @type String
   * @default
   */
  fabric.Image.CSS_CANVAS = 'canvas-img';

  /**
   * Alias for getSrc
   * @static
   */
  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

  /**
   * Creates an instance of fabric.Image from its object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} callback Callback to invoke when an image instance is created
   */
  fabric.Image.fromObject = function(_object, callback) {
    var object = fabric.util.object.clone(_object);
    fabric.util.loadImage(object.src, function(img, isError) {
      if (isError) {
        callback && callback(null, true);
        return;
      }
      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
        object.filters = filters || [];
        fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
          object.resizeFilter = resizeFilters[0];
          fabric.util.enlivenObjectEnlivables(object, object, function () {
            var image = new fabric.Image(img, object);
            callback(image, false);
          });
        });
      });
    }, null, object.crossOrigin);
  };

  /**
   * Creates an instance of fabric.Image from an URL string
   * @static
   * @param {String} url URL to create an image from
   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.
   * @param {Object} [imgOptions] Options object
   */
  fabric.Image.fromURL = function(url, callback, imgOptions) {
    fabric.util.loadImage(url, function(img, isError) {
      callback && callback(new fabric.Image(img, imgOptions), isError);
    }, null, imgOptions && imgOptions.crossOrigin);
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
   * @static
   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
   */
  fabric.Image.ATTRIBUTE_NAMES =
    fabric.SHARED_ATTRIBUTES.concat(
      'x y width height preserveAspectRatio xlink:href crossOrigin image-rendering'.split(' ')
    );

  /**
   * Returns {@link fabric.Image} instance from an SVG element
   * @static
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} callback Callback to execute when fabric.Image object is created
   * @return {fabric.Image} Instance of fabric.Image
   */
  fabric.Image.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
  };
  /* _FROM_SVG_END_ */

})(typeof exports !== 'undefined' ? exports : this);
fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * @private
   * @return {Number} angle value
   */
  _getAngleValueForStraighten: function() {
    var angle = this.angle % 360;
    if (angle > 0) {
      return Math.round((angle - 1) / 90) * 90;
    }
    return Math.round(angle / 90) * 90;
  },

  /**
   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  straighten: function() {
    return this.rotate(this._getAngleValueForStraighten());
  },

  /**
   * Same as {@link fabric.Object.prototype.straighten} but with animation
   * @param {Object} callbacks Object with callback functions
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Object} thisArg
   */
  fxStraighten: function(callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    return fabric.util.animate({
      target: this,
      startValue: this.get('angle'),
      endValue: this._getAngleValueForStraighten(),
      duration: this.FX_DURATION,
      onChange: function(value) {
        _this.rotate(value);
        onChange();
      },
      onComplete: function() {
        _this.setCoords();
        onComplete();
      },
    });
  }
});

fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Straightens object, then rerenders canvas
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  straightenObject: function (object) {
    object.straighten();
    this.requestRenderAll();
    return this;
  },

  /**
   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   */
  fxStraightenObject: function (object) {
    return object.fxStraighten({
      onChange: this.requestRenderAllBound
    });
  }
});
(function() {

  'use strict';

  /**
   * Tests if webgl supports certain precision
   * @param {WebGL} Canvas WebGL context to test on
   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
   * @returns {Boolean} Whether the user's browser WebGL supports given precision.
   */
  function testPrecision(gl, precision){
    var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    return true;
  }

  /**
   * Indicate whether this filtering backend is supported by the user's browser.
   * @param {Number} tileSize check if the tileSize is supported
   * @returns {Boolean} Whether the user's browser supports WebGL.
   */
  fabric.isWebglSupported = function(tileSize) {
    if (fabric.isLikelyNode) {
      return false;
    }
    tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    var isSupported = false;
    // eslint-disable-next-line
    if (gl) {
      fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      isSupported = fabric.maxTextureSize >= tileSize;
      var precisions = ['highp', 'mediump', 'lowp'];
      for (var i = 0; i < 3; i++){
        if (testPrecision(gl, precisions[i])){
          fabric.webGlPrecision = precisions[i];
          break;
        };
      }
    }
    this.isSupported = isSupported;
    return isSupported;
  };

  fabric.WebglFilterBackend = WebglFilterBackend;

  /**
   * WebGL filter backend.
   */
  function WebglFilterBackend(options) {
    if (options && options.tileSize) {
      this.tileSize = options.tileSize;
    }
    this.setupGLContext(this.tileSize, this.tileSize);
    this.captureGPUInfo();
  };

  WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

    tileSize: 2048,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
     */
    setupGLContext: function(width, height) {
      this.dispose();
      this.createWebGLCanvas(width, height);
      // eslint-disable-next-line
      this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
      this.chooseFastestCopyGLTo2DMethod(width, height);
    },

    /**
     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
     * putImageData is faster than drawImage for that specific operation.
     */
    chooseFastestCopyGLTo2DMethod: function(width, height) {
      var canMeasurePerf = typeof window.performance !== 'undefined', canUseImageData;
      try {
        new ImageData(1, 1);
        canUseImageData = true;
      }
      catch (e) {
        canUseImageData = false;
      }
      // eslint-disable-next-line no-undef
      var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
      // eslint-disable-next-line no-undef
      var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

      if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
        return;
      }

      var targetCanvas = fabric.util.createCanvasElement();
      // eslint-disable-next-line no-undef
      var imageBuffer = new ArrayBuffer(width * height * 4);
      if (fabric.forceGLPutImageData) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
        return;
      }
      var testContext = {
        imageBuffer: imageBuffer,
        destinationWidth: width,
        destinationHeight: height,
        targetCanvas: targetCanvas
      };
      var startTime, drawImageTime, putImageDataTime;
      targetCanvas.width = width;
      targetCanvas.height = height;

      startTime = window.performance.now();
      copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
      drawImageTime = window.performance.now() - startTime;

      startTime = window.performance.now();
      copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
      putImageDataTime = window.performance.now() - startTime;

      if (drawImageTime > putImageDataTime) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
      }
      else {
        this.copyGLTo2D = copyGLTo2DDrawImage;
      }
    },

    /**
     * Create a canvas element and associated WebGL context and attaches them as
     * class properties to the GLFilterBackend class.
     */
    createWebGLCanvas: function(width, height) {
      var canvas = fabric.util.createCanvasElement();
      canvas.width = width;
      canvas.height = height;
      var glOptions = {
            alpha: true,
            premultipliedAlpha: false,
            depth: false,
            stencil: false,
            antialias: false
          },
          gl = canvas.getContext('webgl', glOptions);
      if (!gl) {
        gl = canvas.getContext('experimental-webgl', glOptions);
      }
      if (!gl) {
        return;
      }
      gl.clearColor(0, 0, 0, 0);
      // this canvas can fire webglcontextlost and webglcontextrestored
      this.canvas = canvas;
      this.gl = gl;
    },

    /**
     * Attempts to apply the requested filters to the source provided, drawing the filtered output
     * to the provided target canvas.
     *
     * @param {Array} filters The filters to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
     * @param {Number} width The width of the source input.
     * @param {Number} height The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
     * omitted, caching will be skipped.
     */
    applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
      var gl = this.gl;
      var cachedTexture;
      if (cacheKey) {
        cachedTexture = this.getCachedTexture(cacheKey, source);
      }
      var pipelineState = {
        originalWidth: source.width || source.originalWidth,
        originalHeight: source.height || source.originalHeight,
        sourceWidth: width,
        sourceHeight: height,
        destinationWidth: width,
        destinationHeight: height,
        context: gl,
        sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
        targetTexture: this.createTexture(gl, width, height),
        originalTexture: cachedTexture ||
          this.createTexture(gl, width, height, !cachedTexture && source),
        passes: filters.length,
        webgl: true,
        aPosition: this.aPosition,
        programCache: this.programCache,
        pass: 0,
        filterBackend: this,
        targetCanvas: targetCanvas
      };
      var tempFbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
      filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
      resizeCanvasIfNeeded(pipelineState);
      this.copyGLTo2D(gl, pipelineState);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.deleteTexture(pipelineState.sourceTexture);
      gl.deleteTexture(pipelineState.targetTexture);
      gl.deleteFramebuffer(tempFbo);
      targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
      return pipelineState;
    },

    /**
     * Detach event listeners, remove references, and clean up caches.
     */
    dispose: function() {
      if (this.canvas) {
        this.canvas = null;
        this.gl = null;
      }
      this.clearWebGLCaches();
    },

    /**
     * Wipe out WebGL-related caches.
     */
    clearWebGLCaches: function() {
      this.programCache = {};
      this.textureCache = {};
    },

    /**
     * Create a WebGL texture object.
     *
     * Accepts specific dimensions to initialize the texture to or a source image.
     *
     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
     * @param {Number} width The width to initialize the texture at.
     * @param {Number} height The height to initialize the texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
     * @returns {WebGLTexture}
     */
    createTexture: function(gl, width, height, textureImageSource) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (textureImageSource) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
      }
      else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      return texture;
    },

    /**
     * Can be optionally used to get a texture from the cache array
     *
     * If an existing texture is not found, a new texture is created and cached.
     *
     * @param {String} uniqueId A cache key to use to find an existing texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
     * texture cache entry if one does not already exist.
     */
    getCachedTexture: function(uniqueId, textureImageSource) {
      if (this.textureCache[uniqueId]) {
        return this.textureCache[uniqueId];
      }
      else {
        var texture = this.createTexture(
          this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
        this.textureCache[uniqueId] = texture;
        return texture;
      }
    },

    /**
     * Clear out cached resources related to a source image that has been
     * filtered previously.
     *
     * @param {String} cacheKey The cache key provided when the source image was filtered.
     */
    evictCachesForKey: function(cacheKey) {
      if (this.textureCache[cacheKey]) {
        this.gl.deleteTexture(this.textureCache[cacheKey]);
        delete this.textureCache[cacheKey];
      }
    },

    copyGLTo2D: copyGLTo2DDrawImage,

    /**
     * Attempt to extract GPU information strings from a WebGL context.
     *
     * Useful information when debugging or blacklisting specific GPUs.
     *
     * @returns {Object} A GPU info object with renderer and vendor strings.
     */
    captureGPUInfo: function() {
      if (this.gpuInfo) {
        return this.gpuInfo;
      }
      var gl = this.gl, gpuInfo = { renderer: '', vendor: '' };
      if (!gl) {
        return gpuInfo;
      }
      var ext = gl.getExtension('WEBGL_debug_renderer_info');
      if (ext) {
        var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
        var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
        if (renderer) {
          gpuInfo.renderer = renderer.toLowerCase();
        }
        if (vendor) {
          gpuInfo.vendor = vendor.toLowerCase();
        }
      }
      this.gpuInfo = gpuInfo;
      return gpuInfo;
    },
  };
})();

function resizeCanvasIfNeeded(pipelineState) {
  var targetCanvas = pipelineState.targetCanvas,
      width = targetCanvas.width, height = targetCanvas.height,
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight;

  if (width !== dWidth || height !== dHeight) {
    targetCanvas.width = dWidth;
    targetCanvas.height = dHeight;
  }
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas.
 *
 * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
 * desired output image appearing in the bottom-left corner of the WebGL canvas.
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DDrawImage(gl, pipelineState) {
  var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
      ctx = targetCanvas.getContext('2d');
  ctx.translate(0, targetCanvas.height); // move it down again
  ctx.scale(1, -1); // vertical flip
  // where is my image on the big glcanvas?
  var sourceY = glCanvas.height - targetCanvas.height;
  ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
    targetCanvas.width, targetCanvas.height);
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
 * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DPutImageData(gl, pipelineState) {
  var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight,
      numBytes = dWidth * dHeight * 4;

  // eslint-disable-next-line no-undef
  var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
  // eslint-disable-next-line no-undef
  var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

  gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
  var imgData = new ImageData(u8Clamped, dWidth, dHeight);
  ctx.putImageData(imgData, 0, 0);
}
(function() {

  'use strict';

  var noop = function() {};

  fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

  /**
   * Canvas 2D filter backend.
   */
  function Canvas2dFilterBackend() {};

  Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
    evictCachesForKey: noop,
    dispose: noop,
    clearWebGLCaches: noop,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Apply a set of filters against a source image and draw the filtered output
     * to the provided destination canvas.
     *
     * @param {EnhancedFilter} filters The filter to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
     * @param {Number} sourceWidth The width of the source input.
     * @param {Number} sourceHeight The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     */
    applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
      var ctx = targetCanvas.getContext('2d');
      ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
      var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var pipelineState = {
        sourceWidth: sourceWidth,
        sourceHeight: sourceHeight,
        imageData: imageData,
        originalEl: sourceElement,
        originalImageData: originalImageData,
        canvasEl: targetCanvas,
        ctx: ctx,
        filterBackend: this,
      };
      filters.forEach(function(filter) { filter.applyTo(pipelineState); });
      if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
        targetCanvas.width = pipelineState.imageData.width;
        targetCanvas.height = pipelineState.imageData.height;
      }
      ctx.putImageData(pipelineState.imageData, 0, 0);
      return pipelineState;
    },

  };
})();
/**
 * @namespace fabric.Image.filters
 * @memberOf fabric.Image
 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
 */
fabric.Image = fabric.Image || { };
fabric.Image.filters = fabric.Image.filters || { };

/**
 * Root filter class from which all filter classes inherit from
 * @class fabric.Image.filters.BaseFilter
 * @memberOf fabric.Image.filters
 */
fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

  /**
   * Filter type
   * @param {String} type
   * @default
   */
  type: 'BaseFilter',

  /**
   * Array of attributes to send with buffers. do not modify
   * @private
   */

  vertexSource: 'attribute vec2 aPosition;\n' +
    'varying vec2 vTexCoord;\n' +
    'void main() {\n' +
      'vTexCoord = aPosition;\n' +
      'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
    '}',

  fragmentSource: 'precision highp float;\n' +
    'varying vec2 vTexCoord;\n' +
    'uniform sampler2D uTexture;\n' +
    'void main() {\n' +
      'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
    '}',

  /**
   * Constructor
   * @param {Object} [options] Options object
   */
  initialize: function(options) {
    if (options) {
      this.setOptions(options);
    }
  },

  /**
   * Sets filter's properties from options
   * @param {Object} [options] Options object
   */
  setOptions: function(options) {
    for (var prop in options) {
      this[prop] = options[prop];
    }
  },

  /**
   * Compile this filter's shader program.
   *
   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
   * @param {String} fragmentSource fragmentShader source for compilation
   * @param {String} vertexSource vertexShader source for compilation
   */
  createProgram: function(gl, fragmentSource, vertexSource) {
    fragmentSource = fragmentSource || this.fragmentSource;
    vertexSource = vertexSource || this.vertexSource;
    if (fabric.webGlPrecision !== 'highp'){
      fragmentSource = fragmentSource.replace(
        /precision highp float/g,
        'precision ' + fabric.webGlPrecision + ' float'
      );
    }
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Vertex shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(vertexShader)
      );
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Fragment shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(fragmentShader)
      );
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Shader link error for "${this.type}" ' +
        gl.getProgramInfoLog(program)
      );
    }

    var attributeLocations = this.getAttributeLocations(gl, program);
    var uniformLocations = this.getUniformLocations(gl, program) || { };
    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
    return {
      program: program,
      attributeLocations: attributeLocations,
      uniformLocations: uniformLocations
    };
  },

  /**
   * Return a map of attribute names to WebGLAttributeLocation objects.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
   * @returns {Object} A map of attribute names to attribute locations.
   */
  getAttributeLocations: function(gl, program) {
    return {
      aPosition: gl.getAttribLocation(program, 'aPosition'),
    };
  },

  /**
   * Return a map of uniform names to WebGLUniformLocation objects.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
   * @returns {Object} A map of uniform names to uniform locations.
   */
  getUniformLocations: function (/* gl, program */) {
    // in case i do not need any special uniform i need to return an empty object
    return { };
  },

  /**
   * Send attribute data from this filter to its shader program on the GPU.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} attributeLocations A map of shader attribute names to their locations.
   */
  sendAttributeData: function(gl, attributeLocations, aPositionData) {
    var attributeLocation = attributeLocations.aPosition;
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(attributeLocation);
    gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
  },

  _setupFrameBuffer: function(options) {
    var gl = options.context, width, height;
    if (options.passes > 1) {
      width = options.destinationWidth;
      height = options.destinationHeight;
      if (options.sourceWidth !== width || options.sourceHeight !== height) {
        gl.deleteTexture(options.targetTexture);
        options.targetTexture = options.filterBackend.createTexture(gl, width, height);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        options.targetTexture, 0);
    }
    else {
      // draw last filter on canvas and not to framebuffer.
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.finish();
    }
  },

  _swapTextures: function(options) {
    options.passes--;
    options.pass++;
    var temp = options.targetTexture;
    options.targetTexture = options.sourceTexture;
    options.sourceTexture = temp;
  },

  /**
   * Generic isNeutral implementation for one parameter based filters.
   * Used only in image applyFilters to discard filters that will not have an effect
   * on the image
   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )
   * @param {Object} options
   **/
  isNeutralState: function(/* options */) {
    var main = this.mainParameter,
        _class = fabric.Image.filters[this.type].prototype;
    if (main) {
      if (Array.isArray(_class[main])) {
        for (var i = _class[main].length; i--;) {
          if (this[main][i] !== _class[main][i]) {
            return false;
          }
        }
        return true;
      }
      else {
        return _class[main] === this[main];
      }
    }
    else {
      return false;
    }
  },

  /**
   * Apply this filter to the input image data provided.
   *
   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyTo: function(options) {
    if (options.webgl) {
      this._setupFrameBuffer(options);
      this.applyToWebGL(options);
      this._swapTextures(options);
    }
    else {
      this.applyTo2d(options);
    }
  },

  /**
   * Retrieves the cached shader.
   * @param {Object} options
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  retrieveShader: function(options) {
    if (!options.programCache.hasOwnProperty(this.type)) {
      options.programCache[this.type] = this.createProgram(options.context);
    }
    return options.programCache[this.type];
  },

  /**
   * Apply this filter using webgl.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.originalTexture The texture of the original input image.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyToWebGL: function(options) {
    var gl = options.context;
    var shader = this.retrieveShader(options);
    if (options.pass === 0 && options.originalTexture) {
      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
    }
    else {
      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
    }
    gl.useProgram(shader.program);
    this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

    this.sendUniformData(gl, shader.uniformLocations);
    gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  },

  bindAdditionalTexture: function(gl, texture, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // reset active texture to 0 as usual
    gl.activeTexture(gl.TEXTURE0);
  },

  unbindAdditionalTexture: function(gl, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.activeTexture(gl.TEXTURE0);
  },

  getMainParameter: function() {
    return this[this.mainParameter];
  },

  setMainParameter: function(value) {
    this[this.mainParameter] = value;
  },

  /**
   * Send uniform data from this filter to its shader program on the GPU.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} uniformLocations A map of shader uniform names to their locations.
   */
  sendUniformData: function(/* gl, uniformLocations */) {
    // Intentionally left blank.  Override me in subclasses.
  },

  /**
   * If needed by a 2d filter, this functions can create an helper canvas to be used
   * remember that options.targetCanvas is available for use till end of chain.
   */
  createHelpLayer: function(options) {
    if (!options.helpLayer) {
      var helpLayer = document.createElement('canvas');
      helpLayer.width = options.sourceWidth;
      helpLayer.height = options.sourceHeight;
      options.helpLayer = helpLayer;
    }
  },

  /**
   * Returns object representation of an instance
   * @return {Object} Object representation of an instance
   */
  toObject: function() {
    var object = { type: this.type }, mainP = this.mainParameter;
    if (mainP) {
      object[mainP] = this[mainP];
    }
    return object;
  },

  /**
   * Returns a JSON representation of an instance
   * @return {Object} JSON
   */
  toJSON: function() {
    // delegate, not alias
    return this.toObject();
  }
});

fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
  var filter = new fabric.Image.filters[object.type](object);
  callback && callback(filter);
  return filter;
};
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Matrix filter class
   * @class fabric.Image.filters.ColorMatrix
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
   * @example <caption>Kodachrome filter</caption>
   * var filter = new fabric.Image.filters.ColorMatrix({
   *  matrix: [
       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
       0, 0, 0, 1, 0
      ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'ColorMatrix',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform mat4 uColorMatrix;\n' +
      'uniform vec4 uConstants;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color *= uColorMatrix;\n' +
        'color += uConstants;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Colormatrix for pixels.
     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
     * outside the -1, 1 range.
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Array} matrix array of 20 numbers.
     * @default
     */
    matrix: [
      1, 0, 0, 0, 0,
      0, 1, 0, 0, 0,
      0, 0, 1, 0, 0,
      0, 0, 0, 1, 0
    ],

    mainParameter: 'matrix',

    /**
     * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario
     * to save some calculation
     * @type Boolean
     * @default true
     */
    colorsOnly: true,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.matrix = this.matrix.slice(0);
    },

    /**
     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = data.length,
          m = this.matrix,
          r, g, b, a, i, colorsOnly = this.colorsOnly;

      for (i = 0; i < iLen; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        if (colorsOnly) {
          data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
        }
        else {
          a = data[i + 3];
          data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
          data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
        uConstants: gl.getUniformLocation(program, 'uConstants'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var m = this.matrix,
          matrix = [
            m[0], m[1], m[2], m[3],
            m[5], m[6], m[7], m[8],
            m[10], m[11], m[12], m[13],
            m[15], m[16], m[17], m[18]
          ],
          constants = [m[4], m[9], m[14], m[19]];
      gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
      gl.uniform4fv(uniformLocations.uConstants, constants);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] function to invoke after filter creation
   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
   */
  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Brightness filter class
   * @class fabric.Image.filters.Brightness
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Brightness({
   *   brightness: 0.05
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Brightness',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBrightness;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += uBrightness;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Brightness value, from -1 to 1.
     * translated to -255 to 255 for 2d
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Number} brightness
     * @default
     */
    brightness: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'brightness',

    /**
    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
    *
    * @param {Object} options
    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
    */
    applyTo2d: function(options) {
      if (this.brightness === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          brightness = Math.round(this.brightness * 255);
      for (i = 0; i < len; i += 4) {
        data[i] = data[i] + brightness;
        data[i + 1] = data[i + 1] + brightness;
        data[i + 2] = data[i + 2] + brightness;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBrightness: gl.getUniformLocation(program, 'uBrightness'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBrightness, this.brightness);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
   */
  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
   * @class fabric.Image.filters.Convolute
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example <caption>Sharpen filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 0, -1,  0,
   *            -1,  5, -1,
   *             0, -1,  0 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Blur filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter with opaqueness</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   opaque: true,
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Convolute',

    /*
     * Opaque value (true/false)
     */
    opaque: false,

    /*
     * matrix for the filter, max 9x9
     */
    matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: {
      Convolute_3_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_3_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_5_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_5_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_7_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_7_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_9_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_9_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
    },

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Convolute.prototype
     * @param {Object} [options] Options object
     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
     * @param {Array} [options.matrix] Filter matrix
     */


    /**
    * Retrieves the cached shader.
    * @param {Object} options
    * @param {WebGLRenderingContext} options.context The GL context used for rendering.
    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
    */
    retrieveShader: function(options) {
      var size = Math.sqrt(this.matrix.length);
      var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
      var shaderSource = this.fragmentSource[cacheKey];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          weights = this.matrix,
          side = Math.round(Math.sqrt(weights.length)),
          halfSide = Math.floor(side / 2),
          sw = imageData.width,
          sh = imageData.height,
          output = options.ctx.createImageData(sw, sh),
          dst = output.data,
          // go through the destination image pixels
          alphaFac = this.opaque ? 1 : 0,
          r, g, b, a, dstOff,
          scx, scy, srcOff, wt,
          x, y, cx, cy;

      for (y = 0; y < sh; y++) {
        for (x = 0; x < sw; x++) {
          dstOff = (y * sw + x) * 4;
          // calculate the weighed sum of the source image pixels that
          // fall under the convolution matrix
          r = 0; g = 0; b = 0; a = 0;

          for (cy = 0; cy < side; cy++) {
            for (cx = 0; cx < side; cx++) {
              scy = y + cy - halfSide;
              scx = x + cx - halfSide;

              // eslint-disable-next-line max-depth
              if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {
                continue;
              }

              srcOff = (scy * sw + scx) * 4;
              wt = weights[cy * side + cx];

              r += data[srcOff] * wt;
              g += data[srcOff + 1] * wt;
              b += data[srcOff + 2] * wt;
              // eslint-disable-next-line max-depth
              if (!alphaFac) {
                a += data[srcOff + 3] * wt;
              }
            }
          }
          dst[dstOff] = r;
          dst[dstOff + 1] = g;
          dst[dstOff + 2] = b;
          if (!alphaFac) {
            dst[dstOff + 3] = a;
          }
          else {
            dst[dstOff + 3] = data[dstOff + 3];
          }
        }
      }
      options.imageData = output;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMatrix: gl.getUniformLocation(program, 'uMatrix'),
        uOpaque: gl.getUniformLocation(program, 'uOpaque'),
        uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
        uSize: gl.getUniformLocation(program, 'uSize'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        opaque: this.opaque,
        matrix: this.matrix
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
   */
  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Grayscale image filter class
   * @class fabric.Image.filters.Grayscale
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Grayscale();
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Grayscale',

    fragmentSource: {
      average: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float average = (color.r + color.b + color.g) / 3.0;\n' +
          'gl_FragColor = vec4(average, average, average, color.a);\n' +
        '}',
      lightness: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
      luminosity: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
    },


    /**
     * Grayscale mode, between 'average', 'lightness', 'luminosity'
     * @param {String} type
     * @default
     */
    mode: 'average',

    mainParameter: 'mode',

    /**
     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length, value,
          mode = this.mode;
      for (i = 0; i < len; i += 4) {
        if (mode === 'average') {
          value = (data[i] + data[i + 1] + data[i + 2]) / 3;
        }
        else if (mode === 'lightness') {
          value = (Math.min(data[i], data[i + 1], data[i + 2]) +
            Math.max(data[i], data[i + 1], data[i + 2])) / 2;
        }
        else if (mode === 'luminosity') {
          value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
        }
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var shaderSource = this.fragmentSource[this.mode];
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMode: gl.getUniformLocation(program, 'uMode'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      // default average mode.
      var mode = 1;
      gl.uniform1i(uniformLocations.uMode, mode);
    },

    /**
     * Grayscale filter isNeutralState implementation
     * The filter is never neutral
     * on the image
     **/
    isNeutralState: function() {
      return false;
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
   */
  fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Invert filter class
   * @class fabric.Image.filters.Invert
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Invert();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Invert',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform int uInvert;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'if (uInvert == 1) {\n' +
          'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
        '} else {\n' +
          'gl_FragColor = color;\n' +
        '}\n' +
      '}',

    /**
     * Filter invert. if false, does nothing
     * @param {Boolean} invert
     * @default
     */
    invert: true,

    mainParameter: 'invert',

    /**
     * Apply the Invert operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length;
      for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
      }
    },

    /**
     * Invert filter isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function() {
      return !this.invert;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uInvert: gl.getUniformLocation(program, 'uInvert'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1i(uniformLocations.uInvert, this.invert);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
   */
  fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Noise filter class
   * @class fabric.Image.filters.Noise
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Noise({
   *   noise: 700
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Noise',

    /**
     * Fragment source for the noise program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uStepH;\n' +
      'uniform float uNoise;\n' +
      'uniform float uSeed;\n' +
      'varying vec2 vTexCoord;\n' +
      'float rand(vec2 co, float seed, float vScale) {\n' +
        'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'noise',

    /**
     * Noise value, from
     * @param {Number} noise
     * @default
     */
    noise: 0,

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.noise === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          noise = this.noise, rand;

      for (i = 0, len = data.length; i < len; i += 4) {

        rand = (0.5 - Math.random()) * noise;

        data[i] += rand;
        data[i + 1] += rand;
        data[i + 2] += rand;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uNoise: gl.getUniformLocation(program, 'uNoise'),
        uSeed: gl.getUniformLocation(program, 'uSeed'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
      gl.uniform1f(uniformLocations.uSeed, Math.random());
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        noise: this.noise
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
   */
  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Pixelate filter class
   * @class fabric.Image.filters.Pixelate
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Pixelate({
   *   blocksize: 8
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Pixelate',

    blocksize: 4,

    mainParameter: 'blocksize',

    /**
     * Fragment source for the Pixelate program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBlocksize;\n' +
      'uniform float uStepW;\n' +
      'uniform float uStepH;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'float blockW = uBlocksize * uStepW;\n' +
        'float blockH = uBlocksize * uStepW;\n' +
        'int posX = int(vTexCoord.x / blockW);\n' +
        'int posY = int(vTexCoord.y / blockH);\n' +
        'float fposX = float(posX);\n' +
        'float fposY = float(posY);\n' +
        'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
        'vec4 color = texture2D(uTexture, squareCoords);\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = imageData.height,
          jLen = imageData.width,
          index, i, j, r, g, b, a,
          _i, _j, _iLen, _jLen;

      for (i = 0; i < iLen; i += this.blocksize) {
        for (j = 0; j < jLen; j += this.blocksize) {

          index = (i * 4) * jLen + (j * 4);

          r = data[index];
          g = data[index + 1];
          b = data[index + 2];
          a = data[index + 3];

          _iLen = Math.min(i + this.blocksize, iLen);
          _jLen = Math.min(j + this.blocksize, jLen);
          for (_i = i; _i < _iLen; _i++) {
            for (_j = j; _j < _jLen; _j++) {
              index = (_i * 4) * jLen + (_j * 4);
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = a;
            }
          }
        }
      }
    },

    /**
     * Indicate when the filter is not gonna apply changes to the image
     **/
    isNeutralState: function() {
      return this.blocksize === 1;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
        uStepW: gl.getUniformLocation(program, 'uStepW'),
        uStepH: gl.getUniformLocation(program, 'uStepH'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
   */
  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Remove white filter class
   * @class fabric.Image.filters.RemoveColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.RemoveColor({
   *   threshold: 0.2,
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'RemoveColor',

    /**
     * Color to remove, in any format understood by fabric.Color.
     * @param {String} type
     * @default
     */
    color: '#FFFFFF',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec4 uLow;\n' +
      'uniform vec4 uHigh;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
        'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
          'gl_FragColor.a = 0.0;\n' +
        '}\n' +
      '}',

    /**
     * distance to actual color, as value up or down from each r,g,b
     * between 0 and 1
     **/
    distance: 0.02,

    /**
     * For color to remove inside distance, use alpha channel for a smoother deletion
     * NOT IMPLEMENTED YET
     **/
    useAlpha: false,

    /**
     * Constructor
     * @memberOf fabric.Image.filters.RemoveWhite.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.color=#RRGGBB] Threshold value
     * @param {Number} [options.distance=10] Distance value
     */

    /**
     * Applies filter to canvas element
     * @param {Object} canvasEl Canvas element to apply filter to
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          distance = this.distance * 255,
          r, g, b,
          source = new fabric.Color(this.color).getSource(),
          lowC = [
            source[0] - distance,
            source[1] - distance,
            source[2] - distance,
          ],
          highC = [
            source[0] + distance,
            source[1] + distance,
            source[2] + distance,
          ];


      for (i = 0; i < data.length; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        if (r > lowC[0] &&
            g > lowC[1] &&
            b > lowC[2] &&
            r < highC[0] &&
            g < highC[1] &&
            b < highC[2]) {
          data[i + 3] = 0;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uLow: gl.getUniformLocation(program, 'uLow'),
        uHigh: gl.getUniformLocation(program, 'uHigh'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource(),
          distance = parseFloat(this.distance),
          lowC = [
            0 + source[0] / 255 - distance,
            0 + source[1] / 255 - distance,
            0 + source[2] / 255 - distance,
            1
          ],
          highC = [
            source[0] / 255 + distance,
            source[1] / 255 + distance,
            source[2] / 255 + distance,
            1
          ];
      gl.uniform4fv(uniformLocations.uLow, lowC);
      gl.uniform4fv(uniformLocations.uHigh, highC);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        color: this.color,
        distance: this.distance
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
   */
  fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  var matrices = {
    Brownie: [
      0.59970,0.34553,-0.27082,0,0.186,
      -0.03770,0.86095,0.15059,0,-0.1449,
      0.24113,-0.07441,0.44972,0,-0.02965,
      0,0,0,1,0
    ],
    Vintage: [
      0.62793,0.32021,-0.03965,0,0.03784,
      0.02578,0.64411,0.03259,0,0.02926,
      0.04660,-0.08512,0.52416,0,0.02023,
      0,0,0,1,0
    ],
    Kodachrome: [
      1.12855,-0.39673,-0.03992,0,0.24991,
      -0.16404,1.08352,-0.05498,0,0.09698,
      -0.16786,-0.56034,1.60148,0,0.13972,
      0,0,0,1,0
    ],
    Technicolor: [
      1.91252,-0.85453,-0.09155,0,0.04624,
      -0.30878,1.76589,-0.10601,0,-0.27589,
      -0.23110,-0.75018,1.84759,0,0.12137,
      0,0,0,1,0
    ],
    Polaroid: [
      1.438,-0.062,-0.062,0,0,
      -0.122,1.378,-0.122,0,0,
      -0.016,-0.016,1.483,0,0,
      0,0,0,1,0
    ],
    Sepia: [
      0.393, 0.769, 0.189, 0, 0,
      0.349, 0.686, 0.168, 0, 0,
      0.272, 0.534, 0.131, 0, 0,
      0, 0, 0, 1, 0
    ],
    BlackWhite: [
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      0, 0, 0, 1, 0,
    ]
  };

  for (var key in matrices) {
    filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: key,

      /**
       * Colormatrix for the effect
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: matrices[key],

      /**
       * Lock the matrix export for this kind of static, parameter less filters.
       */
      mainParameter: false,
      /**
       * Lock the colormatrix on the color part, skipping alpha
       */
      colorsOnly: true,

    });
    fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
  }
})(typeof exports !== 'undefined' ? exports : this);
(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Blend filter class
   * @class fabric.Image.filter.BlendColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
    type: 'BlendColor',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     * @type String
     * @default
     **/
    color: '#F95C63',

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     * @type String
     * @default
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend color operation.
     * @type Number
     * @default
     **/
    alpha: 1,

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
      screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
      add: 'gl_FragColor.rgb += uColor.rgb;\n',
      diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
      subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
      lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
      darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
      exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
      overlay: 'if (uColor.r < 0.5) {\n' +
          'gl_FragColor.r *= 2.0 * uColor.r;\n' +
        '} else {\n' +
          'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
        '}\n' +
        'if (uColor.g < 0.5) {\n' +
          'gl_FragColor.g *= 2.0 * uColor.g;\n' +
        '} else {\n' +
          'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
        '}\n' +
        'if (uColor.b < 0.5) {\n' +
          'gl_FragColor.b *= 2.0 * uColor.b;\n' +
        '} else {\n' +
          'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
        '}\n',
      tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
        'gl_FragColor.rgb += uColor.rgb;\n',
    },

    /**
     * build the fragment source for the filters, joining the common part with
     * the specific one.
     * @param {String} mode the mode of the filter, a key of this.fragmentSource
     * @return {String} the source to be compiled
     * @private
     */
    buildSource: function(mode) {
      return 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor = color;\n' +
          'if (color.a > 0.0) {\n' +
            this.fragmentSource[mode] +
          '}\n' +
        '}';
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode, shaderSource;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        shaderSource = this.buildSource(this.mode);
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, iLen = data.length,
          tr, tg, tb,
          r, g, b,
          source, alpha1 = 1 - this.alpha;

      source = new fabric.Color(this.color).getSource();
      tr = source[0] * this.alpha;
      tg = source[1] * this.alpha;
      tb = source[2] * this.alpha;

      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            break;
          case 'screen':
            data[i] = 255 - (255 - r) * (255 - tr) / 255;
            data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
            data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
            break;
          case 'add':
            data[i] = r + tr;
            data[i + 1] = g + tg;
            data[i + 2] = b + tb;
            break;
          case 'diff':
          case 'difference':
            data[i] = Math.abs(r - tr);
            data[i + 1] = Math.abs(g - tg);
            data[i + 2] = Math.abs(b - tb);
            break;
          case 'subtract':
            data[i] = r - tr;
            data[i + 1] = g - tg;
            data[i + 2] = b - tb;
            break;
          case 'darken':
            data[i] = Math.min(r, tr);
            data[i + 1] = Math.min(g, tg);
            data[i + 2] = Math.min(b, tb);
            break;
          case 'lighten':
            data[i] = Math.max(r, tr);
            data[i + 1] = Math.max(g, tg);
            data[i + 2] = Math.max(b, tb);
            break;
          case 'overlay':
            data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
            data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
            data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
            break;
          case 'exclusion':
            data[i] = tr + r - ((2 * tr * r) / 255);
            data[i + 1] = tg + g - ((2 * tg * g) / 255);
            data[i + 2] = tb + b - ((2 * tb * b) / 255);
            break;
          case 'tint':
            data[i] = tr + r * alpha1;
            data[i + 1] = tg + g * alpha1;
            data[i + 2] = tb + b * alpha1;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColor: gl.getUniformLocation(program, 'uColor'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource();
      source[0] = this.alpha * source[0] / 255;
      source[1] = this.alpha * source[1] / 255;
      source[2] = this.alpha * source[2] / 255;
      source[3] = this.alpha;
      gl.uniform4fv(uniformLocations.uColor, source);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        color: this.color,
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
   */
  fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Image Blend filter class
   * @class fabric.Image.filter.BlendImage
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
    type: 'BlendImage',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    image: null,

    /**
     * Blend mode for the filter (one of "multiply", "mask")
     * @type String
     * @default
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend image operation.
     * not implemented.
     **/
    alpha: 1,

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'varying vec2 vTexCoord2;\n' +
      'uniform mat3 uTransformMatrix;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.rgba *= color2.rgba;\n' +
          'gl_FragColor = color;\n' +
        '}',
      mask: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.a = color2.a;\n' +
          'gl_FragColor = color;\n' +
        '}',
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    applyToWebGL: function(options) {
      // load texture to blend.
      var gl = options.context,
          texture = this.createTexture(options.filterBackend, this.image);
      this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
      this.callSuper('applyToWebGL', options);
      this.unbindAdditionalTexture(gl, gl.TEXTURE1);
    },

    createTexture: function(backend, image) {
      return backend.getCachedTexture(image.cacheKey, image._element);
    },

    /**
     * Calculate a transformMatrix to adapt the image to blend over
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    calculateMatrix: function() {
      var image = this.image,
          width = image._element.width,
          height = image._element.height;
      return [
        1 / image.scaleX, 0, 0,
        0, 1 / image.scaleY, 0,
        -image.left / width, -image.top / height, 1
      ];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          resources = options.filterBackend.resources,
          data = imageData.data, iLen = data.length,
          width = imageData.width,
          height = imageData.height,
          tr, tg, tb, ta,
          r, g, b, a,
          canvas1, context, image = this.image, blendData;

      if (!resources.blendImage) {
        resources.blendImage = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blendImage;
      context = canvas1.getContext('2d');
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas1.width = width;
        canvas1.height = height;
      }
      else {
        context.clearRect(0, 0, width, height);
      }
      context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
      context.drawImage(image._element, 0, 0, width, height);
      blendData = context.getImageData(0, 0, width, height).data;
      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];

        tr = blendData[i];
        tg = blendData[i + 1];
        tb = blendData[i + 2];
        ta = blendData[i + 3];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            data[i + 3] = a * ta / 255;
            break;
          case 'mask':
            data[i + 3] = ta;
            break;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
        uImage: gl.getUniformLocation(program, 'uImage'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var matrix = this.calculateMatrix();
      gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
      gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        image: this.image && this.image.toObject(),
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} callback to be invoked after filter creation
   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
   */
  fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
    fabric.Image.fromObject(object.image, function(image) {
      var options = fabric.util.object.clone(object);
      options.image = image;
      callback(new fabric.Image.filters.BlendImage(options));
    });
  };

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
      sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
      ceil = Math.ceil,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Resize image filter class
   * @class fabric.Image.filters.Resize
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Resize();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Resize',

    /**
     * Resize type
     * for webgl resizeType is just lanczos, for canvas2d can be:
     * bilinear, hermite, sliceHack, lanczos.
     * @param {String} resizeType
     * @default
     */
    resizeType: 'hermite',

    /**
     * Scale factor for resizing, x axis
     * @param {Number} scaleX
     * @default
     */
    scaleX: 1,

    /**
     * Scale factor for resizing, y axis
     * @param {Number} scaleY
     * @default
     */
    scaleY: 1,

    /**
     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
     * @param {Number} lanczosLobes
     * @default
     */
    lanczosLobes: 3,


    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uDelta: gl.getUniformLocation(program, 'uDelta'),
        uTaps: gl.getUniformLocation(program, 'uTaps'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
      gl.uniform1fv(uniformLocations.uTaps, this.taps);
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var fragmentShader = this.generateShader(filterWindow);
        options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
      }
      return options.programCache[cacheKey];
    },

    getFilterWindow: function() {
      var scale = this.tempScale;
      return Math.ceil(this.lanczosLobes / scale);
    },

    getTaps: function() {
      var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
          filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
      for (var i = 1; i <= filterWindow; i++) {
        taps[i - 1] = lobeFunction(i * scale);
      }
      return taps;
    },

    /**
     * Generate vertex and shader sources from the necessary steps numbers
     * @param {Number} filterWindow
     */
    generateShader: function(filterWindow) {
      var offsets = new Array(filterWindow),
          fragmentShader = this.fragmentSourceTOP, filterWindow;

      for (var i = 1; i <= filterWindow; i++) {
        offsets[i - 1] = i + '.0 * uDelta';
      }

      fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
      fragmentShader += 'void main() {\n';
      fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
      fragmentShader += '  float sum = 1.0;\n';

      offsets.forEach(function(offset, i) {
        fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
      });
      fragmentShader += '  gl_FragColor = color / sum;\n';
      fragmentShader += '}';
      return fragmentShader;
    },

    fragmentSourceTOP: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n',

    /**
     * Apply the resize filter to the image
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        options.passes++;
        this.width = options.sourceWidth;
        this.horizontal = true;
        this.dW = Math.round(this.width * this.scaleX);
        this.dH = options.sourceHeight;
        this.tempScale = this.dW / this.width;
        this.taps = this.getTaps();
        options.destinationWidth = this.dW;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceWidth = options.destinationWidth;

        this.height = options.sourceHeight;
        this.horizontal = false;
        this.dH = Math.round(this.height * this.scaleY);
        this.tempScale = this.dH / this.height;
        this.taps = this.getTaps();
        options.destinationHeight = this.dH;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceHeight = options.destinationHeight;
      }
      else {
        this.applyTo2d(options);
      }
    },

    isNeutralState: function() {
      return this.scaleX === 1 && this.scaleY === 1;
    },

    lanczosCreate: function(lobes) {
      return function(x) {
        if (x >= lobes || x <= -lobes) {
          return 0.0;
        }
        if (x < 1.19209290E-07 && x > -1.19209290E-07) {
          return 1.0;
        }
        x *= Math.PI;
        var xx = x / lobes;
        return (sin(x) / x) * sin(xx) / xx;
      };
    },

    /**
     * Applies filter to canvas element
     * @memberOf fabric.Image.filters.Resize.prototype
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} scaleX
     * @param {Number} scaleY
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          scaleX = this.scaleX,
          scaleY = this.scaleY;

      this.rcpScaleX = 1 / scaleX;
      this.rcpScaleY = 1 / scaleY;

      var oW = imageData.width, oH = imageData.height,
          dW = round(oW * scaleX), dH = round(oH * scaleY),
          newData;

      if (this.resizeType === 'sliceHack') {
        newData = this.sliceByTwo(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'hermite') {
        newData = this.hermiteFastResize(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'bilinear') {
        newData = this.bilinearFiltering(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'lanczos') {
        newData = this.lanczosResize(options, oW, oH, dW, dH);
      }
      options.imageData = newData;
    },

    /**
     * Filter sliceByTwo
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    sliceByTwo: function(options, oW, oH, dW, dH) {
      var imageData = options.imageData,
          mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
          stepH = oH * mult, resources = fabric.filterBackend.resources,
          tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
      if (!resources.sliceByTwo) {
        resources.sliceByTwo = document.createElement('canvas');
      }
      tmpCanvas = resources.sliceByTwo;
      if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
        tmpCanvas.width = oW * 1.5;
        tmpCanvas.height = oH;
      }
      ctx = tmpCanvas.getContext('2d');
      ctx.clearRect(0, 0, oW * 1.5, oH);
      ctx.putImageData(imageData, 0, 0);

      dW = floor(dW);
      dH = floor(dH);

      while (!doneW || !doneH) {
        oW = stepW;
        oH = stepH;
        if (dW < floor(stepW * mult)) {
          stepW = floor(stepW * mult);
        }
        else {
          stepW = dW;
          doneW = true;
        }
        if (dH < floor(stepH * mult)) {
          stepH = floor(stepH * mult);
        }
        else {
          stepH = dH;
          doneH = true;
        }
        ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
        sX = dX;
        sY = dY;
        dY += stepH;
      }
      return ctx.getImageData(sX, sY, dW, dH);
    },

    /**
     * Filter lanczosResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    lanczosResize: function(options, oW, oH, dW, dH) {

      function process(u) {
        var v, i, weight, idx, a, red, green,
            blue, alpha, fX, fY;
        center.x = (u + 0.5) * ratioX;
        icenter.x = floor(center.x);
        for (v = 0; v < dH; v++) {
          center.y = (v + 0.5) * ratioY;
          icenter.y = floor(center.y);
          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
            if (i < 0 || i >= oW) {
              continue;
            }
            fX = floor(1000 * abs(i - center.x));
            if (!cacheLanc[fX]) {
              cacheLanc[fX] = { };
            }
            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
              if (j < 0 || j >= oH) {
                continue;
              }
              fY = floor(1000 * abs(j - center.y));
              if (!cacheLanc[fX][fY]) {
                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
              }
              weight = cacheLanc[fX][fY];
              if (weight > 0) {
                idx = (j * oW + i) * 4;
                a += weight;
                red += weight * srcData[idx];
                green += weight * srcData[idx + 1];
                blue += weight * srcData[idx + 2];
                alpha += weight * srcData[idx + 3];
              }
            }
          }
          idx = (v * dW + u) * 4;
          destData[idx] = red / a;
          destData[idx + 1] = green / a;
          destData[idx + 2] = blue / a;
          destData[idx + 3] = alpha / a;
        }

        if (++u < dW) {
          return process(u);
        }
        else {
          return destImg;
        }
      }

      var srcData = options.imageData.data,
          destImg = options.ctx.createImageData(dW, dH),
          destData = destImg.data,
          lanczos = this.lanczosCreate(this.lanczosLobes),
          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
          range2X = ceil(ratioX * this.lanczosLobes / 2),
          range2Y = ceil(ratioY * this.lanczosLobes / 2),
          cacheLanc = { }, center = { }, icenter = { };

      return process(0);
    },

    /**
     * bilinearFiltering
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    bilinearFiltering: function(options, oW, oH, dW, dH) {
      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
          color, offset = 0, origPix, ratioX = this.rcpScaleX,
          ratioY = this.rcpScaleY,
          w4 = 4 * (oW - 1), img = options.imageData,
          pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
          destPixels = destImage.data;
      for (i = 0; i < dH; i++) {
        for (j = 0; j < dW; j++) {
          x = floor(ratioX * j);
          y = floor(ratioY * i);
          xDiff = ratioX * j - x;
          yDiff = ratioY * i - y;
          origPix = 4 * (y * oW + x);

          for (chnl = 0; chnl < 4; chnl++) {
            a = pixels[origPix + chnl];
            b = pixels[origPix + 4 + chnl];
            c = pixels[origPix + w4 + chnl];
            d = pixels[origPix + w4 + 4 + chnl];
            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
            destPixels[offset++] = color;
          }
        }
      }
      return destImage;
    },

    /**
     * hermiteFastResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    hermiteFastResize: function(options, oW, oH, dW, dH) {
      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
          ratioWHalf = ceil(ratioW / 2),
          ratioHHalf = ceil(ratioH / 2),
          img = options.imageData, data = img.data,
          img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
      for (var j = 0; j < dH; j++) {
        for (var i = 0; i < dW; i++) {
          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                  w = sqrt(w0 + dx * dx);
              /* eslint-disable max-depth */
              if (w > 1 && w < -1) {
                continue;
              }
              //hermite filter
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * oW);
                //alpha
                gxA += weight * data[dx + 3];
                weightsAlpha += weight;
                //colors
                if (data[dx + 3] < 255) {
                  weight = weight * data[dx + 3] / 250;
                }
                gxR += weight * data[dx];
                gxG += weight * data[dx + 1];
                gxB += weight * data[dx + 2];
                weights += weight;
              }
              /* eslint-enable max-depth */
            }
          }
          data2[x2] = gxR / weights;
          data2[x2 + 1] = gxG / weights;
          data2[x2 + 2] = gxB / weights;
          data2[x2 + 3] = gxA / weightsAlpha;
        }
      }
      return img2;
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        resizeType: this.resizeType,
        lanczosLobes: this.lanczosLobes
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
   */
  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Contrast filter class
   * @class fabric.Image.filters.Contrast
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Contrast({
   *   contrast: 0.25
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Contrast',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uContrast;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
        'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * contrast value, range from -1 to 1.
     * @param {Number} contrast
     * @default 0
     */
    contrast: 0,

    mainParameter: 'contrast',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Contrast.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
     */

    /**
      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8Array to be filtered.
      */
    applyTo2d: function(options) {
      if (this.contrast === 0) {
        return;
      }
      var imageData = options.imageData, i, len,
          data = imageData.data, len = data.length,
          contrast = Math.floor(this.contrast * 255),
          contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

      for (i = 0; i < len; i += 4) {
        data[i] = contrastF * (data[i] - 128) + 128;
        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uContrast: gl.getUniformLocation(program, 'uContrast'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uContrast, this.contrast);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
   */
  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Saturate filter class
   * @class fabric.Image.filters.Saturation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Saturation({
   *   saturation: 1
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Saturation',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uSaturation;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float rgMax = max(color.r, color.g);\n' +
        'float rgbMax = max(rgMax, color.b);\n' +
        'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
        'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
        'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Saturation value, from -1 to 1.
     * Increases/decreases the color saturation.
     * A value of 0 has no effect.
     * 
     * @param {Number} saturation
     * @default
     */
    saturation: 0,

    mainParameter: 'saturation',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Saturate.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
     */

    /**
     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.saturation === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, len = data.length,
          adjust = -this.saturation, i, max;

      for (i = 0; i < len; i += 4) {
        max = Math.max(data[i], data[i + 1], data[i + 2]);
        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uSaturation: gl.getUniformLocation(program, 'uSaturation'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
   */
  fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Blur filter class
   * @class fabric.Image.filters.Blur
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Blur({
   *   blur: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

    type: 'Blur',

    /*
'gl_FragColor = vec4(0.0);',
'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
*/

    /* eslint-disable max-len */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n' +
      'const float nSamples = 15.0;\n' +
      'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
      'float random(vec3 scale) {\n' +
        /* use the fragment position for a different seed per-pixel */
        'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = vec4(0.0);\n' +
        'float total = 0.0;\n' +
        'float offset = random(v3offset);\n' +
        'for (float t = -nSamples; t <= nSamples; t++) {\n' +
          'float percent = (t + offset - 0.5) / nSamples;\n' +
          'float weight = 1.0 - abs(percent);\n' +
          'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
          'total += weight;\n' +
        '}\n' +
        'gl_FragColor = color / total;\n' +
      '}',
    /* eslint-enable max-len */

    /**
     * blur value, in percentage of image dimensions.
     * specific to keep the image blur constant at different resolutions
     * range between 0 and 1.
     * @type Number
     * @default
     */
    blur: 0,

    mainParameter: 'blur',

    applyTo: function(options) {
      if (options.webgl) {
        // this aspectRatio is used to give the same blur to vertical and horizontal
        this.aspectRatio = options.sourceWidth / options.sourceHeight;
        options.passes++;
        this._setupFrameBuffer(options);
        this.horizontal = true;
        this.applyToWebGL(options);
        this._swapTextures(options);
        this._setupFrameBuffer(options);
        this.horizontal = false;
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else {
        this.applyTo2d(options);
      }
    },

    applyTo2d: function(options) {
      // paint canvasEl with current image data.
      //options.ctx.putImageData(options.imageData, 0, 0);
      options.imageData = this.simpleBlur(options);
    },

    simpleBlur: function(options) {
      var resources = options.filterBackend.resources, canvas1, canvas2,
          width = options.imageData.width,
          height = options.imageData.height;

      if (!resources.blurLayer1) {
        resources.blurLayer1 = fabric.util.createCanvasElement();
        resources.blurLayer2 = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blurLayer1;
      canvas2 = resources.blurLayer2;
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas2.width = canvas1.width = width;
        canvas2.height = canvas1.height = height;
      }
      var ctx1 = canvas1.getContext('2d'),
          ctx2 = canvas2.getContext('2d'),
          nSamples = 15,
          random, percent, j, i,
          blur = this.blur * 0.06 * 0.5;

      // load first canvas
      ctx1.putImageData(options.imageData, 0, 0);
      ctx2.clearRect(0, 0, width, height);

      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * width + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, j, random);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * height + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, random, j);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      options.ctx.drawImage(canvas1, 0, 0);
      var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
      ctx1.globalAlpha = 1;
      ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
      return newImageData;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        delta: gl.getUniformLocation(program, 'uDelta'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var delta = this.chooseRightDelta();
      gl.uniform2fv(uniformLocations.delta, delta);
    },

    /**
     * choose right value of image percentage to blur with
     * @returns {Array} a numeric array with delta values
     */
    chooseRightDelta: function() {
      var blurScale = 1, delta = [0, 0], blur;
      if (this.horizontal) {
        if (this.aspectRatio > 1) {
          // image is wide, i want to shrink radius horizontal
          blurScale = 1 / this.aspectRatio;
        }
      }
      else {
        if (this.aspectRatio < 1) {
          // image is tall, i want to shrink radius vertical
          blurScale = this.aspectRatio;
        }
      }
      blur = blurScale * this.blur * 0.12;
      if (this.horizontal) {
        delta[0] = blur;
      }
      else {
        delta[1] = blur;
      }
      return delta;
    },
  });

  /**
   * Deserialize a JSON definition of a BlurFilter into a concrete instance.
   */
  filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Gamma filter class
   * @class fabric.Image.filters.Gamma
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Gamma({
   *   gamma: [1, 0.5, 2.1]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Gamma',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec3 uGamma;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'vec3 correction = (1.0 / uGamma);\n' +
        'color.r = pow(color.r, correction.r);\n' +
        'color.g = pow(color.g, correction.g);\n' +
        'color.b = pow(color.b, correction.b);\n' +
        'gl_FragColor = color;\n' +
        'gl_FragColor.rgb *= color.a;\n' +
      '}',

    /**
     * Gamma array value, from 0.01 to 2.2.
     * @param {Array} gamma
     * @default
     */
    gamma: [1, 1, 1],

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'gamma',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.gamma = [1, 1, 1];
      filters.BaseFilter.prototype.initialize.call(this, options);
    },

    /**
     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData, data = imageData.data,
          gamma = this.gamma, len = data.length,
          rInv = 1 / gamma[0], gInv = 1 / gamma[1],
          bInv = 1 / gamma[2], i;

      if (!this.rVals) {
        // eslint-disable-next-line
        this.rVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.gVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.bVals = new Uint8Array(256);
      }

      // This is an optimization - pre-compute a look-up table for each color channel
      // instead of performing these pow calls for each pixel in the image.
      for (i = 0, len = 256; i < len; i++) {
        this.rVals[i] = Math.pow(i / 255, rInv) * 255;
        this.gVals[i] = Math.pow(i / 255, gInv) * 255;
        this.bVals[i] = Math.pow(i / 255, bInv) * 255;
      }
      for (i = 0, len = data.length; i < len; i += 4) {
        data[i] = this.rVals[data[i]];
        data[i + 1] = this.gVals[data[i + 1]];
        data[i + 2] = this.bVals[data[i + 2]];
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uGamma: gl.getUniformLocation(program, 'uGamma'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform3fv(uniformLocations.uGamma, this.gamma);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
   */
  fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * A container class that knows how to apply a sequence of filters to an input image.
   */
  filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

    type: 'Composed',

    /**
     * A non sparse array of filters to apply
     */
    subFilters: [],

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.subFilters = this.subFilters.slice(0);
    },

    /**
     * Apply this container's filters to the input image provided.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be applied.
     */
    applyTo: function(options) {
      options.passes += this.subFilters.length - 1;
      this.subFilters.forEach(function(filter) {
        filter.applyTo(options);
      });
    },

    /**
     * Serialize this filter into JSON.
     *
     * @returns {Object} A JSON representation of this filter.
     */
    toObject: function() {
      return fabric.util.object.extend(this.callSuper('toObject'), {
        subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
      });
    },

    isNeutralState: function() {
      return !this.subFilters.some(function(filter) { return !filter.isNeutralState(); });
    }
  });

  /**
   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
   */
  fabric.Image.filters.Composed.fromObject = function(object, callback) {
    var filters = object.subFilters || [],
        subFilters = filters.map(function(filter) {
          return new fabric.Image.filters[filter.type](filter);
        }),
        instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
    callback && callback(instance);
    return instance;
  };
})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * HueRotation filter class
   * @class fabric.Image.filters.HueRotation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.HueRotation({
   *   rotation: -0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'HueRotation',

    /**
     * HueRotation value, from -1 to 1.
     * the unit is radians
     * @param {Number} myParameter
     * @default
     */
    rotation: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'rotation',

    calculateMatrix: function() {
      var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
          aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
      this.matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ];
      this.matrix[0] = cos + OneMinusCos / 3;
      this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[6] = cos + aThird * OneMinusCos;
      this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[12] = cos + aThird * OneMinusCos;
    },

    /**
     * HueRotation isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function(options) {
      this.calculateMatrix();
      return filters.BaseFilter.prototype.isNeutralState.call(this, options);
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      this.calculateMatrix();
      filters.BaseFilter.prototype.applyTo.call(this, options);
    },

  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
   */
  fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})(typeof exports !== 'undefined' ? exports : this);
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      clone = fabric.util.object.clone;

  if (fabric.Text) {
    fabric.warn('fabric.Text is already defined');
    return;
  }

  var additionalProps =
    ('fontFamily fontWeight fontSize text underline overline linethrough' +
    ' textAlign fontStyle lineHeight textBackgroundColor charSpacing styles' +
    ' direction path pathStartOffset pathSide pathAlign').split(' ');

  /**
   * Text class
   * @class fabric.Text
   * @extends fabric.Object
   * @return {fabric.Text} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
   * @see {@link fabric.Text#initialize} for constructor definition
   */
  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

    /**
     * Properties which when set cause object to change dimensions
     * @type Array
     * @private
     */
    _dimensionAffectingProps: [
      'fontSize',
      'fontWeight',
      'fontFamily',
      'fontStyle',
      'lineHeight',
      'text',
      'charSpacing',
      'textAlign',
      'styles',
      'path',
      'pathStartOffset',
      'pathSide',
      'pathAlign'
    ],

    /**
     * @private
     */
    _reNewline: /\r?\n/,

    /**
     * Use this regular expression to filter for whitespaces that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpacesAndTabs: /[ \t\r]/g,

    /**
     * Use this regular expression to filter for whitespace that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpaceAndTab: /[ \t\r]/,

    /**
     * Use this regular expression to filter consecutive groups of non spaces.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reWords: /\S+/g,

    /**
     * Type of an object
     * @type String
     * @default
     */
    type:                 'text',

    /**
     * Font size (in pixels)
     * @type Number
     * @default
     */
    fontSize:             40,

    /**
     * Font weight (e.g. bold, normal, 400, 600, 800)
     * @type {(Number|String)}
     * @default
     */
    fontWeight:           'normal',

    /**
     * Font family
     * @type String
     * @default
     */
    fontFamily:           'Times New Roman',

    /**
     * Text decoration underline.
     * @type Boolean
     * @default
     */
    underline:       false,

    /**
     * Text decoration overline.
     * @type Boolean
     * @default
     */
    overline:       false,

    /**
     * Text decoration linethrough.
     * @type Boolean
     * @default
     */
    linethrough:       false,

    /**
     * Text alignment. Possible values: "left", "center", "right", "justify",
     * "justify-left", "justify-center" or "justify-right".
     * @type String
     * @default
     */
    textAlign:            'left',

    /**
     * Font style . Possible values: "", "normal", "italic" or "oblique".
     * @type String
     * @default
     */
    fontStyle:            'normal',

    /**
     * Line height
     * @type Number
     * @default
     */
    lineHeight:           1.16,

    /**
     * Superscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    superscript: {
      size:      0.60, // fontSize factor
      baseline: -0.35  // baseline-shift factor (upwards)
    },

    /**
     * Subscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    subscript: {
      size:      0.60, // fontSize factor
      baseline:  0.11  // baseline-shift factor (downwards)
    },

    /**
     * Background color of text lines
     * @type String
     * @default
     */
    textBackgroundColor:  '',

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),

    /**
     * List of properties to consider when checking if cache needs refresh
     * @type Array
     */
    cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),

    /**
     * When defined, an object is rendered via stroke and this property specifies its color.
     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
     * @type String
     * @default
     */
    stroke:               null,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
     * @type fabric.Shadow
     * @default
     */
    shadow:               null,

    /**
     * fabric.Path that the text should follow.
     * since 4.6.0 the path will be drawn automatically.
     * if you want to make the path visible, give it a stroke and strokeWidth or fill value
     * if you want it to be hidden, assign visible = false to the path.
     * This feature is in BETA, and SVG import/export is not yet supported.
     * @type fabric.Path
     * @example
     * var textPath = new fabric.Text('Text on a path', {
     *     top: 150,
     *     left: 150,
     *     textAlign: 'center',
     *     charSpacing: -50,
     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {
     *         strokeWidth: 1,
     *         visible: false
     *     }),
     *     pathSide: 'left',
     *     pathStartOffset: 0
     * });
     * @default
     */
    path:               null,

    /**
     * Offset amount for text path starting position
     * Only used when text has a path
     * @type Number
     * @default
     */
    pathStartOffset:               0,

    /**
     * Which side of the path the text should be drawn on.
     * Only used when text has a path
     * @type {String} 'left|right'
     * @default
     */
    pathSide:               'left',

    /**
     * How text is aligned to the path. This property determines
     * the perpendicular position of each character relative to the path.
     * (one of "baseline", "center", "ascender", "descender")
     * This feature is in BETA, and its behavior may change
     * @type String
     * @default
     */
    pathAlign:               'baseline',

    /**
     * @private
     */
    _fontSizeFraction: 0.222,

    /**
     * @private
     */
    offsets: {
      underline: 0.10,
      linethrough: -0.315,
      overline: -0.88
    },

    /**
     * Text Line proportion to font Size (in pixels)
     * @type Number
     * @default
     */
    _fontSizeMult:             1.13,

    /**
     * additional space between characters
     * expressed in thousands of em unit
     * @type Number
     * @default
     */
    charSpacing:             0,

    /**
     * Object containing character styles - top-level properties -> line numbers,
     * 2nd-level properties - character numbers
     * @type Object
     * @default
     */
    styles: null,

    /**
     * Reference to a context to measure text char or couple of chars
     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every
     * text object created.
     * @type {CanvasRenderingContext2D}
     * @default
     */
    _measuringContext: null,

    /**
     * Baseline shift, styles only, keep at 0 for the main text object
     * @type {Number}
     * @default
     */
    deltaY: 0,

    /**
     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET
     * determine the direction of the text.
     * This has to be set manually together with textAlign and originX for proper
     * experience.
     * some interesting link for the future
     * https://www.w3.org/International/questions/qa-bidi-unicode-controls
     * @since 4.5.0
     * @type {String} 'ltr|rtl'
     * @default
     */
    direction: 'ltr',

    /**
     * Array of properties that define a style unit (of 'styles').
     * @type {Array}
     * @default
     */
    _styleProperties: [
      'stroke',
      'strokeWidth',
      'fill',
      'fontFamily',
      'fontSize',
      'fontWeight',
      'fontStyle',
      'underline',
      'overline',
      'linethrough',
      'deltaY',
      'textBackgroundColor',
    ],

    /**
     * contains characters bounding boxes
     */
    __charBounds: [],

    /**
     * use this size when measuring text. To avoid IE11 rounding errors
     * @type {Number}
     * @default
     * @readonly
     * @private
     */
    CACHE_FONT_SIZE: 400,

    /**
     * contains the min text width to avoid getting 0
     * @type {Number}
     * @default
     */
    MIN_TEXT_WIDTH: 2,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    initialize: function(text, options) {
      this.styles = options ? (options.styles || { }) : { };
      this.text = text;
      this.__skipDimension = true;
      this.callSuper('initialize', options);
      if (this.path) {
        this.setPathInfo();
      }
      this.__skipDimension = false;
      this.initDimensions();
      this.setCoords();
      this.setupState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * If text has a path, it will add the extra information needed
     * for path and text calculations
     * @return {fabric.Text} thisArg
     */
    setPathInfo: function() {
      var path = this.path;
      if (path) {
        path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);
      }
    },

    /**
     * Return a context for measurement of text string.
     * if created it gets stored for reuse
     * this is for internal use, please do not use it
     * @private
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    getMeasuringContext: function() {
      // if we did not return we have to measure something.
      if (!fabric._measuringContext) {
        fabric._measuringContext = this.canvas && this.canvas.contextCache ||
          fabric.util.createCanvasElement().getContext('2d');
      }
      return fabric._measuringContext;
    },

    /**
     * @private
     * Divides text into lines of text and lines of graphemes.
     */
    _splitText: function() {
      var newLines = this._splitTextIntoLines(this.text);
      this.textLines = newLines.lines;
      this._textLines = newLines.graphemeLines;
      this._unwrappedTextLines = newLines._unwrappedLines;
      this._text = newLines.graphemeText;
      return newLines;
    },

    /**
     * Initialize or update text dimensions.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this._splitText();
      this._clearCache();
      if (this.path) {
        this.width = this.path.width;
        this.height = this.path.height;
      }
      else {
        this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
        this.height = this.calcTextHeight();
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Enlarge space boxes and shift the others
     */
    enlargeSpaces: function() {
      var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
          continue;
        }
        accumulatedSpace = 0;
        line = this._textLines[i];
        currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
          numberOfSpaces = spaces.length;
          diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
          for (var j = 0, jlen = line.length; j <= jlen; j++) {
            charBound = this.__charBounds[i][j];
            if (this._reSpaceAndTab.test(line[j])) {
              charBound.width += diffSpace;
              charBound.kernedWidth += diffSpace;
              charBound.left += accumulatedSpace;
              accumulatedSpace += diffSpace;
            }
            else {
              charBound.left += accumulatedSpace;
            }
          }
        }
      }
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      return lineIndex === this._textLines.length - 1;
    },

    /**
     * Detect if a line has a linebreak and so we need to account for it when moving
     * and counting style.
     * It return always for text and Itext.
     * @return Number
     */
    missingNewlineOffset: function() {
      return 1;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of text object
     */
    toString: function() {
      return '#<fabric.Text (' + this.complexity() +
        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @param {Object} dim.x width of object to be cached
     * @param {Object} dim.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var dims = this.callSuper('_getCacheCanvasDimensions');
      var fontSize = this.fontSize;
      dims.width += fontSize * dims.zoomX;
      dims.height += fontSize * dims.zoomY;
      return dims;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var path = this.path;
      path && !path.isNotVisible() && path._render(ctx);
      this._setTextStyles(ctx);
      this._renderTextLinesBackground(ctx);
      this._renderTextDecoration(ctx, 'underline');
      this._renderText(ctx);
      this._renderTextDecoration(ctx, 'overline');
      this._renderTextDecoration(ctx, 'linethrough');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderText: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderTextStroke(ctx);
        this._renderTextFill(ctx);
      }
      else {
        this._renderTextFill(ctx);
        this._renderTextStroke(ctx);
      }
    },

    /**
     * Set the font parameter of the context with the object properties or with charStyle
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [charStyle] object with font style properties
     * @param {String} [charStyle.fontFamily] Font Family
     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
     * @param {String} [charStyle.fontWeight] Font weight
     * @param {String} [charStyle.fontStyle] Font style (italic|normal)
     */
    _setTextStyles: function(ctx, charStyle, forMeasuring) {
      ctx.textBaseline = 'alphabetical';
      if (this.path) {
        switch (this.pathAlign) {
          case 'center':
            ctx.textBaseline = 'middle';
            break;
          case 'ascender':
            ctx.textBaseline = 'top';
            break;
          case 'descender':
            ctx.textBaseline = 'bottom';
            break;
        }
      }
      ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
    },

    /**
     * calculate and return the text Width measuring each line.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {Number} Maximum width of fabric.Text object
     */
    calcTextWidth: function() {
      var maxWidth = this.getLineWidth(0);

      for (var i = 1, len = this._textLines.length; i < len; i++) {
        var currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth > maxWidth) {
          maxWidth = currentLineWidth;
        }
      }
      return maxWidth;
    },

    /**
     * @private
     * @param {String} method Method name ("fillText" or "strokeText")
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Text to render
     * @param {Number} left Left position of text
     * @param {Number} top Top position of text
     * @param {Number} lineIndex Index of a line in a text
     */
    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
      this._renderChars(method, ctx, line, left, top, lineIndex);
    },

    /**
     * Renders the text background for lines, taking care of style
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextLinesBackground: function(ctx) {
      if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
        return;
      }
      var heightOfLine,
          lineLeftOffset, originalFill = ctx.fillStyle,
          line, lastColor,
          leftOffset = this._getLeftOffset(),
          lineTopOffset = this._getTopOffset(),
          boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path,
          drawStart;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
          lineTopOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        lineLeftOffset = this._getLineLeftOffset(i);
        boxWidth = 0;
        boxStart = 0;
        lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (path) {
            ctx.save();
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            ctx.fillStyle = currentColor;
            currentColor && ctx.fillRect(
              -charBox.width / 2,
              -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction),
              charBox.width,
              heightOfLine / this.lineHeight
            );
            ctx.restore();
          }
          else if (currentColor !== lastColor) {
            drawStart = leftOffset + lineLeftOffset + boxStart;
            if (this.direction === 'rtl') {
              drawStart = this.width - drawStart - boxWidth;
            }
            ctx.fillStyle = lastColor;
            lastColor && ctx.fillRect(
              drawStart,
              lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        if (currentColor && !path) {
          drawStart = leftOffset + lineLeftOffset + boxStart;
          if (this.direction === 'rtl') {
            drawStart = this.width - drawStart - boxWidth;
          }
          ctx.fillStyle = currentColor;
          ctx.fillRect(
            drawStart,
            lineTopOffset,
            boxWidth,
            heightOfLine / this.lineHeight
          );
        }
        lineTopOffset += heightOfLine;
      }
      ctx.fillStyle = originalFill;
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {Object} decl style declaration for cache
     * @param {String} decl.fontFamily fontFamily
     * @param {String} decl.fontStyle fontStyle
     * @param {String} decl.fontWeight fontWeight
     * @return {Object} reference to cache
     */
    getFontCache: function(decl) {
      var fontFamily = decl.fontFamily.toLowerCase();
      if (!fabric.charWidthsCache[fontFamily]) {
        fabric.charWidthsCache[fontFamily] = { };
      }
      var cache = fabric.charWidthsCache[fontFamily],
          cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
      if (!cache[cacheProp]) {
        cache[cacheProp] = { };
      }
      return cache[cacheProp];
    },

    /**
     * measure and return the width of a single character.
     * possibly overridden to accommodate different measure logic or
     * to hook some external lib for character measurement
     * @private
     * @param {String} _char, char to be measured
     * @param {Object} charStyle style of char to be measured
     * @param {String} [previousChar] previous char
     * @param {Object} [prevCharStyle] style of previous char
     */
    _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
      // first i try to return from cache
      var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
          previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
          stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
          fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

      if (previousChar && fontCache[previousChar] !== undefined) {
        previousWidth = fontCache[previousChar];
      }
      if (fontCache[_char] !== undefined) {
        kernedWidth = width = fontCache[_char];
      }
      if (stylesAreEqual && fontCache[couple] !== undefined) {
        coupleWidth = fontCache[couple];
        kernedWidth = coupleWidth - previousWidth;
      }
      if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
        var ctx = this.getMeasuringContext();
        // send a TRUE to specify measuring font size CACHE_FONT_SIZE
        this._setTextStyles(ctx, charStyle, true);
      }
      if (width === undefined) {
        kernedWidth = width = ctx.measureText(_char).width;
        fontCache[_char] = width;
      }
      if (previousWidth === undefined && stylesAreEqual && previousChar) {
        previousWidth = ctx.measureText(previousChar).width;
        fontCache[previousChar] = previousWidth;
      }
      if (stylesAreEqual && coupleWidth === undefined) {
        // we can measure the kerning couple and subtract the width of the previous character
        coupleWidth = ctx.measureText(couple).width;
        fontCache[couple] = coupleWidth;
        kernedWidth = coupleWidth - previousWidth;
      }
      return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
    },

    /**
     * Computes height of character at given position
     * @param {Number} line the line index number
     * @param {Number} _char the character index number
     * @return {Number} fontSize of the character
     */
    getHeightOfChar: function(line, _char) {
      return this.getValueOfPropertyAt(line, _char, 'fontSize');
    },

    /**
     * measure a text line measuring all characters.
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    measureLine: function(lineIndex) {
      var lineInfo = this._measureLine(lineIndex);
      if (this.charSpacing !== 0) {
        lineInfo.width -= this._getWidthOfCharSpacing();
      }
      if (lineInfo.width < 0) {
        lineInfo.width = 0;
      }
      return lineInfo;
    },

    /**
     * measure every grapheme of a line, populating __charBounds
     * @param {Number} lineIndex
     * @return {Object} object.width total width of characters
     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
     */
    _measureLine: function(lineIndex) {
      var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
          graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length),
          positionInPath = 0, startingPoint, totalPathLength, path = this.path,
          reverse = this.pathSide === 'right';

      this.__charBounds[lineIndex] = lineBounds;
      for (i = 0; i < line.length; i++) {
        grapheme = line[i];
        graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
        lineBounds[i] = graphemeInfo;
        width += graphemeInfo.kernedWidth;
        prevGrapheme = grapheme;
      }
      // this latest bound box represent the last character of the line
      // to simplify cursor handling in interactive mode.
      lineBounds[i] = {
        left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
        width: 0,
        kernedWidth: 0,
        height: this.fontSize
      };
      if (path) {
        totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;
        startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);
        startingPoint.x += path.pathOffset.x;
        startingPoint.y += path.pathOffset.y;
        switch (this.textAlign) {
          case 'left':
            positionInPath = reverse ? (totalPathLength - width) : 0;
            break;
          case 'center':
            positionInPath = (totalPathLength - width) / 2;
            break;
          case 'right':
            positionInPath = reverse ? 0 : (totalPathLength - width);
            break;
          //todo - add support for justify
        }
        positionInPath += this.pathStartOffset * (reverse ? -1 : 1);
        for (i = reverse ? line.length - 1 : 0;
          reverse ? i >= 0 : i < line.length;
          reverse ? i-- : i++) {
          graphemeInfo = lineBounds[i];
          if (positionInPath > totalPathLength) {
            positionInPath %= totalPathLength;
          }
          else if (positionInPath < 0) {
            positionInPath += totalPathLength;
          }
          // it would probably much faster to send all the grapheme position for a line
          // and calculate path position/angle at once.
          this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);
          positionInPath += graphemeInfo.kernedWidth;
        }
      }
      return { width: width, numOfSpaces: numOfSpaces };
    },

    /**
     * Calculate the angle  and the left,top position of the char that follow a path.
     * It appends it to graphemeInfo to be reused later at rendering
     * @private
     * @param {Number} positionInPath to be measured
     * @param {Object} graphemeInfo current grapheme box information
     * @param {Object} startingPoint position of the point
     */
    _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {
      var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2,
          path = this.path;

      // we are at currentPositionOnPath. we want to know what point on the path is.
      var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);
      graphemeInfo.renderLeft = info.x - startingPoint.x;
      graphemeInfo.renderTop = info.y - startingPoint.y;
      graphemeInfo.angle = info.angle + (this.pathSide ===  'right' ? Math.PI : 0);
    },

    /**
     * Measure and return the info of a single grapheme.
     * needs the the info of previous graphemes already filled
     * @private
     * @param {String} grapheme to be measured
     * @param {Number} lineIndex index of the line where the char is
     * @param {Number} charIndex position in the line
     * @param {String} [prevGrapheme] character preceding the one to be measured
     */
    _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
      var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
          info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
          kernedWidth = info.kernedWidth,
          width = info.width, charSpacing;

      if (this.charSpacing !== 0) {
        charSpacing = this._getWidthOfCharSpacing();
        width += charSpacing;
        kernedWidth += charSpacing;
      }

      var box = {
        width: width,
        left: 0,
        height: style.fontSize,
        kernedWidth: kernedWidth,
        deltaY: style.deltaY,
      };
      if (charIndex > 0 && !skipLeft) {
        var previousBox = this.__charBounds[lineIndex][charIndex - 1];
        box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
      }
      return box;
    },

    /**
     * Calculate height of line at 'lineIndex'
     * @param {Number} lineIndex index of line to calculate
     * @return {Number}
     */
    getHeightOfLine: function(lineIndex) {
      if (this.__lineHeights[lineIndex]) {
        return this.__lineHeights[lineIndex];
      }

      var line = this._textLines[lineIndex],
          // char 0 is measured before the line cycle because it nneds to char
          // emptylines
          maxHeight = this.getHeightOfChar(lineIndex, 0);
      for (var i = 1, len = line.length; i < len; i++) {
        maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
      }

      return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
    },

    /**
     * Calculate text box height
     */
    calcTextHeight: function() {
      var lineHeight, height = 0;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineHeight = this.getHeightOfLine(i);
        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
      }
      return height;
    },

    /**
     * @private
     * @return {Number} Left offset
     */
    _getLeftOffset: function() {
      return this.direction === 'ltr' ? -this.width / 2 : this.width / 2;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function() {
      return -this.height / 2;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} method Method name ("fillText" or "strokeText")
     */
    _renderTextCommon: function(ctx, method) {
      ctx.save();
      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        var heightOfLine = this.getHeightOfLine(i),
            maxHeight = heightOfLine / this.lineHeight,
            leftOffset = this._getLineLeftOffset(i);
        this._renderTextLine(
          method,
          ctx,
          this._textLines[i],
          left + leftOffset,
          top + lineHeights + maxHeight,
          i
        );
        lineHeights += heightOfLine;
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextFill: function(ctx) {
      if (!this.fill && !this.styleHas('fill')) {
        return;
      }

      this._renderTextCommon(ctx, 'fillText');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextStroke: function(ctx) {
      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray);
      ctx.beginPath();
      this._renderTextCommon(ctx, 'strokeText');
      ctx.closePath();
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method fillText or strokeText.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} line Content of the line, splitted in an array by grapheme
     * @param {Number} left
     * @param {Number} top
     * @param {Number} lineIndex
     */
    _renderChars: function(method, ctx, line, left, top, lineIndex) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox,
          boxWidth = 0,
          timeToRender,
          path = this.path,
          shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path,
          isLtr = this.direction === 'ltr', sign = this.direction === 'ltr' ? 1 : -1,
          drawingLeft, currentDirection = ctx.canvas.getAttribute('dir');
      ctx.save();
      if (currentDirection !== this.direction) {
        ctx.canvas.setAttribute('dir', isLtr ? 'ltr' : 'rtl');
        ctx.direction = isLtr ? 'ltr' : 'rtl';
        ctx.textAlign = isLtr ? 'left' : 'right';
      }
      top -= lineHeight * this._fontSizeFraction / this.lineHeight;
      if (shortCut) {
        // render all the line in one pass without checking
        // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);
        this._renderChar(method, ctx, lineIndex, 0, line.join(''), left, top, lineHeight);
        ctx.restore();
        return;
      }
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing || path;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          left += sign * (charBox.kernedWidth - charBox.width);
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
        }
        if (timeToRender) {
          if (path) {
            ctx.save();
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);
            ctx.restore();
          }
          else {
            drawingLeft = left;
            this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight);
          }
          charsToRender = '';
          actualStyle = nextStyle;
          left += sign * boxWidth;
          boxWidth = 0;
        }
      }
      ctx.restore();
    },

    /**
     * This function try to patch the missing gradientTransform on canvas gradients.
     * transforming a context to transform the gradient, is going to transform the stroke too.
     * we want to transform the gradient but not the stroke operation, so we create
     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size
     * is limited.
     * @private
     * @param {fabric.Gradient} filler a fabric gradient instance
     * @return {CanvasPattern} a pattern to use as fill/stroke style
     */
    _applyPatternGradientTransformText: function(filler) {
      var pCanvas = fabric.util.createCanvasElement(), pCtx,
          // TODO: verify compatibility with strokeUniform
          width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx = pCanvas.getContext('2d');
      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
      pCtx.lineTo(0, height); pCtx.closePath();
      pCtx.translate(width / 2, height / 2);
      pCtx.fillStyle = filler.toLive(pCtx);
      this._applyPatternGradientTransform(pCtx, filler);
      pCtx.fill();
      return pCtx.createPattern(pCanvas, 'no-repeat');
    },

    handleFiller: function(ctx, property, filler) {
      var offsetX, offsetY;
      if (filler.toLive) {
        if (filler.gradientUnits === 'percentage' || filler.gradientTransform || filler.patternTransform) {
          // need to transform gradient in a pattern.
          // this is a slow process. If you are hitting this codepath, and the object
          // is not using caching, you should consider switching it on.
          // we need a canvas as big as the current object caching canvas.
          offsetX = -this.width / 2;
          offsetY = -this.height / 2;
          ctx.translate(offsetX, offsetY);
          ctx[property] = this._applyPatternGradientTransformText(filler);
          return { offsetX: offsetX, offsetY: offsetY };
        }
        else {
          // is a simple gradient or pattern
          ctx[property] = filler.toLive(ctx, this);
          return this._applyPatternGradientTransform(ctx, filler);
        }
      }
      else {
        // is a color
        ctx[property] = filler;
      }
      return { offsetX: 0, offsetY: 0 };
    },

    _setStrokeStyles: function(ctx, decl) {
      ctx.lineWidth = decl.strokeWidth;
      ctx.lineCap = this.strokeLineCap;
      ctx.lineDashOffset = this.strokeDashOffset;
      ctx.lineJoin = this.strokeLineJoin;
      ctx.miterLimit = this.strokeMiterLimit;
      return this.handleFiller(ctx, 'strokeStyle', decl.stroke);
    },

    _setFillStyles: function(ctx, decl) {
      return this.handleFiller(ctx, 'fillStyle', decl.fill);
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {String} _char
     * @param {Number} left Left coordinate
     * @param {Number} top Top coordinate
     * @param {Number} lineHeight Height of the line
     */
    _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
      var decl = this._getStyleDeclaration(lineIndex, charIndex),
          fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          shouldFill = method === 'fillText' && fullDecl.fill,
          shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth,
          fillOffsets, strokeOffsets;

      if (!shouldStroke && !shouldFill) {
        return;
      }
      ctx.save();

      shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));
      shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));

      ctx.font = this._getFontDeclaration(fullDecl);


      if (decl && decl.textBackgroundColor) {
        this._removeShadow(ctx);
      }
      if (decl && decl.deltaY) {
        top += decl.deltaY;
      }
      shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);
      shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);
      ctx.restore();
    },

    /**
     * Turns the character into a 'superior figure' (i.e. 'superscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSuperscript: function(start, end) {
      return this._setScript(start, end, this.superscript);
    },

    /**
     * Turns the character into an 'inferior figure' (i.e. 'subscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSubscript: function(start, end) {
      return this._setScript(start, end, this.subscript);
    },

    /**
     * Applies 'schema' at given position
     * @private
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @param {Number} schema
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    _setScript: function(start, end, schema) {
      var loc = this.get2DCursorLocation(start, true),
          fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
          dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
          style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
      this.setSelectionStyles(style, start, end);
      return this;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChanged: function(prevStyle, thisStyle) {
      return prevStyle.fill !== thisStyle.fill ||
              prevStyle.stroke !== thisStyle.stroke ||
              prevStyle.strokeWidth !== thisStyle.strokeWidth ||
              prevStyle.fontSize !== thisStyle.fontSize ||
              prevStyle.fontFamily !== thisStyle.fontFamily ||
              prevStyle.fontWeight !== thisStyle.fontWeight ||
              prevStyle.fontStyle !== thisStyle.fontStyle ||
              prevStyle.deltaY !== thisStyle.deltaY;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
      return this._hasStyleChanged(prevStyle, thisStyle) ||
        prevStyle.overline !== thisStyle.overline ||
        prevStyle.underline !== thisStyle.underline ||
        prevStyle.linethrough !== thisStyle.linethrough;
    },

    /**
     * @private
     * @param {Number} lineIndex index text line
     * @return {Number} Line left offset
     */
    _getLineLeftOffset: function(lineIndex) {
      var lineWidth = this.getLineWidth(lineIndex),
          lineDiff = this.width - lineWidth, textAlign = this.textAlign, direction = this.direction,
          isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);
      if (textAlign === 'justify'
        || (textAlign === 'justify-center' && !isEndOfWrapping)
        || (textAlign === 'justify-right' && !isEndOfWrapping)
        || (textAlign === 'justify-left' && !isEndOfWrapping)
      ) {
        return 0;
      }
      if (textAlign === 'center') {
        leftOffset = lineDiff / 2;
      }
      if (textAlign === 'right') {
        leftOffset = lineDiff;
      }
      if (textAlign === 'justify-center') {
        leftOffset = lineDiff / 2;
      }
      if (textAlign === 'justify-right') {
        leftOffset = lineDiff;
      }
      if (direction === 'rtl') {
        leftOffset -= lineDiff;
      }
      return leftOffset;
    },

    /**
     * @private
     */
    _clearCache: function() {
      this.__lineWidths = [];
      this.__lineHeights = [];
      this.__charBounds = [];
    },

    /**
     * @private
     */
    _shouldClearDimensionCache: function() {
      var shouldClear = this._forceClearCache;
      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
      if (shouldClear) {
        this.dirty = true;
        this._forceClearCache = false;
      }
      return shouldClear;
    },

    /**
     * Measure a single line given its index. Used to calculate the initial
     * text bounding box. The values are calculated and stored in __lineWidths cache.
     * @private
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    getLineWidth: function(lineIndex) {
      if (this.__lineWidths[lineIndex] !== undefined) {
        return this.__lineWidths[lineIndex];
      }

      var lineInfo = this.measureLine(lineIndex);
      var width = lineInfo.width;
      this.__lineWidths[lineIndex] = width;
      return width;
    },

    _getWidthOfCharSpacing: function() {
      if (this.charSpacing !== 0) {
        return this.fontSize * this.charSpacing / 1000;
      }
      return 0;
    },

    /**
     * Retrieves the value of property at given character position
     * @param {Number} lineIndex the line number
     * @param {Number} charIndex the character number
     * @param {String} property the property name
     * @returns the value of 'property'
     */
    getValueOfPropertyAt: function(lineIndex, charIndex, property) {
      var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
      if (charStyle && typeof charStyle[property] !== 'undefined') {
        return charStyle[property];
      }
      return this[property];
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextDecoration: function(ctx, type) {
      if (!this[type] && !this.styleHas(type)) {
        return;
      }
      var heightOfLine, size, _size,
          lineLeftOffset, dy, _dy,
          line, lastDecoration,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(), top,
          boxStart, boxWidth, charBox, currentDecoration,
          maxHeight, currentFill, lastFill, path = this.path,
          charSpacing = this._getWidthOfCharSpacing(),
          offsetY = this.offsets[type];

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this[type] && !this.styleHas(type, i)) {
          topOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        maxHeight = heightOfLine / this.lineHeight;
        lineLeftOffset = this._getLineLeftOffset(i);
        boxStart = 0;
        boxWidth = 0;
        lastDecoration = this.getValueOfPropertyAt(i, 0, type);
        lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
        top = topOffset + maxHeight * (1 - this._fontSizeFraction);
        size = this.getHeightOfChar(i, 0);
        dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentDecoration = this.getValueOfPropertyAt(i, j, type);
          currentFill = this.getValueOfPropertyAt(i, j, 'fill');
          _size = this.getHeightOfChar(i, j);
          _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
          if (path && currentDecoration && currentFill) {
            ctx.save();
            ctx.fillStyle = lastFill;
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            ctx.fillRect(
              -charBox.kernedWidth / 2,
              offsetY * _size + _dy,
              charBox.kernedWidth,
              this.fontSize / 15
            );
            ctx.restore();
          }
          else if (
            (currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy)
            && boxWidth > 0
          ) {
            var drawStart = leftOffset + lineLeftOffset + boxStart;
            if (this.direction === 'rtl') {
              drawStart = this.width - drawStart - boxWidth;
            }
            if (lastDecoration && lastFill) {
              ctx.fillStyle = lastFill;
              ctx.fillRect(
                drawStart,
                top + offsetY * size + dy,
                boxWidth,
                this.fontSize / 15
              );
            }
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastDecoration = currentDecoration;
            lastFill = currentFill;
            size = _size;
            dy = _dy;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        var drawStart = leftOffset + lineLeftOffset + boxStart;
        if (this.direction === 'rtl') {
          drawStart = this.width - drawStart - boxWidth;
        }
        ctx.fillStyle = currentFill;
        currentDecoration && currentFill && ctx.fillRect(
          drawStart,
          top + offsetY * size + dy,
          boxWidth - charSpacing,
          this.fontSize / 15
        );
        topOffset += heightOfLine;
      }
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * return font declaration string for canvas context
     * @param {Object} [styleObject] object
     * @returns {String} font declaration formatted for canvas context.
     */
    _getFontDeclaration: function(styleObject, forMeasuring) {
      var style = styleObject || this, family = this.fontFamily,
          fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
      var fontFamily = family === undefined ||
      family.indexOf('\'') > -1 || family.indexOf(',') > -1 ||
      family.indexOf('"') > -1 || fontIsGeneric
        ? style.fontFamily : '"' + style.fontFamily + '"';
      return [
        // node-canvas needs "weight style", while browsers need "style weight"
        // verify if this can be fixed in JSDOM
        (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
        (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
        forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
        fontFamily
      ].join(' ');
    },

    /**
     * Renders text instance on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if object is not visible
      if (!this.visible) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
      }
      this.callSuper('render', ctx);
    },

    /**
     * Returns the text as an array of lines.
     * @param {String} text text to split
     * @returns {Array} Lines in the text
     */
    _splitTextIntoLines: function(text) {
      var lines = text.split(this._reNewline),
          newLines = new Array(lines.length),
          newLine = ['\n'],
          newText = [];
      for (var i = 0; i < lines.length; i++) {
        newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
        newText = newText.concat(newLines[i], newLine);
      }
      newText.pop();
      return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var allProperties = additionalProps.concat(propertiesToInclude);
      var obj = this.callSuper('toObject', allProperties);
      // styles will be overridden with a properly cloned structure
      obj.styles = clone(this.styles, true);
      if (obj.path) {
        obj.path = this.path.toObject();
      }
      return obj;
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      this.callSuper('set', key, value);
      var needsDims = false;
      var isAddingPath = false;
      if (typeof key === 'object') {
        for (var _key in key) {
          if (_key === 'path') {
            this.setPathInfo();
          }
          needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
          isAddingPath = isAddingPath || _key === 'path';
        }
      }
      else {
        needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
        isAddingPath = key === 'path';
      }
      if (isAddingPath) {
        this.setPathInfo();
      }
      if (needsDims) {
        this.initDimensions();
        this.setCoords();
      }
      return this;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity
     */
    complexity: function() {
      return 1;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
   * @static
   * @memberOf fabric.Text
   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
   */
  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
    'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

  /**
   * Default SVG font size
   * @static
   * @memberOf fabric.Text
   */
  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

  /**
   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
   * @static
   * @memberOf fabric.Text
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Text.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
        parsedAnchor = parsedAttributes.textAnchor || 'left';
    options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

    options.top = options.top || 0;
    options.left = options.left || 0;
    if (parsedAttributes.textDecoration) {
      var textDecoration = parsedAttributes.textDecoration;
      if (textDecoration.indexOf('underline') !== -1) {
        options.underline = true;
      }
      if (textDecoration.indexOf('overline') !== -1) {
        options.overline = true;
      }
      if (textDecoration.indexOf('line-through') !== -1) {
        options.linethrough = true;
      }
      delete options.textDecoration;
    }
    if ('dx' in parsedAttributes) {
      options.left += parsedAttributes.dx;
    }
    if ('dy' in parsedAttributes) {
      options.top += parsedAttributes.dy;
    }
    if (!('fontSize' in options)) {
      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
    }

    var textContent = '';

    // The XML is not properly parsed in IE9 so a workaround to get
    // textContent is through firstChild.data. Another workaround would be
    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
    if (!('textContent' in element)) {
      if ('firstChild' in element && element.firstChild !== null) {
        if ('data' in element.firstChild && element.firstChild.data !== null) {
          textContent = element.firstChild.data;
        }
      }
    }
    else {
      textContent = element.textContent;
    }

    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
    var originalStrokeWidth = options.strokeWidth;
    options.strokeWidth = 0;

    var text = new fabric.Text(textContent, options),
        textHeightScaleFactor = text.getScaledHeight() / text.height,
        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
        scaledDiff = lineHeightDiff * textHeightScaleFactor,
        textHeight = text.getScaledHeight() + scaledDiff,
        offX = 0;
    /*
      Adjust positioning:
        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
        fabric output by default at top, left.
    */
    if (parsedAnchor === 'center') {
      offX = text.getScaledWidth() / 2;
    }
    if (parsedAnchor === 'right') {
      offX = text.getScaledWidth();
    }
    text.set({
      left: text.left - offX,
      top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
      strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
    });
    callback(text);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Text instance from an object representation
   * @static
   * @memberOf fabric.Text
   * @param {Object} object plain js Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
   */
  fabric.Text.fromObject = function(object, callback) {
    var objectCopy = clone(object), path = object.path;
    delete objectCopy.path;
    return fabric.Object._fromObject('Text', objectCopy, function(textInstance) {
      if (path) {
        fabric.Object._fromObject('Path', path, function(pathInstance) {
          textInstance.set('path', pathInstance);
          callback(textInstance);
        }, 'path');
      }
      else {
        callback(textInstance);
      }
    }, 'text');
  };

  fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

})(typeof exports !== 'undefined' ? exports : this);
(function() {
  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return true;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          // eslint-disable-next-line no-unused-vars
          for (var p3 in obj[p1][p2]) {
            return false;
          }
        }
      }
      return true;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * This function is used to detect if a text will use a particular property or not.
     * @param {String} property to check for
     * @param {Number} lineIndex to check the style on
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return false;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { 0: this.styles[lineIndex] };
      // eslint-disable-next-line
      for (var p1 in obj) {
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          if (typeof obj[p1][p2][property] !== 'undefined') {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Check if characters in a text have a value for a property
     * whose value matches the textbox's value for that property.  If so,
     * the character-level property is deleted.  If the character
     * has no other properties, then it is also deleted.  Finally,
     * if the line containing that character has no other characters
     * then it also is deleted.
     *
     * @param {string} property The property to compare between characters and text.
     */
    cleanStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
          allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
      // eslint-disable-next-line
      for (var p1 in obj) {
        letterCount = 0;
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          var styleObject = obj[p1][p2],
              stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

          stylesCount++;

          if (stylePropertyHasBeenSet) {
            if (!stylePropertyValue) {
              stylePropertyValue = styleObject[property];
            }
            else if (styleObject[property] !== stylePropertyValue) {
              allStyleObjectPropertiesMatch = false;
            }

            if (styleObject[property] === this[property]) {
              delete styleObject[property];
            }
          }
          else {
            allStyleObjectPropertiesMatch = false;
          }

          if (Object.keys(styleObject).length !== 0) {
            letterCount++;
          }
          else {
            delete obj[p1][p2];
          }
        }

        if (letterCount === 0) {
          delete obj[p1];
        }
      }
      // if every grapheme has the same style set then
      // delete those styles and set it on the parent
      for (var i = 0; i < this._textLines.length; i++) {
        graphemeCount += this._textLines[i].length;
      }
      if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
        this[property] = stylePropertyValue;
        this.removeStyle(property);
      }
    },

    /**
     * Remove a style property or properties from all individual character styles
     * in a text object.  Deletes the character style object if it contains no other style
     * props.  Deletes a line style object if it contains no other character styles.
     *
     * @param {String} props The property to remove from character styles.
     */
    removeStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return;
      }
      var obj = this.styles, line, lineNum, charNum;
      for (lineNum in obj) {
        line = obj[lineNum];
        for (charNum in line) {
          delete line[charNum][property];
          if (Object.keys(line[charNum]).length === 0) {
            delete line[charNum];
          }
        }
        if (Object.keys(line).length === 0) {
          delete obj[lineNum];
        }
      }
    },

    /**
     * @private
     */
    _extendStyles: function(index, styles) {
      var loc = this.get2DCursorLocation(index);

      if (!this._getLineStyle(loc.lineIndex)) {
        this._setLineStyle(loc.lineIndex);
      }

      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
      }

      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
    },

    /**
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.
     */
    get2DCursorLocation: function(selectionStart, skipWrapping) {
      if (typeof selectionStart === 'undefined') {
        selectionStart = this.selectionStart;
      }
      var lines = skipWrapping ? this._unwrappedTextLines : this._textLines,
          len = lines.length;
      for (var i = 0; i < len; i++) {
        if (selectionStart <= lines[i].length) {
          return {
            lineIndex: i,
            charIndex: selectionStart
          };
        }
        selectionStart -= lines[i].length + this.missingNewlineOffset(i);
      }
      return {
        lineIndex: i - 1,
        charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
      };
    },

    /**
     * Gets style of a current selection/cursor (at the start position)
     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @param {Boolean} [complete] get full style or not
     * @return {Array} styles an array with one, zero or more Style objects
     */
    getSelectionStyles: function(startIndex, endIndex, complete) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      var styles = [];
      for (var i = startIndex; i < endIndex; i++) {
        styles.push(this.getStyleAtPosition(i, complete));
      }
      return styles;
    },

    /**
     * Gets style of a current selection/cursor position
     * @param {Number} position  to get styles at
     * @param {Boolean} [complete] full style if true
     * @return {Object} style Style object at a specified index
     * @private
     */
    getStyleAtPosition: function(position, complete) {
      var loc = this.get2DCursorLocation(position),
          style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
            this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
      return style || {};
    },

    /**
     * Sets style of a current selection, if no selection exist, do not set anything.
     * @param {Object} [styles] Styles object
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @return {fabric.IText} thisArg
     * @chainable
     */
    setSelectionStyles: function(styles, startIndex, endIndex) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      for (var i = startIndex; i < endIndex; i++) {
        this._extendStyles(i, styles);
      }
      /* not included in _extendStyles to avoid clearing cache more than once */
      this._forceClearCache = true;
      return this;
    },

    /**
     * get the reference, not a clone, of the style object for a given character
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Object} style object
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      var lineStyle = this.styles && this.styles[lineIndex];
      if (!lineStyle) {
        return null;
      }
      return lineStyle[charIndex];
    },

    /**
     * return a new object that contains all the style property for a character
     * the object returned is newly created
     * @param {Number} lineIndex of the line where the character is
     * @param {Number} charIndex position of the character on the line
     * @return {Object} style object
     */
    getCompleteStyleDeclaration: function(lineIndex, charIndex) {
      var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
          styleObject = { }, prop;
      for (var i = 0; i < this._styleProperties.length; i++) {
        prop = this._styleProperties[i];
        styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
      }
      return styleObject;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      this.styles[lineIndex][charIndex] = style;
    },

    /**
     *
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * @param {Number} lineIndex
     * @return {Boolean} if the line exists or not
     * @private
     */
    _getLineStyle: function(lineIndex) {
      return !!this.styles[lineIndex];
    },

    /**
     * Set the line style to an empty object so that is initialized
     * @param {Number} lineIndex
     * @private
     */
    _setLineStyle: function(lineIndex) {
      this.styles[lineIndex] = {};
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      delete this.styles[lineIndex];
    }
  });
})();
(function() {

  function parseDecoration(object) {
    if (object.textDecoration) {
      object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
      object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
      object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
      delete object.textDecoration;
    }
  }

  /**
   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
   * prefix when observing canvas.
   * @class fabric.IText
   * @extends fabric.Text
   * @mixes fabric.Observable
   *
   * @fires changed
   * @fires selection:changed
   * @fires editing:entered
   * @fires editing:exited
   *
   * @return {fabric.IText} thisArg
   * @see {@link fabric.IText#initialize} for constructor definition
   *
   * <p>Supported key combinations:</p>
   * <pre>
   *   Move cursor:                    left, right, up, down
   *   Select character:               shift + left, shift + right
   *   Select text vertically:         shift + up, shift + down
   *   Move cursor by word:            alt + left, alt + right
   *   Select words:                   shift + alt + left, shift + alt + right
   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
   *   Jump to start/end of text:      cmd + up, cmd + down
   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
   *   Delete character:               backspace
   *   Delete word:                    alt + backspace
   *   Delete line:                    cmd + backspace
   *   Forward delete:                 delete
   *   Copy text:                      ctrl/cmd + c
   *   Paste text:                     ctrl/cmd + v
   *   Cut text:                       ctrl/cmd + x
   *   Select entire text:             ctrl/cmd + a
   *   Quit editing                    tab or esc
   * </pre>
   *
   * <p>Supported mouse/touch combination</p>
   * <pre>
   *   Position cursor:                click/touch
   *   Create selection:               click/touch & drag
   *   Create selection:               click & shift + click
   *   Select word:                    double click
   *   Select line:                    triple click
   * </pre>
   */
  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'i-text',

    /**
     * Index where text selection starts (or where cursor is when there is no selection)
     * @type Number
     * @default
     */
    selectionStart: 0,

    /**
     * Index where text selection ends
     * @type Number
     * @default
     */
    selectionEnd: 0,

    /**
     * Color of text selection
     * @type String
     * @default
     */
    selectionColor: 'rgba(17,119,255,0.3)',

    /**
     * Indicates whether text is in editing mode
     * @type Boolean
     * @default
     */
    isEditing: false,

    /**
     * Indicates whether a text can be edited
     * @type Boolean
     * @default
     */
    editable: true,

    /**
     * Border color of text object while it's in editing mode
     * @type String
     * @default
     */
    editingBorderColor: 'rgba(102,153,255,0.25)',

    /**
     * Width of cursor (in px)
     * @type Number
     * @default
     */
    cursorWidth: 2,

    /**
     * Color of text cursor color in editing mode.
     * if not set (default) will take color from the text.
     * if set to a color value that fabric can understand, it will
     * be used instead of the color of the text at the current position.
     * @type String
     * @default
     */
    cursorColor: '',

    /**
     * Delay between cursor blink (in ms)
     * @type Number
     * @default
     */
    cursorDelay: 1000,

    /**
     * Duration of cursor fadein (in ms)
     * @type Number
     * @default
     */
    cursorDuration: 600,

    /**
     * Indicates whether internal text char widths can be cached
     * @type Boolean
     * @default
     */
    caching: true,

    /**
     * DOM container to append the hiddenTextarea.
     * An alternative to attaching to the document.body.
     * Useful to reduce laggish redraw of the full document.body tree and
     * also with modals event capturing that won't let the textarea take focus.
     * @type HTMLElement
     * @default
     */
    hiddenTextareaContainer: null,

    /**
     * @private
     */
    _reSpace: /\s|\n/,

    /**
     * @private
     */
    _currentCursorOpacity: 0,

    /**
     * @private
     */
    _selectionDirection: null,

    /**
     * @private
     */
    _abortCursorAnimation: false,

    /**
     * @private
     */
    __widthOfSpace: [],

    /**
     * Helps determining when the text is in composition, so that the cursor
     * rendering is altered.
     */
    inCompositionMode: false,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.IText} thisArg
     */
    initialize: function(text, options) {
      this.callSuper('initialize', text, options);
      this.initBehavior();
    },

    /**
     * Sets selection start (left boundary of a selection)
     * @param {Number} index Index to set selection start to
     */
    setSelectionStart: function(index) {
      index = Math.max(index, 0);
      this._updateAndFire('selectionStart', index);
    },

    /**
     * Sets selection end (right boundary of a selection)
     * @param {Number} index Index to set selection end to
     */
    setSelectionEnd: function(index) {
      index = Math.min(index, this.text.length);
      this._updateAndFire('selectionEnd', index);
    },

    /**
     * @private
     * @param {String} property 'selectionStart' or 'selectionEnd'
     * @param {Number} index new position of property
     */
    _updateAndFire: function(property, index) {
      if (this[property] !== index) {
        this._fireSelectionChanged();
        this[property] = index;
      }
      this._updateTextarea();
    },

    /**
     * Fires the even of selection changed
     * @private
     */
    _fireSelectionChanged: function() {
      this.fire('selection:changed');
      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
    },

    /**
     * Initialize text dimensions. Render all text on given context
     * or on a offscreen canvas to get the text width with measureText.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     * @private
     */
    initDimensions: function() {
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this.callSuper('initDimensions');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      this.clearContextTop();
      this.callSuper('render', ctx);
      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
      // the correct position but not at every cursor animation.
      this.cursorOffsetCache = { };
      this.renderCursorOrSelection();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this.callSuper('_render', ctx);
    },

    /**
     * Prepare and clean the contextTop
     */
    clearContextTop: function(skipRestore) {
      if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
        return;
      }
      var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this.transform(ctx);
      this._clearTextArea(ctx);
      skipRestore || ctx.restore();
    },
    /**
     * Renders cursor or selection (depending on what exists)
     * it does on the contextTop. If contextTop is not available, do nothing.
     */
    renderCursorOrSelection: function() {
      if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
        return;
      }
      var boundaries = this._getCursorBoundaries(),
          ctx = this.canvas.contextTop;
      this.clearContextTop(true);
      if (this.selectionStart === this.selectionEnd) {
        this.renderCursor(boundaries, ctx);
      }
      else {
        this.renderSelection(boundaries, ctx);
      }
      ctx.restore();
    },

    _clearTextArea: function(ctx) {
      // we add 4 pixel, to be sure to do not leave any pixel out
      var width = this.width + 4, height = this.height + 4;
      ctx.clearRect(-width / 2, -height / 2, width, height);
    },

    /**
     * Returns cursor boundaries (left, top, leftOffset, topOffset)
     * @private
     * @param {Array} chars Array of characters
     * @param {String} typeOfBoundaries
     */
    _getCursorBoundaries: function(position) {

      // left/top are left/top of entire text box
      // leftOffset/topOffset are offset from that left/top point of a text box

      if (typeof position === 'undefined') {
        position = this.selectionStart;
      }

      var left = this._getLeftOffset(),
          top = this._getTopOffset(),
          offsets = this._getCursorBoundariesOffsets(position);
      return {
        left: left,
        top: top,
        leftOffset: offsets.left,
        topOffset: offsets.top
      };
    },

    /**
     * @private
     */
    _getCursorBoundariesOffsets: function(position) {
      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
        return this.cursorOffsetCache;
      }
      var lineLeftOffset,
          lineIndex,
          charIndex,
          topOffset = 0,
          leftOffset = 0,
          boundaries,
          cursorPosition = this.get2DCursorLocation(position);
      charIndex = cursorPosition.charIndex;
      lineIndex = cursorPosition.lineIndex;
      for (var i = 0; i < lineIndex; i++) {
        topOffset += this.getHeightOfLine(i);
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      var bound = this.__charBounds[lineIndex][charIndex];
      bound && (leftOffset = bound.left);
      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
        leftOffset -= this._getWidthOfCharSpacing();
      }
      boundaries = {
        top: topOffset,
        left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
      };
      if (this.direction === 'rtl') {
        boundaries.left *= -1;
      }
      this.cursorOffsetCache = boundaries;
      return this.cursorOffsetCache;
    },

    /**
     * Renders cursor
     * @param {Object} boundaries
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderCursor: function(boundaries, ctx) {
      var cursorLocation = this.get2DCursorLocation(),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
          multiplier = this.scaleX * this.canvas.getZoom(),
          cursorWidth = this.cursorWidth / multiplier,
          topOffset = boundaries.topOffset,
          dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');
      topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
        - charHeight * (1 - this._fontSizeFraction);

      if (this.inCompositionMode) {
        this.renderSelection(boundaries, ctx);
      }
      ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
      ctx.fillRect(
        boundaries.left + boundaries.leftOffset - cursorWidth / 2,
        topOffset + boundaries.top + dy,
        cursorWidth,
        charHeight);
    },

    /**
     * Renders text selection
     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderSelection: function(boundaries, ctx) {

      var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
          selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
          isJustify = this.textAlign.indexOf('justify') !== -1,
          start = this.get2DCursorLocation(selectionStart),
          end = this.get2DCursorLocation(selectionEnd),
          startLine = start.lineIndex,
          endLine = end.lineIndex,
          startChar = start.charIndex < 0 ? 0 : start.charIndex,
          endChar = end.charIndex < 0 ? 0 : end.charIndex;

      for (var i = startLine; i <= endLine; i++) {
        var lineOffset = this._getLineLeftOffset(i) || 0,
            lineHeight = this.getHeightOfLine(i),
            realLineHeight = 0, boxStart = 0, boxEnd = 0;

        if (i === startLine) {
          boxStart = this.__charBounds[startLine][startChar].left;
        }
        if (i >= startLine && i < endLine) {
          boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
        }
        else if (i === endLine) {
          if (endChar === 0) {
            boxEnd = this.__charBounds[endLine][endChar].left;
          }
          else {
            var charSpacing = this._getWidthOfCharSpacing();
            boxEnd = this.__charBounds[endLine][endChar - 1].left
              + this.__charBounds[endLine][endChar - 1].width - charSpacing;
          }
        }
        realLineHeight = lineHeight;
        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
          lineHeight /= this.lineHeight;
        }
        var drawStart = boundaries.left + lineOffset + boxStart,
            drawWidth = boxEnd - boxStart,
            drawHeight = lineHeight, extraTop = 0;
        if (this.inCompositionMode) {
          ctx.fillStyle = this.compositionColor || 'black';
          drawHeight = 1;
          extraTop = lineHeight;
        }
        else {
          ctx.fillStyle = this.selectionColor;
        }
        if (this.direction === 'rtl') {
          drawStart = this.width - drawStart - drawWidth;
        }
        ctx.fillRect(
          drawStart,
          boundaries.top + boundaries.topOffset + extraTop,
          drawWidth,
          drawHeight);
        boundaries.topOffset += realLineHeight;
      }
    },

    /**
     * High level function to know the height of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns fontSize of char at the current cursor
     * Unused from the library, is for the end user
     * @return {Number} Character font size
     */
    getCurrentCharFontSize: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
    },

    /**
     * High level function to know the color of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns color (fill) of char at the current cursor
     * if the text object has a pattern or gradient for filler, it will return that.
     * Unused by the library, is for the end user
     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)
     */
    getCurrentCharColor: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
    },

    /**
     * Returns the cursor position for the getCurrent.. functions
     * @private
     */
    _getCurrentCharIndex: function() {
      var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
          charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
      return { l: cursorPosition.lineIndex, c: charIndex };
    }
  });

  /**
   * Returns fabric.IText instance from an object representation
   * @static
   * @memberOf fabric.IText
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as argument
   */
  fabric.IText.fromObject = function(object, callback) {
    parseDecoration(object);
    if (object.styles) {
      for (var i in object.styles) {
        for (var j in object.styles[i]) {
          parseDecoration(object.styles[i][j]);
        }
      }
    }
    fabric.Object._fromObject('IText', object, callback, 'text');
  };
})();
(function() {

  var clone = fabric.util.object.clone;

  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes all the interactive behavior of IText
     */
    initBehavior: function() {
      this.initAddedHandler();
      this.initRemovedHandler();
      this.initCursorSelectionHandlers();
      this.initDoubleClickSimulation();
      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    },

    onDeselect: function() {
      this.isEditing && this.exitEditing();
      this.selected = false;
    },

    /**
     * Initializes "added" event handler
     */
    initAddedHandler: function() {
      var _this = this;
      this.on('added', function() {
        var canvas = _this.canvas;
        if (canvas) {
          if (!canvas._hasITextHandlers) {
            canvas._hasITextHandlers = true;
            _this._initCanvasHandlers(canvas);
          }
          canvas._iTextInstances = canvas._iTextInstances || [];
          canvas._iTextInstances.push(_this);
        }
      });
    },

    initRemovedHandler: function() {
      var _this = this;
      this.on('removed', function() {
        var canvas = _this.canvas;
        if (canvas) {
          canvas._iTextInstances = canvas._iTextInstances || [];
          fabric.util.removeFromArray(canvas._iTextInstances, _this);
          if (canvas._iTextInstances.length === 0) {
            canvas._hasITextHandlers = false;
            _this._removeCanvasHandlers(canvas);
          }
        }
      });
    },

    /**
     * register canvas event to manage exiting on other instances
     * @private
     */
    _initCanvasHandlers: function(canvas) {
      canvas._mouseUpITextHandler = function() {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.__isMousedown = false;
          });
        }
      };
      canvas.on('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * remove canvas event to manage exiting on other instances
     * @private
     */
    _removeCanvasHandlers: function(canvas) {
      canvas.off('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * @private
     */
    _tick: function() {
      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
    },

    /**
     * @private
     */
    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

      var tickState;

      tickState = {
        isAborted: false,
        abort: function() {
          this.isAborted = true;
        },
      };

      obj.animate('_currentCursorOpacity', targetOpacity, {
        duration: duration,
        onComplete: function() {
          if (!tickState.isAborted) {
            obj[completeMethod]();
          }
        },
        onChange: function() {
          // we do not want to animate a selection, only cursor
          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
            obj.renderCursorOrSelection();
          }
        },
        abort: function() {
          return tickState.isAborted;
        }
      });
      return tickState;
    },

    /**
     * @private
     */
    _onTickComplete: function() {

      var _this = this;

      if (this._cursorTimeout1) {
        clearTimeout(this._cursorTimeout1);
      }
      this._cursorTimeout1 = setTimeout(function() {
        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
      }, 100);
    },

    /**
     * Initializes delayed cursor
     */
    initDelayedCursor: function(restart) {
      var _this = this,
          delay = restart ? 0 : this.cursorDelay;

      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this._cursorTimeout2 = setTimeout(function() {
        _this._tick();
      }, delay);
    },

    /**
     * Aborts cursor animation and clears all timeouts
     */
    abortCursorAnimation: function() {
      var shouldClear = this._currentTickState || this._currentTickCompleteState,
          canvas = this.canvas;
      this._currentTickState && this._currentTickState.abort();
      this._currentTickCompleteState && this._currentTickCompleteState.abort();

      clearTimeout(this._cursorTimeout1);
      clearTimeout(this._cursorTimeout2);

      this._currentCursorOpacity = 0;
      // to clear just itext area we need to transform the context
      // it may not be worth it
      if (shouldClear && canvas) {
        canvas.clearContext(canvas.contextTop || canvas.contextContainer);
      }

    },

    /**
     * Selects entire text
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectAll: function() {
      this.selectionStart = 0;
      this.selectionEnd = this._text.length;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Returns selected text
     * @return {String}
     */
    getSelectedText: function() {
      return this._text.slice(this.selectionStart, this.selectionEnd).join('');
    },

    /**
     * Find new selection index representing start of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      // remove space before cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index--;
        }
      }
      while (/\S/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      // remove space after cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index++;
        }
      }
      while (/\S/.test(this._text[index]) && index < this._text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Find new selection index representing start of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      while (!/\n/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      while (!/\n/.test(this._text[index]) && index < this._text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Finds index corresponding to beginning or end of a word
     * @param {Number} selectionStart Index of a character
     * @param {Number} direction 1 or -1
     * @return {Number} Index of the beginning or end of a word
     */
    searchWordBoundary: function(selectionStart, direction) {
      var text = this._text,
          index     = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart,
          _char     = text[index],
          // wrong
          reNonWord = fabric.reNonWord;

      while (!reNonWord.test(_char) && index > 0 && index < text.length) {
        index += direction;
        _char = text[index];
      }
      if (reNonWord.test(_char)) {
        index += direction === 1 ? 0 : 1;
      }
      return index;
    },

    /**
     * Selects a word based on the index
     * @param {Number} selectionStart Index of a character
     */
    selectWord: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      this.renderCursorOrSelection();
    },

    /**
     * Selects a line based on the index
     * @param {Number} selectionStart Index of a character
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectLine: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
          newSelectionEnd = this.findLineBoundaryRight(selectionStart);

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Enters editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    enterEditing: function(e) {
      if (this.isEditing || !this.editable) {
        return;
      }

      if (this.canvas) {
        this.canvas.calcOffset();
        this.exitEditingOnOthers(this.canvas);
      }

      this.isEditing = true;

      this.initHiddenTextarea(e);
      this.hiddenTextarea.focus();
      this.hiddenTextarea.value = this.text;
      this._updateTextarea();
      this._saveEditingProps();
      this._setEditingProps();
      this._textBeforeEdit = this.text;

      this._tick();
      this.fire('editing:entered');
      this._fireSelectionChanged();
      if (!this.canvas) {
        return this;
      }
      this.canvas.fire('text:editing:entered', { target: this });
      this.initMouseMoveHandler();
      this.canvas.requestRenderAll();
      return this;
    },

    exitEditingOnOthers: function(canvas) {
      if (canvas._iTextInstances) {
        canvas._iTextInstances.forEach(function(obj) {
          obj.selected = false;
          if (obj.isEditing) {
            obj.exitEditing();
          }
        });
      }
    },

    /**
     * Initializes "mousemove" event handler
     */
    initMouseMoveHandler: function() {
      this.canvas.on('mouse:move', this.mouseMoveHandler);
    },

    /**
     * @private
     */
    mouseMoveHandler: function(options) {
      if (!this.__isMousedown || !this.isEditing) {
        return;
      }

      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
          currentStart = this.selectionStart,
          currentEnd = this.selectionEnd;
      if (
        (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
        &&
        (currentStart === newSelectionStart || currentEnd === newSelectionStart)
      ) {
        return;
      }
      if (newSelectionStart > this.__selectionStartOnMouseDown) {
        this.selectionStart = this.__selectionStartOnMouseDown;
        this.selectionEnd = newSelectionStart;
      }
      else {
        this.selectionStart = newSelectionStart;
        this.selectionEnd = this.__selectionStartOnMouseDown;
      }
      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
        this.restartCursorIfNeeded();
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      }
    },

    /**
     * @private
     */
    _setEditingProps: function() {
      this.hoverCursor = 'text';

      if (this.canvas) {
        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
      }

      this.borderColor = this.editingBorderColor;
      this.hasControls = this.selectable = false;
      this.lockMovementX = this.lockMovementY = true;
    },

    /**
     * convert from textarea to grapheme indexes
     */
    fromStringToGraphemeSelection: function(start, end, text) {
      var smallerTextStart = text.slice(0, start),
          graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = text.slice(start, end),
          graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * convert from fabric to textarea values
     */
    fromGraphemeToStringSelection: function(start, end, _text) {
      var smallerTextStart = _text.slice(0, start),
          graphemeStart = smallerTextStart.join('').length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = _text.slice(start, end),
          graphemeEnd = smallerTextEnd.join('').length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * @private
     */
    _updateTextarea: function() {
      this.cursorOffsetCache = { };
      if (!this.hiddenTextarea) {
        return;
      }
      if (!this.inCompositionMode) {
        var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = newSelection.selectionStart;
        this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateFromTextArea: function() {
      if (!this.hiddenTextarea) {
        return;
      }
      this.cursorOffsetCache = { };
      this.text = this.hiddenTextarea.value;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      var newSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
      this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
      if (!this.inCompositionMode) {
        this.selectionStart = newSelection.selectionStart;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateTextareaPosition: function() {
      if (this.selectionStart === this.selectionEnd) {
        var style = this._calcTextareaPosition();
        this.hiddenTextarea.style.left = style.left;
        this.hiddenTextarea.style.top = style.top;
      }
    },

    /**
     * @private
     * @return {Object} style contains style for hiddenTextarea
     */
    _calcTextareaPosition: function() {
      if (!this.canvas) {
        return { x: 1, y: 1 };
      }
      var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart,
          boundaries = this._getCursorBoundaries(desiredPosition),
          cursorLocation = this.get2DCursorLocation(desiredPosition),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
          leftOffset = boundaries.leftOffset,
          m = this.calcTransformMatrix(),
          p = {
            x: boundaries.left + leftOffset,
            y: boundaries.top + boundaries.topOffset + charHeight
          },
          retinaScaling = this.canvas.getRetinaScaling(),
          upperCanvas = this.canvas.upperCanvasEl,
          upperCanvasWidth = upperCanvas.width / retinaScaling,
          upperCanvasHeight = upperCanvas.height / retinaScaling,
          maxWidth = upperCanvasWidth - charHeight,
          maxHeight = upperCanvasHeight - charHeight,
          scaleX = upperCanvas.clientWidth / upperCanvasWidth,
          scaleY = upperCanvas.clientHeight / upperCanvasHeight;

      p = fabric.util.transformPoint(p, m);
      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
      p.x *= scaleX;
      p.y *= scaleY;
      if (p.x < 0) {
        p.x = 0;
      }
      if (p.x > maxWidth) {
        p.x = maxWidth;
      }
      if (p.y < 0) {
        p.y = 0;
      }
      if (p.y > maxHeight) {
        p.y = maxHeight;
      }

      // add canvas offset on document
      p.x += this.canvas._offset.left;
      p.y += this.canvas._offset.top;

      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
    },

    /**
     * @private
     */
    _saveEditingProps: function() {
      this._savedProps = {
        hasControls: this.hasControls,
        borderColor: this.borderColor,
        lockMovementX: this.lockMovementX,
        lockMovementY: this.lockMovementY,
        hoverCursor: this.hoverCursor,
        selectable: this.selectable,
        defaultCursor: this.canvas && this.canvas.defaultCursor,
        moveCursor: this.canvas && this.canvas.moveCursor
      };
    },

    /**
     * @private
     */
    _restoreEditingProps: function() {
      if (!this._savedProps) {
        return;
      }

      this.hoverCursor = this._savedProps.hoverCursor;
      this.hasControls = this._savedProps.hasControls;
      this.borderColor = this._savedProps.borderColor;
      this.selectable = this._savedProps.selectable;
      this.lockMovementX = this._savedProps.lockMovementX;
      this.lockMovementY = this._savedProps.lockMovementY;

      if (this.canvas) {
        this.canvas.defaultCursor = this._savedProps.defaultCursor;
        this.canvas.moveCursor = this._savedProps.moveCursor;
      }
    },

    /**
     * Exits from editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    exitEditing: function() {
      var isTextChanged = (this._textBeforeEdit !== this.text);
      var hiddenTextarea = this.hiddenTextarea;
      this.selected = false;
      this.isEditing = false;

      this.selectionEnd = this.selectionStart;

      if (hiddenTextarea) {
        hiddenTextarea.blur && hiddenTextarea.blur();
        hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
      }
      this.hiddenTextarea = null;
      this.abortCursorAnimation();
      this._restoreEditingProps();
      this._currentCursorOpacity = 0;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this.fire('editing:exited');
      isTextChanged && this.fire('modified');
      if (this.canvas) {
        this.canvas.off('mouse:move', this.mouseMoveHandler);
        this.canvas.fire('text:editing:exited', { target: this });
        isTextChanged && this.canvas.fire('object:modified', { target: this });
      }
      return this;
    },

    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this.styles) {
        if (!this._textLines[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * remove and reflow a style block from start to end.
     * @param {Number} start linear start position for removal (included in removal)
     * @param {Number} end linear end position for removal ( excluded from removal )
     */
    removeStyleFromTo: function(start, end) {
      var cursorStart = this.get2DCursorLocation(start, true),
          cursorEnd = this.get2DCursorLocation(end, true),
          lineStart = cursorStart.lineIndex,
          charStart = cursorStart.charIndex,
          lineEnd = cursorEnd.lineIndex,
          charEnd = cursorEnd.charIndex,
          i, styleObj;
      if (lineStart !== lineEnd) {
        // step1 remove the trailing of lineStart
        if (this.styles[lineStart]) {
          for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
            delete this.styles[lineStart][i];
          }
        }
        // step2 move the trailing of lineEnd to lineStart if needed
        if (this.styles[lineEnd]) {
          for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
            styleObj = this.styles[lineEnd][i];
            if (styleObj) {
              this.styles[lineStart] || (this.styles[lineStart] = { });
              this.styles[lineStart][charStart + i - charEnd] = styleObj;
            }
          }
        }
        // step3 detects lines will be completely removed.
        for (i = lineStart + 1; i <= lineEnd; i++) {
          delete this.styles[i];
        }
        // step4 shift remaining lines.
        this.shiftLineStyles(lineEnd, lineStart - lineEnd);
      }
      else {
        // remove and shift left on the same line
        if (this.styles[lineStart]) {
          styleObj = this.styles[lineStart];
          var diff = charEnd - charStart, numericChar, _char;
          for (i = charStart; i < charEnd; i++) {
            delete styleObj[i];
          }
          for (_char in this.styles[lineStart]) {
            numericChar = parseInt(_char, 10);
            if (numericChar >= charEnd) {
              styleObj[numericChar - diff] = styleObj[_char];
              delete styleObj[_char];
            }
          }
        }
      }
    },

    /**
     * Shifts line styles up or down
     * @param {Number} lineIndex Index of a line
     * @param {Number} offset Can any number?
     */
    shiftLineStyles: function(lineIndex, offset) {
      // shift all line styles by offset upward or downward
      // do not clone deep. we need new array, not new style objects
      var clonedStyles = clone(this.styles);
      for (var line in this.styles) {
        var numericLine = parseInt(line, 10);
        if (numericLine > lineIndex) {
          this.styles[numericLine + offset] = clonedStyles[numericLine];
          if (!clonedStyles[numericLine - offset]) {
            delete this.styles[numericLine];
          }
        }
      }
    },

    restartCursorIfNeeded: function() {
      if (!this._currentTickState || this._currentTickState.isAborted
        || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
      ) {
        this.initDelayedCursor();
      }
    },

    /**
     * Handle insertion of more consecutive style lines for when one or more
     * newlines gets added to the text. Since current style needs to be shifted
     * first we shift the current style of the number lines needed, then we add
     * new lines from the last to the first.
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} qty number of lines to add
     * @param {Array} copiedStyle Array of objects styles
     */
    insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
      var currentCharStyle,
          newLineStyles = {},
          somethingAdded = false,
          isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;

      qty || (qty = 1);
      this.shiftLineStyles(lineIndex, qty);
      if (this.styles[lineIndex]) {
        currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
      }
      // we clone styles of all chars
      // after cursor onto the current line
      for (var index in this.styles[lineIndex]) {
        var numIndex = parseInt(index, 10);
        if (numIndex >= charIndex) {
          somethingAdded = true;
          newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
          // remove lines from the previous line since they're on a new line now
          if (!(isEndOfLine && charIndex === 0)) {
            delete this.styles[lineIndex][index];
          }
        }
      }
      var styleCarriedOver = false;
      if (somethingAdded && !isEndOfLine) {
        // if is end of line, the extra style we copied
        // is probably not something we want
        this.styles[lineIndex + qty] = newLineStyles;
        styleCarriedOver = true;
      }
      if (styleCarriedOver) {
        // skip the last line of since we already prepared it.
        qty--;
      }
      // for the all the lines or all the other lines
      // we clone current char style onto the next (otherwise empty) line
      while (qty > 0) {
        if (copiedStyle && copiedStyle[qty - 1]) {
          this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty - 1]) };
        }
        else if (currentCharStyle) {
          this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
        }
        else {
          delete this.styles[lineIndex + qty];
        }
        qty--;
      }
      this._forceClearCache = true;
    },

    /**
     * Inserts style object for a given line/char index
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} quantity number Style object to insert, if given
     * @param {Array} copiedStyle array of style objects
     */
    insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
      if (!this.styles) {
        this.styles = {};
      }
      var currentLineStyles       = this.styles[lineIndex],
          currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

      quantity || (quantity = 1);
      // shift all char styles by quantity forward
      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
      for (var index in currentLineStylesCloned) {
        var numericIndex = parseInt(index, 10);
        if (numericIndex >= charIndex) {
          currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
          // only delete the style if there was nothing moved there
          if (!currentLineStylesCloned[numericIndex - quantity]) {
            delete currentLineStyles[numericIndex];
          }
        }
      }
      this._forceClearCache = true;
      if (copiedStyle) {
        while (quantity--) {
          if (!Object.keys(copiedStyle[quantity]).length) {
            continue;
          }
          if (!this.styles[lineIndex]) {
            this.styles[lineIndex] = {};
          }
          this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
        }
        return;
      }
      if (!currentLineStyles) {
        return;
      }
      var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
      while (newStyle && quantity--) {
        this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
      }
    },

    /**
     * Inserts style object(s)
     * @param {Array} insertedText Characters at the location where style is inserted
     * @param {Number} start cursor index for inserting style
     * @param {Array} [copiedStyle] array of style objects to insert.
     */
    insertNewStyleBlock: function(insertedText, start, copiedStyle) {
      var cursorLoc = this.get2DCursorLocation(start, true),
          addedLines = [0], linesLength = 0;
      // get an array of how many char per lines are being added.
      for (var i = 0; i < insertedText.length; i++) {
        if (insertedText[i] === '\n') {
          linesLength++;
          addedLines[linesLength] = 0;
        }
        else {
          addedLines[linesLength]++;
        }
      }
      // for the first line copy the style from the current char position.
      if (addedLines[0] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
      }
      linesLength && this.insertNewlineStyleObject(
        cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);
      for (var i = 1; i < linesLength; i++) {
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
        else if (copiedStyle) {
          // this test is required in order to close #6841
          // when a pasted buffer begins with a newline then
          // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]
          // may be undefined for some reason
          if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {
            this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
          }
        }
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
      }
      // we use i outside the loop to get it like linesLength
      if (addedLines[i] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
      }
    },

    /**
     * Set the selectionStart and selectionEnd according to the new position of cursor
     * mimic the key - mouse navigation when shift is pressed.
     */
    setSelectionStartEndWithShift: function(start, end, newSelection) {
      if (newSelection <= start) {
        if (end === start) {
          this._selectionDirection = 'left';
        }
        else if (this._selectionDirection === 'right') {
          this._selectionDirection = 'left';
          this.selectionEnd = start;
        }
        this.selectionStart = newSelection;
      }
      else if (newSelection > start && newSelection < end) {
        if (this._selectionDirection === 'right') {
          this.selectionEnd = newSelection;
        }
        else {
          this.selectionStart = newSelection;
        }
      }
      else {
        // newSelection is > selection start and end
        if (end === start) {
          this._selectionDirection = 'right';
        }
        else if (this._selectionDirection === 'left') {
          this._selectionDirection = 'right';
          this.selectionStart = end;
        }
        this.selectionEnd = newSelection;
      }
    },

    setSelectionInBoundaries: function() {
      var length = this.text.length;
      if (this.selectionStart > length) {
        this.selectionStart = length;
      }
      else if (this.selectionStart < 0) {
        this.selectionStart = 0;
      }
      if (this.selectionEnd > length) {
        this.selectionEnd = length;
      }
      else if (this.selectionEnd < 0) {
        this.selectionEnd = 0;
      }
    }
  });
})();
fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
  /**
   * Initializes "dbclick" event handler
   */
  initDoubleClickSimulation: function() {

    // for double click
    this.__lastClickTime = +new Date();

    // for triple click
    this.__lastLastClickTime = +new Date();

    this.__lastPointer = { };

    this.on('mousedown', this.onMouseDown);
  },

  /**
   * Default event handler to simulate triple click
   * @private
   */
  onMouseDown: function(options) {
    if (!this.canvas) {
      return;
    }
    this.__newClickTime = +new Date();
    var newPointer = options.pointer;
    if (this.isTripleClick(newPointer)) {
      this.fire('tripleclick', options);
      this._stopEvent(options.e);
    }
    this.__lastLastClickTime = this.__lastClickTime;
    this.__lastClickTime = this.__newClickTime;
    this.__lastPointer = newPointer;
    this.__lastIsEditing = this.isEditing;
    this.__lastSelected = this.selected;
  },

  isTripleClick: function(newPointer) {
    return this.__newClickTime - this.__lastClickTime < 500 &&
        this.__lastClickTime - this.__lastLastClickTime < 500 &&
        this.__lastPointer.x === newPointer.x &&
        this.__lastPointer.y === newPointer.y;
  },

  /**
   * @private
   */
  _stopEvent: function(e) {
    e.preventDefault && e.preventDefault();
    e.stopPropagation && e.stopPropagation();
  },

  /**
   * Initializes event handlers related to cursor or selection
   */
  initCursorSelectionHandlers: function() {
    this.initMousedownHandler();
    this.initMouseupHandler();
    this.initClicks();
  },

  /**
   * Default handler for double click, select a word
   */
  doubleClickHandler: function(options) {
    if (!this.isEditing) {
      return;
    }
    this.selectWord(this.getSelectionStartFromPointer(options.e));
  },

  /**
   * Default handler for triple click, select a line
   */
  tripleClickHandler: function(options) {
    if (!this.isEditing) {
      return;
    }
    this.selectLine(this.getSelectionStartFromPointer(options.e));
  },

  /**
   * Initializes double and triple click event handlers
   */
  initClicks: function() {
    this.on('mousedblclick', this.doubleClickHandler);
    this.on('tripleclick', this.tripleClickHandler);
  },

  /**
   * Default event handler for the basic functionalities needed on _mouseDown
   * can be overridden to do something different.
   * Scope of this implementation is: find the click position, set selectionStart
   * find selectionEnd, initialize the drawing of either cursor or selection area
   * initializing a mousedDown on a text area will cancel fabricjs knowledge of
   * current compositionMode. It will be set to false.
   */
  _mouseDownHandler: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }

    this.__isMousedown = true;

    if (this.selected) {
      this.inCompositionMode = false;
      this.setCursorByClick(options.e);
    }

    if (this.isEditing) {
      this.__selectionStartOnMouseDown = this.selectionStart;
      if (this.selectionStart === this.selectionEnd) {
        this.abortCursorAnimation();
      }
      this.renderCursorOrSelection();
    }
  },

  /**
   * Default event handler for the basic functionalities needed on mousedown:before
   * can be overridden to do something different.
   * Scope of this implementation is: verify the object is already selected when mousing down
   */
  _mouseDownHandlerBefore: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }
    // we want to avoid that an object that was selected and then becomes unselectable,
    // may trigger editing mode in some way.
    this.selected = this === this.canvas._activeObject;
  },

  /**
   * Initializes "mousedown" event handler
   */
  initMousedownHandler: function() {
    this.on('mousedown', this._mouseDownHandler);
    this.on('mousedown:before', this._mouseDownHandlerBefore);
  },

  /**
   * Initializes "mouseup" event handler
   */
  initMouseupHandler: function() {
    this.on('mouseup', this.mouseUpHandler);
  },

  /**
   * standard handler for mouse up, overridable
   * @private
   */
  mouseUpHandler: function(options) {
    this.__isMousedown = false;
    if (!this.editable || this.group ||
      (options.transform && options.transform.actionPerformed) ||
      (options.e.button && options.e.button !== 1)) {
      return;
    }

    if (this.canvas) {
      var currentActive = this.canvas._activeObject;
      if (currentActive && currentActive !== this) {
        // avoid running this logic when there is an active object
        // this because is possible with shift click and fast clicks,
        // to rapidly deselect and reselect this object and trigger an enterEdit
        return;
      }
    }

    if (this.__lastSelected && !this.__corner) {
      this.selected = false;
      this.__lastSelected = false;
      this.enterEditing(options.e);
      if (this.selectionStart === this.selectionEnd) {
        this.initDelayedCursor(true);
      }
      else {
        this.renderCursorOrSelection();
      }
    }
    else {
      this.selected = true;
    }
  },

  /**
   * Changes cursor location in a text depending on passed pointer (x/y) object
   * @param {Event} e Event object
   */
  setCursorByClick: function(e) {
    var newSelection = this.getSelectionStartFromPointer(e),
        start = this.selectionStart, end = this.selectionEnd;
    if (e.shiftKey) {
      this.setSelectionStartEndWithShift(start, end, newSelection);
    }
    else {
      this.selectionStart = newSelection;
      this.selectionEnd = newSelection;
    }
    if (this.isEditing) {
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Returns index of a character corresponding to where an object was clicked
   * @param {Event} e Event object
   * @return {Number} Index of a character
   */
  getSelectionStartFromPointer: function(e) {
    var mouseOffset = this.getLocalPointer(e),
        prevWidth = 0,
        width = 0,
        height = 0,
        charIndex = 0,
        lineIndex = 0,
        lineLeftOffset,
        line;
    for (var i = 0, len = this._textLines.length; i < len; i++) {
      if (height <= mouseOffset.y) {
        height += this.getHeightOfLine(i) * this.scaleY;
        lineIndex = i;
        if (i > 0) {
          charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
        }
      }
      else {
        break;
      }
    }
    lineLeftOffset = this._getLineLeftOffset(lineIndex);
    width = lineLeftOffset * this.scaleX;
    line = this._textLines[lineIndex];
    // handling of RTL: in order to get things work correctly,
    // we assume RTL writing is mirrored compared to LTR writing.
    // so in position detection we mirror the X offset, and when is time
    // of rendering it, we mirror it again.
    if (this.direction === 'rtl') {
      mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;
    }
    for (var j = 0, jlen = line.length; j < jlen; j++) {
      prevWidth = width;
      // i removed something about flipX here, check.
      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
      if (width <= mouseOffset.x) {
        charIndex++;
      }
      else {
        break;
      }
    }
    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
  },

  /**
   * @private
   */
  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
        distanceBtwNextCharAndCursor = width - mouseOffset.x,
        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
          distanceBtwNextCharAndCursor < 0 ? 0 : 1,
        newSelectionStart = index + offset;
    // if object is horizontally flipped, mirror cursor location from the end
    if (this.flipX) {
      newSelectionStart = jlen - newSelectionStart;
    }

    if (newSelectionStart > this._text.length) {
      newSelectionStart = this._text.length;
    }

    return newSelectionStart;
  }
});
fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

  /**
   * Initializes hidden textarea (needed to bring up keyboard in iOS)
   */
  initHiddenTextarea: function() {
    this.hiddenTextarea = fabric.document.createElement('textarea');
    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
    this.hiddenTextarea.setAttribute('autocorrect', 'off');
    this.hiddenTextarea.setAttribute('autocomplete', 'off');
    this.hiddenTextarea.setAttribute('spellcheck', 'false');
    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
    this.hiddenTextarea.setAttribute('wrap', 'off');
    var style = this._calcTextareaPosition();
    // line-height: 1px; was removed from the style to fix this:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
    ' paddingtop: ' + style.fontSize + ';';

    if (this.hiddenTextareaContainer) {
      this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);
    }
    else {
      fabric.document.body.appendChild(this.hiddenTextarea);
    }

    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

    if (!this._clickHandlerInitialized && this.canvas) {
      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
      this._clickHandlerInitialized = true;
    }
  },

  /**
   * For functionalities on keyDown
   * Map a special key to a function of the instance/prototype
   * If you need different behaviour for ESC or TAB or arrows, you have to change
   * this map setting the name of a function that you build on the fabric.Itext or
   * your prototype.
   * the map change will affect all Instances unless you need for only some text Instances
   * in that case you have to clone this object and assign your Instance.
   * this.keysMap = fabric.util.object.clone(this.keysMap);
   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
   */
  keysMap: {
    9:  'exitEditing',
    27: 'exitEditing',
    33: 'moveCursorUp',
    34: 'moveCursorDown',
    35: 'moveCursorRight',
    36: 'moveCursorLeft',
    37: 'moveCursorLeft',
    38: 'moveCursorUp',
    39: 'moveCursorRight',
    40: 'moveCursorDown',
  },

  keysMapRtl: {
    9:  'exitEditing',
    27: 'exitEditing',
    33: 'moveCursorUp',
    34: 'moveCursorDown',
    35: 'moveCursorLeft',
    36: 'moveCursorRight',
    37: 'moveCursorRight',
    38: 'moveCursorUp',
    39: 'moveCursorLeft',
    40: 'moveCursorDown',
  },

  /**
   * For functionalities on keyUp + ctrl || cmd
   */
  ctrlKeysMapUp: {
    67: 'copy',
    88: 'cut'
  },

  /**
   * For functionalities on keyDown + ctrl || cmd
   */
  ctrlKeysMapDown: {
    65: 'selectAll'
  },

  onClick: function() {
    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
    this.hiddenTextarea && this.hiddenTextarea.focus();
  },

  /**
   * Handles keydown event
   * only used for arrows and combination of modifier keys.
   * @param {Event} e Event object
   */
  onKeyDown: function(e) {
    if (!this.isEditing) {
      return;
    }
    var keyMap = this.direction === 'rtl' ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in keyMap) {
      this[keyMap[e.keyCode]](e);
    }
    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    if (e.keyCode >= 33 && e.keyCode <= 40) {
      // if i press an arrow key just update selection
      this.inCompositionMode = false;
      this.clearContextTop();
      this.renderCursorOrSelection();
    }
    else {
      this.canvas && this.canvas.requestRenderAll();
    }
  },

  /**
   * Handles keyup event
   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
   * if a copy/cut event fired, keyup is dismissed
   * @param {Event} e Event object
   */
  onKeyUp: function(e) {
    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
      this._copyDone = false;
      return;
    }
    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapUp[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.canvas && this.canvas.requestRenderAll();
  },

  /**
   * Handles onInput event
   * @param {Event} e Event object
   */
  onInput: function(e) {
    var fromPaste = this.fromPaste;
    this.fromPaste = false;
    e && e.stopPropagation();
    if (!this.isEditing) {
      return;
    }
    // decisions about style changes.
    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
        charCount = this._text.length,
        nextCharCount = nextText.length,
        removedText, insertedText,
        charDiff = nextCharCount - charCount,
        selectionStart = this.selectionStart, selectionEnd = this.selectionEnd,
        selection = selectionStart !== selectionEnd,
        copiedStyle, removeFrom, removeTo;
    if (this.hiddenTextarea.value === '') {
      this.styles = { };
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
      return;
    }

    var textareaSelection = this.fromStringToGraphemeSelection(
      this.hiddenTextarea.selectionStart,
      this.hiddenTextarea.selectionEnd,
      this.hiddenTextarea.value
    );
    var backDelete = selectionStart > textareaSelection.selectionStart;

    if (selection) {
      removedText = this._text.slice(selectionStart, selectionEnd);
      charDiff += selectionEnd - selectionStart;
    }
    else if (nextCharCount < charCount) {
      if (backDelete) {
        removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
      }
      else {
        removedText = this._text.slice(selectionStart, selectionStart - charDiff);
      }
    }
    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
    if (removedText && removedText.length) {
      if (insertedText.length) {
        // let's copy some style before deleting.
        // we want to copy the style before the cursor OR the style at the cursor if selection
        // is bigger than 0.
        copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
        // now duplicate the style one for each inserted text.
        copiedStyle = insertedText.map(function() {
          // this return an array of references, but that is fine since we are
          // copying the style later.
          return copiedStyle[0];
        });
      }
      if (selection) {
        removeFrom = selectionStart;
        removeTo = selectionEnd;
      }
      else if (backDelete) {
        // detect differences between forwardDelete and backDelete
        removeFrom = selectionEnd - removedText.length;
        removeTo = selectionEnd;
      }
      else {
        removeFrom = selectionEnd;
        removeTo = selectionEnd + removedText.length;
      }
      this.removeStyleFromTo(removeFrom, removeTo);
    }
    if (insertedText.length) {
      if (fromPaste && insertedText.join('') === fabric.copiedText && !fabric.disableStyleCopyPaste) {
        copiedStyle = fabric.copiedTextStyle;
      }
      this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
    }
    this.updateFromTextArea();
    this.fire('changed');
    if (this.canvas) {
      this.canvas.fire('text:changed', { target: this });
      this.canvas.requestRenderAll();
    }
  },
  /**
   * Composition start
   */
  onCompositionStart: function() {
    this.inCompositionMode = true;
  },

  /**
   * Composition end
   */
  onCompositionEnd: function() {
    this.inCompositionMode = false;
  },

  // /**
  //  * Composition update
  //  */
  onCompositionUpdate: function(e) {
    this.compositionStart = e.target.selectionStart;
    this.compositionEnd = e.target.selectionEnd;
    this.updateTextareaPosition();
  },

  /**
   * Copies selected text
   * @param {Event} e Event object
   */
  copy: function() {
    if (this.selectionStart === this.selectionEnd) {
      //do not cut-copy if no selection
      return;
    }

    fabric.copiedText = this.getSelectedText();
    if (!fabric.disableStyleCopyPaste) {
      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
    }
    else {
      fabric.copiedTextStyle = null;
    }
    this._copyDone = true;
  },

  /**
   * Pastes text
   * @param {Event} e Event object
   */
  paste: function() {
    this.fromPaste = true;
  },

  /**
   * @private
   * @param {Event} e Event object
   * @return {Object} Clipboard data object
   */
  _getClipboardData: function(e) {
    return (e && e.clipboardData) || fabric.window.clipboardData;
  },

  /**
   * Finds the width in pixels before the cursor on the same line
   * @private
   * @param {Number} lineIndex
   * @param {Number} charIndex
   * @return {Number} widthBeforeCursor width before cursor
   */
  _getWidthBeforeCursor: function(lineIndex, charIndex) {
    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

    if (charIndex > 0) {
      bound = this.__charBounds[lineIndex][charIndex - 1];
      widthBeforeCursor += bound.left + bound.width;
    }
    return widthBeforeCursor;
  },

  /**
   * Gets start offset of a selection
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getDownCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    // if on last line, down cursor goes to end of line
    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
      // move to the end of a text
      return this._text.length - selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
    return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
  },

  /**
   * private
   * Helps finding if the offset should be counted from Start or End
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  _getSelectionForOffset: function(e, isRight) {
    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
      return this.selectionEnd;
    }
    else {
      return this.selectionStart;
    }
  },

  /**
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getUpCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
      // if on first line, up cursor goes to start of line
      return -selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
        missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
    // return a negative offset
    return -this._textLines[lineIndex - 1].length
     + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
  },

  /**
   * for a given width it founds the matching character.
   * @private
   */
  _getIndexOnLine: function(lineIndex, width) {

    var line = this._textLines[lineIndex],
        lineLeftOffset = this._getLineLeftOffset(lineIndex),
        widthOfCharsOnLine = lineLeftOffset,
        indexOnLine = 0, charWidth, foundMatch;

    for (var j = 0, jlen = line.length; j < jlen; j++) {
      charWidth = this.__charBounds[lineIndex][j].width;
      widthOfCharsOnLine += charWidth;
      if (widthOfCharsOnLine > width) {
        foundMatch = true;
        var leftEdge = widthOfCharsOnLine - charWidth,
            rightEdge = widthOfCharsOnLine,
            offsetFromLeftEdge = Math.abs(leftEdge - width),
            offsetFromRightEdge = Math.abs(rightEdge - width);

        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
        break;
      }
    }

    // reached end
    if (!foundMatch) {
      indexOnLine = line.length - 1;
    }

    return indexOnLine;
  },


  /**
   * Moves cursor down
   * @param {Event} e Event object
   */
  moveCursorDown: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorUpOrDown('Down', e);
  },

  /**
   * Moves cursor up
   * @param {Event} e Event object
   */
  moveCursorUp: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorUpOrDown('Up', e);
  },

  /**
   * Moves cursor up or down, fires the events
   * @param {String} direction 'Up' or 'Down'
   * @param {Event} e Event object
   */
  _moveCursorUpOrDown: function(direction, e) {
    // getUpCursorOffset
    // getDownCursorOffset
    var action = 'get' + direction + 'CursorOffset',
        offset = this[action](e, this._selectionDirection === 'right');
    if (e.shiftKey) {
      this.moveCursorWithShift(offset);
    }
    else {
      this.moveCursorWithoutShift(offset);
    }
    if (offset !== 0) {
      this.setSelectionInBoundaries();
      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor with shift
   * @param {Number} offset
   */
  moveCursorWithShift: function(offset) {
    var newSelection = this._selectionDirection === 'left'
      ? this.selectionStart + offset
      : this.selectionEnd + offset;
    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
    return offset !== 0;
  },

  /**
   * Moves cursor up without shift
   * @param {Number} offset
   */
  moveCursorWithoutShift: function(offset) {
    if (offset < 0) {
      this.selectionStart += offset;
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionEnd += offset;
      this.selectionStart = this.selectionEnd;
    }
    return offset !== 0;
  },

  /**
   * Moves cursor left
   * @param {Event} e Event object
   */
  moveCursorLeft: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorLeftOrRight('Left', e);
  },

  /**
   * @private
   * @return {Boolean} true if a change happened
   */
  _move: function(e, prop, direction) {
    var newValue;
    if (e.altKey) {
      newValue = this['findWordBoundary' + direction](this[prop]);
    }
    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
      newValue = this['findLineBoundary' + direction](this[prop]);
    }
    else {
      this[prop] += direction === 'Left' ? -1 : 1;
      return true;
    }
    if (typeof newValue !== undefined && this[prop] !== newValue) {
      this[prop] = newValue;
      return true;
    }
  },

  /**
   * @private
   */
  _moveLeft: function(e, prop) {
    return this._move(e, prop, 'Left');
  },

  /**
   * @private
   */
  _moveRight: function(e, prop) {
    return this._move(e, prop, 'Right');
  },

  /**
   * Moves cursor left without keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithoutShift: function(e) {
    var change = true;
    this._selectionDirection = 'left';

    // only move cursor when there is no selection,
    // otherwise we discard it, and leave cursor on same place
    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
      change = this._moveLeft(e, 'selectionStart');

    }
    this.selectionEnd = this.selectionStart;
    return change;
  },

  /**
   * Moves cursor left while keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithShift: function(e) {
    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
      return this._moveLeft(e, 'selectionEnd');
    }
    else if (this.selectionStart !== 0){
      this._selectionDirection = 'left';
      return this._moveLeft(e, 'selectionStart');
    }
  },

  /**
   * Moves cursor right
   * @param {Event} e Event object
   */
  moveCursorRight: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorLeftOrRight('Right', e);
  },

  /**
   * Moves cursor right or Left, fires event
   * @param {String} direction 'Left', 'Right'
   * @param {Event} e Event object
   */
  _moveCursorLeftOrRight: function(direction, e) {
    var actionName = 'moveCursor' + direction + 'With';
    this._currentCursorOpacity = 1;

    if (e.shiftKey) {
      actionName += 'Shift';
    }
    else {
      actionName += 'outShift';
    }
    if (this[actionName](e)) {
      this.abortCursorAnimation();
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor right while keeping selection
   * @param {Event} e
   */
  moveCursorRightWithShift: function(e) {
    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
      return this._moveRight(e, 'selectionStart');
    }
    else if (this.selectionEnd !== this._text.length) {
      this._selectionDirection = 'right';
      return this._moveRight(e, 'selectionEnd');
    }
  },

  /**
   * Moves cursor right without keeping selection
   * @param {Event} e Event object
   */
  moveCursorRightWithoutShift: function(e) {
    var changed = true;
    this._selectionDirection = 'right';

    if (this.selectionStart === this.selectionEnd) {
      changed = this._moveRight(e, 'selectionStart');
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionStart = this.selectionEnd;
    }
    return changed;
  },

  /**
   * Removes characters from start/end
   * start/end ar per grapheme position in _text array.
   *
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  removeChars: function(start, end) {
    if (typeof end === 'undefined') {
      end = start + 1;
    }
    this.removeStyleFromTo(start, end);
    this._text.splice(start, end - start);
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

  /**
   * insert characters at start position, before start position.
   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
   * if style array is provided, it must be as the same length of text in graphemes
   * if end is provided and is bigger than start, old text is replaced.
   * start/end ar per grapheme position in _text array.
   *
   * @param {String} text text to insert
   * @param {Array} style array of style objects
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  insertChars: function(text, style, start, end) {
    if (typeof end === 'undefined') {
      end = start;
    }
    if (end > start) {
      this.removeStyleFromTo(start, end);
    }
    var graphemes = fabric.util.string.graphemeSplit(text);
    this.insertNewStyleBlock(graphemes, start, style);
    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

});
/* _TO_SVG_START_ */
(function() {
  var toFixed = fabric.util.toFixed,
      multipleSpacesRegex = /  +/g;

  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function() {
      var offsets = this._getSVGLeftTopOffsets(),
          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
      return this._wrapSVGTextAndBg(textAndBg);
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(
        this._toSVG(),
        { reviver: reviver, noStyle: true, withShadow: true }
      );
    },

    /**
     * @private
     */
    _getSVGLeftTopOffsets: function() {
      return {
        textLeft: -this.width / 2,
        textTop: -this.height / 2,
        lineTop: this.getHeightOfLine(0)
      };
    },

    /**
     * @private
     */
    _wrapSVGTextAndBg: function(textAndBg) {
      var noShadow = true,
          textDecoration = this.getSvgTextDecoration(this);
      return [
        textAndBg.textBgRects.join(''),
        '\t\t<text xml:space="preserve" ',
        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
        textAndBg.textSpans.join(''),
        '</text>\n'
      ];
    },

    /**
     * @private
     * @param {Number} textTopOffset Text top offset
     * @param {Number} textLeftOffset Text left offset
     * @return {Object}
     */
    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
      var textSpans = [],
          textBgRects = [],
          height = textTopOffset, lineOffset;
      // bounding-box background
      this._setSVGBg(textBgRects);

      // text and text-background
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineOffset = this._getLineLeftOffset(i);
        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
        }
        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
        height += this.getHeightOfLine(i);
      }

      return {
        textSpans: textSpans,
        textBgRects: textBgRects
      };
    },

    /**
     * @private
     */
    _createTextCharSpan: function(_char, styleDecl, left, top) {
      var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
          styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
          fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
          dy = styleDecl.deltaY, dySpan = '',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      if (dy) {
        dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
      }
      return [
        '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
        toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
        fillStyles, '>',
        fabric.util.string.escapeXml(_char),
        '</tspan>'
      ].join('');
    },

    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox, style,
          boxWidth = 0,
          line = this._textLines[lineIndex],
          timeToRender;

      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          textLeftOffset += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
        }
        if (timeToRender) {
          style = this._getStyleDeclaration(lineIndex, i) || { };
          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
          charsToRender = '';
          actualStyle = nextStyle;
          textLeftOffset += boxWidth;
          boxWidth = 0;
        }
      }
    },

    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      textBgRects.push(
        '\t\t<rect ',
        this._getFillAttributes(color),
        ' x="',
        toFixed(left, NUM_FRACTION_DIGITS),
        '" y="',
        toFixed(top, NUM_FRACTION_DIGITS),
        '" width="',
        toFixed(width, NUM_FRACTION_DIGITS),
        '" height="',
        toFixed(height, NUM_FRACTION_DIGITS),
        '"></rect>\n');
    },

    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
      var line = this._textLines[i],
          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
          boxWidth = 0,
          boxStart = 0,
          charBox, currentColor,
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charBox = this.__charBounds[i][j];
        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
        if (currentColor !== lastColor) {
          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
            textTopOffset, boxWidth, heightOfLine);
          boxStart = charBox.left;
          boxWidth = charBox.width;
          lastColor = currentColor;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
      }
      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
        textTopOffset, boxWidth, heightOfLine);
    },

    /**
     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
     *
     * @private
     * @param {*} value
     * @return {String}
     */
    _getFillAttributes: function(value) {
      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
        return 'fill="' + value + '"';
      }
      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
    },

    /**
     * @private
     */
    _getSVGLineTopOffset: function(lineIndex) {
      var lineTopOffset = 0, lastHeight = 0;
      for (var j = 0; j < lineIndex; j++) {
        lineTopOffset += this.getHeightOfLine(j);
      }
      lastHeight = this.getHeightOfLine(j);
      return {
        lineTop: lineTopOffset,
        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
      };
    },

    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {
      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
      return svgStyle + ' white-space: pre;';
    },
  });
})();
/* _TO_SVG_END_ */
(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = {});

  /**
   * Textbox class, based on IText, allows the user to resize the text rectangle
   * and wraps lines automatically. Textboxes have their Y scaling locked, the
   * user can only change width. Height is adjusted automatically based on the
   * wrapping of lines.
   * @class fabric.Textbox
   * @extends fabric.IText
   * @mixes fabric.Observable
   * @return {fabric.Textbox} thisArg
   * @see {@link fabric.Textbox#initialize} for constructor definition
   */
  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'textbox',

    /**
     * Minimum width of textbox, in pixels.
     * @type Number
     * @default
     */
    minWidth: 20,

    /**
     * Minimum calculated width of a textbox, in pixels.
     * fixed to 2 so that an empty textbox cannot go to 0
     * and is still selectable without text.
     * @type Number
     * @default
     */
    dynamicMinWidth: 2,

    /**
     * Cached array of text wrapping.
     * @type Array
     */
    __cachedLines: null,

    /**
     * Override standard Object class values
     */
    lockScalingFlip: true,

    /**
     * Override standard Object class values
     * Textbox needs this on false
     */
    noScaleCache: false,

    /**
     * Properties which when set cause object to change dimensions
     * @type Object
     * @private
     */
    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

    /**
     * Use this regular expression to split strings in breakable lines
     * @private
     */
    _wordJoiners: /[ \t\r]/,

    /**
     * Use this boolean property in order to split strings that have no white space concept.
     * this is a cheap way to help with chinese/japanese
     * @type Boolean
     * @since 2.6.0
     */
    splitByGrapheme: false,

    /**
     * Unlike superclass's version of this function, Textbox does not update
     * its width.
     * @private
     * @override
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this._clearCache();
      // clear dynamicMinWidth as it will be different after we re-wrap line
      this.dynamicMinWidth = 0;
      // wrap lines
      this._styleMap = this._generateStyleMap(this._splitText());
      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
      if (this.dynamicMinWidth > this.width) {
        this._set('width', this.dynamicMinWidth);
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      // clear cache and re-calculate height
      this.height = this.calcTextHeight();
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Generate an object that translates the style object so that it is
     * broken up by visual lines (new lines and automatic wrapping).
     * The original text styles object is broken up by actual lines (new lines only),
     * which is only sufficient for Text / IText
     * @private
     */
    _generateStyleMap: function(textInfo) {
      var realLineCount     = 0,
          realLineCharCount = 0,
          charCount         = 0,
          map               = {};

      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
          realLineCharCount = 0;
          charCount++;
          realLineCount++;
        }
        else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
          // this case deals with space's that are removed from end of lines when wrapping
          realLineCharCount++;
          charCount++;
        }

        map[i] = { line: realLineCount, offset: realLineCharCount };

        charCount += textInfo.graphemeLines[i].length;
        realLineCharCount += textInfo.graphemeLines[i].length;
      }

      return map;
    },

    /**
     * Returns true if object has a style property or has it on a specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (map) {
          lineIndex = map.line;
        }
      }
      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
    },

    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false,
          map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
      if (map) {
        lineIndex = map.line;
        offset = map.offset;
      }
      if (mapNextLine) {
        nextLineIndex = mapNextLine.line;
        shouldLimit = nextLineIndex === lineIndex;
        nextOffset = mapNextLine.offset;
      }
      obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
      }
      return true;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (!map) {
          return null;
        }
        lineIndex = map.line;
        charIndex = map.offset + charIndex;
      }
      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      this.styles[lineIndex][charIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * probably broken need a fix
     * Returns the real style line that correspond to the wrapped lineIndex line
     * Used just to verify if the line does exist or not.
     * @param {Number} lineIndex
     * @returns {Boolean} if the line exists or not
     * @private
     */
    _getLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      return !!this.styles[map.line];
    },

    /**
     * Set the line style to an empty object so that is initialized
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      this.styles[map.line] = {};
    },

    /**
     * Wraps text using the 'width' property of Textbox. First this function
     * splits text on newlines, so we preserve newlines entered by the user.
     * Then it wraps each line using the width of the Textbox by calling
     * _wrapLine().
     * @param {Array} lines The string array of text that is split into lines
     * @param {Number} desiredWidth width you want to wrap to
     * @returns {Array} Array of lines
     */
    _wrapText: function(lines, desiredWidth) {
      var wrapped = [], i;
      this.isWrapping = true;
      for (i = 0; i < lines.length; i++) {
        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
      }
      this.isWrapping = false;
      return wrapped;
    },

    /**
     * Helper function to measure a string of text, given its lineIndex and charIndex offset
     * it gets called when charBounds are not available yet.
     * @param {CanvasRenderingContext2D} ctx
     * @param {String} text
     * @param {number} lineIndex
     * @param {number} charOffset
     * @returns {number}
     * @private
     */
    _measureWord: function(word, lineIndex, charOffset) {
      var width = 0, prevGrapheme, skipLeft = true;
      charOffset = charOffset || 0;
      for (var i = 0, len = word.length; i < len; i++) {
        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
        width += box.kernedWidth;
        prevGrapheme = word[i];
      }
      return width;
    },

    /**
     * Wraps a line of text using the width of the Textbox and a context.
     * @param {Array} line The grapheme array that represent the line
     * @param {Number} lineIndex
     * @param {Number} desiredWidth width you want to wrap the line to
     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
     * @returns {Array} Array of line(s) into which the given text is wrapped
     * to.
     */
    _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
      var lineWidth = 0,
          splitByGrapheme = this.splitByGrapheme,
          graphemeLines = [],
          line = [],
          // spaces in different languages?
          words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
          word = '',
          offset = 0,
          infix = splitByGrapheme ? '' : ' ',
          wordWidth = 0,
          infixWidth = 0,
          largestWordWidth = 0,
          lineJustStarted = true,
          additionalSpace = this._getWidthOfCharSpacing(),
          reservedSpace = reservedSpace || 0;
      // fix a difference between split and graphemeSplit
      if (words.length === 0) {
        words.push([]);
      }
      desiredWidth -= reservedSpace;
      for (var i = 0; i < words.length; i++) {
        // if using splitByGrapheme words are already in graphemes.
        word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);
        wordWidth = this._measureWord(word, lineIndex, offset);
        offset += word.length;

        lineWidth += infixWidth + wordWidth - additionalSpace;
        if (lineWidth > desiredWidth && !lineJustStarted) {
          graphemeLines.push(line);
          line = [];
          lineWidth = wordWidth;
          lineJustStarted = true;
        }
        else {
          lineWidth += additionalSpace;
        }

        if (!lineJustStarted && !splitByGrapheme) {
          line.push(infix);
        }
        line = line.concat(word);

        infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
        offset++;
        lineJustStarted = false;
        // keep track of largest word
        if (wordWidth > largestWordWidth) {
          largestWordWidth = wordWidth;
        }
      }

      i && graphemeLines.push(line);

      if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
        this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
      }
      return graphemeLines;
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @param {Number} lineIndex text to split
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      if (!this._styleMap[lineIndex + 1]) {
        // is last line, return true;
        return true;
      }
      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
        // this is last line before a line break, return true;
        return true;
      }
      return false;
    },

    /**
     * Detect if a line has a linebreak and so we need to account for it when moving
     * and counting style.
     * @return Number
     */
    missingNewlineOffset: function(lineIndex) {
      if (this.splitByGrapheme) {
        return this.isEndOfWrapping(lineIndex) ? 1 : 0;
      }
      return 1;
    },

    /**
    * Gets lines of text to render in the Textbox. This function calculates
    * text wrapping on the fly every time it is called.
    * @param {String} text text to split
    * @returns {Array} Array of lines in the Textbox.
    * @override
    */
    _splitTextIntoLines: function(text) {
      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
          graphemeLines = this._wrapText(newText.lines, this.width),
          lines = new Array(graphemeLines.length);
      for (var i = 0; i < graphemeLines.length; i++) {
        lines[i] = graphemeLines[i].join('');
      }
      newText.lines = lines;
      newText.graphemeLines = graphemeLines;
      return newText;
    },

    getMinWidth: function() {
      return Math.max(this.minWidth, this.dynamicMinWidth);
    },

    _removeExtraneousStyles: function() {
      var linesToKeep = {};
      for (var prop in this._styleMap) {
        if (this._textLines[prop]) {
          linesToKeep[this._styleMap[prop].line] = 1;
        }
      }
      for (var prop in this.styles) {
        if (!linesToKeep[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
    }
  });

  /**
   * Returns fabric.Textbox instance from an object representation
   * @static
   * @memberOf fabric.Textbox
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
   */
  fabric.Textbox.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Textbox', object, callback, 'text');
  };
})(typeof exports !== 'undefined' ? exports : this);
(function() {

  var controlsUtils = fabric.controlsUtils,
      scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler,
      scaleStyleHandler = controlsUtils.scaleCursorStyleHandler,
      scalingEqually = controlsUtils.scalingEqually,
      scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX,
      scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY,
      scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName,
      objectControls = fabric.Object.prototype.controls;

  objectControls.ml = new fabric.Control({
    x: -0.5,
    y: 0,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingXOrSkewingY,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mr = new fabric.Control({
    x: 0.5,
    y: 0,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingXOrSkewingY,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mb = new fabric.Control({
    x: 0,
    y: 0.5,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingYOrSkewingX,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mt = new fabric.Control({
    x: 0,
    y: -0.5,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingYOrSkewingX,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.tl = new fabric.Control({
    x: -0.5,
    y: -0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.tr = new fabric.Control({
    x: 0.5,
    y: -0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.bl = new fabric.Control({
    x: -0.5,
    y: 0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.br = new fabric.Control({
    x: 0.5,
    y: 0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.mtr = new fabric.Control({
    x: 0,
    y: -0.5,
    actionHandler: controlsUtils.rotationWithSnapping,
    cursorStyleHandler: controlsUtils.rotationStyleHandler,
    offsetY: -40,
    withConnection: true,
    actionName: 'rotate',
  });

  if (fabric.Textbox) {
    // this is breaking the prototype inheritance, no time / ideas to fix it.
    // is important to document that if you want to have all objects to have a
    // specific custom control, you have to add it to Object prototype and to Textbox
    // prototype. The controls are shared as references. So changes to control `tr`
    // can still apply to all objects if needed.
    var textBoxControls = fabric.Textbox.prototype.controls = { };

    textBoxControls.mtr = objectControls.mtr;
    textBoxControls.tr = objectControls.tr;
    textBoxControls.br = objectControls.br;
    textBoxControls.tl = objectControls.tl;
    textBoxControls.bl = objectControls.bl;
    textBoxControls.mt = objectControls.mt;
    textBoxControls.mb = objectControls.mb;

    textBoxControls.mr = new fabric.Control({
      x: 0.5,
      y: 0,
      actionHandler: controlsUtils.changeWidth,
      cursorStyleHandler: scaleSkewStyleHandler,
      actionName: 'resizing',
    });

    textBoxControls.ml = new fabric.Control({
      x: -0.5,
      y: 0,
      actionHandler: controlsUtils.changeWidth,
      cursorStyleHandler: scaleSkewStyleHandler,
      actionName: 'resizing',
    });
  }
})();
(function () {
  /** ERASER_START */

  /**
   * add `eraser` to enlivened props
   */
  fabric.Object.ENLIVEN_PROPS.push('eraser');

  var __drawClipPath = fabric.Object.prototype._drawClipPath;
  var _needsItsOwnCache = fabric.Object.prototype.needsItsOwnCache;
  var _toObject = fabric.Object.prototype.toObject;
  var _getSvgCommons = fabric.Object.prototype.getSvgCommons;
  var __createBaseClipPathSVGMarkup = fabric.Object.prototype._createBaseClipPathSVGMarkup;
  var __createBaseSVGMarkup = fabric.Object.prototype._createBaseSVGMarkup;
  /**
   * @fires erasing:end
   */
  fabric.util.object.extend(fabric.Object.prototype, {
    /**
     * Indicates whether this object can be erased by {@link fabric.EraserBrush}
     * The `deep` option introduces fine grained control over a group's `erasable` property.
     * When set to `deep` the eraser will erase nested objects if they are erasable, leaving the group and the other objects untouched.
     * When set to `true` the eraser will erase the entire group. Once the group changes the eraser is propagated to its children for proper functionality.
     * When set to `false` the eraser will leave all objects including the group untouched.
     * @tutorial {@link http://fabricjs.com/erasing#erasable_property}
     * @type boolean | 'deep'
     * @default true
     */
    erasable: true,

    /**
     * @tutorial {@link http://fabricjs.com/erasing#eraser}
     * @type fabric.Eraser
     */
    eraser: undefined,

    /**
     * @override
     * @returns Boolean
     */
    needsItsOwnCache: function () {
      return _needsItsOwnCache.call(this) || !!this.eraser;
    },

    /**
     * draw eraser above clip path
     * @override
     * @private
     * @param {CanvasRenderingContext2D} ctx
     * @param {fabric.Object} clipPath
     */
    _drawClipPath: function (ctx, clipPath) {
      __drawClipPath.call(this, ctx, clipPath);
      if (this.eraser) {
        //  update eraser size to match instance
        var size = this._getNonTransformedDimensions();
        this.eraser.isType('eraser') && this.eraser.set({
          width: size.x,
          height: size.y
        });
        __drawClipPath.call(this, ctx, this.eraser);
      }
    },

    /**
     * Returns an object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function (propertiesToInclude) {
      var object = _toObject.call(this, ['erasable'].concat(propertiesToInclude));
      if (this.eraser && !this.eraser.excludeFromExport) {
        object.eraser = this.eraser.toObject(propertiesToInclude);
      }
      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns id attribute for svg output
     * @override
     * @return {String}
     */
    getSvgCommons: function () {
      return _getSvgCommons.call(this) + (this.eraser ? 'mask="url(#' + this.eraser.clipPathId + ')" ' : '');
    },

    /**
     * create svg markup for eraser
     * use <mask> to achieve erasing for svg, credit: https://travishorn.com/removing-parts-of-shapes-in-svg-b539a89e5649
     * must be called before object markup creation as it relies on the `clipPathId` property of the mask
     * @param {Function} [reviver]
     * @returns
     */
    _createEraserSVGMarkup: function (reviver) {
      if (this.eraser) {
        this.eraser.clipPathId = 'MASK_' + fabric.Object.__uid++;
        return [
          '<mask id="', this.eraser.clipPathId, '" >',
          this.eraser.toSVG(reviver),
          '</mask>', '\n'
        ].join('');
      }
      return '';
    },

    /**
     * @private
     */
    _createBaseClipPathSVGMarkup: function (objectMarkup, options) {
      return [
        this._createEraserSVGMarkup(options && options.reviver),
        __createBaseClipPathSVGMarkup.call(this, objectMarkup, options)
      ].join('');
    },

    /**
     * @private
     */
    _createBaseSVGMarkup: function (objectMarkup, options) {
      return [
        this._createEraserSVGMarkup(options && options.reviver),
        __createBaseSVGMarkup.call(this, objectMarkup, options)
      ].join('');
    }
    /* _TO_SVG_END_ */
  });

  var __restoreObjectsState = fabric.Group.prototype._restoreObjectsState;
  fabric.util.object.extend(fabric.Group.prototype, {
    /**
     * @private
     * @param {fabric.Path} path
     */
    _addEraserPathToObjects: function (path) {
      this._objects.forEach(function (object) {
        fabric.EraserBrush.prototype._addPathToObjectEraser.call(
          fabric.EraserBrush.prototype,
          object,
          path
        );
      });
    },

    /**
     * Applies the group's eraser to its objects
     * @tutorial {@link http://fabricjs.com/erasing#erasable_property}
     */
    applyEraserToObjects: function () {
      var _this = this, eraser = this.eraser;
      if (eraser) {
        delete this.eraser;
        var transform = _this.calcTransformMatrix();
        eraser.clone(function (eraser) {
          var clipPath = _this.clipPath;
          eraser.getObjects('path')
            .forEach(function (path) {
              //  first we transform the path from the group's coordinate system to the canvas'
              var originalTransform = fabric.util.multiplyTransformMatrices(
                transform,
                path.calcTransformMatrix()
              );
              fabric.util.applyTransformToObject(path, originalTransform);
              if (clipPath) {
                clipPath.clone(function (_clipPath) {
                  var eraserPath = fabric.EraserBrush.prototype.applyClipPathToPath.call(
                    fabric.EraserBrush.prototype,
                    path,
                    _clipPath,
                    transform
                  );
                  _this._addEraserPathToObjects(eraserPath);
                }, ['absolutePositioned', 'inverted']);
              }
              else {
                _this._addEraserPathToObjects(path);
              }
            });
        });
      }
    },

    /**
     * Propagate the group's eraser to its objects, crucial for proper functionality of the eraser within the group and nested objects.
     * @private
     */
    _restoreObjectsState: function () {
      this.erasable === true && this.applyEraserToObjects();
      return __restoreObjectsState.call(this);
    }
  });

  /**
   * An object's Eraser
   * @private
   * @class fabric.Eraser
   * @extends fabric.Group
   * @memberof fabric
   */
  fabric.Eraser = fabric.util.createClass(fabric.Group, {
    /**
     * @readonly
     * @static
     */
    type: 'eraser',

    /**
     * @default
     */
    originX: 'center',

    /**
     * @default
     */
    originY: 'center',

    drawObject: function (ctx) {
      ctx.save();
      ctx.fillStyle = 'black';
      ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
      ctx.restore();
      this.callSuper('drawObject', ctx);
    },

    /**
     * eraser should retain size
     * dimensions should not change when paths are added or removed
     * handled by {@link fabric.Object#_drawClipPath}
     * @override
     * @private
     */
    _getBounds: function () {
      //  noop
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * use <mask> to achieve erasing for svg, credit: https://travishorn.com/removing-parts-of-shapes-in-svg-b539a89e5649
     * for masking we need to add a white rect before all paths
     *
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function (reviver) {
      var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];
      var x = -this.width / 2, y = -this.height / 2;
      var rectSvg = [
        '<rect ', 'fill="white" ',
        'x="', x, '" y="', y,
        '" width="', this.width, '" height="', this.height,
        '" />\n'
      ].join('');
      svgString.push('\t\t', rectSvg);
      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t\t', this._objects[i].toSVG(reviver));
      }
      svgString.push('</g>\n');
      return svgString;
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Eraser} instance from an object representation
   * @static
   * @memberOf fabric.Eraser
   * @param {Object} object Object to create an Eraser from
   * @param {Function} [callback] Callback to invoke when an eraser instance is created
   */
  fabric.Eraser.fromObject = function (object, callback) {
    var objects = object.objects;
    fabric.util.enlivenObjects(objects, function (enlivenedObjects) {
      var options = fabric.util.object.clone(object, true);
      delete options.objects;
      fabric.util.enlivenObjectEnlivables(object, options, function () {
        callback && callback(new fabric.Eraser(enlivenedObjects, options, true));
      });
    });
  };

  var __renderOverlay = fabric.Canvas.prototype._renderOverlay;
  /**
   * @fires erasing:start
   * @fires erasing:end
   */
  fabric.util.object.extend(fabric.Canvas.prototype, {
    /**
     * Used by {@link #renderAll}
     * @returns boolean
     */
    isErasing: function () {
      return (
        this.isDrawingMode &&
        this.freeDrawingBrush &&
        this.freeDrawingBrush.type === 'eraser' &&
        this.freeDrawingBrush._isErasing
      );
    },

    /**
     * While erasing the brush clips out the erasing path from canvas
     * so we need to render it on top of canvas every render
     * @param {CanvasRenderingContext2D} ctx
     */
    _renderOverlay: function (ctx) {
      __renderOverlay.call(this, ctx);
      if (this.isErasing() && !this.freeDrawingBrush.inverted) {
        this.freeDrawingBrush._render();
      }
    }
  });

  /**
   * EraserBrush class
   * Supports selective erasing meaning that only erasable objects are affected by the eraser brush.
   * Supports **inverted** erasing meaning that the brush can "undo" erasing.
   *
   * In order to support selective erasing, the brush clips the entire canvas
   * and then draws all non-erasable objects over the erased path using a pattern brush so to speak (masking).
   * If brush is **inverted** there is no need to clip canvas. The brush draws all erasable objects without their eraser.
   * This achieves the desired effect of seeming to erase or unerase only erasable objects.
   * After erasing is done the created path is added to all intersected objects' `eraser` property.
   *
   * In order to update the EraserBrush call `preparePattern`.
   * It may come in handy when canvas changes during erasing (i.e animations) and you want the eraser to reflect the changes.
   *
   * @tutorial {@link http://fabricjs.com/erasing}
   * @class fabric.EraserBrush
   * @extends fabric.PencilBrush
   * @memberof fabric
   */
  fabric.EraserBrush = fabric.util.createClass(
    fabric.PencilBrush,
    /** @lends fabric.EraserBrush.prototype */ {
      type: 'eraser',

      /**
       * When set to `true` the brush will create a visual effect of undoing erasing
       */
      inverted: false,

      /**
       * @private
       */
      _isErasing: false,

      /**
       *
       * @private
       * @param {fabric.Object} object
       * @returns boolean
       */
      _isErasable: function (object) {
        return object.erasable !== false;
      },

      /**
       * @private
       * This is designed to support erasing a collection with both erasable and non-erasable objects.
       * Iterates over collections to allow nested selective erasing.
       * Prepares the pattern brush that will draw on the top context to achieve the desired visual effect.
       * If brush is **NOT** inverted render all non-erasable objects.
       * If brush is inverted render all erasable objects that have been erased with their clip path inverted.
       * This will render the erased parts as if they were not erased.
       *
       * @param {fabric.Collection} collection
       * @param {CanvasRenderingContext2D} ctx
       * @param {{ visibility: fabric.Object[], eraser: fabric.Object[], collection: fabric.Object[] }} restorationContext
       */
      _prepareCollectionTraversal: function (collection, ctx, restorationContext) {
        collection.forEachObject(function (obj) {
          if (obj.forEachObject && obj.erasable === 'deep') {
            //  traverse
            this._prepareCollectionTraversal(obj, ctx, restorationContext);
          }
          else if (!this.inverted && obj.erasable && obj.visible) {
            //  render only non-erasable objects
            obj.visible = false;
            collection.dirty = true;
            restorationContext.visibility.push(obj);
            restorationContext.collection.push(collection);
          }
          else if (this.inverted && obj.visible) {
            //  render only erasable objects that were erased
            if (obj.erasable && obj.eraser) {
              obj.eraser.inverted = true;
              obj.dirty = true;
              collection.dirty = true;
              restorationContext.eraser.push(obj);
              restorationContext.collection.push(collection);
            }
            else {
              obj.visible = false;
              collection.dirty = true;
              restorationContext.visibility.push(obj);
              restorationContext.collection.push(collection);
            }
          }
        }, this);
      },

      /**
       * Prepare the pattern for the erasing brush
       * This pattern will be drawn on the top context, achieving a visual effect of erasing only erasable objects
       * @todo decide how overlay color should behave when `inverted === true`, currently draws over it which is undesirable
       * @private
       */
      preparePattern: function () {
        if (!this._patternCanvas) {
          this._patternCanvas = fabric.util.createCanvasElement();
        }
        var canvas = this._patternCanvas;
        canvas.width = this.canvas.width;
        canvas.height = this.canvas.height;
        var patternCtx = canvas.getContext('2d');
        if (this.canvas._isRetinaScaling()) {
          var retinaScaling = this.canvas.getRetinaScaling();
          this.canvas.__initRetinaScaling(retinaScaling, canvas, patternCtx);
        }
        var backgroundImage = this.canvas.backgroundImage,
            bgErasable = backgroundImage && this._isErasable(backgroundImage),
            overlayImage = this.canvas.overlayImage,
            overlayErasable = overlayImage && this._isErasable(overlayImage);
        if (!this.inverted && ((backgroundImage && !bgErasable) || !!this.canvas.backgroundColor)) {
          if (bgErasable) { this.canvas.backgroundImage = undefined; }
          this.canvas._renderBackground(patternCtx);
          if (bgErasable) { this.canvas.backgroundImage = backgroundImage; }
        }
        else if (this.inverted && (backgroundImage && bgErasable)) {
          var color = this.canvas.backgroundColor;
          this.canvas.backgroundColor = undefined;
          this.canvas._renderBackground(patternCtx);
          this.canvas.backgroundColor = color;
        }
        patternCtx.save();
        patternCtx.transform.apply(patternCtx, this.canvas.viewportTransform);
        var restorationContext = { visibility: [], eraser: [], collection: [] };
        this._prepareCollectionTraversal(this.canvas, patternCtx, restorationContext);
        this.canvas._renderObjects(patternCtx, this.canvas._objects);
        restorationContext.visibility.forEach(function (obj) { obj.visible = true; });
        restorationContext.eraser.forEach(function (obj) {
          obj.eraser.inverted = false;
          obj.dirty = true;
        });
        restorationContext.collection.forEach(function (obj) { obj.dirty = true; });
        patternCtx.restore();
        if (!this.inverted && ((overlayImage && !overlayErasable) || !!this.canvas.overlayColor)) {
          if (overlayErasable) { this.canvas.overlayImage = undefined; }
          __renderOverlay.call(this.canvas, patternCtx);
          if (overlayErasable) { this.canvas.overlayImage = overlayImage; }
        }
        else if (this.inverted && (overlayImage && overlayErasable)) {
          var color = this.canvas.overlayColor;
          this.canvas.overlayColor = undefined;
          __renderOverlay.call(this.canvas, patternCtx);
          this.canvas.overlayColor = color;
        }
      },

      /**
       * Sets brush styles
       * @private
       * @param {CanvasRenderingContext2D} ctx
       */
      _setBrushStyles: function (ctx) {
        this.callSuper('_setBrushStyles', ctx);
        ctx.strokeStyle = 'black';
      },

      /**
       * **Customiztion**
       *
       * if you need the eraser to update on each render (i.e animating during erasing) override this method by **adding** the following (performance may suffer):
       * @example
       * ```
       * if(ctx === this.canvas.contextTop) {
       *  this.preparePattern();
       * }
       * ```
       *
       * @override fabric.BaseBrush#_saveAndTransform
       * @param {CanvasRenderingContext2D} ctx
       */
      _saveAndTransform: function (ctx) {
        this.callSuper('_saveAndTransform', ctx);
        this._setBrushStyles(ctx);
        ctx.globalCompositeOperation = ctx === this.canvas.getContext() ? 'destination-out' : 'source-over';
      },

      /**
       * We indicate {@link fabric.PencilBrush} to repaint itself if necessary
       * @returns
       */
      needsFullRender: function () {
        return true;
      },

      /**
       *
       * @param {fabric.Point} pointer
       * @param {fabric.IEvent} options
       * @returns
       */
      onMouseDown: function (pointer, options) {
        if (!this.canvas._isMainEvent(options.e)) {
          return;
        }
        this._prepareForDrawing(pointer);
        // capture coordinates immediately
        // this allows to draw dots (when movement never occurs)
        this._captureDrawingPath(pointer);

        //  prepare for erasing
        this.preparePattern();
        this._isErasing = true;
        this.canvas.fire('erasing:start');
        this._render();
      },

      /**
       * Rendering Logic:
       * 1. Use brush to clip canvas by rendering it on top of canvas (unnecessary if `inverted === true`)
       * 2. Render brush with canvas pattern on top context
       *
       */
      _render: function () {
        var ctx;
        if (!this.inverted) {
          //  clip canvas
          ctx = this.canvas.getContext();
          this.callSuper('_render', ctx);
        }
        //  render brush and mask it with image of non erasables
        ctx = this.canvas.contextTop;
        this.canvas.clearContext(ctx);
        this.callSuper('_render', ctx);
        ctx.save();
        var t = this.canvas.getRetinaScaling(), s = 1 / t;
        ctx.scale(s, s);
        ctx.globalCompositeOperation = 'source-in';
        ctx.drawImage(this._patternCanvas, 0, 0);
        ctx.restore();
      },

      /**
       * Creates fabric.Path object
       * @override
       * @private
       * @param {(string|number)[][]} pathData Path data
       * @return {fabric.Path} Path to add on canvas
       * @returns
       */
      createPath: function (pathData) {
        var path = this.callSuper('createPath', pathData);
        path.globalCompositeOperation = this.inverted ? 'source-over' : 'destination-out';
        path.stroke = this.inverted ? 'white' : 'black';
        return path;
      },

      /**
       * Utility to apply a clip path to a path.
       * Used to preserve clipping on eraser paths in nested objects.
       * Called when a group has a clip path that should be applied to the path before applying erasing on the group's objects.
       * @param {fabric.Path} path The eraser path in canvas coordinate plane
       * @param {fabric.Object} clipPath The clipPath to apply to the path
       * @param {number[]} clipPathContainerTransformMatrix The transform matrix of the object that the clip path belongs to
       * @returns {fabric.Path} path with clip path
       */
      applyClipPathToPath: function (path, clipPath, clipPathContainerTransformMatrix) {
        var pathInvTransform = fabric.util.invertTransform(path.calcTransformMatrix()),
            clipPathTransform = clipPath.calcTransformMatrix(),
            transform = clipPath.absolutePositioned ?
              pathInvTransform :
              fabric.util.multiplyTransformMatrices(
                pathInvTransform,
                clipPathContainerTransformMatrix
              );
        //  when passing down a clip path it becomes relative to the parent
        //  so we transform it acoordingly and set `absolutePositioned` to false
        clipPath.absolutePositioned = false;
        fabric.util.applyTransformToObject(
          clipPath,
          fabric.util.multiplyTransformMatrices(
            transform,
            clipPathTransform
          )
        );
        //  We need to clip `path` with both `clipPath` and it's own clip path if existing (`path.clipPath`)
        //  so in turn `path` erases an object only where it overlaps with all it's clip paths, regardless of how many there are.
        //  this is done because both clip paths may have nested clip paths of their own (this method walks down a collection => this may reccur),
        //  so we can't assign one to the other's clip path property.
        path.clipPath = path.clipPath ? fabric.util.mergeClipPaths(clipPath, path.clipPath) : clipPath;
        return path;
      },

      /**
       * Utility to apply a clip path to a path.
       * Used to preserve clipping on eraser paths in nested objects.
       * Called when a group has a clip path that should be applied to the path before applying erasing on the group's objects.
       * @param {fabric.Path} path The eraser path
       * @param {fabric.Object} object The clipPath to apply to path belongs to object
       * @param {Function} callback Callback to be invoked with the cloned path after applying the clip path
       */
      clonePathWithClipPath: function (path, object, callback) {
        var objTransform = object.calcTransformMatrix();
        var clipPath = object.clipPath;
        var _this = this;
        path.clone(function (_path) {
          clipPath.clone(function (_clipPath) {
            callback(_this.applyClipPathToPath(_path, _clipPath, objTransform));
          }, ['absolutePositioned', 'inverted']);
        });
      },

      /**
       * Adds path to object's eraser, walks down object's descendants if necessary
       *
       * @fires erasing:end on object
       * @param {fabric.Object} obj
       * @param {fabric.Path} path
       */
      _addPathToObjectEraser: function (obj, path) {
        var _this = this;
        //  object is collection, i.e group
        if (obj.forEachObject && obj.erasable === 'deep') {
          var targets = obj._objects.filter(function (_obj) {
            return _obj.erasable;
          });
          if (targets.length > 0 && obj.clipPath) {
            this.clonePathWithClipPath(path, obj, function (_path) {
              targets.forEach(function (_obj) {
                _this._addPathToObjectEraser(_obj, _path);
              });
            });
          }
          else if (targets.length > 0) {
            targets.forEach(function (_obj) {
              _this._addPathToObjectEraser(_obj, path);
            });
          }
          return;
        }
        //  prepare eraser
        var eraser = obj.eraser;
        if (!eraser) {
          eraser = new fabric.Eraser();
          obj.eraser = eraser;
        }
        //  clone and add path
        path.clone(function (path) {
          // http://fabricjs.com/using-transformations
          var desiredTransform = fabric.util.multiplyTransformMatrices(
            fabric.util.invertTransform(
              obj.calcTransformMatrix()
            ),
            path.calcTransformMatrix()
          );
          fabric.util.applyTransformToObject(path, desiredTransform);
          eraser.addWithUpdate(path);
          obj.set('dirty', true);
          obj.fire('erasing:end', {
            path: path
          });
          if (obj.group && Array.isArray(_this.__subTargets)) {
            _this.__subTargets.push(obj);
          }
        });
      },

      /**
       * Add the eraser path to canvas drawables' clip paths
       *
       * @param {fabric.Canvas} source
       * @param {fabric.Canvas} path
       * @returns {Object} canvas drawables that were erased by the path
       */
      applyEraserToCanvas: function (path) {
        var canvas = this.canvas;
        var drawables = {};
        [
          'backgroundImage',
          'overlayImage',
        ].forEach(function (prop) {
          var drawable = canvas[prop];
          if (drawable && drawable.erasable) {
            this._addPathToObjectEraser(drawable, path);
            drawables[prop] = drawable;
          }
        }, this);
        return drawables;
      },

      /**
       * On mouseup after drawing the path on contextTop canvas
       * we use the points captured to create an new fabric path object
       * and add it to every intersected erasable object.
       */
      _finalizeAndAddPath: function () {
        var ctx = this.canvas.contextTop, canvas = this.canvas;
        ctx.closePath();
        if (this.decimate) {
          this._points = this.decimatePoints(this._points, this.decimate);
        }

        // clear
        canvas.clearContext(canvas.contextTop);
        this._isErasing = false;

        var pathData = this._points && this._points.length > 1 ?
          this.convertPointsToSVGPath(this._points) :
          null;
        if (!pathData || this._isEmptySVGPath(pathData)) {
          canvas.fire('erasing:end');
          // do not create 0 width/height paths, as they are
          // rendered inconsistently across browsers
          // Firefox 4, for example, renders a dot,
          // whereas Chrome 10 renders nothing
          canvas.requestRenderAll();
          return;
        }

        var path = this.createPath(pathData);
        //  needed for `intersectsWithObject`
        path.setCoords();
        //  commense event sequence
        canvas.fire('before:path:created', { path: path });

        // finalize erasing
        var drawables = this.applyEraserToCanvas(path);
        var _this = this;
        this.__subTargets = [];
        var targets = [];
        canvas.forEachObject(function (obj) {
          if (obj.erasable && obj.intersectsWithObject(path, true, true)) {
            _this._addPathToObjectEraser(obj, path);
            targets.push(obj);
          }
        });
        //  fire erasing:end
        canvas.fire('erasing:end', {
          path: path,
          targets: targets,
          subTargets: this.__subTargets,
          drawables: drawables
        });
        delete this.__subTargets;

        canvas.requestRenderAll();
        this._resetShadow();

        // fire event 'path' created
        canvas.fire('path:created', { path: path });
      }
    }
  );

  /** ERASER_END */
})();

// threejs.org/license
!(function (t, e) {
	'object' == typeof exports && 'undefined' != typeof module
		? e(exports)
		: 'function' == typeof define && define.amd
		? define(['exports'], e)
		: e(
				((t = 'undefined' != typeof globalThis ? globalThis : t || self).THREE =
					{})
		  );
})(this, function (t) {
	'use strict';
	void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
		void 0 === Number.isInteger &&
			(Number.isInteger = function (t) {
				return 'number' == typeof t && isFinite(t) && Math.floor(t) === t;
			}),
		void 0 === Math.sign &&
			(Math.sign = function (t) {
				return t < 0 ? -1 : t > 0 ? 1 : +t;
			}),
		'name' in Function.prototype == !1 &&
			Object.defineProperty(Function.prototype, 'name', {
				get: function () {
					return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
				},
			}),
		void 0 === Object.assign &&
			(Object.assign = function (t) {
				if (null == t)
					throw new TypeError('Cannot convert undefined or null to object');
				for (var e = Object(t), n = 1; n < arguments.length; n++) {
					var r = arguments[n];
					if (null != r)
						for (var i in r)
							Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
				}
				return e;
			});
	var e = 100,
		n = 300,
		r = 301,
		i = 302,
		a = 303,
		o = 304,
		s = 306,
		c = 307,
		l = 1e3,
		u = 1001,
		h = 1002,
		d = 1003,
		p = 1004,
		f = 1005,
		m = 1006,
		v = 1007,
		g = 1008,
		y = 1009,
		x = 1012,
		_ = 1014,
		b = 1015,
		w = 1016,
		M = 1020,
		S = 1022,
		T = 1023,
		E = 1026,
		A = 1027,
		L = 33776,
		R = 33777,
		C = 33778,
		P = 33779,
		I = 35840,
		D = 35841,
		N = 35842,
		O = 35843,
		B = 37492,
		z = 37496,
		G = 2300,
		F = 2301,
		U = 2302,
		H = 2400,
		k = 2401,
		V = 2402,
		W = 2500,
		j = 2501,
		q = 3e3,
		X = 3001,
		Y = 3007,
		Z = 3002,
		J = 3004,
		Q = 3005,
		K = 3006,
		$ = 7680,
		tt = 35044,
		et = 35048,
		nt = '300 es';
	function rt() {}
	Object.assign(rt.prototype, {
		addEventListener: function (t, e) {
			void 0 === this._listeners && (this._listeners = {});
			var n = this._listeners;
			void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
		},
		hasEventListener: function (t, e) {
			if (void 0 === this._listeners) return !1;
			var n = this._listeners;
			return void 0 !== n[t] && -1 !== n[t].indexOf(e);
		},
		removeEventListener: function (t, e) {
			if (void 0 !== this._listeners) {
				var n = this._listeners[t];
				if (void 0 !== n) {
					var r = n.indexOf(e);
					-1 !== r && n.splice(r, 1);
				}
			}
		},
		dispatchEvent: function (t) {
			if (void 0 !== this._listeners) {
				var e = this._listeners[t.type];
				if (void 0 !== e) {
					t.target = this;
					for (var n = e.slice(0), r = 0, i = n.length; r < i; r++)
						n[r].call(this, t);
				}
			}
		},
	});
	for (var it = [], at = 0; at < 256; at++)
		it[at] = (at < 16 ? '0' : '') + at.toString(16);
	var ot = 1234567,
		st = {
			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,
			generateUUID: function () {
				var t = (4294967295 * Math.random()) | 0,
					e = (4294967295 * Math.random()) | 0,
					n = (4294967295 * Math.random()) | 0,
					r = (4294967295 * Math.random()) | 0;
				return (
					it[255 & t] +
					it[(t >> 8) & 255] +
					it[(t >> 16) & 255] +
					it[(t >> 24) & 255] +
					'-' +
					it[255 & e] +
					it[(e >> 8) & 255] +
					'-' +
					it[((e >> 16) & 15) | 64] +
					it[(e >> 24) & 255] +
					'-' +
					it[(63 & n) | 128] +
					it[(n >> 8) & 255] +
					'-' +
					it[(n >> 16) & 255] +
					it[(n >> 24) & 255] +
					it[255 & r] +
					it[(r >> 8) & 255] +
					it[(r >> 16) & 255] +
					it[(r >> 24) & 255]
				).toUpperCase();
			},
			clamp: function (t, e, n) {
				return Math.max(e, Math.min(n, t));
			},
			euclideanModulo: function (t, e) {
				return ((t % e) + e) % e;
			},
			mapLinear: function (t, e, n, r, i) {
				return r + ((t - e) * (i - r)) / (n - e);
			},
			lerp: function (t, e, n) {
				return (1 - n) * t + n * e;
			},
			smoothstep: function (t, e, n) {
				return t <= e
					? 0
					: t >= n
					? 1
					: (t = (t - e) / (n - e)) * t * (3 - 2 * t);
			},
			smootherstep: function (t, e, n) {
				return t <= e
					? 0
					: t >= n
					? 1
					: (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
			},
			randInt: function (t, e) {
				return t + Math.floor(Math.random() * (e - t + 1));
			},
			randFloat: function (t, e) {
				return t + Math.random() * (e - t);
			},
			randFloatSpread: function (t) {
				return t * (0.5 - Math.random());
			},
			seededRandom: function (t) {
				return (
					void 0 !== t && (ot = t % 2147483647),
					((ot = (16807 * ot) % 2147483647) - 1) / 2147483646
				);
			},
			degToRad: function (t) {
				return t * st.DEG2RAD;
			},
			radToDeg: function (t) {
				return t * st.RAD2DEG;
			},
			isPowerOfTwo: function (t) {
				return 0 == (t & (t - 1)) && 0 !== t;
			},
			ceilPowerOfTwo: function (t) {
				return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
			},
			floorPowerOfTwo: function (t) {
				return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
			},
			setQuaternionFromProperEuler: function (t, e, n, r, i) {
				var a = Math.cos,
					o = Math.sin,
					s = a(n / 2),
					c = o(n / 2),
					l = a((e + r) / 2),
					u = o((e + r) / 2),
					h = a((e - r) / 2),
					d = o((e - r) / 2),
					p = a((r - e) / 2),
					f = o((r - e) / 2);
				switch (i) {
					case 'XYX':
						t.set(s * u, c * h, c * d, s * l);
						break;
					case 'YZY':
						t.set(c * d, s * u, c * h, s * l);
						break;
					case 'ZXZ':
						t.set(c * h, c * d, s * u, s * l);
						break;
					case 'XZX':
						t.set(s * u, c * f, c * p, s * l);
						break;
					case 'YXY':
						t.set(c * p, s * u, c * f, s * l);
						break;
					case 'ZYZ':
						t.set(c * f, c * p, s * u, s * l);
						break;
					default:
						console.warn(
							'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
								i
						);
				}
			},
		};
	function ct(t, e) {
		for (var n = 0; n < e.length; n++) {
			var r = e[n];
			(r.enumerable = r.enumerable || !1),
				(r.configurable = !0),
				'value' in r && (r.writable = !0),
				Object.defineProperty(t, r.key, r);
		}
	}
	function lt(t, e, n) {
		return e && ct(t.prototype, e), n && ct(t, n), t;
	}
	function ut(t, e) {
		(t.prototype = Object.create(e.prototype)),
			(t.prototype.constructor = t),
			(t.__proto__ = e);
	}
	function ht(t) {
		if (void 0 === t)
			throw new ReferenceError(
				"this hasn't been initialised - super() hasn't been called"
			);
		return t;
	}
	var dt,
		pt = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					Object.defineProperty(this, 'isVector2', { value: !0 }),
					(this.x = t),
					(this.y = e);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return (this.x = t), (this.y = e), this;
				}),
				(e.setScalar = function (t) {
					return (this.x = t), (this.y = t), this;
				}),
				(e.setX = function (t) {
					return (this.x = t), this;
				}),
				(e.setY = function (t) {
					return (this.y = t), this;
				}),
				(e.setComponent = function (t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						default:
							throw new Error('index is out of range: ' + t);
					}
					return this;
				}),
				(e.getComponent = function (t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						default:
							throw new Error('index is out of range: ' + t);
					}
				}),
				(e.clone = function () {
					return new this.constructor(this.x, this.y);
				}),
				(e.copy = function (t) {
					return (this.x = t.x), (this.y = t.y), this;
				}),
				(e.add = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
						  ),
						  this.addVectors(t, e))
						: ((this.x += t.x), (this.y += t.y), this);
				}),
				(e.addScalar = function (t) {
					return (this.x += t), (this.y += t), this;
				}),
				(e.addVectors = function (t, e) {
					return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
				}),
				(e.addScaledVector = function (t, e) {
					return (this.x += t.x * e), (this.y += t.y * e), this;
				}),
				(e.sub = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
						  ),
						  this.subVectors(t, e))
						: ((this.x -= t.x), (this.y -= t.y), this);
				}),
				(e.subScalar = function (t) {
					return (this.x -= t), (this.y -= t), this;
				}),
				(e.subVectors = function (t, e) {
					return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
				}),
				(e.multiply = function (t) {
					return (this.x *= t.x), (this.y *= t.y), this;
				}),
				(e.multiplyScalar = function (t) {
					return (this.x *= t), (this.y *= t), this;
				}),
				(e.divide = function (t) {
					return (this.x /= t.x), (this.y /= t.y), this;
				}),
				(e.divideScalar = function (t) {
					return this.multiplyScalar(1 / t);
				}),
				(e.applyMatrix3 = function (t) {
					var e = this.x,
						n = this.y,
						r = t.elements;
					return (
						(this.x = r[0] * e + r[3] * n + r[6]),
						(this.y = r[1] * e + r[4] * n + r[7]),
						this
					);
				}),
				(e.min = function (t) {
					return (
						(this.x = Math.min(this.x, t.x)),
						(this.y = Math.min(this.y, t.y)),
						this
					);
				}),
				(e.max = function (t) {
					return (
						(this.x = Math.max(this.x, t.x)),
						(this.y = Math.max(this.y, t.y)),
						this
					);
				}),
				(e.clamp = function (t, e) {
					return (
						(this.x = Math.max(t.x, Math.min(e.x, this.x))),
						(this.y = Math.max(t.y, Math.min(e.y, this.y))),
						this
					);
				}),
				(e.clampScalar = function (t, e) {
					return (
						(this.x = Math.max(t, Math.min(e, this.x))),
						(this.y = Math.max(t, Math.min(e, this.y))),
						this
					);
				}),
				(e.clampLength = function (t, e) {
					var n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(
						Math.max(t, Math.min(e, n))
					);
				}),
				(e.floor = function () {
					return (
						(this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
					);
				}),
				(e.ceil = function () {
					return (
						(this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
					);
				}),
				(e.round = function () {
					return (
						(this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
					);
				}),
				(e.roundToZero = function () {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						this
					);
				}),
				(e.negate = function () {
					return (this.x = -this.x), (this.y = -this.y), this;
				}),
				(e.dot = function (t) {
					return this.x * t.x + this.y * t.y;
				}),
				(e.cross = function (t) {
					return this.x * t.y - this.y * t.x;
				}),
				(e.lengthSq = function () {
					return this.x * this.x + this.y * this.y;
				}),
				(e.length = function () {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				}),
				(e.manhattanLength = function () {
					return Math.abs(this.x) + Math.abs(this.y);
				}),
				(e.normalize = function () {
					return this.divideScalar(this.length() || 1);
				}),
				(e.angle = function () {
					var t = Math.atan2(-this.y, -this.x) + Math.PI;
					return t;
				}),
				(e.distanceTo = function (t) {
					return Math.sqrt(this.distanceToSquared(t));
				}),
				(e.distanceToSquared = function (t) {
					var e = this.x - t.x,
						n = this.y - t.y;
					return e * e + n * n;
				}),
				(e.manhattanDistanceTo = function (t) {
					return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
				}),
				(e.setLength = function (t) {
					return this.normalize().multiplyScalar(t);
				}),
				(e.lerp = function (t, e) {
					return (
						(this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
					);
				}),
				(e.lerpVectors = function (t, e, n) {
					return (
						(this.x = t.x + (e.x - t.x) * n),
						(this.y = t.y + (e.y - t.y) * n),
						this
					);
				}),
				(e.equals = function (t) {
					return t.x === this.x && t.y === this.y;
				}),
				(e.fromArray = function (t, e) {
					return (
						void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
					);
				}),
				(e.toArray = function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this.x),
						(t[e + 1] = this.y),
						t
					);
				}),
				(e.fromBufferAttribute = function (t, e, n) {
					return (
						void 0 !== n &&
							console.warn(
								'THREE.Vector2: offset has been removed from .fromBufferAttribute().'
							),
						(this.x = t.getX(e)),
						(this.y = t.getY(e)),
						this
					);
				}),
				(e.rotateAround = function (t, e) {
					var n = Math.cos(e),
						r = Math.sin(e),
						i = this.x - t.x,
						a = this.y - t.y;
					return (
						(this.x = i * n - a * r + t.x), (this.y = i * r + a * n + t.y), this
					);
				}),
				(e.random = function () {
					return (this.x = Math.random()), (this.y = Math.random()), this;
				}),
				lt(t, [
					{
						key: 'width',
						get: function () {
							return this.x;
						},
						set: function (t) {
							this.x = t;
						},
					},
					{
						key: 'height',
						get: function () {
							return this.y;
						},
						set: function (t) {
							this.y = t;
						},
					},
				]),
				t
			);
		})(),
		ft = (function () {
			function t() {
				Object.defineProperty(this, 'isMatrix3', { value: !0 }),
					(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
					arguments.length > 0 &&
						console.error(
							'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.'
						);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n, r, i, a, o, s, c) {
					var l = this.elements;
					return (
						(l[0] = t),
						(l[1] = r),
						(l[2] = o),
						(l[3] = e),
						(l[4] = i),
						(l[5] = s),
						(l[6] = n),
						(l[7] = a),
						(l[8] = c),
						this
					);
				}),
				(e.identity = function () {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
				}),
				(e.clone = function () {
					return new this.constructor().fromArray(this.elements);
				}),
				(e.copy = function (t) {
					var e = this.elements,
						n = t.elements;
					return (
						(e[0] = n[0]),
						(e[1] = n[1]),
						(e[2] = n[2]),
						(e[3] = n[3]),
						(e[4] = n[4]),
						(e[5] = n[5]),
						(e[6] = n[6]),
						(e[7] = n[7]),
						(e[8] = n[8]),
						this
					);
				}),
				(e.extractBasis = function (t, e, n) {
					return (
						t.setFromMatrix3Column(this, 0),
						e.setFromMatrix3Column(this, 1),
						n.setFromMatrix3Column(this, 2),
						this
					);
				}),
				(e.setFromMatrix4 = function (t) {
					var e = t.elements;
					return (
						this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
						this
					);
				}),
				(e.multiply = function (t) {
					return this.multiplyMatrices(this, t);
				}),
				(e.premultiply = function (t) {
					return this.multiplyMatrices(t, this);
				}),
				(e.multiplyMatrices = function (t, e) {
					var n = t.elements,
						r = e.elements,
						i = this.elements,
						a = n[0],
						o = n[3],
						s = n[6],
						c = n[1],
						l = n[4],
						u = n[7],
						h = n[2],
						d = n[5],
						p = n[8],
						f = r[0],
						m = r[3],
						v = r[6],
						g = r[1],
						y = r[4],
						x = r[7],
						_ = r[2],
						b = r[5],
						w = r[8];
					return (
						(i[0] = a * f + o * g + s * _),
						(i[3] = a * m + o * y + s * b),
						(i[6] = a * v + o * x + s * w),
						(i[1] = c * f + l * g + u * _),
						(i[4] = c * m + l * y + u * b),
						(i[7] = c * v + l * x + u * w),
						(i[2] = h * f + d * g + p * _),
						(i[5] = h * m + d * y + p * b),
						(i[8] = h * v + d * x + p * w),
						this
					);
				}),
				(e.multiplyScalar = function (t) {
					var e = this.elements;
					return (
						(e[0] *= t),
						(e[3] *= t),
						(e[6] *= t),
						(e[1] *= t),
						(e[4] *= t),
						(e[7] *= t),
						(e[2] *= t),
						(e[5] *= t),
						(e[8] *= t),
						this
					);
				}),
				(e.determinant = function () {
					var t = this.elements,
						e = t[0],
						n = t[1],
						r = t[2],
						i = t[3],
						a = t[4],
						o = t[5],
						s = t[6],
						c = t[7],
						l = t[8];
					return (
						e * a * l -
						e * o * c -
						n * i * l +
						n * o * s +
						r * i * c -
						r * a * s
					);
				}),
				(e.getInverse = function (t, e) {
					void 0 !== e &&
						console.warn(
							'THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.'
						);
					var n = t.elements,
						r = this.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						c = n[4],
						l = n[5],
						u = n[6],
						h = n[7],
						d = n[8],
						p = d * c - l * h,
						f = l * u - d * s,
						m = h * s - c * u,
						v = i * p + a * f + o * m;
					if (0 === v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
					var g = 1 / v;
					return (
						(r[0] = p * g),
						(r[1] = (o * h - d * a) * g),
						(r[2] = (l * a - o * c) * g),
						(r[3] = f * g),
						(r[4] = (d * i - o * u) * g),
						(r[5] = (o * s - l * i) * g),
						(r[6] = m * g),
						(r[7] = (a * u - h * i) * g),
						(r[8] = (c * i - a * s) * g),
						this
					);
				}),
				(e.transpose = function () {
					var t,
						e = this.elements;
					return (
						(t = e[1]),
						(e[1] = e[3]),
						(e[3] = t),
						(t = e[2]),
						(e[2] = e[6]),
						(e[6] = t),
						(t = e[5]),
						(e[5] = e[7]),
						(e[7] = t),
						this
					);
				}),
				(e.getNormalMatrix = function (t) {
					return this.setFromMatrix4(t).getInverse(this).transpose();
				}),
				(e.transposeIntoArray = function (t) {
					var e = this.elements;
					return (
						(t[0] = e[0]),
						(t[1] = e[3]),
						(t[2] = e[6]),
						(t[3] = e[1]),
						(t[4] = e[4]),
						(t[5] = e[7]),
						(t[6] = e[2]),
						(t[7] = e[5]),
						(t[8] = e[8]),
						this
					);
				}),
				(e.setUvTransform = function (t, e, n, r, i, a, o) {
					var s = Math.cos(i),
						c = Math.sin(i);
					this.set(
						n * s,
						n * c,
						-n * (s * a + c * o) + a + t,
						-r * c,
						r * s,
						-r * (-c * a + s * o) + o + e,
						0,
						0,
						1
					);
				}),
				(e.scale = function (t, e) {
					var n = this.elements;
					return (
						(n[0] *= t),
						(n[3] *= t),
						(n[6] *= t),
						(n[1] *= e),
						(n[4] *= e),
						(n[7] *= e),
						this
					);
				}),
				(e.rotate = function (t) {
					var e = Math.cos(t),
						n = Math.sin(t),
						r = this.elements,
						i = r[0],
						a = r[3],
						o = r[6],
						s = r[1],
						c = r[4],
						l = r[7];
					return (
						(r[0] = e * i + n * s),
						(r[3] = e * a + n * c),
						(r[6] = e * o + n * l),
						(r[1] = -n * i + e * s),
						(r[4] = -n * a + e * c),
						(r[7] = -n * o + e * l),
						this
					);
				}),
				(e.translate = function (t, e) {
					var n = this.elements;
					return (
						(n[0] += t * n[2]),
						(n[3] += t * n[5]),
						(n[6] += t * n[8]),
						(n[1] += e * n[2]),
						(n[4] += e * n[5]),
						(n[7] += e * n[8]),
						this
					);
				}),
				(e.equals = function (t) {
					for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
						if (e[r] !== n[r]) return !1;
					return !0;
				}),
				(e.fromArray = function (t, e) {
					void 0 === e && (e = 0);
					for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
					return this;
				}),
				(e.toArray = function (t, e) {
					void 0 === t && (t = []), void 0 === e && (e = 0);
					var n = this.elements;
					return (
						(t[e] = n[0]),
						(t[e + 1] = n[1]),
						(t[e + 2] = n[2]),
						(t[e + 3] = n[3]),
						(t[e + 4] = n[4]),
						(t[e + 5] = n[5]),
						(t[e + 6] = n[6]),
						(t[e + 7] = n[7]),
						(t[e + 8] = n[8]),
						t
					);
				}),
				t
			);
		})(),
		mt = {
			getDataURL: function (t) {
				if (/^data:/i.test(t.src)) return t.src;
				if ('undefined' == typeof HTMLCanvasElement) return t.src;
				var e;
				if (t instanceof HTMLCanvasElement) e = t;
				else {
					void 0 === dt &&
						(dt = document.createElementNS(
							'http://www.w3.org/1999/xhtml',
							'canvas'
						)),
						(dt.width = t.width),
						(dt.height = t.height);
					var n = dt.getContext('2d');
					t instanceof ImageData
						? n.putImageData(t, 0, 0)
						: n.drawImage(t, 0, 0, t.width, t.height),
						(e = dt);
				}
				return e.width > 2048 || e.height > 2048
					? e.toDataURL('image/jpeg', 0.6)
					: e.toDataURL('image/png');
			},
		},
		vt = 0;
	function gt(t, e, n, r, i, a, o, s, c, l) {
		Object.defineProperty(this, 'id', { value: vt++ }),
			(this.uuid = st.generateUUID()),
			(this.name = ''),
			(this.image = void 0 !== t ? t : gt.DEFAULT_IMAGE),
			(this.mipmaps = []),
			(this.mapping = void 0 !== e ? e : gt.DEFAULT_MAPPING),
			(this.wrapS = void 0 !== n ? n : u),
			(this.wrapT = void 0 !== r ? r : u),
			(this.magFilter = void 0 !== i ? i : m),
			(this.minFilter = void 0 !== a ? a : g),
			(this.anisotropy = void 0 !== c ? c : 1),
			(this.format = void 0 !== o ? o : T),
			(this.internalFormat = null),
			(this.type = void 0 !== s ? s : y),
			(this.offset = new pt(0, 0)),
			(this.repeat = new pt(1, 1)),
			(this.center = new pt(0, 0)),
			(this.rotation = 0),
			(this.matrixAutoUpdate = !0),
			(this.matrix = new ft()),
			(this.generateMipmaps = !0),
			(this.premultiplyAlpha = !1),
			(this.flipY = !0),
			(this.unpackAlignment = 4),
			(this.encoding = void 0 !== l ? l : q),
			(this.version = 0),
			(this.onUpdate = null);
	}
	(gt.DEFAULT_IMAGE = void 0),
		(gt.DEFAULT_MAPPING = n),
		(gt.prototype = Object.assign(Object.create(rt.prototype), {
			constructor: gt,
			isTexture: !0,
			updateMatrix: function () {
				this.matrix.setUvTransform(
					this.offset.x,
					this.offset.y,
					this.repeat.x,
					this.repeat.y,
					this.rotation,
					this.center.x,
					this.center.y
				);
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return (
					(this.name = t.name),
					(this.image = t.image),
					(this.mipmaps = t.mipmaps.slice(0)),
					(this.mapping = t.mapping),
					(this.wrapS = t.wrapS),
					(this.wrapT = t.wrapT),
					(this.magFilter = t.magFilter),
					(this.minFilter = t.minFilter),
					(this.anisotropy = t.anisotropy),
					(this.format = t.format),
					(this.internalFormat = t.internalFormat),
					(this.type = t.type),
					this.offset.copy(t.offset),
					this.repeat.copy(t.repeat),
					this.center.copy(t.center),
					(this.rotation = t.rotation),
					(this.matrixAutoUpdate = t.matrixAutoUpdate),
					this.matrix.copy(t.matrix),
					(this.generateMipmaps = t.generateMipmaps),
					(this.premultiplyAlpha = t.premultiplyAlpha),
					(this.flipY = t.flipY),
					(this.unpackAlignment = t.unpackAlignment),
					(this.encoding = t.encoding),
					this
				);
			},
			toJSON: function (t) {
				var e = void 0 === t || 'string' == typeof t;
				if (!e && void 0 !== t.textures[this.uuid])
					return t.textures[this.uuid];
				var n = {
					metadata: {
						version: 4.5,
						type: 'Texture',
						generator: 'Texture.toJSON',
					},
					uuid: this.uuid,
					name: this.name,
					mapping: this.mapping,
					repeat: [this.repeat.x, this.repeat.y],
					offset: [this.offset.x, this.offset.y],
					center: [this.center.x, this.center.y],
					rotation: this.rotation,
					wrap: [this.wrapS, this.wrapT],
					format: this.format,
					type: this.type,
					encoding: this.encoding,
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
					flipY: this.flipY,
					premultiplyAlpha: this.premultiplyAlpha,
					unpackAlignment: this.unpackAlignment,
				};
				if (void 0 !== this.image) {
					var r = this.image;
					if (
						(void 0 === r.uuid && (r.uuid = st.generateUUID()),
						!e && void 0 === t.images[r.uuid])
					) {
						var i;
						if (Array.isArray(r)) {
							i = [];
							for (var a = 0, o = r.length; a < o; a++)
								i.push(mt.getDataURL(r[a]));
						} else i = mt.getDataURL(r);
						t.images[r.uuid] = { uuid: r.uuid, url: i };
					}
					n.image = r.uuid;
				}
				return e || (t.textures[this.uuid] = n), n;
			},
			dispose: function () {
				this.dispatchEvent({ type: 'dispose' });
			},
			transformUv: function (t) {
				if (this.mapping !== n) return t;
				if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
					switch (this.wrapS) {
						case l:
							t.x = t.x - Math.floor(t.x);
							break;
						case u:
							t.x = t.x < 0 ? 0 : 1;
							break;
						case h:
							1 === Math.abs(Math.floor(t.x) % 2)
								? (t.x = Math.ceil(t.x) - t.x)
								: (t.x = t.x - Math.floor(t.x));
					}
				if (t.y < 0 || t.y > 1)
					switch (this.wrapT) {
						case l:
							t.y = t.y - Math.floor(t.y);
							break;
						case u:
							t.y = t.y < 0 ? 0 : 1;
							break;
						case h:
							1 === Math.abs(Math.floor(t.y) % 2)
								? (t.y = Math.ceil(t.y) - t.y)
								: (t.y = t.y - Math.floor(t.y));
					}
				return this.flipY && (t.y = 1 - t.y), t;
			},
		})),
		Object.defineProperty(gt.prototype, 'needsUpdate', {
			set: function (t) {
				!0 === t && this.version++;
			},
		});
	var yt = (function () {
		function t(t, e, n, r) {
			void 0 === t && (t = 0),
				void 0 === e && (e = 0),
				void 0 === n && (n = 0),
				void 0 === r && (r = 1),
				Object.defineProperty(this, 'isVector4', { value: !0 }),
				(this.x = t),
				(this.y = e),
				(this.z = n),
				(this.w = r);
		}
		var e = t.prototype;
		return (
			(e.set = function (t, e, n, r) {
				return (this.x = t), (this.y = e), (this.z = n), (this.w = r), this;
			}),
			(e.setScalar = function (t) {
				return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
			}),
			(e.setX = function (t) {
				return (this.x = t), this;
			}),
			(e.setY = function (t) {
				return (this.y = t), this;
			}),
			(e.setZ = function (t) {
				return (this.z = t), this;
			}),
			(e.setW = function (t) {
				return (this.w = t), this;
			}),
			(e.setComponent = function (t, e) {
				switch (t) {
					case 0:
						this.x = e;
						break;
					case 1:
						this.y = e;
						break;
					case 2:
						this.z = e;
						break;
					case 3:
						this.w = e;
						break;
					default:
						throw new Error('index is out of range: ' + t);
				}
				return this;
			}),
			(e.getComponent = function (t) {
				switch (t) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					case 3:
						return this.w;
					default:
						throw new Error('index is out of range: ' + t);
				}
			}),
			(e.clone = function () {
				return new this.constructor(this.x, this.y, this.z, this.w);
			}),
			(e.copy = function (t) {
				return (
					(this.x = t.x),
					(this.y = t.y),
					(this.z = t.z),
					(this.w = void 0 !== t.w ? t.w : 1),
					this
				);
			}),
			(e.add = function (t, e) {
				return void 0 !== e
					? (console.warn(
							'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
					  ),
					  this.addVectors(t, e))
					: ((this.x += t.x),
					  (this.y += t.y),
					  (this.z += t.z),
					  (this.w += t.w),
					  this);
			}),
			(e.addScalar = function (t) {
				return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
			}),
			(e.addVectors = function (t, e) {
				return (
					(this.x = t.x + e.x),
					(this.y = t.y + e.y),
					(this.z = t.z + e.z),
					(this.w = t.w + e.w),
					this
				);
			}),
			(e.addScaledVector = function (t, e) {
				return (
					(this.x += t.x * e),
					(this.y += t.y * e),
					(this.z += t.z * e),
					(this.w += t.w * e),
					this
				);
			}),
			(e.sub = function (t, e) {
				return void 0 !== e
					? (console.warn(
							'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
					  ),
					  this.subVectors(t, e))
					: ((this.x -= t.x),
					  (this.y -= t.y),
					  (this.z -= t.z),
					  (this.w -= t.w),
					  this);
			}),
			(e.subScalar = function (t) {
				return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
			}),
			(e.subVectors = function (t, e) {
				return (
					(this.x = t.x - e.x),
					(this.y = t.y - e.y),
					(this.z = t.z - e.z),
					(this.w = t.w - e.w),
					this
				);
			}),
			(e.multiplyScalar = function (t) {
				return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
			}),
			(e.applyMatrix4 = function (t) {
				var e = this.x,
					n = this.y,
					r = this.z,
					i = this.w,
					a = t.elements;
				return (
					(this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i),
					(this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i),
					(this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i),
					(this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i),
					this
				);
			}),
			(e.divideScalar = function (t) {
				return this.multiplyScalar(1 / t);
			}),
			(e.setAxisAngleFromQuaternion = function (t) {
				this.w = 2 * Math.acos(t.w);
				var e = Math.sqrt(1 - t.w * t.w);
				return (
					e < 1e-4
						? ((this.x = 1), (this.y = 0), (this.z = 0))
						: ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
					this
				);
			}),
			(e.setAxisAngleFromRotationMatrix = function (t) {
				var e,
					n,
					r,
					i,
					a = 0.01,
					o = 0.1,
					s = t.elements,
					c = s[0],
					l = s[4],
					u = s[8],
					h = s[1],
					d = s[5],
					p = s[9],
					f = s[2],
					m = s[6],
					v = s[10];
				if (Math.abs(l - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
					if (
						Math.abs(l + h) < o &&
						Math.abs(u + f) < o &&
						Math.abs(p + m) < o &&
						Math.abs(c + d + v - 3) < o
					)
						return this.set(1, 0, 0, 0), this;
					e = Math.PI;
					var g = (c + 1) / 2,
						y = (d + 1) / 2,
						x = (v + 1) / 2,
						_ = (l + h) / 4,
						b = (u + f) / 4,
						w = (p + m) / 4;
					return (
						g > y && g > x
							? g < a
								? ((n = 0), (r = 0.707106781), (i = 0.707106781))
								: ((r = _ / (n = Math.sqrt(g))), (i = b / n))
							: y > x
							? y < a
								? ((n = 0.707106781), (r = 0), (i = 0.707106781))
								: ((n = _ / (r = Math.sqrt(y))), (i = w / r))
							: x < a
							? ((n = 0.707106781), (r = 0.707106781), (i = 0))
							: ((n = b / (i = Math.sqrt(x))), (r = w / i)),
						this.set(n, r, i, e),
						this
					);
				}
				var M = Math.sqrt(
					(m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l)
				);
				return (
					Math.abs(M) < 0.001 && (M = 1),
					(this.x = (m - p) / M),
					(this.y = (u - f) / M),
					(this.z = (h - l) / M),
					(this.w = Math.acos((c + d + v - 1) / 2)),
					this
				);
			}),
			(e.min = function (t) {
				return (
					(this.x = Math.min(this.x, t.x)),
					(this.y = Math.min(this.y, t.y)),
					(this.z = Math.min(this.z, t.z)),
					(this.w = Math.min(this.w, t.w)),
					this
				);
			}),
			(e.max = function (t) {
				return (
					(this.x = Math.max(this.x, t.x)),
					(this.y = Math.max(this.y, t.y)),
					(this.z = Math.max(this.z, t.z)),
					(this.w = Math.max(this.w, t.w)),
					this
				);
			}),
			(e.clamp = function (t, e) {
				return (
					(this.x = Math.max(t.x, Math.min(e.x, this.x))),
					(this.y = Math.max(t.y, Math.min(e.y, this.y))),
					(this.z = Math.max(t.z, Math.min(e.z, this.z))),
					(this.w = Math.max(t.w, Math.min(e.w, this.w))),
					this
				);
			}),
			(e.clampScalar = function (t, e) {
				return (
					(this.x = Math.max(t, Math.min(e, this.x))),
					(this.y = Math.max(t, Math.min(e, this.y))),
					(this.z = Math.max(t, Math.min(e, this.z))),
					(this.w = Math.max(t, Math.min(e, this.w))),
					this
				);
			}),
			(e.clampLength = function (t, e) {
				var n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(
					Math.max(t, Math.min(e, n))
				);
			}),
			(e.floor = function () {
				return (
					(this.x = Math.floor(this.x)),
					(this.y = Math.floor(this.y)),
					(this.z = Math.floor(this.z)),
					(this.w = Math.floor(this.w)),
					this
				);
			}),
			(e.ceil = function () {
				return (
					(this.x = Math.ceil(this.x)),
					(this.y = Math.ceil(this.y)),
					(this.z = Math.ceil(this.z)),
					(this.w = Math.ceil(this.w)),
					this
				);
			}),
			(e.round = function () {
				return (
					(this.x = Math.round(this.x)),
					(this.y = Math.round(this.y)),
					(this.z = Math.round(this.z)),
					(this.w = Math.round(this.w)),
					this
				);
			}),
			(e.roundToZero = function () {
				return (
					(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
					(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
					(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
					(this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
					this
				);
			}),
			(e.negate = function () {
				return (
					(this.x = -this.x),
					(this.y = -this.y),
					(this.z = -this.z),
					(this.w = -this.w),
					this
				);
			}),
			(e.dot = function (t) {
				return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
			}),
			(e.lengthSq = function () {
				return (
					this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				);
			}),
			(e.length = function () {
				return Math.sqrt(
					this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				);
			}),
			(e.manhattanLength = function () {
				return (
					Math.abs(this.x) +
					Math.abs(this.y) +
					Math.abs(this.z) +
					Math.abs(this.w)
				);
			}),
			(e.normalize = function () {
				return this.divideScalar(this.length() || 1);
			}),
			(e.setLength = function (t) {
				return this.normalize().multiplyScalar(t);
			}),
			(e.lerp = function (t, e) {
				return (
					(this.x += (t.x - this.x) * e),
					(this.y += (t.y - this.y) * e),
					(this.z += (t.z - this.z) * e),
					(this.w += (t.w - this.w) * e),
					this
				);
			}),
			(e.lerpVectors = function (t, e, n) {
				return (
					(this.x = t.x + (e.x - t.x) * n),
					(this.y = t.y + (e.y - t.y) * n),
					(this.z = t.z + (e.z - t.z) * n),
					(this.w = t.w + (e.w - t.w) * n),
					this
				);
			}),
			(e.equals = function (t) {
				return (
					t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
				);
			}),
			(e.fromArray = function (t, e) {
				return (
					void 0 === e && (e = 0),
					(this.x = t[e]),
					(this.y = t[e + 1]),
					(this.z = t[e + 2]),
					(this.w = t[e + 3]),
					this
				);
			}),
			(e.toArray = function (t, e) {
				return (
					void 0 === t && (t = []),
					void 0 === e && (e = 0),
					(t[e] = this.x),
					(t[e + 1] = this.y),
					(t[e + 2] = this.z),
					(t[e + 3] = this.w),
					t
				);
			}),
			(e.fromBufferAttribute = function (t, e, n) {
				return (
					void 0 !== n &&
						console.warn(
							'THREE.Vector4: offset has been removed from .fromBufferAttribute().'
						),
					(this.x = t.getX(e)),
					(this.y = t.getY(e)),
					(this.z = t.getZ(e)),
					(this.w = t.getW(e)),
					this
				);
			}),
			(e.random = function () {
				return (
					(this.x = Math.random()),
					(this.y = Math.random()),
					(this.z = Math.random()),
					(this.w = Math.random()),
					this
				);
			}),
			lt(t, [
				{
					key: 'width',
					get: function () {
						return this.z;
					},
					set: function (t) {
						this.z = t;
					},
				},
				{
					key: 'height',
					get: function () {
						return this.w;
					},
					set: function (t) {
						this.w = t;
					},
				},
			]),
			t
		);
	})();
	function xt(t, e, n) {
		(this.width = t),
			(this.height = e),
			(this.scissor = new yt(0, 0, t, e)),
			(this.scissorTest = !1),
			(this.viewport = new yt(0, 0, t, e)),
			(n = n || {}),
			(this.texture = new gt(
				void 0,
				n.mapping,
				n.wrapS,
				n.wrapT,
				n.magFilter,
				n.minFilter,
				n.format,
				n.type,
				n.anisotropy,
				n.encoding
			)),
			(this.texture.image = {}),
			(this.texture.image.width = t),
			(this.texture.image.height = e),
			(this.texture.generateMipmaps =
				void 0 !== n.generateMipmaps && n.generateMipmaps),
			(this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : m),
			(this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
			(this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
			(this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
	}
	function _t(t, e, n) {
		xt.call(this, t, e, n), (this.samples = 4);
	}
	(xt.prototype = Object.assign(Object.create(rt.prototype), {
		constructor: xt,
		isWebGLRenderTarget: !0,
		setSize: function (t, e) {
			(this.width === t && this.height === e) ||
				((this.width = t),
				(this.height = e),
				(this.texture.image.width = t),
				(this.texture.image.height = e),
				this.dispose()),
				this.viewport.set(0, 0, t, e),
				this.scissor.set(0, 0, t, e);
		},
		clone: function () {
			return new this.constructor().copy(this);
		},
		copy: function (t) {
			return (
				(this.width = t.width),
				(this.height = t.height),
				this.viewport.copy(t.viewport),
				(this.texture = t.texture.clone()),
				(this.depthBuffer = t.depthBuffer),
				(this.stencilBuffer = t.stencilBuffer),
				(this.depthTexture = t.depthTexture),
				this
			);
		},
		dispose: function () {
			this.dispatchEvent({ type: 'dispose' });
		},
	})),
		(_t.prototype = Object.assign(Object.create(xt.prototype), {
			constructor: _t,
			isWebGLMultisampleRenderTarget: !0,
			copy: function (t) {
				return (
					xt.prototype.copy.call(this, t), (this.samples = t.samples), this
				);
			},
		}));
	var bt = (function () {
			function t(t, e, n, r) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === n && (n = 0),
					void 0 === r && (r = 1),
					Object.defineProperty(this, 'isQuaternion', { value: !0 }),
					(this._x = t),
					(this._y = e),
					(this._z = n),
					(this._w = r);
			}
			(t.slerp = function (t, e, n, r) {
				return n.copy(t).slerp(e, r);
			}),
				(t.slerpFlat = function (t, e, n, r, i, a, o) {
					var s = n[r + 0],
						c = n[r + 1],
						l = n[r + 2],
						u = n[r + 3],
						h = i[a + 0],
						d = i[a + 1],
						p = i[a + 2],
						f = i[a + 3];
					if (u !== f || s !== h || c !== d || l !== p) {
						var m = 1 - o,
							v = s * h + c * d + l * p + u * f,
							g = v >= 0 ? 1 : -1,
							y = 1 - v * v;
						if (y > Number.EPSILON) {
							var x = Math.sqrt(y),
								_ = Math.atan2(x, v * g);
							(m = Math.sin(m * _) / x), (o = Math.sin(o * _) / x);
						}
						var b = o * g;
						if (
							((s = s * m + h * b),
							(c = c * m + d * b),
							(l = l * m + p * b),
							(u = u * m + f * b),
							m === 1 - o)
						) {
							var w = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
							(s *= w), (c *= w), (l *= w), (u *= w);
						}
					}
					(t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = u);
				}),
				(t.multiplyQuaternionsFlat = function (t, e, n, r, i, a) {
					var o = n[r],
						s = n[r + 1],
						c = n[r + 2],
						l = n[r + 3],
						u = i[a],
						h = i[a + 1],
						d = i[a + 2],
						p = i[a + 3];
					return (
						(t[e] = o * p + l * u + s * d - c * h),
						(t[e + 1] = s * p + l * h + c * u - o * d),
						(t[e + 2] = c * p + l * d + o * h - s * u),
						(t[e + 3] = l * p - o * u - s * h - c * d),
						t
					);
				});
			var e = t.prototype;
			return (
				(e.set = function (t, e, n, r) {
					return (
						(this._x = t),
						(this._y = e),
						(this._z = n),
						(this._w = r),
						this._onChangeCallback(),
						this
					);
				}),
				(e.clone = function () {
					return new this.constructor(this._x, this._y, this._z, this._w);
				}),
				(e.copy = function (t) {
					return (
						(this._x = t.x),
						(this._y = t.y),
						(this._z = t.z),
						(this._w = t.w),
						this._onChangeCallback(),
						this
					);
				}),
				(e.setFromEuler = function (t, e) {
					if (!t || !t.isEuler)
						throw new Error(
							'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
						);
					var n = t._x,
						r = t._y,
						i = t._z,
						a = t._order,
						o = Math.cos,
						s = Math.sin,
						c = o(n / 2),
						l = o(r / 2),
						u = o(i / 2),
						h = s(n / 2),
						d = s(r / 2),
						p = s(i / 2);
					switch (a) {
						case 'XYZ':
							(this._x = h * l * u + c * d * p),
								(this._y = c * d * u - h * l * p),
								(this._z = c * l * p + h * d * u),
								(this._w = c * l * u - h * d * p);
							break;
						case 'YXZ':
							(this._x = h * l * u + c * d * p),
								(this._y = c * d * u - h * l * p),
								(this._z = c * l * p - h * d * u),
								(this._w = c * l * u + h * d * p);
							break;
						case 'ZXY':
							(this._x = h * l * u - c * d * p),
								(this._y = c * d * u + h * l * p),
								(this._z = c * l * p + h * d * u),
								(this._w = c * l * u - h * d * p);
							break;
						case 'ZYX':
							(this._x = h * l * u - c * d * p),
								(this._y = c * d * u + h * l * p),
								(this._z = c * l * p - h * d * u),
								(this._w = c * l * u + h * d * p);
							break;
						case 'YZX':
							(this._x = h * l * u + c * d * p),
								(this._y = c * d * u + h * l * p),
								(this._z = c * l * p - h * d * u),
								(this._w = c * l * u - h * d * p);
							break;
						case 'XZY':
							(this._x = h * l * u - c * d * p),
								(this._y = c * d * u - h * l * p),
								(this._z = c * l * p + h * d * u),
								(this._w = c * l * u + h * d * p);
							break;
						default:
							console.warn(
								'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
									a
							);
					}
					return !1 !== e && this._onChangeCallback(), this;
				}),
				(e.setFromAxisAngle = function (t, e) {
					var n = e / 2,
						r = Math.sin(n);
					return (
						(this._x = t.x * r),
						(this._y = t.y * r),
						(this._z = t.z * r),
						(this._w = Math.cos(n)),
						this._onChangeCallback(),
						this
					);
				}),
				(e.setFromRotationMatrix = function (t) {
					var e = t.elements,
						n = e[0],
						r = e[4],
						i = e[8],
						a = e[1],
						o = e[5],
						s = e[9],
						c = e[2],
						l = e[6],
						u = e[10],
						h = n + o + u;
					if (h > 0) {
						var d = 0.5 / Math.sqrt(h + 1);
						(this._w = 0.25 / d),
							(this._x = (l - s) * d),
							(this._y = (i - c) * d),
							(this._z = (a - r) * d);
					} else if (n > o && n > u) {
						var p = 2 * Math.sqrt(1 + n - o - u);
						(this._w = (l - s) / p),
							(this._x = 0.25 * p),
							(this._y = (r + a) / p),
							(this._z = (i + c) / p);
					} else if (o > u) {
						var f = 2 * Math.sqrt(1 + o - n - u);
						(this._w = (i - c) / f),
							(this._x = (r + a) / f),
							(this._y = 0.25 * f),
							(this._z = (s + l) / f);
					} else {
						var m = 2 * Math.sqrt(1 + u - n - o);
						(this._w = (a - r) / m),
							(this._x = (i + c) / m),
							(this._y = (s + l) / m),
							(this._z = 0.25 * m);
					}
					return this._onChangeCallback(), this;
				}),
				(e.setFromUnitVectors = function (t, e) {
					var n = t.dot(e) + 1;
					return (
						n < 1e-6
							? ((n = 0),
							  Math.abs(t.x) > Math.abs(t.z)
									? ((this._x = -t.y),
									  (this._y = t.x),
									  (this._z = 0),
									  (this._w = n))
									: ((this._x = 0),
									  (this._y = -t.z),
									  (this._z = t.y),
									  (this._w = n)))
							: ((this._x = t.y * e.z - t.z * e.y),
							  (this._y = t.z * e.x - t.x * e.z),
							  (this._z = t.x * e.y - t.y * e.x),
							  (this._w = n)),
						this.normalize()
					);
				}),
				(e.angleTo = function (t) {
					return 2 * Math.acos(Math.abs(st.clamp(this.dot(t), -1, 1)));
				}),
				(e.rotateTowards = function (t, e) {
					var n = this.angleTo(t);
					if (0 === n) return this;
					var r = Math.min(1, e / n);
					return this.slerp(t, r), this;
				}),
				(e.identity = function () {
					return this.set(0, 0, 0, 1);
				}),
				(e.inverse = function () {
					return this.conjugate();
				}),
				(e.conjugate = function () {
					return (
						(this._x *= -1),
						(this._y *= -1),
						(this._z *= -1),
						this._onChangeCallback(),
						this
					);
				}),
				(e.dot = function (t) {
					return (
						this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
					);
				}),
				(e.lengthSq = function () {
					return (
						this._x * this._x +
						this._y * this._y +
						this._z * this._z +
						this._w * this._w
					);
				}),
				(e.length = function () {
					return Math.sqrt(
						this._x * this._x +
							this._y * this._y +
							this._z * this._z +
							this._w * this._w
					);
				}),
				(e.normalize = function () {
					var t = this.length();
					return (
						0 === t
							? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
							: ((t = 1 / t),
							  (this._x = this._x * t),
							  (this._y = this._y * t),
							  (this._z = this._z * t),
							  (this._w = this._w * t)),
						this._onChangeCallback(),
						this
					);
				}),
				(e.multiply = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
						  ),
						  this.multiplyQuaternions(t, e))
						: this.multiplyQuaternions(this, t);
				}),
				(e.premultiply = function (t) {
					return this.multiplyQuaternions(t, this);
				}),
				(e.multiplyQuaternions = function (t, e) {
					var n = t._x,
						r = t._y,
						i = t._z,
						a = t._w,
						o = e._x,
						s = e._y,
						c = e._z,
						l = e._w;
					return (
						(this._x = n * l + a * o + r * c - i * s),
						(this._y = r * l + a * s + i * o - n * c),
						(this._z = i * l + a * c + n * s - r * o),
						(this._w = a * l - n * o - r * s - i * c),
						this._onChangeCallback(),
						this
					);
				}),
				(e.slerp = function (t, e) {
					if (0 === e) return this;
					if (1 === e) return this.copy(t);
					var n = this._x,
						r = this._y,
						i = this._z,
						a = this._w,
						o = a * t._w + n * t._x + r * t._y + i * t._z;
					if (
						(o < 0
							? ((this._w = -t._w),
							  (this._x = -t._x),
							  (this._y = -t._y),
							  (this._z = -t._z),
							  (o = -o))
							: this.copy(t),
						o >= 1)
					)
						return (
							(this._w = a), (this._x = n), (this._y = r), (this._z = i), this
						);
					var s = 1 - o * o;
					if (s <= Number.EPSILON) {
						var c = 1 - e;
						return (
							(this._w = c * a + e * this._w),
							(this._x = c * n + e * this._x),
							(this._y = c * r + e * this._y),
							(this._z = c * i + e * this._z),
							this.normalize(),
							this._onChangeCallback(),
							this
						);
					}
					var l = Math.sqrt(s),
						u = Math.atan2(l, o),
						h = Math.sin((1 - e) * u) / l,
						d = Math.sin(e * u) / l;
					return (
						(this._w = a * h + this._w * d),
						(this._x = n * h + this._x * d),
						(this._y = r * h + this._y * d),
						(this._z = i * h + this._z * d),
						this._onChangeCallback(),
						this
					);
				}),
				(e.equals = function (t) {
					return (
						t._x === this._x &&
						t._y === this._y &&
						t._z === this._z &&
						t._w === this._w
					);
				}),
				(e.fromArray = function (t, e) {
					return (
						void 0 === e && (e = 0),
						(this._x = t[e]),
						(this._y = t[e + 1]),
						(this._z = t[e + 2]),
						(this._w = t[e + 3]),
						this._onChangeCallback(),
						this
					);
				}),
				(e.toArray = function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this._x),
						(t[e + 1] = this._y),
						(t[e + 2] = this._z),
						(t[e + 3] = this._w),
						t
					);
				}),
				(e.fromBufferAttribute = function (t, e) {
					return (
						(this._x = t.getX(e)),
						(this._y = t.getY(e)),
						(this._z = t.getZ(e)),
						(this._w = t.getW(e)),
						this
					);
				}),
				(e._onChange = function (t) {
					return (this._onChangeCallback = t), this;
				}),
				(e._onChangeCallback = function () {}),
				lt(t, [
					{
						key: 'x',
						get: function () {
							return this._x;
						},
						set: function (t) {
							(this._x = t), this._onChangeCallback();
						},
					},
					{
						key: 'y',
						get: function () {
							return this._y;
						},
						set: function (t) {
							(this._y = t), this._onChangeCallback();
						},
					},
					{
						key: 'z',
						get: function () {
							return this._z;
						},
						set: function (t) {
							(this._z = t), this._onChangeCallback();
						},
					},
					{
						key: 'w',
						get: function () {
							return this._w;
						},
						set: function (t) {
							(this._w = t), this._onChangeCallback();
						},
					},
				]),
				t
			);
		})(),
		wt = (function () {
			function t(t, e, n) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === n && (n = 0),
					Object.defineProperty(this, 'isVector3', { value: !0 }),
					(this.x = t),
					(this.y = e),
					(this.z = n);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n) {
					return (
						void 0 === n && (n = this.z),
						(this.x = t),
						(this.y = e),
						(this.z = n),
						this
					);
				}),
				(e.setScalar = function (t) {
					return (this.x = t), (this.y = t), (this.z = t), this;
				}),
				(e.setX = function (t) {
					return (this.x = t), this;
				}),
				(e.setY = function (t) {
					return (this.y = t), this;
				}),
				(e.setZ = function (t) {
					return (this.z = t), this;
				}),
				(e.setComponent = function (t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						case 2:
							this.z = e;
							break;
						default:
							throw new Error('index is out of range: ' + t);
					}
					return this;
				}),
				(e.getComponent = function (t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						default:
							throw new Error('index is out of range: ' + t);
					}
				}),
				(e.clone = function () {
					return new this.constructor(this.x, this.y, this.z);
				}),
				(e.copy = function (t) {
					return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
				}),
				(e.add = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
						  ),
						  this.addVectors(t, e))
						: ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
				}),
				(e.addScalar = function (t) {
					return (this.x += t), (this.y += t), (this.z += t), this;
				}),
				(e.addVectors = function (t, e) {
					return (
						(this.x = t.x + e.x),
						(this.y = t.y + e.y),
						(this.z = t.z + e.z),
						this
					);
				}),
				(e.addScaledVector = function (t, e) {
					return (
						(this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
					);
				}),
				(e.sub = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
						  ),
						  this.subVectors(t, e))
						: ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
				}),
				(e.subScalar = function (t) {
					return (this.x -= t), (this.y -= t), (this.z -= t), this;
				}),
				(e.subVectors = function (t, e) {
					return (
						(this.x = t.x - e.x),
						(this.y = t.y - e.y),
						(this.z = t.z - e.z),
						this
					);
				}),
				(e.multiply = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
						  ),
						  this.multiplyVectors(t, e))
						: ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
				}),
				(e.multiplyScalar = function (t) {
					return (this.x *= t), (this.y *= t), (this.z *= t), this;
				}),
				(e.multiplyVectors = function (t, e) {
					return (
						(this.x = t.x * e.x),
						(this.y = t.y * e.y),
						(this.z = t.z * e.z),
						this
					);
				}),
				(e.applyEuler = function (t) {
					return (
						(t && t.isEuler) ||
							console.error(
								'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
							),
						this.applyQuaternion(St.setFromEuler(t))
					);
				}),
				(e.applyAxisAngle = function (t, e) {
					return this.applyQuaternion(St.setFromAxisAngle(t, e));
				}),
				(e.applyMatrix3 = function (t) {
					var e = this.x,
						n = this.y,
						r = this.z,
						i = t.elements;
					return (
						(this.x = i[0] * e + i[3] * n + i[6] * r),
						(this.y = i[1] * e + i[4] * n + i[7] * r),
						(this.z = i[2] * e + i[5] * n + i[8] * r),
						this
					);
				}),
				(e.applyNormalMatrix = function (t) {
					return this.applyMatrix3(t).normalize();
				}),
				(e.applyMatrix4 = function (t) {
					var e = this.x,
						n = this.y,
						r = this.z,
						i = t.elements,
						a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
					return (
						(this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a),
						(this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a),
						(this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a),
						this
					);
				}),
				(e.applyQuaternion = function (t) {
					var e = this.x,
						n = this.y,
						r = this.z,
						i = t.x,
						a = t.y,
						o = t.z,
						s = t.w,
						c = s * e + a * r - o * n,
						l = s * n + o * e - i * r,
						u = s * r + i * n - a * e,
						h = -i * e - a * n - o * r;
					return (
						(this.x = c * s + h * -i + l * -o - u * -a),
						(this.y = l * s + h * -a + u * -i - c * -o),
						(this.z = u * s + h * -o + c * -a - l * -i),
						this
					);
				}),
				(e.project = function (t) {
					return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
						t.projectionMatrix
					);
				}),
				(e.unproject = function (t) {
					return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
						t.matrixWorld
					);
				}),
				(e.transformDirection = function (t) {
					var e = this.x,
						n = this.y,
						r = this.z,
						i = t.elements;
					return (
						(this.x = i[0] * e + i[4] * n + i[8] * r),
						(this.y = i[1] * e + i[5] * n + i[9] * r),
						(this.z = i[2] * e + i[6] * n + i[10] * r),
						this.normalize()
					);
				}),
				(e.divide = function (t) {
					return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
				}),
				(e.divideScalar = function (t) {
					return this.multiplyScalar(1 / t);
				}),
				(e.min = function (t) {
					return (
						(this.x = Math.min(this.x, t.x)),
						(this.y = Math.min(this.y, t.y)),
						(this.z = Math.min(this.z, t.z)),
						this
					);
				}),
				(e.max = function (t) {
					return (
						(this.x = Math.max(this.x, t.x)),
						(this.y = Math.max(this.y, t.y)),
						(this.z = Math.max(this.z, t.z)),
						this
					);
				}),
				(e.clamp = function (t, e) {
					return (
						(this.x = Math.max(t.x, Math.min(e.x, this.x))),
						(this.y = Math.max(t.y, Math.min(e.y, this.y))),
						(this.z = Math.max(t.z, Math.min(e.z, this.z))),
						this
					);
				}),
				(e.clampScalar = function (t, e) {
					return (
						(this.x = Math.max(t, Math.min(e, this.x))),
						(this.y = Math.max(t, Math.min(e, this.y))),
						(this.z = Math.max(t, Math.min(e, this.z))),
						this
					);
				}),
				(e.clampLength = function (t, e) {
					var n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(
						Math.max(t, Math.min(e, n))
					);
				}),
				(e.floor = function () {
					return (
						(this.x = Math.floor(this.x)),
						(this.y = Math.floor(this.y)),
						(this.z = Math.floor(this.z)),
						this
					);
				}),
				(e.ceil = function () {
					return (
						(this.x = Math.ceil(this.x)),
						(this.y = Math.ceil(this.y)),
						(this.z = Math.ceil(this.z)),
						this
					);
				}),
				(e.round = function () {
					return (
						(this.x = Math.round(this.x)),
						(this.y = Math.round(this.y)),
						(this.z = Math.round(this.z)),
						this
					);
				}),
				(e.roundToZero = function () {
					return (
						(this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
						(this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
						(this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
						this
					);
				}),
				(e.negate = function () {
					return (
						(this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
					);
				}),
				(e.dot = function (t) {
					return this.x * t.x + this.y * t.y + this.z * t.z;
				}),
				(e.lengthSq = function () {
					return this.x * this.x + this.y * this.y + this.z * this.z;
				}),
				(e.length = function () {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
				}),
				(e.manhattanLength = function () {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
				}),
				(e.normalize = function () {
					return this.divideScalar(this.length() || 1);
				}),
				(e.setLength = function (t) {
					return this.normalize().multiplyScalar(t);
				}),
				(e.lerp = function (t, e) {
					return (
						(this.x += (t.x - this.x) * e),
						(this.y += (t.y - this.y) * e),
						(this.z += (t.z - this.z) * e),
						this
					);
				}),
				(e.lerpVectors = function (t, e, n) {
					return (
						(this.x = t.x + (e.x - t.x) * n),
						(this.y = t.y + (e.y - t.y) * n),
						(this.z = t.z + (e.z - t.z) * n),
						this
					);
				}),
				(e.cross = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'
						  ),
						  this.crossVectors(t, e))
						: this.crossVectors(this, t);
				}),
				(e.crossVectors = function (t, e) {
					var n = t.x,
						r = t.y,
						i = t.z,
						a = e.x,
						o = e.y,
						s = e.z;
					return (
						(this.x = r * s - i * o),
						(this.y = i * a - n * s),
						(this.z = n * o - r * a),
						this
					);
				}),
				(e.projectOnVector = function (t) {
					var e = t.lengthSq();
					if (0 === e) return this.set(0, 0, 0);
					var n = t.dot(this) / e;
					return this.copy(t).multiplyScalar(n);
				}),
				(e.projectOnPlane = function (t) {
					return Mt.copy(this).projectOnVector(t), this.sub(Mt);
				}),
				(e.reflect = function (t) {
					return this.sub(Mt.copy(t).multiplyScalar(2 * this.dot(t)));
				}),
				(e.angleTo = function (t) {
					var e = Math.sqrt(this.lengthSq() * t.lengthSq());
					if (0 === e) return Math.PI / 2;
					var n = this.dot(t) / e;
					return Math.acos(st.clamp(n, -1, 1));
				}),
				(e.distanceTo = function (t) {
					return Math.sqrt(this.distanceToSquared(t));
				}),
				(e.distanceToSquared = function (t) {
					var e = this.x - t.x,
						n = this.y - t.y,
						r = this.z - t.z;
					return e * e + n * n + r * r;
				}),
				(e.manhattanDistanceTo = function (t) {
					return (
						Math.abs(this.x - t.x) +
						Math.abs(this.y - t.y) +
						Math.abs(this.z - t.z)
					);
				}),
				(e.setFromSpherical = function (t) {
					return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
				}),
				(e.setFromSphericalCoords = function (t, e, n) {
					var r = Math.sin(e) * t;
					return (
						(this.x = r * Math.sin(n)),
						(this.y = Math.cos(e) * t),
						(this.z = r * Math.cos(n)),
						this
					);
				}),
				(e.setFromCylindrical = function (t) {
					return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
				}),
				(e.setFromCylindricalCoords = function (t, e, n) {
					return (
						(this.x = t * Math.sin(e)),
						(this.y = n),
						(this.z = t * Math.cos(e)),
						this
					);
				}),
				(e.setFromMatrixPosition = function (t) {
					var e = t.elements;
					return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
				}),
				(e.setFromMatrixScale = function (t) {
					var e = this.setFromMatrixColumn(t, 0).length(),
						n = this.setFromMatrixColumn(t, 1).length(),
						r = this.setFromMatrixColumn(t, 2).length();
					return (this.x = e), (this.y = n), (this.z = r), this;
				}),
				(e.setFromMatrixColumn = function (t, e) {
					return this.fromArray(t.elements, 4 * e);
				}),
				(e.setFromMatrix3Column = function (t, e) {
					return this.fromArray(t.elements, 3 * e);
				}),
				(e.equals = function (t) {
					return t.x === this.x && t.y === this.y && t.z === this.z;
				}),
				(e.fromArray = function (t, e) {
					return (
						void 0 === e && (e = 0),
						(this.x = t[e]),
						(this.y = t[e + 1]),
						(this.z = t[e + 2]),
						this
					);
				}),
				(e.toArray = function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this.x),
						(t[e + 1] = this.y),
						(t[e + 2] = this.z),
						t
					);
				}),
				(e.fromBufferAttribute = function (t, e, n) {
					return (
						void 0 !== n &&
							console.warn(
								'THREE.Vector3: offset has been removed from .fromBufferAttribute().'
							),
						(this.x = t.getX(e)),
						(this.y = t.getY(e)),
						(this.z = t.getZ(e)),
						this
					);
				}),
				(e.random = function () {
					return (
						(this.x = Math.random()),
						(this.y = Math.random()),
						(this.z = Math.random()),
						this
					);
				}),
				t
			);
		})(),
		Mt = new wt(),
		St = new bt(),
		Tt = (function () {
			function t(t, e) {
				Object.defineProperty(this, 'isBox3', { value: !0 }),
					(this.min = void 0 !== t ? t : new wt(1 / 0, 1 / 0, 1 / 0)),
					(this.max = void 0 !== e ? e : new wt(-1 / 0, -1 / 0, -1 / 0));
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return this.min.copy(t), this.max.copy(e), this;
				}),
				(e.setFromArray = function (t) {
					for (
						var e = 1 / 0,
							n = 1 / 0,
							r = 1 / 0,
							i = -1 / 0,
							a = -1 / 0,
							o = -1 / 0,
							s = 0,
							c = t.length;
						s < c;
						s += 3
					) {
						var l = t[s],
							u = t[s + 1],
							h = t[s + 2];
						l < e && (e = l),
							u < n && (n = u),
							h < r && (r = h),
							l > i && (i = l),
							u > a && (a = u),
							h > o && (o = h);
					}
					return this.min.set(e, n, r), this.max.set(i, a, o), this;
				}),
				(e.setFromBufferAttribute = function (t) {
					for (
						var e = 1 / 0,
							n = 1 / 0,
							r = 1 / 0,
							i = -1 / 0,
							a = -1 / 0,
							o = -1 / 0,
							s = 0,
							c = t.count;
						s < c;
						s++
					) {
						var l = t.getX(s),
							u = t.getY(s),
							h = t.getZ(s);
						l < e && (e = l),
							u < n && (n = u),
							h < r && (r = h),
							l > i && (i = l),
							u > a && (a = u),
							h > o && (o = h);
					}
					return this.min.set(e, n, r), this.max.set(i, a, o), this;
				}),
				(e.setFromPoints = function (t) {
					this.makeEmpty();
					for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
					return this;
				}),
				(e.setFromCenterAndSize = function (t, e) {
					var n = Lt.copy(e).multiplyScalar(0.5);
					return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
				}),
				(e.setFromObject = function (t) {
					return this.makeEmpty(), this.expandByObject(t);
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return this.min.copy(t.min), this.max.copy(t.max), this;
				}),
				(e.makeEmpty = function () {
					return (
						(this.min.x = this.min.y = this.min.z = 1 / 0),
						(this.max.x = this.max.y = this.max.z = -1 / 0),
						this
					);
				}),
				(e.isEmpty = function () {
					return (
						this.max.x < this.min.x ||
						this.max.y < this.min.y ||
						this.max.z < this.min.z
					);
				}),
				(e.getCenter = function (t) {
					return (
						void 0 === t &&
							(console.warn('THREE.Box3: .getCenter() target is now required'),
							(t = new wt())),
						this.isEmpty()
							? t.set(0, 0, 0)
							: t.addVectors(this.min, this.max).multiplyScalar(0.5)
					);
				}),
				(e.getSize = function (t) {
					return (
						void 0 === t &&
							(console.warn('THREE.Box3: .getSize() target is now required'),
							(t = new wt())),
						this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
					);
				}),
				(e.expandByPoint = function (t) {
					return this.min.min(t), this.max.max(t), this;
				}),
				(e.expandByVector = function (t) {
					return this.min.sub(t), this.max.add(t), this;
				}),
				(e.expandByScalar = function (t) {
					return this.min.addScalar(-t), this.max.addScalar(t), this;
				}),
				(e.expandByObject = function (t) {
					t.updateWorldMatrix(!1, !1);
					var e = t.geometry;
					void 0 !== e &&
						(null === e.boundingBox && e.computeBoundingBox(),
						Rt.copy(e.boundingBox),
						Rt.applyMatrix4(t.matrixWorld),
						this.union(Rt));
					for (var n = t.children, r = 0, i = n.length; r < i; r++)
						this.expandByObject(n[r]);
					return this;
				}),
				(e.containsPoint = function (t) {
					return !(
						t.x < this.min.x ||
						t.x > this.max.x ||
						t.y < this.min.y ||
						t.y > this.max.y ||
						t.z < this.min.z ||
						t.z > this.max.z
					);
				}),
				(e.containsBox = function (t) {
					return (
						this.min.x <= t.min.x &&
						t.max.x <= this.max.x &&
						this.min.y <= t.min.y &&
						t.max.y <= this.max.y &&
						this.min.z <= t.min.z &&
						t.max.z <= this.max.z
					);
				}),
				(e.getParameter = function (t, e) {
					return (
						void 0 === e &&
							(console.warn(
								'THREE.Box3: .getParameter() target is now required'
							),
							(e = new wt())),
						e.set(
							(t.x - this.min.x) / (this.max.x - this.min.x),
							(t.y - this.min.y) / (this.max.y - this.min.y),
							(t.z - this.min.z) / (this.max.z - this.min.z)
						)
					);
				}),
				(e.intersectsBox = function (t) {
					return !(
						t.max.x < this.min.x ||
						t.min.x > this.max.x ||
						t.max.y < this.min.y ||
						t.min.y > this.max.y ||
						t.max.z < this.min.z ||
						t.min.z > this.max.z
					);
				}),
				(e.intersectsSphere = function (t) {
					return (
						this.clampPoint(t.center, Lt),
						Lt.distanceToSquared(t.center) <= t.radius * t.radius
					);
				}),
				(e.intersectsPlane = function (t) {
					var e, n;
					return (
						t.normal.x > 0
							? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
							: ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
						t.normal.y > 0
							? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
							: ((e += t.normal.y * this.max.y),
							  (n += t.normal.y * this.min.y)),
						t.normal.z > 0
							? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
							: ((e += t.normal.z * this.max.z),
							  (n += t.normal.z * this.min.z)),
						e <= -t.constant && n >= -t.constant
					);
				}),
				(e.intersectsTriangle = function (t) {
					if (this.isEmpty()) return !1;
					this.getCenter(Bt),
						zt.subVectors(this.max, Bt),
						Ct.subVectors(t.a, Bt),
						Pt.subVectors(t.b, Bt),
						It.subVectors(t.c, Bt),
						Dt.subVectors(Pt, Ct),
						Nt.subVectors(It, Pt),
						Ot.subVectors(Ct, It);
					var e = [
						0,
						-Dt.z,
						Dt.y,
						0,
						-Nt.z,
						Nt.y,
						0,
						-Ot.z,
						Ot.y,
						Dt.z,
						0,
						-Dt.x,
						Nt.z,
						0,
						-Nt.x,
						Ot.z,
						0,
						-Ot.x,
						-Dt.y,
						Dt.x,
						0,
						-Nt.y,
						Nt.x,
						0,
						-Ot.y,
						Ot.x,
						0,
					];
					return (
						!!Et(e, Ct, Pt, It, zt) &&
						!!Et((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Ct, Pt, It, zt) &&
						(Gt.crossVectors(Dt, Nt),
						Et((e = [Gt.x, Gt.y, Gt.z]), Ct, Pt, It, zt))
					);
				}),
				(e.clampPoint = function (t, e) {
					return (
						void 0 === e &&
							(console.warn('THREE.Box3: .clampPoint() target is now required'),
							(e = new wt())),
						e.copy(t).clamp(this.min, this.max)
					);
				}),
				(e.distanceToPoint = function (t) {
					return Lt.copy(t).clamp(this.min, this.max).sub(t).length();
				}),
				(e.getBoundingSphere = function (t) {
					return (
						void 0 === t &&
							console.error(
								'THREE.Box3: .getBoundingSphere() target is now required'
							),
						this.getCenter(t.center),
						(t.radius = 0.5 * this.getSize(Lt).length()),
						t
					);
				}),
				(e.intersect = function (t) {
					return (
						this.min.max(t.min),
						this.max.min(t.max),
						this.isEmpty() && this.makeEmpty(),
						this
					);
				}),
				(e.union = function (t) {
					return this.min.min(t.min), this.max.max(t.max), this;
				}),
				(e.applyMatrix4 = function (t) {
					return (
						this.isEmpty() ||
							(At[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
							At[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
							At[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
							At[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
							At[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
							At[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
							At[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
							At[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
							this.setFromPoints(At)),
						this
					);
				}),
				(e.translate = function (t) {
					return this.min.add(t), this.max.add(t), this;
				}),
				(e.equals = function (t) {
					return t.min.equals(this.min) && t.max.equals(this.max);
				}),
				t
			);
		})();
	function Et(t, e, n, r, i) {
		for (var a = 0, o = t.length - 3; a <= o; a += 3) {
			Ft.fromArray(t, a);
			var s =
					i.x * Math.abs(Ft.x) + i.y * Math.abs(Ft.y) + i.z * Math.abs(Ft.z),
				c = e.dot(Ft),
				l = n.dot(Ft),
				u = r.dot(Ft);
			if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > s) return !1;
		}
		return !0;
	}
	var At = [
			new wt(),
			new wt(),
			new wt(),
			new wt(),
			new wt(),
			new wt(),
			new wt(),
			new wt(),
		],
		Lt = new wt(),
		Rt = new Tt(),
		Ct = new wt(),
		Pt = new wt(),
		It = new wt(),
		Dt = new wt(),
		Nt = new wt(),
		Ot = new wt(),
		Bt = new wt(),
		zt = new wt(),
		Gt = new wt(),
		Ft = new wt(),
		Ut = new Tt(),
		Ht = (function () {
			function t(t, e) {
				(this.center = void 0 !== t ? t : new wt()),
					(this.radius = void 0 !== e ? e : -1);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return this.center.copy(t), (this.radius = e), this;
				}),
				(e.setFromPoints = function (t, e) {
					var n = this.center;
					void 0 !== e ? n.copy(e) : Ut.setFromPoints(t).getCenter(n);
					for (var r = 0, i = 0, a = t.length; i < a; i++)
						r = Math.max(r, n.distanceToSquared(t[i]));
					return (this.radius = Math.sqrt(r)), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return this.center.copy(t.center), (this.radius = t.radius), this;
				}),
				(e.isEmpty = function () {
					return this.radius < 0;
				}),
				(e.makeEmpty = function () {
					return this.center.set(0, 0, 0), (this.radius = -1), this;
				}),
				(e.containsPoint = function (t) {
					return t.distanceToSquared(this.center) <= this.radius * this.radius;
				}),
				(e.distanceToPoint = function (t) {
					return t.distanceTo(this.center) - this.radius;
				}),
				(e.intersectsSphere = function (t) {
					var e = this.radius + t.radius;
					return t.center.distanceToSquared(this.center) <= e * e;
				}),
				(e.intersectsBox = function (t) {
					return t.intersectsSphere(this);
				}),
				(e.intersectsPlane = function (t) {
					return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
				}),
				(e.clampPoint = function (t, e) {
					var n = this.center.distanceToSquared(t);
					return (
						void 0 === e &&
							(console.warn(
								'THREE.Sphere: .clampPoint() target is now required'
							),
							(e = new wt())),
						e.copy(t),
						n > this.radius * this.radius &&
							(e.sub(this.center).normalize(),
							e.multiplyScalar(this.radius).add(this.center)),
						e
					);
				}),
				(e.getBoundingBox = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								'THREE.Sphere: .getBoundingBox() target is now required'
							),
							(t = new Tt())),
						this.isEmpty()
							? (t.makeEmpty(), t)
							: (t.set(this.center, this.center),
							  t.expandByScalar(this.radius),
							  t)
					);
				}),
				(e.applyMatrix4 = function (t) {
					return (
						this.center.applyMatrix4(t),
						(this.radius = this.radius * t.getMaxScaleOnAxis()),
						this
					);
				}),
				(e.translate = function (t) {
					return this.center.add(t), this;
				}),
				(e.equals = function (t) {
					return t.center.equals(this.center) && t.radius === this.radius;
				}),
				t
			);
		})(),
		kt = new wt(),
		Vt = new wt(),
		Wt = new wt(),
		jt = new wt(),
		qt = new wt(),
		Xt = new wt(),
		Yt = new wt(),
		Zt = (function () {
			function t(t, e) {
				(this.origin = void 0 !== t ? t : new wt()),
					(this.direction = void 0 !== e ? e : new wt(0, 0, -1));
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return this.origin.copy(t), this.direction.copy(e), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return (
						this.origin.copy(t.origin), this.direction.copy(t.direction), this
					);
				}),
				(e.at = function (t, e) {
					return (
						void 0 === e &&
							(console.warn('THREE.Ray: .at() target is now required'),
							(e = new wt())),
						e.copy(this.direction).multiplyScalar(t).add(this.origin)
					);
				}),
				(e.lookAt = function (t) {
					return this.direction.copy(t).sub(this.origin).normalize(), this;
				}),
				(e.recast = function (t) {
					return this.origin.copy(this.at(t, kt)), this;
				}),
				(e.closestPointToPoint = function (t, e) {
					void 0 === e &&
						(console.warn(
							'THREE.Ray: .closestPointToPoint() target is now required'
						),
						(e = new wt())),
						e.subVectors(t, this.origin);
					var n = e.dot(this.direction);
					return n < 0
						? e.copy(this.origin)
						: e.copy(this.direction).multiplyScalar(n).add(this.origin);
				}),
				(e.distanceToPoint = function (t) {
					return Math.sqrt(this.distanceSqToPoint(t));
				}),
				(e.distanceSqToPoint = function (t) {
					var e = kt.subVectors(t, this.origin).dot(this.direction);
					return e < 0
						? this.origin.distanceToSquared(t)
						: (kt.copy(this.direction).multiplyScalar(e).add(this.origin),
						  kt.distanceToSquared(t));
				}),
				(e.distanceSqToSegment = function (t, e, n, r) {
					Vt.copy(t).add(e).multiplyScalar(0.5),
						Wt.copy(e).sub(t).normalize(),
						jt.copy(this.origin).sub(Vt);
					var i,
						a,
						o,
						s,
						c = 0.5 * t.distanceTo(e),
						l = -this.direction.dot(Wt),
						u = jt.dot(this.direction),
						h = -jt.dot(Wt),
						d = jt.lengthSq(),
						p = Math.abs(1 - l * l);
					if (p > 0)
						if (((a = l * u - h), (s = c * p), (i = l * h - u) >= 0))
							if (a >= -s)
								if (a <= s) {
									var f = 1 / p;
									o =
										(i *= f) * (i + l * (a *= f) + 2 * u) +
										a * (l * i + a + 2 * h) +
										d;
								} else
									(a = c),
										(o =
											-(i = Math.max(0, -(l * a + u))) * i +
											a * (a + 2 * h) +
											d);
							else
								(a = -c),
									(o =
										-(i = Math.max(0, -(l * a + u))) * i + a * (a + 2 * h) + d);
						else
							a <= -s
								? (o =
										-(i = Math.max(0, -(-l * c + u))) * i +
										(a = i > 0 ? -c : Math.min(Math.max(-c, -h), c)) *
											(a + 2 * h) +
										d)
								: a <= s
								? ((i = 0),
								  (o = (a = Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d))
								: (o =
										-(i = Math.max(0, -(l * c + u))) * i +
										(a = i > 0 ? c : Math.min(Math.max(-c, -h), c)) *
											(a + 2 * h) +
										d);
					else
						(a = l > 0 ? -c : c),
							(o = -(i = Math.max(0, -(l * a + u))) * i + a * (a + 2 * h) + d);
					return (
						n && n.copy(this.direction).multiplyScalar(i).add(this.origin),
						r && r.copy(Wt).multiplyScalar(a).add(Vt),
						o
					);
				}),
				(e.intersectSphere = function (t, e) {
					kt.subVectors(t.center, this.origin);
					var n = kt.dot(this.direction),
						r = kt.dot(kt) - n * n,
						i = t.radius * t.radius;
					if (r > i) return null;
					var a = Math.sqrt(i - r),
						o = n - a,
						s = n + a;
					return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e);
				}),
				(e.intersectsSphere = function (t) {
					return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
				}),
				(e.distanceToPlane = function (t) {
					var e = t.normal.dot(this.direction);
					if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
					var n = -(this.origin.dot(t.normal) + t.constant) / e;
					return n >= 0 ? n : null;
				}),
				(e.intersectPlane = function (t, e) {
					var n = this.distanceToPlane(t);
					return null === n ? null : this.at(n, e);
				}),
				(e.intersectsPlane = function (t) {
					var e = t.distanceToPoint(this.origin);
					return 0 === e || t.normal.dot(this.direction) * e < 0;
				}),
				(e.intersectBox = function (t, e) {
					var n,
						r,
						i,
						a,
						o,
						s,
						c = 1 / this.direction.x,
						l = 1 / this.direction.y,
						u = 1 / this.direction.z,
						h = this.origin;
					return (
						c >= 0
							? ((n = (t.min.x - h.x) * c), (r = (t.max.x - h.x) * c))
							: ((n = (t.max.x - h.x) * c), (r = (t.min.x - h.x) * c)),
						l >= 0
							? ((i = (t.min.y - h.y) * l), (a = (t.max.y - h.y) * l))
							: ((i = (t.max.y - h.y) * l), (a = (t.min.y - h.y) * l)),
						n > a || i > r
							? null
							: ((i > n || n != n) && (n = i),
							  (a < r || r != r) && (r = a),
							  u >= 0
									? ((o = (t.min.z - h.z) * u), (s = (t.max.z - h.z) * u))
									: ((o = (t.max.z - h.z) * u), (s = (t.min.z - h.z) * u)),
							  n > s || o > r
									? null
									: ((o > n || n != n) && (n = o),
									  (s < r || r != r) && (r = s),
									  r < 0 ? null : this.at(n >= 0 ? n : r, e)))
					);
				}),
				(e.intersectsBox = function (t) {
					return null !== this.intersectBox(t, kt);
				}),
				(e.intersectTriangle = function (t, e, n, r, i) {
					qt.subVectors(e, t), Xt.subVectors(n, t), Yt.crossVectors(qt, Xt);
					var a,
						o = this.direction.dot(Yt);
					if (o > 0) {
						if (r) return null;
						a = 1;
					} else {
						if (!(o < 0)) return null;
						(a = -1), (o = -o);
					}
					jt.subVectors(this.origin, t);
					var s = a * this.direction.dot(Xt.crossVectors(jt, Xt));
					if (s < 0) return null;
					var c = a * this.direction.dot(qt.cross(jt));
					if (c < 0) return null;
					if (s + c > o) return null;
					var l = -a * jt.dot(Yt);
					return l < 0 ? null : this.at(l / o, i);
				}),
				(e.applyMatrix4 = function (t) {
					return (
						this.origin.applyMatrix4(t),
						this.direction.transformDirection(t),
						this
					);
				}),
				(e.equals = function (t) {
					return (
						t.origin.equals(this.origin) && t.direction.equals(this.direction)
					);
				}),
				t
			);
		})(),
		Jt = (function () {
			function t() {
				Object.defineProperty(this, 'isMatrix4', { value: !0 }),
					(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
					arguments.length > 0 &&
						console.error(
							'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.'
						);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n, r, i, a, o, s, c, l, u, h, d, p, f, m) {
					var v = this.elements;
					return (
						(v[0] = t),
						(v[4] = e),
						(v[8] = n),
						(v[12] = r),
						(v[1] = i),
						(v[5] = a),
						(v[9] = o),
						(v[13] = s),
						(v[2] = c),
						(v[6] = l),
						(v[10] = u),
						(v[14] = h),
						(v[3] = d),
						(v[7] = p),
						(v[11] = f),
						(v[15] = m),
						this
					);
				}),
				(e.identity = function () {
					return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
				}),
				(e.clone = function () {
					return new t().fromArray(this.elements);
				}),
				(e.copy = function (t) {
					var e = this.elements,
						n = t.elements;
					return (
						(e[0] = n[0]),
						(e[1] = n[1]),
						(e[2] = n[2]),
						(e[3] = n[3]),
						(e[4] = n[4]),
						(e[5] = n[5]),
						(e[6] = n[6]),
						(e[7] = n[7]),
						(e[8] = n[8]),
						(e[9] = n[9]),
						(e[10] = n[10]),
						(e[11] = n[11]),
						(e[12] = n[12]),
						(e[13] = n[13]),
						(e[14] = n[14]),
						(e[15] = n[15]),
						this
					);
				}),
				(e.copyPosition = function (t) {
					var e = this.elements,
						n = t.elements;
					return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
				}),
				(e.extractBasis = function (t, e, n) {
					return (
						t.setFromMatrixColumn(this, 0),
						e.setFromMatrixColumn(this, 1),
						n.setFromMatrixColumn(this, 2),
						this
					);
				}),
				(e.makeBasis = function (t, e, n) {
					return (
						this.set(
							t.x,
							e.x,
							n.x,
							0,
							t.y,
							e.y,
							n.y,
							0,
							t.z,
							e.z,
							n.z,
							0,
							0,
							0,
							0,
							1
						),
						this
					);
				}),
				(e.extractRotation = function (t) {
					var e = this.elements,
						n = t.elements,
						r = 1 / Qt.setFromMatrixColumn(t, 0).length(),
						i = 1 / Qt.setFromMatrixColumn(t, 1).length(),
						a = 1 / Qt.setFromMatrixColumn(t, 2).length();
					return (
						(e[0] = n[0] * r),
						(e[1] = n[1] * r),
						(e[2] = n[2] * r),
						(e[3] = 0),
						(e[4] = n[4] * i),
						(e[5] = n[5] * i),
						(e[6] = n[6] * i),
						(e[7] = 0),
						(e[8] = n[8] * a),
						(e[9] = n[9] * a),
						(e[10] = n[10] * a),
						(e[11] = 0),
						(e[12] = 0),
						(e[13] = 0),
						(e[14] = 0),
						(e[15] = 1),
						this
					);
				}),
				(e.makeRotationFromEuler = function (t) {
					(t && t.isEuler) ||
						console.error(
							'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
						);
					var e = this.elements,
						n = t.x,
						r = t.y,
						i = t.z,
						a = Math.cos(n),
						o = Math.sin(n),
						s = Math.cos(r),
						c = Math.sin(r),
						l = Math.cos(i),
						u = Math.sin(i);
					if ('XYZ' === t.order) {
						var h = a * l,
							d = a * u,
							p = o * l,
							f = o * u;
						(e[0] = s * l),
							(e[4] = -s * u),
							(e[8] = c),
							(e[1] = d + p * c),
							(e[5] = h - f * c),
							(e[9] = -o * s),
							(e[2] = f - h * c),
							(e[6] = p + d * c),
							(e[10] = a * s);
					} else if ('YXZ' === t.order) {
						var m = s * l,
							v = s * u,
							g = c * l,
							y = c * u;
						(e[0] = m + y * o),
							(e[4] = g * o - v),
							(e[8] = a * c),
							(e[1] = a * u),
							(e[5] = a * l),
							(e[9] = -o),
							(e[2] = v * o - g),
							(e[6] = y + m * o),
							(e[10] = a * s);
					} else if ('ZXY' === t.order) {
						var x = s * l,
							_ = s * u,
							b = c * l,
							w = c * u;
						(e[0] = x - w * o),
							(e[4] = -a * u),
							(e[8] = b + _ * o),
							(e[1] = _ + b * o),
							(e[5] = a * l),
							(e[9] = w - x * o),
							(e[2] = -a * c),
							(e[6] = o),
							(e[10] = a * s);
					} else if ('ZYX' === t.order) {
						var M = a * l,
							S = a * u,
							T = o * l,
							E = o * u;
						(e[0] = s * l),
							(e[4] = T * c - S),
							(e[8] = M * c + E),
							(e[1] = s * u),
							(e[5] = E * c + M),
							(e[9] = S * c - T),
							(e[2] = -c),
							(e[6] = o * s),
							(e[10] = a * s);
					} else if ('YZX' === t.order) {
						var A = a * s,
							L = a * c,
							R = o * s,
							C = o * c;
						(e[0] = s * l),
							(e[4] = C - A * u),
							(e[8] = R * u + L),
							(e[1] = u),
							(e[5] = a * l),
							(e[9] = -o * l),
							(e[2] = -c * l),
							(e[6] = L * u + R),
							(e[10] = A - C * u);
					} else if ('XZY' === t.order) {
						var P = a * s,
							I = a * c,
							D = o * s,
							N = o * c;
						(e[0] = s * l),
							(e[4] = -u),
							(e[8] = c * l),
							(e[1] = P * u + N),
							(e[5] = a * l),
							(e[9] = I * u - D),
							(e[2] = D * u - I),
							(e[6] = o * l),
							(e[10] = N * u + P);
					}
					return (
						(e[3] = 0),
						(e[7] = 0),
						(e[11] = 0),
						(e[12] = 0),
						(e[13] = 0),
						(e[14] = 0),
						(e[15] = 1),
						this
					);
				}),
				(e.makeRotationFromQuaternion = function (t) {
					return this.compose($t, t, te);
				}),
				(e.lookAt = function (t, e, n) {
					var r = this.elements;
					return (
						re.subVectors(t, e),
						0 === re.lengthSq() && (re.z = 1),
						re.normalize(),
						ee.crossVectors(n, re),
						0 === ee.lengthSq() &&
							(1 === Math.abs(n.z) ? (re.x += 1e-4) : (re.z += 1e-4),
							re.normalize(),
							ee.crossVectors(n, re)),
						ee.normalize(),
						ne.crossVectors(re, ee),
						(r[0] = ee.x),
						(r[4] = ne.x),
						(r[8] = re.x),
						(r[1] = ee.y),
						(r[5] = ne.y),
						(r[9] = re.y),
						(r[2] = ee.z),
						(r[6] = ne.z),
						(r[10] = re.z),
						this
					);
				}),
				(e.multiply = function (t, e) {
					return void 0 !== e
						? (console.warn(
								'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
						  ),
						  this.multiplyMatrices(t, e))
						: this.multiplyMatrices(this, t);
				}),
				(e.premultiply = function (t) {
					return this.multiplyMatrices(t, this);
				}),
				(e.multiplyMatrices = function (t, e) {
					var n = t.elements,
						r = e.elements,
						i = this.elements,
						a = n[0],
						o = n[4],
						s = n[8],
						c = n[12],
						l = n[1],
						u = n[5],
						h = n[9],
						d = n[13],
						p = n[2],
						f = n[6],
						m = n[10],
						v = n[14],
						g = n[3],
						y = n[7],
						x = n[11],
						_ = n[15],
						b = r[0],
						w = r[4],
						M = r[8],
						S = r[12],
						T = r[1],
						E = r[5],
						A = r[9],
						L = r[13],
						R = r[2],
						C = r[6],
						P = r[10],
						I = r[14],
						D = r[3],
						N = r[7],
						O = r[11],
						B = r[15];
					return (
						(i[0] = a * b + o * T + s * R + c * D),
						(i[4] = a * w + o * E + s * C + c * N),
						(i[8] = a * M + o * A + s * P + c * O),
						(i[12] = a * S + o * L + s * I + c * B),
						(i[1] = l * b + u * T + h * R + d * D),
						(i[5] = l * w + u * E + h * C + d * N),
						(i[9] = l * M + u * A + h * P + d * O),
						(i[13] = l * S + u * L + h * I + d * B),
						(i[2] = p * b + f * T + m * R + v * D),
						(i[6] = p * w + f * E + m * C + v * N),
						(i[10] = p * M + f * A + m * P + v * O),
						(i[14] = p * S + f * L + m * I + v * B),
						(i[3] = g * b + y * T + x * R + _ * D),
						(i[7] = g * w + y * E + x * C + _ * N),
						(i[11] = g * M + y * A + x * P + _ * O),
						(i[15] = g * S + y * L + x * I + _ * B),
						this
					);
				}),
				(e.multiplyScalar = function (t) {
					var e = this.elements;
					return (
						(e[0] *= t),
						(e[4] *= t),
						(e[8] *= t),
						(e[12] *= t),
						(e[1] *= t),
						(e[5] *= t),
						(e[9] *= t),
						(e[13] *= t),
						(e[2] *= t),
						(e[6] *= t),
						(e[10] *= t),
						(e[14] *= t),
						(e[3] *= t),
						(e[7] *= t),
						(e[11] *= t),
						(e[15] *= t),
						this
					);
				}),
				(e.determinant = function () {
					var t = this.elements,
						e = t[0],
						n = t[4],
						r = t[8],
						i = t[12],
						a = t[1],
						o = t[5],
						s = t[9],
						c = t[13],
						l = t[2],
						u = t[6],
						h = t[10],
						d = t[14];
					return (
						t[3] *
							(+i * s * u -
								r * c * u -
								i * o * h +
								n * c * h +
								r * o * d -
								n * s * d) +
						t[7] *
							(+e * s * d -
								e * c * h +
								i * a * h -
								r * a * d +
								r * c * l -
								i * s * l) +
						t[11] *
							(+e * c * u -
								e * o * d -
								i * a * u +
								n * a * d +
								i * o * l -
								n * c * l) +
						t[15] *
							(-r * o * l -
								e * s * u +
								e * o * h +
								r * a * u -
								n * a * h +
								n * s * l)
					);
				}),
				(e.transpose = function () {
					var t,
						e = this.elements;
					return (
						(t = e[1]),
						(e[1] = e[4]),
						(e[4] = t),
						(t = e[2]),
						(e[2] = e[8]),
						(e[8] = t),
						(t = e[6]),
						(e[6] = e[9]),
						(e[9] = t),
						(t = e[3]),
						(e[3] = e[12]),
						(e[12] = t),
						(t = e[7]),
						(e[7] = e[13]),
						(e[13] = t),
						(t = e[11]),
						(e[11] = e[14]),
						(e[14] = t),
						this
					);
				}),
				(e.setPosition = function (t, e, n) {
					var r = this.elements;
					return (
						t.isVector3
							? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
							: ((r[12] = t), (r[13] = e), (r[14] = n)),
						this
					);
				}),
				(e.getInverse = function (t, e) {
					void 0 !== e &&
						console.warn(
							'THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.'
						);
					var n = this.elements,
						r = t.elements,
						i = r[0],
						a = r[1],
						o = r[2],
						s = r[3],
						c = r[4],
						l = r[5],
						u = r[6],
						h = r[7],
						d = r[8],
						p = r[9],
						f = r[10],
						m = r[11],
						v = r[12],
						g = r[13],
						y = r[14],
						x = r[15],
						_ =
							p * y * h -
							g * f * h +
							g * u * m -
							l * y * m -
							p * u * x +
							l * f * x,
						b =
							v * f * h -
							d * y * h -
							v * u * m +
							c * y * m +
							d * u * x -
							c * f * x,
						w =
							d * g * h -
							v * p * h +
							v * l * m -
							c * g * m -
							d * l * x +
							c * p * x,
						M =
							v * p * u -
							d * g * u -
							v * l * f +
							c * g * f +
							d * l * y -
							c * p * y,
						S = i * _ + a * b + o * w + s * M;
					if (0 === S)
						return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
					var T = 1 / S;
					return (
						(n[0] = _ * T),
						(n[1] =
							(g * f * s -
								p * y * s -
								g * o * m +
								a * y * m +
								p * o * x -
								a * f * x) *
							T),
						(n[2] =
							(l * y * s -
								g * u * s +
								g * o * h -
								a * y * h -
								l * o * x +
								a * u * x) *
							T),
						(n[3] =
							(p * u * s -
								l * f * s -
								p * o * h +
								a * f * h +
								l * o * m -
								a * u * m) *
							T),
						(n[4] = b * T),
						(n[5] =
							(d * y * s -
								v * f * s +
								v * o * m -
								i * y * m -
								d * o * x +
								i * f * x) *
							T),
						(n[6] =
							(v * u * s -
								c * y * s -
								v * o * h +
								i * y * h +
								c * o * x -
								i * u * x) *
							T),
						(n[7] =
							(c * f * s -
								d * u * s +
								d * o * h -
								i * f * h -
								c * o * m +
								i * u * m) *
							T),
						(n[8] = w * T),
						(n[9] =
							(v * p * s -
								d * g * s -
								v * a * m +
								i * g * m +
								d * a * x -
								i * p * x) *
							T),
						(n[10] =
							(c * g * s -
								v * l * s +
								v * a * h -
								i * g * h -
								c * a * x +
								i * l * x) *
							T),
						(n[11] =
							(d * l * s -
								c * p * s -
								d * a * h +
								i * p * h +
								c * a * m -
								i * l * m) *
							T),
						(n[12] = M * T),
						(n[13] =
							(d * g * o -
								v * p * o +
								v * a * f -
								i * g * f -
								d * a * y +
								i * p * y) *
							T),
						(n[14] =
							(v * l * o -
								c * g * o -
								v * a * u +
								i * g * u +
								c * a * y -
								i * l * y) *
							T),
						(n[15] =
							(c * p * o -
								d * l * o +
								d * a * u -
								i * p * u -
								c * a * f +
								i * l * f) *
							T),
						this
					);
				}),
				(e.scale = function (t) {
					var e = this.elements,
						n = t.x,
						r = t.y,
						i = t.z;
					return (
						(e[0] *= n),
						(e[4] *= r),
						(e[8] *= i),
						(e[1] *= n),
						(e[5] *= r),
						(e[9] *= i),
						(e[2] *= n),
						(e[6] *= r),
						(e[10] *= i),
						(e[3] *= n),
						(e[7] *= r),
						(e[11] *= i),
						this
					);
				}),
				(e.getMaxScaleOnAxis = function () {
					var t = this.elements,
						e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
						n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
						r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
					return Math.sqrt(Math.max(e, n, r));
				}),
				(e.makeTranslation = function (t, e, n) {
					return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
				}),
				(e.makeRotationX = function (t) {
					var e = Math.cos(t),
						n = Math.sin(t);
					return (
						this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
					);
				}),
				(e.makeRotationY = function (t) {
					var e = Math.cos(t),
						n = Math.sin(t);
					return (
						this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
					);
				}),
				(e.makeRotationZ = function (t) {
					var e = Math.cos(t),
						n = Math.sin(t);
					return (
						this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
					);
				}),
				(e.makeRotationAxis = function (t, e) {
					var n = Math.cos(e),
						r = Math.sin(e),
						i = 1 - n,
						a = t.x,
						o = t.y,
						s = t.z,
						c = i * a,
						l = i * o;
					return (
						this.set(
							c * a + n,
							c * o - r * s,
							c * s + r * o,
							0,
							c * o + r * s,
							l * o + n,
							l * s - r * a,
							0,
							c * s - r * o,
							l * s + r * a,
							i * s * s + n,
							0,
							0,
							0,
							0,
							1
						),
						this
					);
				}),
				(e.makeScale = function (t, e, n) {
					return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
				}),
				(e.makeShear = function (t, e, n) {
					return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
				}),
				(e.compose = function (t, e, n) {
					var r = this.elements,
						i = e._x,
						a = e._y,
						o = e._z,
						s = e._w,
						c = i + i,
						l = a + a,
						u = o + o,
						h = i * c,
						d = i * l,
						p = i * u,
						f = a * l,
						m = a * u,
						v = o * u,
						g = s * c,
						y = s * l,
						x = s * u,
						_ = n.x,
						b = n.y,
						w = n.z;
					return (
						(r[0] = (1 - (f + v)) * _),
						(r[1] = (d + x) * _),
						(r[2] = (p - y) * _),
						(r[3] = 0),
						(r[4] = (d - x) * b),
						(r[5] = (1 - (h + v)) * b),
						(r[6] = (m + g) * b),
						(r[7] = 0),
						(r[8] = (p + y) * w),
						(r[9] = (m - g) * w),
						(r[10] = (1 - (h + f)) * w),
						(r[11] = 0),
						(r[12] = t.x),
						(r[13] = t.y),
						(r[14] = t.z),
						(r[15] = 1),
						this
					);
				}),
				(e.decompose = function (t, e, n) {
					var r = this.elements,
						i = Qt.set(r[0], r[1], r[2]).length(),
						a = Qt.set(r[4], r[5], r[6]).length(),
						o = Qt.set(r[8], r[9], r[10]).length();
					this.determinant() < 0 && (i = -i),
						(t.x = r[12]),
						(t.y = r[13]),
						(t.z = r[14]),
						Kt.copy(this);
					var s = 1 / i,
						c = 1 / a,
						l = 1 / o;
					return (
						(Kt.elements[0] *= s),
						(Kt.elements[1] *= s),
						(Kt.elements[2] *= s),
						(Kt.elements[4] *= c),
						(Kt.elements[5] *= c),
						(Kt.elements[6] *= c),
						(Kt.elements[8] *= l),
						(Kt.elements[9] *= l),
						(Kt.elements[10] *= l),
						e.setFromRotationMatrix(Kt),
						(n.x = i),
						(n.y = a),
						(n.z = o),
						this
					);
				}),
				(e.makePerspective = function (t, e, n, r, i, a) {
					void 0 === a &&
						console.warn(
							'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
						);
					var o = this.elements,
						s = (2 * i) / (e - t),
						c = (2 * i) / (n - r),
						l = (e + t) / (e - t),
						u = (n + r) / (n - r),
						h = -(a + i) / (a - i),
						d = (-2 * a * i) / (a - i);
					return (
						(o[0] = s),
						(o[4] = 0),
						(o[8] = l),
						(o[12] = 0),
						(o[1] = 0),
						(o[5] = c),
						(o[9] = u),
						(o[13] = 0),
						(o[2] = 0),
						(o[6] = 0),
						(o[10] = h),
						(o[14] = d),
						(o[3] = 0),
						(o[7] = 0),
						(o[11] = -1),
						(o[15] = 0),
						this
					);
				}),
				(e.makeOrthographic = function (t, e, n, r, i, a) {
					var o = this.elements,
						s = 1 / (e - t),
						c = 1 / (n - r),
						l = 1 / (a - i),
						u = (e + t) * s,
						h = (n + r) * c,
						d = (a + i) * l;
					return (
						(o[0] = 2 * s),
						(o[4] = 0),
						(o[8] = 0),
						(o[12] = -u),
						(o[1] = 0),
						(o[5] = 2 * c),
						(o[9] = 0),
						(o[13] = -h),
						(o[2] = 0),
						(o[6] = 0),
						(o[10] = -2 * l),
						(o[14] = -d),
						(o[3] = 0),
						(o[7] = 0),
						(o[11] = 0),
						(o[15] = 1),
						this
					);
				}),
				(e.equals = function (t) {
					for (var e = this.elements, n = t.elements, r = 0; r < 16; r++)
						if (e[r] !== n[r]) return !1;
					return !0;
				}),
				(e.fromArray = function (t, e) {
					void 0 === e && (e = 0);
					for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
					return this;
				}),
				(e.toArray = function (t, e) {
					void 0 === t && (t = []), void 0 === e && (e = 0);
					var n = this.elements;
					return (
						(t[e] = n[0]),
						(t[e + 1] = n[1]),
						(t[e + 2] = n[2]),
						(t[e + 3] = n[3]),
						(t[e + 4] = n[4]),
						(t[e + 5] = n[5]),
						(t[e + 6] = n[6]),
						(t[e + 7] = n[7]),
						(t[e + 8] = n[8]),
						(t[e + 9] = n[9]),
						(t[e + 10] = n[10]),
						(t[e + 11] = n[11]),
						(t[e + 12] = n[12]),
						(t[e + 13] = n[13]),
						(t[e + 14] = n[14]),
						(t[e + 15] = n[15]),
						t
					);
				}),
				t
			);
		})(),
		Qt = new wt(),
		Kt = new Jt(),
		$t = new wt(0, 0, 0),
		te = new wt(1, 1, 1),
		ee = new wt(),
		ne = new wt(),
		re = new wt(),
		ie = (function () {
			function t(e, n, r, i) {
				void 0 === e && (e = 0),
					void 0 === n && (n = 0),
					void 0 === r && (r = 0),
					void 0 === i && (i = t.DefaultOrder),
					Object.defineProperty(this, 'isEuler', { value: !0 }),
					(this._x = e),
					(this._y = n),
					(this._z = r),
					(this._order = i);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n, r) {
					return (
						(this._x = t),
						(this._y = e),
						(this._z = n),
						(this._order = r || this._order),
						this._onChangeCallback(),
						this
					);
				}),
				(e.clone = function () {
					return new this.constructor(this._x, this._y, this._z, this._order);
				}),
				(e.copy = function (t) {
					return (
						(this._x = t._x),
						(this._y = t._y),
						(this._z = t._z),
						(this._order = t._order),
						this._onChangeCallback(),
						this
					);
				}),
				(e.setFromRotationMatrix = function (t, e, n) {
					var r = st.clamp,
						i = t.elements,
						a = i[0],
						o = i[4],
						s = i[8],
						c = i[1],
						l = i[5],
						u = i[9],
						h = i[2],
						d = i[6],
						p = i[10];
					switch ((e = e || this._order)) {
						case 'XYZ':
							(this._y = Math.asin(r(s, -1, 1))),
								Math.abs(s) < 0.9999999
									? ((this._x = Math.atan2(-u, p)),
									  (this._z = Math.atan2(-o, a)))
									: ((this._x = Math.atan2(d, l)), (this._z = 0));
							break;
						case 'YXZ':
							(this._x = Math.asin(-r(u, -1, 1))),
								Math.abs(u) < 0.9999999
									? ((this._y = Math.atan2(s, p)), (this._z = Math.atan2(c, l)))
									: ((this._y = Math.atan2(-h, a)), (this._z = 0));
							break;
						case 'ZXY':
							(this._x = Math.asin(r(d, -1, 1))),
								Math.abs(d) < 0.9999999
									? ((this._y = Math.atan2(-h, p)),
									  (this._z = Math.atan2(-o, l)))
									: ((this._y = 0), (this._z = Math.atan2(c, a)));
							break;
						case 'ZYX':
							(this._y = Math.asin(-r(h, -1, 1))),
								Math.abs(h) < 0.9999999
									? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(c, a)))
									: ((this._x = 0), (this._z = Math.atan2(-o, l)));
							break;
						case 'YZX':
							(this._z = Math.asin(r(c, -1, 1))),
								Math.abs(c) < 0.9999999
									? ((this._x = Math.atan2(-u, l)),
									  (this._y = Math.atan2(-h, a)))
									: ((this._x = 0), (this._y = Math.atan2(s, p)));
							break;
						case 'XZY':
							(this._z = Math.asin(-r(o, -1, 1))),
								Math.abs(o) < 0.9999999
									? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(s, a)))
									: ((this._x = Math.atan2(-u, p)), (this._y = 0));
							break;
						default:
							console.warn(
								'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
									e
							);
					}
					return (this._order = e), !1 !== n && this._onChangeCallback(), this;
				}),
				(e.setFromQuaternion = function (t, e, n) {
					return (
						ae.makeRotationFromQuaternion(t),
						this.setFromRotationMatrix(ae, e, n)
					);
				}),
				(e.setFromVector3 = function (t, e) {
					return this.set(t.x, t.y, t.z, e || this._order);
				}),
				(e.reorder = function (t) {
					return oe.setFromEuler(this), this.setFromQuaternion(oe, t);
				}),
				(e.equals = function (t) {
					return (
						t._x === this._x &&
						t._y === this._y &&
						t._z === this._z &&
						t._order === this._order
					);
				}),
				(e.fromArray = function (t) {
					return (
						(this._x = t[0]),
						(this._y = t[1]),
						(this._z = t[2]),
						void 0 !== t[3] && (this._order = t[3]),
						this._onChangeCallback(),
						this
					);
				}),
				(e.toArray = function (t, e) {
					return (
						void 0 === t && (t = []),
						void 0 === e && (e = 0),
						(t[e] = this._x),
						(t[e + 1] = this._y),
						(t[e + 2] = this._z),
						(t[e + 3] = this._order),
						t
					);
				}),
				(e.toVector3 = function (t) {
					return t
						? t.set(this._x, this._y, this._z)
						: new wt(this._x, this._y, this._z);
				}),
				(e._onChange = function (t) {
					return (this._onChangeCallback = t), this;
				}),
				(e._onChangeCallback = function () {}),
				lt(t, [
					{
						key: 'x',
						get: function () {
							return this._x;
						},
						set: function (t) {
							(this._x = t), this._onChangeCallback();
						},
					},
					{
						key: 'y',
						get: function () {
							return this._y;
						},
						set: function (t) {
							(this._y = t), this._onChangeCallback();
						},
					},
					{
						key: 'z',
						get: function () {
							return this._z;
						},
						set: function (t) {
							(this._z = t), this._onChangeCallback();
						},
					},
					{
						key: 'order',
						get: function () {
							return this._order;
						},
						set: function (t) {
							(this._order = t), this._onChangeCallback();
						},
					},
				]),
				t
			);
		})();
	(ie.DefaultOrder = 'XYZ'),
		(ie.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']);
	var ae = new Jt(),
		oe = new bt(),
		se = (function () {
			function t() {
				this.mask = 1;
			}
			var e = t.prototype;
			return (
				(e.set = function (t) {
					this.mask = (1 << t) | 0;
				}),
				(e.enable = function (t) {
					this.mask |= (1 << t) | 0;
				}),
				(e.enableAll = function () {
					this.mask = -1;
				}),
				(e.toggle = function (t) {
					this.mask ^= (1 << t) | 0;
				}),
				(e.disable = function (t) {
					this.mask &= ~((1 << t) | 0);
				}),
				(e.disableAll = function () {
					this.mask = 0;
				}),
				(e.test = function (t) {
					return 0 != (this.mask & t.mask);
				}),
				t
			);
		})(),
		ce = 0,
		le = new wt(),
		ue = new bt(),
		he = new Jt(),
		de = new wt(),
		pe = new wt(),
		fe = new wt(),
		me = new bt(),
		ve = new wt(1, 0, 0),
		ge = new wt(0, 1, 0),
		ye = new wt(0, 0, 1),
		xe = { type: 'added' },
		_e = { type: 'removed' };
	function be() {
		Object.defineProperty(this, 'id', { value: ce++ }),
			(this.uuid = st.generateUUID()),
			(this.name = ''),
			(this.type = 'Object3D'),
			(this.parent = null),
			(this.children = []),
			(this.up = be.DefaultUp.clone());
		var t = new wt(),
			e = new ie(),
			n = new bt(),
			r = new wt(1, 1, 1);
		e._onChange(function () {
			n.setFromEuler(e, !1);
		}),
			n._onChange(function () {
				e.setFromQuaternion(n, void 0, !1);
			}),
			Object.defineProperties(this, {
				position: { configurable: !0, enumerable: !0, value: t },
				rotation: { configurable: !0, enumerable: !0, value: e },
				quaternion: { configurable: !0, enumerable: !0, value: n },
				scale: { configurable: !0, enumerable: !0, value: r },
				modelViewMatrix: { value: new Jt() },
				normalMatrix: { value: new ft() },
			}),
			(this.matrix = new Jt()),
			(this.matrixWorld = new Jt()),
			(this.matrixAutoUpdate = be.DefaultMatrixAutoUpdate),
			(this.matrixWorldNeedsUpdate = !1),
			(this.layers = new se()),
			(this.visible = !0),
			(this.castShadow = !1),
			(this.receiveShadow = !1),
			(this.frustumCulled = !0),
			(this.renderOrder = 0),
			(this.userData = {});
	}
	(be.DefaultUp = new wt(0, 1, 0)),
		(be.DefaultMatrixAutoUpdate = !0),
		(be.prototype = Object.assign(Object.create(rt.prototype), {
			constructor: be,
			isObject3D: !0,
			onBeforeRender: function () {},
			onAfterRender: function () {},
			applyMatrix4: function (t) {
				this.matrixAutoUpdate && this.updateMatrix(),
					this.matrix.premultiply(t),
					this.matrix.decompose(this.position, this.quaternion, this.scale);
			},
			applyQuaternion: function (t) {
				return this.quaternion.premultiply(t), this;
			},
			setRotationFromAxisAngle: function (t, e) {
				this.quaternion.setFromAxisAngle(t, e);
			},
			setRotationFromEuler: function (t) {
				this.quaternion.setFromEuler(t, !0);
			},
			setRotationFromMatrix: function (t) {
				this.quaternion.setFromRotationMatrix(t);
			},
			setRotationFromQuaternion: function (t) {
				this.quaternion.copy(t);
			},
			rotateOnAxis: function (t, e) {
				return ue.setFromAxisAngle(t, e), this.quaternion.multiply(ue), this;
			},
			rotateOnWorldAxis: function (t, e) {
				return ue.setFromAxisAngle(t, e), this.quaternion.premultiply(ue), this;
			},
			rotateX: function (t) {
				return this.rotateOnAxis(ve, t);
			},
			rotateY: function (t) {
				return this.rotateOnAxis(ge, t);
			},
			rotateZ: function (t) {
				return this.rotateOnAxis(ye, t);
			},
			translateOnAxis: function (t, e) {
				return (
					le.copy(t).applyQuaternion(this.quaternion),
					this.position.add(le.multiplyScalar(e)),
					this
				);
			},
			translateX: function (t) {
				return this.translateOnAxis(ve, t);
			},
			translateY: function (t) {
				return this.translateOnAxis(ge, t);
			},
			translateZ: function (t) {
				return this.translateOnAxis(ye, t);
			},
			localToWorld: function (t) {
				return t.applyMatrix4(this.matrixWorld);
			},
			worldToLocal: function (t) {
				return t.applyMatrix4(he.getInverse(this.matrixWorld));
			},
			lookAt: function (t, e, n) {
				t.isVector3 ? de.copy(t) : de.set(t, e, n);
				var r = this.parent;
				this.updateWorldMatrix(!0, !1),
					pe.setFromMatrixPosition(this.matrixWorld),
					this.isCamera || this.isLight
						? he.lookAt(pe, de, this.up)
						: he.lookAt(de, pe, this.up),
					this.quaternion.setFromRotationMatrix(he),
					r &&
						(he.extractRotation(r.matrixWorld),
						ue.setFromRotationMatrix(he),
						this.quaternion.premultiply(ue.inverse()));
			},
			add: function (t) {
				if (arguments.length > 1) {
					for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
					return this;
				}
				return t === this
					? (console.error(
							"THREE.Object3D.add: object can't be added as a child of itself.",
							t
					  ),
					  this)
					: (t && t.isObject3D
							? (null !== t.parent && t.parent.remove(t),
							  (t.parent = this),
							  this.children.push(t),
							  t.dispatchEvent(xe))
							: console.error(
									'THREE.Object3D.add: object not an instance of THREE.Object3D.',
									t
							  ),
					  this);
			},
			remove: function (t) {
				if (arguments.length > 1) {
					for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
					return this;
				}
				var n = this.children.indexOf(t);
				return (
					-1 !== n &&
						((t.parent = null),
						this.children.splice(n, 1),
						t.dispatchEvent(_e)),
					this
				);
			},
			attach: function (t) {
				return (
					this.updateWorldMatrix(!0, !1),
					he.getInverse(this.matrixWorld),
					null !== t.parent &&
						(t.parent.updateWorldMatrix(!0, !1),
						he.multiply(t.parent.matrixWorld)),
					t.applyMatrix4(he),
					t.updateWorldMatrix(!1, !1),
					this.add(t),
					this
				);
			},
			getObjectById: function (t) {
				return this.getObjectByProperty('id', t);
			},
			getObjectByName: function (t) {
				return this.getObjectByProperty('name', t);
			},
			getObjectByProperty: function (t, e) {
				if (this[t] === e) return this;
				for (var n = 0, r = this.children.length; n < r; n++) {
					var i = this.children[n].getObjectByProperty(t, e);
					if (void 0 !== i) return i;
				}
			},
			getWorldPosition: function (t) {
				return (
					void 0 === t &&
						(console.warn(
							'THREE.Object3D: .getWorldPosition() target is now required'
						),
						(t = new wt())),
					this.updateWorldMatrix(!0, !1),
					t.setFromMatrixPosition(this.matrixWorld)
				);
			},
			getWorldQuaternion: function (t) {
				return (
					void 0 === t &&
						(console.warn(
							'THREE.Object3D: .getWorldQuaternion() target is now required'
						),
						(t = new bt())),
					this.updateWorldMatrix(!0, !1),
					this.matrixWorld.decompose(pe, t, fe),
					t
				);
			},
			getWorldScale: function (t) {
				return (
					void 0 === t &&
						(console.warn(
							'THREE.Object3D: .getWorldScale() target is now required'
						),
						(t = new wt())),
					this.updateWorldMatrix(!0, !1),
					this.matrixWorld.decompose(pe, me, t),
					t
				);
			},
			getWorldDirection: function (t) {
				void 0 === t &&
					(console.warn(
						'THREE.Object3D: .getWorldDirection() target is now required'
					),
					(t = new wt())),
					this.updateWorldMatrix(!0, !1);
				var e = this.matrixWorld.elements;
				return t.set(e[8], e[9], e[10]).normalize();
			},
			raycast: function () {},
			traverse: function (t) {
				t(this);
				for (var e = this.children, n = 0, r = e.length; n < r; n++)
					e[n].traverse(t);
			},
			traverseVisible: function (t) {
				if (!1 !== this.visible) {
					t(this);
					for (var e = this.children, n = 0, r = e.length; n < r; n++)
						e[n].traverseVisible(t);
				}
			},
			traverseAncestors: function (t) {
				var e = this.parent;
				null !== e && (t(e), e.traverseAncestors(t));
			},
			updateMatrix: function () {
				this.matrix.compose(this.position, this.quaternion, this.scale),
					(this.matrixWorldNeedsUpdate = !0);
			},
			updateMatrixWorld: function (t) {
				this.matrixAutoUpdate && this.updateMatrix(),
					(this.matrixWorldNeedsUpdate || t) &&
						(null === this.parent
							? this.matrixWorld.copy(this.matrix)
							: this.matrixWorld.multiplyMatrices(
									this.parent.matrixWorld,
									this.matrix
							  ),
						(this.matrixWorldNeedsUpdate = !1),
						(t = !0));
				for (var e = this.children, n = 0, r = e.length; n < r; n++)
					e[n].updateMatrixWorld(t);
			},
			updateWorldMatrix: function (t, e) {
				var n = this.parent;
				if (
					(!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
					this.matrixAutoUpdate && this.updateMatrix(),
					null === this.parent
						? this.matrixWorld.copy(this.matrix)
						: this.matrixWorld.multiplyMatrices(
								this.parent.matrixWorld,
								this.matrix
						  ),
					!0 === e)
				)
					for (var r = this.children, i = 0, a = r.length; i < a; i++)
						r[i].updateWorldMatrix(!1, !0);
			},
			toJSON: function (t) {
				var e = void 0 === t || 'string' == typeof t,
					n = {};
				e &&
					((t = {
						geometries: {},
						materials: {},
						textures: {},
						images: {},
						shapes: {},
					}),
					(n.metadata = {
						version: 4.5,
						type: 'Object',
						generator: 'Object3D.toJSON',
					}));
				var r = {};
				function i(e, n) {
					return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
				}
				if (
					((r.uuid = this.uuid),
					(r.type = this.type),
					'' !== this.name && (r.name = this.name),
					!0 === this.castShadow && (r.castShadow = !0),
					!0 === this.receiveShadow && (r.receiveShadow = !0),
					!1 === this.visible && (r.visible = !1),
					!1 === this.frustumCulled && (r.frustumCulled = !1),
					0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
					'{}' !== JSON.stringify(this.userData) &&
						(r.userData = this.userData),
					(r.layers = this.layers.mask),
					(r.matrix = this.matrix.toArray()),
					!1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
					this.isInstancedMesh &&
						((r.type = 'InstancedMesh'),
						(r.count = this.count),
						(r.instanceMatrix = this.instanceMatrix.toJSON())),
					this.isMesh || this.isLine || this.isPoints)
				) {
					r.geometry = i(t.geometries, this.geometry);
					var a = this.geometry.parameters;
					if (void 0 !== a && void 0 !== a.shapes) {
						var o = a.shapes;
						if (Array.isArray(o))
							for (var s = 0, c = o.length; s < c; s++) {
								var l = o[s];
								i(t.shapes, l);
							}
						else i(t.shapes, o);
					}
				}
				if (void 0 !== this.material)
					if (Array.isArray(this.material)) {
						for (var u = [], h = 0, d = this.material.length; h < d; h++)
							u.push(i(t.materials, this.material[h]));
						r.material = u;
					} else r.material = i(t.materials, this.material);
				if (this.children.length > 0) {
					r.children = [];
					for (var p = 0; p < this.children.length; p++)
						r.children.push(this.children[p].toJSON(t).object);
				}
				if (e) {
					var f = x(t.geometries),
						m = x(t.materials),
						v = x(t.textures),
						g = x(t.images),
						y = x(t.shapes);
					f.length > 0 && (n.geometries = f),
						m.length > 0 && (n.materials = m),
						v.length > 0 && (n.textures = v),
						g.length > 0 && (n.images = g),
						y.length > 0 && (n.shapes = y);
				}
				return (n.object = r), n;
				function x(t) {
					var e = [];
					for (var n in t) {
						var r = t[n];
						delete r.metadata, e.push(r);
					}
					return e;
				}
			},
			clone: function (t) {
				return new this.constructor().copy(this, t);
			},
			copy: function (t, e) {
				if (
					(void 0 === e && (e = !0),
					(this.name = t.name),
					this.up.copy(t.up),
					this.position.copy(t.position),
					(this.rotation.order = t.rotation.order),
					this.quaternion.copy(t.quaternion),
					this.scale.copy(t.scale),
					this.matrix.copy(t.matrix),
					this.matrixWorld.copy(t.matrixWorld),
					(this.matrixAutoUpdate = t.matrixAutoUpdate),
					(this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
					(this.layers.mask = t.layers.mask),
					(this.visible = t.visible),
					(this.castShadow = t.castShadow),
					(this.receiveShadow = t.receiveShadow),
					(this.frustumCulled = t.frustumCulled),
					(this.renderOrder = t.renderOrder),
					(this.userData = JSON.parse(JSON.stringify(t.userData))),
					!0 === e)
				)
					for (var n = 0; n < t.children.length; n++) {
						var r = t.children[n];
						this.add(r.clone());
					}
				return this;
			},
		}));
	var we = new wt(),
		Me = new wt(),
		Se = new ft(),
		Te = (function () {
			function t(t, e) {
				Object.defineProperty(this, 'isPlane', { value: !0 }),
					(this.normal = void 0 !== t ? t : new wt(1, 0, 0)),
					(this.constant = void 0 !== e ? e : 0);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return this.normal.copy(t), (this.constant = e), this;
				}),
				(e.setComponents = function (t, e, n, r) {
					return this.normal.set(t, e, n), (this.constant = r), this;
				}),
				(e.setFromNormalAndCoplanarPoint = function (t, e) {
					return (
						this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
					);
				}),
				(e.setFromCoplanarPoints = function (t, e, n) {
					var r = we.subVectors(n, e).cross(Me.subVectors(t, e)).normalize();
					return this.setFromNormalAndCoplanarPoint(r, t), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return this.normal.copy(t.normal), (this.constant = t.constant), this;
				}),
				(e.normalize = function () {
					var t = 1 / this.normal.length();
					return this.normal.multiplyScalar(t), (this.constant *= t), this;
				}),
				(e.negate = function () {
					return (this.constant *= -1), this.normal.negate(), this;
				}),
				(e.distanceToPoint = function (t) {
					return this.normal.dot(t) + this.constant;
				}),
				(e.distanceToSphere = function (t) {
					return this.distanceToPoint(t.center) - t.radius;
				}),
				(e.projectPoint = function (t, e) {
					return (
						void 0 === e &&
							(console.warn(
								'THREE.Plane: .projectPoint() target is now required'
							),
							(e = new wt())),
						e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
					);
				}),
				(e.intersectLine = function (t, e) {
					void 0 === e &&
						(console.warn(
							'THREE.Plane: .intersectLine() target is now required'
						),
						(e = new wt()));
					var n = t.delta(we),
						r = this.normal.dot(n);
					if (0 === r)
						return 0 === this.distanceToPoint(t.start)
							? e.copy(t.start)
							: void 0;
					var i = -(t.start.dot(this.normal) + this.constant) / r;
					return i < 0 || i > 1
						? void 0
						: e.copy(n).multiplyScalar(i).add(t.start);
				}),
				(e.intersectsLine = function (t) {
					var e = this.distanceToPoint(t.start),
						n = this.distanceToPoint(t.end);
					return (e < 0 && n > 0) || (n < 0 && e > 0);
				}),
				(e.intersectsBox = function (t) {
					return t.intersectsPlane(this);
				}),
				(e.intersectsSphere = function (t) {
					return t.intersectsPlane(this);
				}),
				(e.coplanarPoint = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								'THREE.Plane: .coplanarPoint() target is now required'
							),
							(t = new wt())),
						t.copy(this.normal).multiplyScalar(-this.constant)
					);
				}),
				(e.applyMatrix4 = function (t, e) {
					var n = e || Se.getNormalMatrix(t),
						r = this.coplanarPoint(we).applyMatrix4(t),
						i = this.normal.applyMatrix3(n).normalize();
					return (this.constant = -r.dot(i)), this;
				}),
				(e.translate = function (t) {
					return (this.constant -= t.dot(this.normal)), this;
				}),
				(e.equals = function (t) {
					return t.normal.equals(this.normal) && t.constant === this.constant;
				}),
				t
			);
		})(),
		Ee = new wt(),
		Ae = new wt(),
		Le = new wt(),
		Re = new wt(),
		Ce = new wt(),
		Pe = new wt(),
		Ie = new wt(),
		De = new wt(),
		Ne = new wt(),
		Oe = new wt(),
		Be = (function () {
			function t(t, e, n) {
				(this.a = void 0 !== t ? t : new wt()),
					(this.b = void 0 !== e ? e : new wt()),
					(this.c = void 0 !== n ? n : new wt());
			}
			(t.getNormal = function (t, e, n, r) {
				void 0 === r &&
					(console.warn('THREE.Triangle: .getNormal() target is now required'),
					(r = new wt())),
					r.subVectors(n, e),
					Ee.subVectors(t, e),
					r.cross(Ee);
				var i = r.lengthSq();
				return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
			}),
				(t.getBarycoord = function (t, e, n, r, i) {
					Ee.subVectors(r, e), Ae.subVectors(n, e), Le.subVectors(t, e);
					var a = Ee.dot(Ee),
						o = Ee.dot(Ae),
						s = Ee.dot(Le),
						c = Ae.dot(Ae),
						l = Ae.dot(Le),
						u = a * c - o * o;
					if (
						(void 0 === i &&
							(console.warn(
								'THREE.Triangle: .getBarycoord() target is now required'
							),
							(i = new wt())),
						0 === u)
					)
						return i.set(-2, -1, -1);
					var h = 1 / u,
						d = (c * s - o * l) * h,
						p = (a * l - o * s) * h;
					return i.set(1 - d - p, p, d);
				}),
				(t.containsPoint = function (t, e, n, r) {
					return (
						this.getBarycoord(t, e, n, r, Re),
						Re.x >= 0 && Re.y >= 0 && Re.x + Re.y <= 1
					);
				}),
				(t.getUV = function (t, e, n, r, i, a, o, s) {
					return (
						this.getBarycoord(t, e, n, r, Re),
						s.set(0, 0),
						s.addScaledVector(i, Re.x),
						s.addScaledVector(a, Re.y),
						s.addScaledVector(o, Re.z),
						s
					);
				}),
				(t.isFrontFacing = function (t, e, n, r) {
					return (
						Ee.subVectors(n, e), Ae.subVectors(t, e), Ee.cross(Ae).dot(r) < 0
					);
				});
			var e = t.prototype;
			return (
				(e.set = function (t, e, n) {
					return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
				}),
				(e.setFromPointsAndIndices = function (t, e, n, r) {
					return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
				}),
				(e.getArea = function () {
					return (
						Ee.subVectors(this.c, this.b),
						Ae.subVectors(this.a, this.b),
						0.5 * Ee.cross(Ae).length()
					);
				}),
				(e.getMidpoint = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								'THREE.Triangle: .getMidpoint() target is now required'
							),
							(t = new wt())),
						t
							.addVectors(this.a, this.b)
							.add(this.c)
							.multiplyScalar(1 / 3)
					);
				}),
				(e.getNormal = function (e) {
					return t.getNormal(this.a, this.b, this.c, e);
				}),
				(e.getPlane = function (t) {
					return (
						void 0 === t &&
							(console.warn(
								'THREE.Triangle: .getPlane() target is now required'
							),
							(t = new Te())),
						t.setFromCoplanarPoints(this.a, this.b, this.c)
					);
				}),
				(e.getBarycoord = function (e, n) {
					return t.getBarycoord(e, this.a, this.b, this.c, n);
				}),
				(e.getUV = function (e, n, r, i, a) {
					return t.getUV(e, this.a, this.b, this.c, n, r, i, a);
				}),
				(e.containsPoint = function (e) {
					return t.containsPoint(e, this.a, this.b, this.c);
				}),
				(e.isFrontFacing = function (e) {
					return t.isFrontFacing(this.a, this.b, this.c, e);
				}),
				(e.intersectsBox = function (t) {
					return t.intersectsTriangle(this);
				}),
				(e.closestPointToPoint = function (t, e) {
					void 0 === e &&
						(console.warn(
							'THREE.Triangle: .closestPointToPoint() target is now required'
						),
						(e = new wt()));
					var n,
						r,
						i = this.a,
						a = this.b,
						o = this.c;
					Ce.subVectors(a, i), Pe.subVectors(o, i), De.subVectors(t, i);
					var s = Ce.dot(De),
						c = Pe.dot(De);
					if (s <= 0 && c <= 0) return e.copy(i);
					Ne.subVectors(t, a);
					var l = Ce.dot(Ne),
						u = Pe.dot(Ne);
					if (l >= 0 && u <= l) return e.copy(a);
					var h = s * u - l * c;
					if (h <= 0 && s >= 0 && l <= 0)
						return (n = s / (s - l)), e.copy(i).addScaledVector(Ce, n);
					Oe.subVectors(t, o);
					var d = Ce.dot(Oe),
						p = Pe.dot(Oe);
					if (p >= 0 && d <= p) return e.copy(o);
					var f = d * c - s * p;
					if (f <= 0 && c >= 0 && p <= 0)
						return (r = c / (c - p)), e.copy(i).addScaledVector(Pe, r);
					var m = l * p - d * u;
					if (m <= 0 && u - l >= 0 && d - p >= 0)
						return (
							Ie.subVectors(o, a),
							(r = (u - l) / (u - l + (d - p))),
							e.copy(a).addScaledVector(Ie, r)
						);
					var v = 1 / (m + f + h);
					return (
						(n = f * v),
						(r = h * v),
						e.copy(i).addScaledVector(Ce, n).addScaledVector(Pe, r)
					);
				}),
				(e.equals = function (t) {
					return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
				}),
				t
			);
		})(),
		ze = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074,
		},
		Ge = { h: 0, s: 0, l: 0 },
		Fe = { h: 0, s: 0, l: 0 };
	function Ue(t, e, n) {
		return (
			n < 0 && (n += 1),
			n > 1 && (n -= 1),
			n < 1 / 6
				? t + 6 * (e - t) * n
				: n < 0.5
				? e
				: n < 2 / 3
				? t + 6 * (e - t) * (2 / 3 - n)
				: t
		);
	}
	function He(t) {
		return t < 0.04045
			? 0.0773993808 * t
			: Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
	}
	function ke(t) {
		return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
	}
	var Ve = (function () {
		function t(t, e, n) {
			return (
				Object.defineProperty(this, 'isColor', { value: !0 }),
				void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
			);
		}
		var e = t.prototype;
		return (
			(e.set = function (t) {
				return (
					t && t.isColor
						? this.copy(t)
						: 'number' == typeof t
						? this.setHex(t)
						: 'string' == typeof t && this.setStyle(t),
					this
				);
			}),
			(e.setScalar = function (t) {
				return (this.r = t), (this.g = t), (this.b = t), this;
			}),
			(e.setHex = function (t) {
				return (
					(t = Math.floor(t)),
					(this.r = ((t >> 16) & 255) / 255),
					(this.g = ((t >> 8) & 255) / 255),
					(this.b = (255 & t) / 255),
					this
				);
			}),
			(e.setRGB = function (t, e, n) {
				return (this.r = t), (this.g = e), (this.b = n), this;
			}),
			(e.setHSL = function (t, e, n) {
				if (
					((t = st.euclideanModulo(t, 1)),
					(e = st.clamp(e, 0, 1)),
					(n = st.clamp(n, 0, 1)),
					0 === e)
				)
					this.r = this.g = this.b = n;
				else {
					var r = n <= 0.5 ? n * (1 + e) : n + e - n * e,
						i = 2 * n - r;
					(this.r = Ue(i, r, t + 1 / 3)),
						(this.g = Ue(i, r, t)),
						(this.b = Ue(i, r, t - 1 / 3));
				}
				return this;
			}),
			(e.setStyle = function (t) {
				function e(e) {
					void 0 !== e &&
						parseFloat(e) < 1 &&
						console.warn(
							'THREE.Color: Alpha component of ' + t + ' will be ignored.'
						);
				}
				var n;
				if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
					var r,
						i = n[1],
						a = n[2];
					switch (i) {
						case 'rgb':
						case 'rgba':
							if (
								(r =
									/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
										a
									))
							)
								return (
									(this.r = Math.min(255, parseInt(r[1], 10)) / 255),
									(this.g = Math.min(255, parseInt(r[2], 10)) / 255),
									(this.b = Math.min(255, parseInt(r[3], 10)) / 255),
									e(r[5]),
									this
								);
							if (
								(r =
									/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
										a
									))
							)
								return (
									(this.r = Math.min(100, parseInt(r[1], 10)) / 100),
									(this.g = Math.min(100, parseInt(r[2], 10)) / 100),
									(this.b = Math.min(100, parseInt(r[3], 10)) / 100),
									e(r[5]),
									this
								);
							break;
						case 'hsl':
						case 'hsla':
							if (
								(r =
									/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
										a
									))
							) {
								var o = parseFloat(r[1]) / 360,
									s = parseInt(r[2], 10) / 100,
									c = parseInt(r[3], 10) / 100;
								return e(r[5]), this.setHSL(o, s, c);
							}
					}
				} else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
					var l = n[1],
						u = l.length;
					if (3 === u)
						return (
							(this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
							(this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
							(this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
							this
						);
					if (6 === u)
						return (
							(this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
							(this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
							(this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
							this
						);
				}
				return t && t.length > 0 ? this.setColorName(t) : this;
			}),
			(e.setColorName = function (t) {
				var e = ze[t];
				return (
					void 0 !== e
						? this.setHex(e)
						: console.warn('THREE.Color: Unknown color ' + t),
					this
				);
			}),
			(e.clone = function () {
				return new this.constructor(this.r, this.g, this.b);
			}),
			(e.copy = function (t) {
				return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
			}),
			(e.copyGammaToLinear = function (t, e) {
				return (
					void 0 === e && (e = 2),
					(this.r = Math.pow(t.r, e)),
					(this.g = Math.pow(t.g, e)),
					(this.b = Math.pow(t.b, e)),
					this
				);
			}),
			(e.copyLinearToGamma = function (t, e) {
				void 0 === e && (e = 2);
				var n = e > 0 ? 1 / e : 1;
				return (
					(this.r = Math.pow(t.r, n)),
					(this.g = Math.pow(t.g, n)),
					(this.b = Math.pow(t.b, n)),
					this
				);
			}),
			(e.convertGammaToLinear = function (t) {
				return this.copyGammaToLinear(this, t), this;
			}),
			(e.convertLinearToGamma = function (t) {
				return this.copyLinearToGamma(this, t), this;
			}),
			(e.copySRGBToLinear = function (t) {
				return (this.r = He(t.r)), (this.g = He(t.g)), (this.b = He(t.b)), this;
			}),
			(e.copyLinearToSRGB = function (t) {
				return (this.r = ke(t.r)), (this.g = ke(t.g)), (this.b = ke(t.b)), this;
			}),
			(e.convertSRGBToLinear = function () {
				return this.copySRGBToLinear(this), this;
			}),
			(e.convertLinearToSRGB = function () {
				return this.copyLinearToSRGB(this), this;
			}),
			(e.getHex = function () {
				return (
					((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
				);
			}),
			(e.getHexString = function () {
				return ('000000' + this.getHex().toString(16)).slice(-6);
			}),
			(e.getHSL = function (t) {
				void 0 === t &&
					(console.warn('THREE.Color: .getHSL() target is now required'),
					(t = { h: 0, s: 0, l: 0 }));
				var e,
					n,
					r = this.r,
					i = this.g,
					a = this.b,
					o = Math.max(r, i, a),
					s = Math.min(r, i, a),
					c = (s + o) / 2;
				if (s === o) (e = 0), (n = 0);
				else {
					var l = o - s;
					switch (((n = c <= 0.5 ? l / (o + s) : l / (2 - o - s)), o)) {
						case r:
							e = (i - a) / l + (i < a ? 6 : 0);
							break;
						case i:
							e = (a - r) / l + 2;
							break;
						case a:
							e = (r - i) / l + 4;
					}
					e /= 6;
				}
				return (t.h = e), (t.s = n), (t.l = c), t;
			}),
			(e.getStyle = function () {
				return (
					'rgb(' +
					((255 * this.r) | 0) +
					',' +
					((255 * this.g) | 0) +
					',' +
					((255 * this.b) | 0) +
					')'
				);
			}),
			(e.offsetHSL = function (t, e, n) {
				return (
					this.getHSL(Ge),
					(Ge.h += t),
					(Ge.s += e),
					(Ge.l += n),
					this.setHSL(Ge.h, Ge.s, Ge.l),
					this
				);
			}),
			(e.add = function (t) {
				return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
			}),
			(e.addColors = function (t, e) {
				return (
					(this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
				);
			}),
			(e.addScalar = function (t) {
				return (this.r += t), (this.g += t), (this.b += t), this;
			}),
			(e.sub = function (t) {
				return (
					(this.r = Math.max(0, this.r - t.r)),
					(this.g = Math.max(0, this.g - t.g)),
					(this.b = Math.max(0, this.b - t.b)),
					this
				);
			}),
			(e.multiply = function (t) {
				return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
			}),
			(e.multiplyScalar = function (t) {
				return (this.r *= t), (this.g *= t), (this.b *= t), this;
			}),
			(e.lerp = function (t, e) {
				return (
					(this.r += (t.r - this.r) * e),
					(this.g += (t.g - this.g) * e),
					(this.b += (t.b - this.b) * e),
					this
				);
			}),
			(e.lerpHSL = function (t, e) {
				this.getHSL(Ge), t.getHSL(Fe);
				var n = st.lerp(Ge.h, Fe.h, e),
					r = st.lerp(Ge.s, Fe.s, e),
					i = st.lerp(Ge.l, Fe.l, e);
				return this.setHSL(n, r, i), this;
			}),
			(e.equals = function (t) {
				return t.r === this.r && t.g === this.g && t.b === this.b;
			}),
			(e.fromArray = function (t, e) {
				return (
					void 0 === e && (e = 0),
					(this.r = t[e]),
					(this.g = t[e + 1]),
					(this.b = t[e + 2]),
					this
				);
			}),
			(e.toArray = function (t, e) {
				return (
					void 0 === t && (t = []),
					void 0 === e && (e = 0),
					(t[e] = this.r),
					(t[e + 1] = this.g),
					(t[e + 2] = this.b),
					t
				);
			}),
			(e.fromBufferAttribute = function (t, e) {
				return (
					(this.r = t.getX(e)),
					(this.g = t.getY(e)),
					(this.b = t.getZ(e)),
					!0 === t.normalized &&
						((this.r /= 255), (this.g /= 255), (this.b /= 255)),
					this
				);
			}),
			(e.toJSON = function () {
				return this.getHex();
			}),
			t
		);
	})();
	(Ve.NAMES = ze),
		(Ve.prototype.r = 1),
		(Ve.prototype.g = 1),
		(Ve.prototype.b = 1);
	var We = (function () {
			function t(t, e, n, r, i, a) {
				(this.a = t),
					(this.b = e),
					(this.c = n),
					(this.normal = r && r.isVector3 ? r : new wt()),
					(this.vertexNormals = Array.isArray(r) ? r : []),
					(this.color = i && i.isColor ? i : new Ve()),
					(this.vertexColors = Array.isArray(i) ? i : []),
					(this.materialIndex = void 0 !== a ? a : 0);
			}
			var e = t.prototype;
			return (
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					(this.a = t.a),
						(this.b = t.b),
						(this.c = t.c),
						this.normal.copy(t.normal),
						this.color.copy(t.color),
						(this.materialIndex = t.materialIndex);
					for (var e = 0, n = t.vertexNormals.length; e < n; e++)
						this.vertexNormals[e] = t.vertexNormals[e].clone();
					for (var r = 0, i = t.vertexColors.length; r < i; r++)
						this.vertexColors[r] = t.vertexColors[r].clone();
					return this;
				}),
				t
			);
		})(),
		je = 0;
	function qe() {
		Object.defineProperty(this, 'id', { value: je++ }),
			(this.uuid = st.generateUUID()),
			(this.name = ''),
			(this.type = 'Material'),
			(this.fog = !0),
			(this.blending = 1),
			(this.side = 0),
			(this.flatShading = !1),
			(this.vertexColors = !1),
			(this.opacity = 1),
			(this.transparent = !1),
			(this.blendSrc = 204),
			(this.blendDst = 205),
			(this.blendEquation = e),
			(this.blendSrcAlpha = null),
			(this.blendDstAlpha = null),
			(this.blendEquationAlpha = null),
			(this.depthFunc = 3),
			(this.depthTest = !0),
			(this.depthWrite = !0),
			(this.stencilWriteMask = 255),
			(this.stencilFunc = 519),
			(this.stencilRef = 0),
			(this.stencilFuncMask = 255),
			(this.stencilFail = $),
			(this.stencilZFail = $),
			(this.stencilZPass = $),
			(this.stencilWrite = !1),
			(this.clippingPlanes = null),
			(this.clipIntersection = !1),
			(this.clipShadows = !1),
			(this.shadowSide = null),
			(this.colorWrite = !0),
			(this.precision = null),
			(this.polygonOffset = !1),
			(this.polygonOffsetFactor = 0),
			(this.polygonOffsetUnits = 0),
			(this.dithering = !1),
			(this.alphaTest = 0),
			(this.premultipliedAlpha = !1),
			(this.visible = !0),
			(this.toneMapped = !0),
			(this.userData = {}),
			(this.version = 0);
	}
	function Xe(t) {
		qe.call(this),
			(this.type = 'MeshBasicMaterial'),
			(this.color = new Ve(16777215)),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.specularMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.combine = 0),
			(this.reflectivity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.skinning = !1),
			(this.morphTargets = !1),
			this.setValues(t);
	}
	(qe.prototype = Object.assign(Object.create(rt.prototype), {
		constructor: qe,
		isMaterial: !0,
		onBeforeCompile: function () {},
		customProgramCacheKey: function () {
			return this.onBeforeCompile.toString();
		},
		setValues: function (t) {
			if (void 0 !== t)
				for (var e in t) {
					var n = t[e];
					if (void 0 !== n)
						if ('shading' !== e) {
							var r = this[e];
							void 0 !== r
								? r && r.isColor
									? r.set(n)
									: r && r.isVector3 && n && n.isVector3
									? r.copy(n)
									: (this[e] = n)
								: console.warn(
										'THREE.' +
											this.type +
											": '" +
											e +
											"' is not a property of this material."
								  );
						} else
							console.warn(
								'THREE.' +
									this.type +
									': .shading has been removed. Use the boolean .flatShading instead.'
							),
								(this.flatShading = 1 === n);
					else
						console.warn("THREE.Material: '" + e + "' parameter is undefined.");
				}
		},
		toJSON: function (t) {
			var e = void 0 === t || 'string' == typeof t;
			e && (t = { textures: {}, images: {} });
			var n = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON',
				},
			};
			function r(t) {
				var e = [];
				for (var n in t) {
					var r = t[n];
					delete r.metadata, e.push(r);
				}
				return e;
			}
			if (
				((n.uuid = this.uuid),
				(n.type = this.type),
				'' !== this.name && (n.name = this.name),
				this.color && this.color.isColor && (n.color = this.color.getHex()),
				void 0 !== this.roughness && (n.roughness = this.roughness),
				void 0 !== this.metalness && (n.metalness = this.metalness),
				this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
				this.emissive &&
					this.emissive.isColor &&
					(n.emissive = this.emissive.getHex()),
				this.emissiveIntensity &&
					1 !== this.emissiveIntensity &&
					(n.emissiveIntensity = this.emissiveIntensity),
				this.specular &&
					this.specular.isColor &&
					(n.specular = this.specular.getHex()),
				void 0 !== this.shininess && (n.shininess = this.shininess),
				void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
				void 0 !== this.clearcoatRoughness &&
					(n.clearcoatRoughness = this.clearcoatRoughness),
				this.clearcoatMap &&
					this.clearcoatMap.isTexture &&
					(n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
				this.clearcoatRoughnessMap &&
					this.clearcoatRoughnessMap.isTexture &&
					(n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
				this.clearcoatNormalMap &&
					this.clearcoatNormalMap.isTexture &&
					((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
					(n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
				this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
				this.matcap &&
					this.matcap.isTexture &&
					(n.matcap = this.matcap.toJSON(t).uuid),
				this.alphaMap &&
					this.alphaMap.isTexture &&
					(n.alphaMap = this.alphaMap.toJSON(t).uuid),
				this.lightMap &&
					this.lightMap.isTexture &&
					(n.lightMap = this.lightMap.toJSON(t).uuid),
				this.aoMap &&
					this.aoMap.isTexture &&
					((n.aoMap = this.aoMap.toJSON(t).uuid),
					(n.aoMapIntensity = this.aoMapIntensity)),
				this.bumpMap &&
					this.bumpMap.isTexture &&
					((n.bumpMap = this.bumpMap.toJSON(t).uuid),
					(n.bumpScale = this.bumpScale)),
				this.normalMap &&
					this.normalMap.isTexture &&
					((n.normalMap = this.normalMap.toJSON(t).uuid),
					(n.normalMapType = this.normalMapType),
					(n.normalScale = this.normalScale.toArray())),
				this.displacementMap &&
					this.displacementMap.isTexture &&
					((n.displacementMap = this.displacementMap.toJSON(t).uuid),
					(n.displacementScale = this.displacementScale),
					(n.displacementBias = this.displacementBias)),
				this.roughnessMap &&
					this.roughnessMap.isTexture &&
					(n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
				this.metalnessMap &&
					this.metalnessMap.isTexture &&
					(n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
				this.emissiveMap &&
					this.emissiveMap.isTexture &&
					(n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
				this.specularMap &&
					this.specularMap.isTexture &&
					(n.specularMap = this.specularMap.toJSON(t).uuid),
				this.envMap &&
					this.envMap.isTexture &&
					((n.envMap = this.envMap.toJSON(t).uuid),
					(n.reflectivity = this.reflectivity),
					(n.refractionRatio = this.refractionRatio),
					void 0 !== this.combine && (n.combine = this.combine),
					void 0 !== this.envMapIntensity &&
						(n.envMapIntensity = this.envMapIntensity)),
				this.gradientMap &&
					this.gradientMap.isTexture &&
					(n.gradientMap = this.gradientMap.toJSON(t).uuid),
				void 0 !== this.size && (n.size = this.size),
				void 0 !== this.sizeAttenuation &&
					(n.sizeAttenuation = this.sizeAttenuation),
				1 !== this.blending && (n.blending = this.blending),
				!0 === this.flatShading && (n.flatShading = this.flatShading),
				0 !== this.side && (n.side = this.side),
				this.vertexColors && (n.vertexColors = !0),
				this.opacity < 1 && (n.opacity = this.opacity),
				!0 === this.transparent && (n.transparent = this.transparent),
				(n.depthFunc = this.depthFunc),
				(n.depthTest = this.depthTest),
				(n.depthWrite = this.depthWrite),
				(n.stencilWrite = this.stencilWrite),
				(n.stencilWriteMask = this.stencilWriteMask),
				(n.stencilFunc = this.stencilFunc),
				(n.stencilRef = this.stencilRef),
				(n.stencilFuncMask = this.stencilFuncMask),
				(n.stencilFail = this.stencilFail),
				(n.stencilZFail = this.stencilZFail),
				(n.stencilZPass = this.stencilZPass),
				this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
				!0 === this.polygonOffset && (n.polygonOffset = !0),
				0 !== this.polygonOffsetFactor &&
					(n.polygonOffsetFactor = this.polygonOffsetFactor),
				0 !== this.polygonOffsetUnits &&
					(n.polygonOffsetUnits = this.polygonOffsetUnits),
				this.linewidth &&
					1 !== this.linewidth &&
					(n.linewidth = this.linewidth),
				void 0 !== this.dashSize && (n.dashSize = this.dashSize),
				void 0 !== this.gapSize && (n.gapSize = this.gapSize),
				void 0 !== this.scale && (n.scale = this.scale),
				!0 === this.dithering && (n.dithering = !0),
				this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
				!0 === this.premultipliedAlpha &&
					(n.premultipliedAlpha = this.premultipliedAlpha),
				!0 === this.wireframe && (n.wireframe = this.wireframe),
				this.wireframeLinewidth > 1 &&
					(n.wireframeLinewidth = this.wireframeLinewidth),
				'round' !== this.wireframeLinecap &&
					(n.wireframeLinecap = this.wireframeLinecap),
				'round' !== this.wireframeLinejoin &&
					(n.wireframeLinejoin = this.wireframeLinejoin),
				!0 === this.morphTargets && (n.morphTargets = !0),
				!0 === this.morphNormals && (n.morphNormals = !0),
				!0 === this.skinning && (n.skinning = !0),
				!1 === this.visible && (n.visible = !1),
				!1 === this.toneMapped && (n.toneMapped = !1),
				'{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
				e)
			) {
				var i = r(t.textures),
					a = r(t.images);
				i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a);
			}
			return n;
		},
		clone: function () {
			return new this.constructor().copy(this);
		},
		copy: function (t) {
			(this.name = t.name),
				(this.fog = t.fog),
				(this.blending = t.blending),
				(this.side = t.side),
				(this.flatShading = t.flatShading),
				(this.vertexColors = t.vertexColors),
				(this.opacity = t.opacity),
				(this.transparent = t.transparent),
				(this.blendSrc = t.blendSrc),
				(this.blendDst = t.blendDst),
				(this.blendEquation = t.blendEquation),
				(this.blendSrcAlpha = t.blendSrcAlpha),
				(this.blendDstAlpha = t.blendDstAlpha),
				(this.blendEquationAlpha = t.blendEquationAlpha),
				(this.depthFunc = t.depthFunc),
				(this.depthTest = t.depthTest),
				(this.depthWrite = t.depthWrite),
				(this.stencilWriteMask = t.stencilWriteMask),
				(this.stencilFunc = t.stencilFunc),
				(this.stencilRef = t.stencilRef),
				(this.stencilFuncMask = t.stencilFuncMask),
				(this.stencilFail = t.stencilFail),
				(this.stencilZFail = t.stencilZFail),
				(this.stencilZPass = t.stencilZPass),
				(this.stencilWrite = t.stencilWrite);
			var e = t.clippingPlanes,
				n = null;
			if (null !== e) {
				var r = e.length;
				n = new Array(r);
				for (var i = 0; i !== r; ++i) n[i] = e[i].clone();
			}
			return (
				(this.clippingPlanes = n),
				(this.clipIntersection = t.clipIntersection),
				(this.clipShadows = t.clipShadows),
				(this.shadowSide = t.shadowSide),
				(this.colorWrite = t.colorWrite),
				(this.precision = t.precision),
				(this.polygonOffset = t.polygonOffset),
				(this.polygonOffsetFactor = t.polygonOffsetFactor),
				(this.polygonOffsetUnits = t.polygonOffsetUnits),
				(this.dithering = t.dithering),
				(this.alphaTest = t.alphaTest),
				(this.premultipliedAlpha = t.premultipliedAlpha),
				(this.visible = t.visible),
				(this.toneMapped = t.toneMapped),
				(this.userData = JSON.parse(JSON.stringify(t.userData))),
				this
			);
		},
		dispose: function () {
			this.dispatchEvent({ type: 'dispose' });
		},
	})),
		Object.defineProperty(qe.prototype, 'needsUpdate', {
			set: function (t) {
				!0 === t && this.version++;
			},
		}),
		(Xe.prototype = Object.create(qe.prototype)),
		(Xe.prototype.constructor = Xe),
		(Xe.prototype.isMeshBasicMaterial = !0),
		(Xe.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				(this.map = t.map),
				(this.lightMap = t.lightMap),
				(this.lightMapIntensity = t.lightMapIntensity),
				(this.aoMap = t.aoMap),
				(this.aoMapIntensity = t.aoMapIntensity),
				(this.specularMap = t.specularMap),
				(this.alphaMap = t.alphaMap),
				(this.envMap = t.envMap),
				(this.combine = t.combine),
				(this.reflectivity = t.reflectivity),
				(this.refractionRatio = t.refractionRatio),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.wireframeLinecap = t.wireframeLinecap),
				(this.wireframeLinejoin = t.wireframeLinejoin),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				this
			);
		});
	var Ye = new wt(),
		Ze = new pt();
	function Je(t, e, n) {
		if (Array.isArray(t))
			throw new TypeError(
				'THREE.BufferAttribute: array should be a Typed Array.'
			);
		(this.name = ''),
			(this.array = t),
			(this.itemSize = e),
			(this.count = void 0 !== t ? t.length / e : 0),
			(this.normalized = !0 === n),
			(this.usage = tt),
			(this.updateRange = { offset: 0, count: -1 }),
			(this.version = 0);
	}
	function Qe(t, e, n) {
		Je.call(this, new Int8Array(t), e, n);
	}
	function Ke(t, e, n) {
		Je.call(this, new Uint8Array(t), e, n);
	}
	function $e(t, e, n) {
		Je.call(this, new Uint8ClampedArray(t), e, n);
	}
	function tn(t, e, n) {
		Je.call(this, new Int16Array(t), e, n);
	}
	function en(t, e, n) {
		Je.call(this, new Uint16Array(t), e, n);
	}
	function nn(t, e, n) {
		Je.call(this, new Int32Array(t), e, n);
	}
	function rn(t, e, n) {
		Je.call(this, new Uint32Array(t), e, n);
	}
	function an(t, e, n) {
		Je.call(this, new Float32Array(t), e, n);
	}
	function on(t, e, n) {
		Je.call(this, new Float64Array(t), e, n);
	}
	Object.defineProperty(Je.prototype, 'needsUpdate', {
		set: function (t) {
			!0 === t && this.version++;
		},
	}),
		Object.assign(Je.prototype, {
			isBufferAttribute: !0,
			onUploadCallback: function () {},
			setUsage: function (t) {
				return (this.usage = t), this;
			},
			copy: function (t) {
				return (
					(this.name = t.name),
					(this.array = new t.array.constructor(t.array)),
					(this.itemSize = t.itemSize),
					(this.count = t.count),
					(this.normalized = t.normalized),
					(this.usage = t.usage),
					this
				);
			},
			copyAt: function (t, e, n) {
				(t *= this.itemSize), (n *= e.itemSize);
				for (var r = 0, i = this.itemSize; r < i; r++)
					this.array[t + r] = e.array[n + r];
				return this;
			},
			copyArray: function (t) {
				return this.array.set(t), this;
			},
			copyColorsArray: function (t) {
				for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
					var a = t[r];
					void 0 === a &&
						(console.warn(
							'THREE.BufferAttribute.copyColorsArray(): color is undefined',
							r
						),
						(a = new Ve())),
						(e[n++] = a.r),
						(e[n++] = a.g),
						(e[n++] = a.b);
				}
				return this;
			},
			copyVector2sArray: function (t) {
				for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
					var a = t[r];
					void 0 === a &&
						(console.warn(
							'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
							r
						),
						(a = new pt())),
						(e[n++] = a.x),
						(e[n++] = a.y);
				}
				return this;
			},
			copyVector3sArray: function (t) {
				for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
					var a = t[r];
					void 0 === a &&
						(console.warn(
							'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
							r
						),
						(a = new wt())),
						(e[n++] = a.x),
						(e[n++] = a.y),
						(e[n++] = a.z);
				}
				return this;
			},
			copyVector4sArray: function (t) {
				for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
					var a = t[r];
					void 0 === a &&
						(console.warn(
							'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
							r
						),
						(a = new yt())),
						(e[n++] = a.x),
						(e[n++] = a.y),
						(e[n++] = a.z),
						(e[n++] = a.w);
				}
				return this;
			},
			applyMatrix3: function (t) {
				if (2 === this.itemSize)
					for (var e = 0, n = this.count; e < n; e++)
						Ze.fromBufferAttribute(this, e),
							Ze.applyMatrix3(t),
							this.setXY(e, Ze.x, Ze.y);
				else if (3 === this.itemSize)
					for (var r = 0, i = this.count; r < i; r++)
						Ye.fromBufferAttribute(this, r),
							Ye.applyMatrix3(t),
							this.setXYZ(r, Ye.x, Ye.y, Ye.z);
				return this;
			},
			applyMatrix4: function (t) {
				for (var e = 0, n = this.count; e < n; e++)
					(Ye.x = this.getX(e)),
						(Ye.y = this.getY(e)),
						(Ye.z = this.getZ(e)),
						Ye.applyMatrix4(t),
						this.setXYZ(e, Ye.x, Ye.y, Ye.z);
				return this;
			},
			applyNormalMatrix: function (t) {
				for (var e = 0, n = this.count; e < n; e++)
					(Ye.x = this.getX(e)),
						(Ye.y = this.getY(e)),
						(Ye.z = this.getZ(e)),
						Ye.applyNormalMatrix(t),
						this.setXYZ(e, Ye.x, Ye.y, Ye.z);
				return this;
			},
			transformDirection: function (t) {
				for (var e = 0, n = this.count; e < n; e++)
					(Ye.x = this.getX(e)),
						(Ye.y = this.getY(e)),
						(Ye.z = this.getZ(e)),
						Ye.transformDirection(t),
						this.setXYZ(e, Ye.x, Ye.y, Ye.z);
				return this;
			},
			set: function (t, e) {
				return void 0 === e && (e = 0), this.array.set(t, e), this;
			},
			getX: function (t) {
				return this.array[t * this.itemSize];
			},
			setX: function (t, e) {
				return (this.array[t * this.itemSize] = e), this;
			},
			getY: function (t) {
				return this.array[t * this.itemSize + 1];
			},
			setY: function (t, e) {
				return (this.array[t * this.itemSize + 1] = e), this;
			},
			getZ: function (t) {
				return this.array[t * this.itemSize + 2];
			},
			setZ: function (t, e) {
				return (this.array[t * this.itemSize + 2] = e), this;
			},
			getW: function (t) {
				return this.array[t * this.itemSize + 3];
			},
			setW: function (t, e) {
				return (this.array[t * this.itemSize + 3] = e), this;
			},
			setXY: function (t, e, n) {
				return (
					(t *= this.itemSize),
					(this.array[t + 0] = e),
					(this.array[t + 1] = n),
					this
				);
			},
			setXYZ: function (t, e, n, r) {
				return (
					(t *= this.itemSize),
					(this.array[t + 0] = e),
					(this.array[t + 1] = n),
					(this.array[t + 2] = r),
					this
				);
			},
			setXYZW: function (t, e, n, r, i) {
				return (
					(t *= this.itemSize),
					(this.array[t + 0] = e),
					(this.array[t + 1] = n),
					(this.array[t + 2] = r),
					(this.array[t + 3] = i),
					this
				);
			},
			onUpload: function (t) {
				return (this.onUploadCallback = t), this;
			},
			clone: function () {
				return new this.constructor(this.array, this.itemSize).copy(this);
			},
			toJSON: function () {
				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: Array.prototype.slice.call(this.array),
					normalized: this.normalized,
				};
			},
		}),
		(Qe.prototype = Object.create(Je.prototype)),
		(Qe.prototype.constructor = Qe),
		(Ke.prototype = Object.create(Je.prototype)),
		(Ke.prototype.constructor = Ke),
		($e.prototype = Object.create(Je.prototype)),
		($e.prototype.constructor = $e),
		(tn.prototype = Object.create(Je.prototype)),
		(tn.prototype.constructor = tn),
		(en.prototype = Object.create(Je.prototype)),
		(en.prototype.constructor = en),
		(nn.prototype = Object.create(Je.prototype)),
		(nn.prototype.constructor = nn),
		(rn.prototype = Object.create(Je.prototype)),
		(rn.prototype.constructor = rn),
		(an.prototype = Object.create(Je.prototype)),
		(an.prototype.constructor = an),
		(on.prototype = Object.create(Je.prototype)),
		(on.prototype.constructor = on);
	var sn = (function () {
		function t() {
			(this.vertices = []),
				(this.normals = []),
				(this.colors = []),
				(this.uvs = []),
				(this.uvs2 = []),
				(this.groups = []),
				(this.morphTargets = {}),
				(this.skinWeights = []),
				(this.skinIndices = []),
				(this.boundingBox = null),
				(this.boundingSphere = null),
				(this.verticesNeedUpdate = !1),
				(this.normalsNeedUpdate = !1),
				(this.colorsNeedUpdate = !1),
				(this.uvsNeedUpdate = !1),
				(this.groupsNeedUpdate = !1);
		}
		var e = t.prototype;
		return (
			(e.computeGroups = function (t) {
				var e,
					n,
					r = [],
					i = void 0,
					a = t.faces;
				for (n = 0; n < a.length; n++) {
					var o = a[n];
					o.materialIndex !== i &&
						((i = o.materialIndex),
						void 0 !== e && ((e.count = 3 * n - e.start), r.push(e)),
						(e = { start: 3 * n, materialIndex: i }));
				}
				void 0 !== e && ((e.count = 3 * n - e.start), r.push(e)),
					(this.groups = r);
			}),
			(e.fromGeometry = function (t) {
				var e,
					n = t.faces,
					r = t.vertices,
					i = t.faceVertexUvs,
					a = i[0] && i[0].length > 0,
					o = i[1] && i[1].length > 0,
					s = t.morphTargets,
					c = s.length;
				if (c > 0) {
					e = [];
					for (var l = 0; l < c; l++) e[l] = { name: s[l].name, data: [] };
					this.morphTargets.position = e;
				}
				var u,
					h = t.morphNormals,
					d = h.length;
				if (d > 0) {
					u = [];
					for (var p = 0; p < d; p++) u[p] = { name: h[p].name, data: [] };
					this.morphTargets.normal = u;
				}
				var f = t.skinIndices,
					m = t.skinWeights,
					v = f.length === r.length,
					g = m.length === r.length;
				r.length > 0 &&
					0 === n.length &&
					console.error(
						'THREE.DirectGeometry: Faceless geometries are not supported.'
					);
				for (var y = 0; y < n.length; y++) {
					var x = n[y];
					this.vertices.push(r[x.a], r[x.b], r[x.c]);
					var _ = x.vertexNormals;
					if (3 === _.length) this.normals.push(_[0], _[1], _[2]);
					else {
						var b = x.normal;
						this.normals.push(b, b, b);
					}
					var w = x.vertexColors;
					if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
					else {
						var M = x.color;
						this.colors.push(M, M, M);
					}
					if (!0 === a) {
						var S = i[0][y];
						void 0 !== S
							? this.uvs.push(S[0], S[1], S[2])
							: (console.warn(
									'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',
									y
							  ),
							  this.uvs.push(new pt(), new pt(), new pt()));
					}
					if (!0 === o) {
						var T = i[1][y];
						void 0 !== T
							? this.uvs2.push(T[0], T[1], T[2])
							: (console.warn(
									'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',
									y
							  ),
							  this.uvs2.push(new pt(), new pt(), new pt()));
					}
					for (var E = 0; E < c; E++) {
						var A = s[E].vertices;
						e[E].data.push(A[x.a], A[x.b], A[x.c]);
					}
					for (var L = 0; L < d; L++) {
						var R = h[L].vertexNormals[y];
						u[L].data.push(R.a, R.b, R.c);
					}
					v && this.skinIndices.push(f[x.a], f[x.b], f[x.c]),
						g && this.skinWeights.push(m[x.a], m[x.b], m[x.c]);
				}
				return (
					this.computeGroups(t),
					(this.verticesNeedUpdate = t.verticesNeedUpdate),
					(this.normalsNeedUpdate = t.normalsNeedUpdate),
					(this.colorsNeedUpdate = t.colorsNeedUpdate),
					(this.uvsNeedUpdate = t.uvsNeedUpdate),
					(this.groupsNeedUpdate = t.groupsNeedUpdate),
					null !== t.boundingSphere &&
						(this.boundingSphere = t.boundingSphere.clone()),
					null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
					this
				);
			}),
			t
		);
	})();
	function cn(t) {
		if (0 === t.length) return -1 / 0;
		for (var e = t[0], n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
		return e;
	}
	var ln = 1,
		un = new Jt(),
		hn = new be(),
		dn = new wt(),
		pn = new Tt(),
		fn = new Tt(),
		mn = new wt();
	function vn() {
		Object.defineProperty(this, 'id', { value: (ln += 2) }),
			(this.uuid = st.generateUUID()),
			(this.name = ''),
			(this.type = 'BufferGeometry'),
			(this.index = null),
			(this.attributes = {}),
			(this.morphAttributes = {}),
			(this.morphTargetsRelative = !1),
			(this.groups = []),
			(this.boundingBox = null),
			(this.boundingSphere = null),
			(this.drawRange = { start: 0, count: 1 / 0 }),
			(this.userData = {});
	}
	vn.prototype = Object.assign(Object.create(rt.prototype), {
		constructor: vn,
		isBufferGeometry: !0,
		getIndex: function () {
			return this.index;
		},
		setIndex: function (t) {
			return (
				Array.isArray(t)
					? (this.index = new (cn(t) > 65535 ? rn : en)(t, 1))
					: (this.index = t),
				this
			);
		},
		getAttribute: function (t) {
			return this.attributes[t];
		},
		setAttribute: function (t, e) {
			return (this.attributes[t] = e), this;
		},
		deleteAttribute: function (t) {
			return delete this.attributes[t], this;
		},
		addGroup: function (t, e, n) {
			this.groups.push({
				start: t,
				count: e,
				materialIndex: void 0 !== n ? n : 0,
			});
		},
		clearGroups: function () {
			this.groups = [];
		},
		setDrawRange: function (t, e) {
			(this.drawRange.start = t), (this.drawRange.count = e);
		},
		applyMatrix4: function (t) {
			var e = this.attributes.position;
			void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
			var n = this.attributes.normal;
			if (void 0 !== n) {
				var r = new ft().getNormalMatrix(t);
				n.applyNormalMatrix(r), (n.needsUpdate = !0);
			}
			var i = this.attributes.tangent;
			return (
				void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
				null !== this.boundingBox && this.computeBoundingBox(),
				null !== this.boundingSphere && this.computeBoundingSphere(),
				this
			);
		},
		rotateX: function (t) {
			return un.makeRotationX(t), this.applyMatrix4(un), this;
		},
		rotateY: function (t) {
			return un.makeRotationY(t), this.applyMatrix4(un), this;
		},
		rotateZ: function (t) {
			return un.makeRotationZ(t), this.applyMatrix4(un), this;
		},
		translate: function (t, e, n) {
			return un.makeTranslation(t, e, n), this.applyMatrix4(un), this;
		},
		scale: function (t, e, n) {
			return un.makeScale(t, e, n), this.applyMatrix4(un), this;
		},
		lookAt: function (t) {
			return (
				hn.lookAt(t), hn.updateMatrix(), this.applyMatrix4(hn.matrix), this
			);
		},
		center: function () {
			return (
				this.computeBoundingBox(),
				this.boundingBox.getCenter(dn).negate(),
				this.translate(dn.x, dn.y, dn.z),
				this
			);
		},
		setFromObject: function (t) {
			var e = t.geometry;
			if (t.isPoints || t.isLine) {
				var n = new an(3 * e.vertices.length, 3),
					r = new an(3 * e.colors.length, 3);
				if (
					(this.setAttribute('position', n.copyVector3sArray(e.vertices)),
					this.setAttribute('color', r.copyColorsArray(e.colors)),
					e.lineDistances && e.lineDistances.length === e.vertices.length)
				) {
					var i = new an(e.lineDistances.length, 1);
					this.setAttribute('lineDistance', i.copyArray(e.lineDistances));
				}
				null !== e.boundingSphere &&
					(this.boundingSphere = e.boundingSphere.clone()),
					null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone());
			} else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
			return this;
		},
		setFromPoints: function (t) {
			for (var e = [], n = 0, r = t.length; n < r; n++) {
				var i = t[n];
				e.push(i.x, i.y, i.z || 0);
			}
			return this.setAttribute('position', new an(e, 3)), this;
		},
		updateFromObject: function (t) {
			var e = t.geometry;
			if (t.isMesh) {
				var n = e.__directGeometry;
				if (
					(!0 === e.elementsNeedUpdate &&
						((n = void 0), (e.elementsNeedUpdate = !1)),
					void 0 === n)
				)
					return this.fromGeometry(e);
				(n.verticesNeedUpdate = e.verticesNeedUpdate),
					(n.normalsNeedUpdate = e.normalsNeedUpdate),
					(n.colorsNeedUpdate = e.colorsNeedUpdate),
					(n.uvsNeedUpdate = e.uvsNeedUpdate),
					(n.groupsNeedUpdate = e.groupsNeedUpdate),
					(e.verticesNeedUpdate = !1),
					(e.normalsNeedUpdate = !1),
					(e.colorsNeedUpdate = !1),
					(e.uvsNeedUpdate = !1),
					(e.groupsNeedUpdate = !1),
					(e = n);
			}
			if (!0 === e.verticesNeedUpdate) {
				var r = this.attributes.position;
				void 0 !== r && (r.copyVector3sArray(e.vertices), (r.needsUpdate = !0)),
					(e.verticesNeedUpdate = !1);
			}
			if (!0 === e.normalsNeedUpdate) {
				var i = this.attributes.normal;
				void 0 !== i && (i.copyVector3sArray(e.normals), (i.needsUpdate = !0)),
					(e.normalsNeedUpdate = !1);
			}
			if (!0 === e.colorsNeedUpdate) {
				var a = this.attributes.color;
				void 0 !== a && (a.copyColorsArray(e.colors), (a.needsUpdate = !0)),
					(e.colorsNeedUpdate = !1);
			}
			if (e.uvsNeedUpdate) {
				var o = this.attributes.uv;
				void 0 !== o && (o.copyVector2sArray(e.uvs), (o.needsUpdate = !0)),
					(e.uvsNeedUpdate = !1);
			}
			if (e.lineDistancesNeedUpdate) {
				var s = this.attributes.lineDistance;
				void 0 !== s && (s.copyArray(e.lineDistances), (s.needsUpdate = !0)),
					(e.lineDistancesNeedUpdate = !1);
			}
			return (
				e.groupsNeedUpdate &&
					(e.computeGroups(t.geometry),
					(this.groups = e.groups),
					(e.groupsNeedUpdate = !1)),
				this
			);
		},
		fromGeometry: function (t) {
			return (
				(t.__directGeometry = new sn().fromGeometry(t)),
				this.fromDirectGeometry(t.__directGeometry)
			);
		},
		fromDirectGeometry: function (t) {
			var e = new Float32Array(3 * t.vertices.length);
			if (
				(this.setAttribute(
					'position',
					new Je(e, 3).copyVector3sArray(t.vertices)
				),
				t.normals.length > 0)
			) {
				var n = new Float32Array(3 * t.normals.length);
				this.setAttribute('normal', new Je(n, 3).copyVector3sArray(t.normals));
			}
			if (t.colors.length > 0) {
				var r = new Float32Array(3 * t.colors.length);
				this.setAttribute('color', new Je(r, 3).copyColorsArray(t.colors));
			}
			if (t.uvs.length > 0) {
				var i = new Float32Array(2 * t.uvs.length);
				this.setAttribute('uv', new Je(i, 2).copyVector2sArray(t.uvs));
			}
			if (t.uvs2.length > 0) {
				var a = new Float32Array(2 * t.uvs2.length);
				this.setAttribute('uv2', new Je(a, 2).copyVector2sArray(t.uvs2));
			}
			for (var o in ((this.groups = t.groups), t.morphTargets)) {
				for (
					var s = [], c = t.morphTargets[o], l = 0, u = c.length;
					l < u;
					l++
				) {
					var h = c[l],
						d = new an(3 * h.data.length, 3);
					(d.name = h.name), s.push(d.copyVector3sArray(h.data));
				}
				this.morphAttributes[o] = s;
			}
			if (t.skinIndices.length > 0) {
				var p = new an(4 * t.skinIndices.length, 4);
				this.setAttribute('skinIndex', p.copyVector4sArray(t.skinIndices));
			}
			if (t.skinWeights.length > 0) {
				var f = new an(4 * t.skinWeights.length, 4);
				this.setAttribute('skinWeight', f.copyVector4sArray(t.skinWeights));
			}
			return (
				null !== t.boundingSphere &&
					(this.boundingSphere = t.boundingSphere.clone()),
				null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
				this
			);
		},
		computeBoundingBox: function () {
			null === this.boundingBox && (this.boundingBox = new Tt());
			var t = this.attributes.position,
				e = this.morphAttributes.position;
			if (t && t.isGLBufferAttribute)
				return (
					console.error(
						'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
						this
					),
					void this.boundingBox.set(
						new wt(-1 / 0, -1 / 0, -1 / 0),
						new wt(1 / 0, 1 / 0, 1 / 0)
					)
				);
			if (void 0 !== t) {
				if ((this.boundingBox.setFromBufferAttribute(t), e))
					for (var n = 0, r = e.length; n < r; n++) {
						var i = e[n];
						pn.setFromBufferAttribute(i),
							this.morphTargetsRelative
								? (mn.addVectors(this.boundingBox.min, pn.min),
								  this.boundingBox.expandByPoint(mn),
								  mn.addVectors(this.boundingBox.max, pn.max),
								  this.boundingBox.expandByPoint(mn))
								: (this.boundingBox.expandByPoint(pn.min),
								  this.boundingBox.expandByPoint(pn.max));
					}
			} else this.boundingBox.makeEmpty();
			(isNaN(this.boundingBox.min.x) ||
				isNaN(this.boundingBox.min.y) ||
				isNaN(this.boundingBox.min.z)) &&
				console.error(
					'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
					this
				);
		},
		computeBoundingSphere: function () {
			null === this.boundingSphere && (this.boundingSphere = new Ht());
			var t = this.attributes.position,
				e = this.morphAttributes.position;
			if (t && t.isGLBufferAttribute)
				return (
					console.error(
						'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
						this
					),
					void this.boundingSphere.set(new wt(), 1 / 0)
				);
			if (t) {
				var n = this.boundingSphere.center;
				if ((pn.setFromBufferAttribute(t), e))
					for (var r = 0, i = e.length; r < i; r++) {
						var a = e[r];
						fn.setFromBufferAttribute(a),
							this.morphTargetsRelative
								? (mn.addVectors(pn.min, fn.min),
								  pn.expandByPoint(mn),
								  mn.addVectors(pn.max, fn.max),
								  pn.expandByPoint(mn))
								: (pn.expandByPoint(fn.min), pn.expandByPoint(fn.max));
					}
				pn.getCenter(n);
				for (var o = 0, s = 0, c = t.count; s < c; s++)
					mn.fromBufferAttribute(t, s),
						(o = Math.max(o, n.distanceToSquared(mn)));
				if (e)
					for (var l = 0, u = e.length; l < u; l++)
						for (
							var h = e[l], d = this.morphTargetsRelative, p = 0, f = h.count;
							p < f;
							p++
						)
							mn.fromBufferAttribute(h, p),
								d && (dn.fromBufferAttribute(t, p), mn.add(dn)),
								(o = Math.max(o, n.distanceToSquared(mn)));
				(this.boundingSphere.radius = Math.sqrt(o)),
					isNaN(this.boundingSphere.radius) &&
						console.error(
							'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
							this
						);
			}
		},
		computeFaceNormals: function () {},
		computeVertexNormals: function () {
			var t = this.index,
				e = this.getAttribute('position');
			if (void 0 !== e) {
				var n = this.getAttribute('normal');
				if (void 0 === n)
					(n = new Je(new Float32Array(3 * e.count), 3)),
						this.setAttribute('normal', n);
				else for (var r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
				var a = new wt(),
					o = new wt(),
					s = new wt(),
					c = new wt(),
					l = new wt(),
					u = new wt(),
					h = new wt(),
					d = new wt();
				if (t)
					for (var p = 0, f = t.count; p < f; p += 3) {
						var m = t.getX(p + 0),
							v = t.getX(p + 1),
							g = t.getX(p + 2);
						a.fromBufferAttribute(e, m),
							o.fromBufferAttribute(e, v),
							s.fromBufferAttribute(e, g),
							h.subVectors(s, o),
							d.subVectors(a, o),
							h.cross(d),
							c.fromBufferAttribute(n, m),
							l.fromBufferAttribute(n, v),
							u.fromBufferAttribute(n, g),
							c.add(h),
							l.add(h),
							u.add(h),
							n.setXYZ(m, c.x, c.y, c.z),
							n.setXYZ(v, l.x, l.y, l.z),
							n.setXYZ(g, u.x, u.y, u.z);
					}
				else
					for (var y = 0, x = e.count; y < x; y += 3)
						a.fromBufferAttribute(e, y + 0),
							o.fromBufferAttribute(e, y + 1),
							s.fromBufferAttribute(e, y + 2),
							h.subVectors(s, o),
							d.subVectors(a, o),
							h.cross(d),
							n.setXYZ(y + 0, h.x, h.y, h.z),
							n.setXYZ(y + 1, h.x, h.y, h.z),
							n.setXYZ(y + 2, h.x, h.y, h.z);
				this.normalizeNormals(), (n.needsUpdate = !0);
			}
		},
		merge: function (t, e) {
			if (t && t.isBufferGeometry) {
				void 0 === e &&
					((e = 0),
					console.warn(
						'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
					));
				var n = this.attributes;
				for (var r in n)
					if (void 0 !== t.attributes[r])
						for (
							var i = n[r].array,
								a = t.attributes[r],
								o = a.array,
								s = a.itemSize * e,
								c = Math.min(o.length, i.length - s),
								l = 0,
								u = s;
							l < c;
							l++, u++
						)
							i[u] = o[l];
				return this;
			}
			console.error(
				'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
				t
			);
		},
		normalizeNormals: function () {
			for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)
				mn.fromBufferAttribute(t, e),
					mn.normalize(),
					t.setXYZ(e, mn.x, mn.y, mn.z);
		},
		toNonIndexed: function () {
			function t(t, e) {
				for (
					var n = t.array,
						r = t.itemSize,
						i = t.normalized,
						a = new n.constructor(e.length * r),
						o = 0,
						s = 0,
						c = 0,
						l = e.length;
					c < l;
					c++
				) {
					o = e[c] * r;
					for (var u = 0; u < r; u++) a[s++] = n[o++];
				}
				return new Je(a, r, i);
			}
			if (null === this.index)
				return (
					console.warn(
						'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.'
					),
					this
				);
			var e = new vn(),
				n = this.index.array,
				r = this.attributes;
			for (var i in r) {
				var a = t(r[i], n);
				e.setAttribute(i, a);
			}
			var o = this.morphAttributes;
			for (var s in o) {
				for (var c = [], l = o[s], u = 0, h = l.length; u < h; u++) {
					var d = t(l[u], n);
					c.push(d);
				}
				e.morphAttributes[s] = c;
			}
			e.morphTargetsRelative = this.morphTargetsRelative;
			for (var p = this.groups, f = 0, m = p.length; f < m; f++) {
				var v = p[f];
				e.addGroup(v.start, v.count, v.materialIndex);
			}
			return e;
		},
		toJSON: function () {
			var t = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON',
				},
			};
			if (
				((t.uuid = this.uuid),
				(t.type = this.type),
				'' !== this.name && (t.name = this.name),
				Object.keys(this.userData).length > 0 && (t.userData = this.userData),
				void 0 !== this.parameters)
			) {
				var e = this.parameters;
				for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
				return t;
			}
			t.data = { attributes: {} };
			var r = this.index;
			null !== r &&
				(t.data.index = {
					type: r.array.constructor.name,
					array: Array.prototype.slice.call(r.array),
				});
			var i = this.attributes;
			for (var a in i) {
				var o = i[a],
					s = o.toJSON(t.data);
				'' !== o.name && (s.name = o.name), (t.data.attributes[a] = s);
			}
			var c = {},
				l = !1;
			for (var u in this.morphAttributes) {
				for (
					var h = this.morphAttributes[u], d = [], p = 0, f = h.length;
					p < f;
					p++
				) {
					var m = h[p],
						v = m.toJSON(t.data);
					'' !== m.name && (v.name = m.name), d.push(v);
				}
				d.length > 0 && ((c[u] = d), (l = !0));
			}
			l &&
				((t.data.morphAttributes = c),
				(t.data.morphTargetsRelative = this.morphTargetsRelative));
			var g = this.groups;
			g.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(g)));
			var y = this.boundingSphere;
			return (
				null !== y &&
					(t.data.boundingSphere = {
						center: y.center.toArray(),
						radius: y.radius,
					}),
				t
			);
		},
		clone: function () {
			return new vn().copy(this);
		},
		copy: function (t) {
			(this.index = null),
				(this.attributes = {}),
				(this.morphAttributes = {}),
				(this.groups = []),
				(this.boundingBox = null),
				(this.boundingSphere = null);
			var e = {};
			this.name = t.name;
			var n = t.index;
			null !== n && this.setIndex(n.clone(e));
			var r = t.attributes;
			for (var i in r) {
				var a = r[i];
				this.setAttribute(i, a.clone(e));
			}
			var o = t.morphAttributes;
			for (var s in o) {
				for (var c = [], l = o[s], u = 0, h = l.length; u < h; u++)
					c.push(l[u].clone(e));
				this.morphAttributes[s] = c;
			}
			this.morphTargetsRelative = t.morphTargetsRelative;
			for (var d = t.groups, p = 0, f = d.length; p < f; p++) {
				var m = d[p];
				this.addGroup(m.start, m.count, m.materialIndex);
			}
			var v = t.boundingBox;
			null !== v && (this.boundingBox = v.clone());
			var g = t.boundingSphere;
			return (
				null !== g && (this.boundingSphere = g.clone()),
				(this.drawRange.start = t.drawRange.start),
				(this.drawRange.count = t.drawRange.count),
				(this.userData = t.userData),
				this
			);
		},
		dispose: function () {
			this.dispatchEvent({ type: 'dispose' });
		},
	});
	var gn = new Jt(),
		yn = new Zt(),
		xn = new Ht(),
		_n = new wt(),
		bn = new wt(),
		wn = new wt(),
		Mn = new wt(),
		Sn = new wt(),
		Tn = new wt(),
		En = new wt(),
		An = new wt(),
		Ln = new wt(),
		Rn = new pt(),
		Cn = new pt(),
		Pn = new pt(),
		In = new wt(),
		Dn = new wt();
	function Nn(t, e) {
		be.call(this),
			(this.type = 'Mesh'),
			(this.geometry = void 0 !== t ? t : new vn()),
			(this.material = void 0 !== e ? e : new Xe()),
			this.updateMorphTargets();
	}
	function On(t, e, n, r, i, a, o, s) {
		if (
			null ===
			(1 === e.side
				? r.intersectTriangle(o, a, i, !0, s)
				: r.intersectTriangle(i, a, o, 2 !== e.side, s))
		)
			return null;
		Dn.copy(s), Dn.applyMatrix4(t.matrixWorld);
		var c = n.ray.origin.distanceTo(Dn);
		return c < n.near || c > n.far
			? null
			: { distance: c, point: Dn.clone(), object: t };
	}
	function Bn(t, e, n, r, i, a, o, s, c, l, u, h) {
		_n.fromBufferAttribute(i, l),
			bn.fromBufferAttribute(i, u),
			wn.fromBufferAttribute(i, h);
		var d = t.morphTargetInfluences;
		if (e.morphTargets && a && d) {
			En.set(0, 0, 0), An.set(0, 0, 0), Ln.set(0, 0, 0);
			for (var p = 0, f = a.length; p < f; p++) {
				var m = d[p],
					v = a[p];
				0 !== m &&
					(Mn.fromBufferAttribute(v, l),
					Sn.fromBufferAttribute(v, u),
					Tn.fromBufferAttribute(v, h),
					o
						? (En.addScaledVector(Mn, m),
						  An.addScaledVector(Sn, m),
						  Ln.addScaledVector(Tn, m))
						: (En.addScaledVector(Mn.sub(_n), m),
						  An.addScaledVector(Sn.sub(bn), m),
						  Ln.addScaledVector(Tn.sub(wn), m)));
			}
			_n.add(En), bn.add(An), wn.add(Ln);
		}
		t.isSkinnedMesh &&
			(t.boneTransform(l, _n), t.boneTransform(u, bn), t.boneTransform(h, wn));
		var g = On(t, e, n, r, _n, bn, wn, In);
		if (g) {
			s &&
				(Rn.fromBufferAttribute(s, l),
				Cn.fromBufferAttribute(s, u),
				Pn.fromBufferAttribute(s, h),
				(g.uv = Be.getUV(In, _n, bn, wn, Rn, Cn, Pn, new pt()))),
				c &&
					(Rn.fromBufferAttribute(c, l),
					Cn.fromBufferAttribute(c, u),
					Pn.fromBufferAttribute(c, h),
					(g.uv2 = Be.getUV(In, _n, bn, wn, Rn, Cn, Pn, new pt())));
			var y = new We(l, u, h);
			Be.getNormal(_n, bn, wn, y.normal), (g.face = y);
		}
		return g;
	}
	Nn.prototype = Object.assign(Object.create(be.prototype), {
		constructor: Nn,
		isMesh: !0,
		copy: function (t) {
			return (
				be.prototype.copy.call(this, t),
				void 0 !== t.morphTargetInfluences &&
					(this.morphTargetInfluences = t.morphTargetInfluences.slice()),
				void 0 !== t.morphTargetDictionary &&
					(this.morphTargetDictionary = Object.assign(
						{},
						t.morphTargetDictionary
					)),
				(this.material = t.material),
				(this.geometry = t.geometry),
				this
			);
		},
		updateMorphTargets: function () {
			var t = this.geometry;
			if (t.isBufferGeometry) {
				var e = t.morphAttributes,
					n = Object.keys(e);
				if (n.length > 0) {
					var r = e[n[0]];
					if (void 0 !== r) {
						(this.morphTargetInfluences = []),
							(this.morphTargetDictionary = {});
						for (var i = 0, a = r.length; i < a; i++) {
							var o = r[i].name || String(i);
							this.morphTargetInfluences.push(0),
								(this.morphTargetDictionary[o] = i);
						}
					}
				}
			} else {
				var s = t.morphTargets;
				void 0 !== s &&
					s.length > 0 &&
					console.error(
						'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
					);
			}
		},
		raycast: function (t, e) {
			var n,
				r = this.geometry,
				i = this.material,
				a = this.matrixWorld;
			if (
				void 0 !== i &&
				(null === r.boundingSphere && r.computeBoundingSphere(),
				xn.copy(r.boundingSphere),
				xn.applyMatrix4(a),
				!1 !== t.ray.intersectsSphere(xn) &&
					(gn.getInverse(a),
					yn.copy(t.ray).applyMatrix4(gn),
					null === r.boundingBox || !1 !== yn.intersectsBox(r.boundingBox)))
			)
				if (r.isBufferGeometry) {
					var o = r.index,
						s = r.attributes.position,
						c = r.morphAttributes.position,
						l = r.morphTargetsRelative,
						u = r.attributes.uv,
						h = r.attributes.uv2,
						d = r.groups,
						p = r.drawRange;
					if (null !== o)
						if (Array.isArray(i))
							for (var f = 0, m = d.length; f < m; f++)
								for (
									var v = d[f],
										g = i[v.materialIndex],
										y = Math.max(v.start, p.start),
										x = Math.min(v.start + v.count, p.start + p.count);
									y < x;
									y += 3
								) {
									var _ = o.getX(y),
										b = o.getX(y + 1),
										w = o.getX(y + 2);
									(n = Bn(this, g, t, yn, s, c, l, u, h, _, b, w)) &&
										((n.faceIndex = Math.floor(y / 3)),
										(n.face.materialIndex = v.materialIndex),
										e.push(n));
								}
						else
							for (
								var M = Math.max(0, p.start),
									S = Math.min(o.count, p.start + p.count);
								M < S;
								M += 3
							) {
								var T = o.getX(M),
									E = o.getX(M + 1),
									A = o.getX(M + 2);
								(n = Bn(this, i, t, yn, s, c, l, u, h, T, E, A)) &&
									((n.faceIndex = Math.floor(M / 3)), e.push(n));
							}
					else if (void 0 !== s)
						if (Array.isArray(i))
							for (var L = 0, R = d.length; L < R; L++)
								for (
									var C = d[L],
										P = i[C.materialIndex],
										I = Math.max(C.start, p.start),
										D = Math.min(C.start + C.count, p.start + p.count);
									I < D;
									I += 3
								) {
									(n = Bn(this, P, t, yn, s, c, l, u, h, I, I + 1, I + 2)) &&
										((n.faceIndex = Math.floor(I / 3)),
										(n.face.materialIndex = C.materialIndex),
										e.push(n));
								}
						else
							for (
								var N = Math.max(0, p.start),
									O = Math.min(s.count, p.start + p.count);
								N < O;
								N += 3
							) {
								(n = Bn(this, i, t, yn, s, c, l, u, h, N, N + 1, N + 2)) &&
									((n.faceIndex = Math.floor(N / 3)), e.push(n));
							}
				} else if (r.isGeometry) {
					var B,
						z = Array.isArray(i),
						G = r.vertices,
						F = r.faces,
						U = r.faceVertexUvs[0];
					U.length > 0 && (B = U);
					for (var H = 0, k = F.length; H < k; H++) {
						var V = F[H],
							W = z ? i[V.materialIndex] : i;
						if (void 0 !== W) {
							var j = G[V.a],
								q = G[V.b],
								X = G[V.c];
							if ((n = On(this, W, t, yn, j, q, X, In))) {
								if (B && B[H]) {
									var Y = B[H];
									Rn.copy(Y[0]),
										Cn.copy(Y[1]),
										Pn.copy(Y[2]),
										(n.uv = Be.getUV(In, j, q, X, Rn, Cn, Pn, new pt()));
								}
								(n.face = V), (n.faceIndex = H), e.push(n);
							}
						}
					}
				}
		},
	});
	var zn = (function (t) {
		function e(e, n, r, i, a, o) {
			var s;
			void 0 === e && (e = 1),
				void 0 === n && (n = 1),
				void 0 === r && (r = 1),
				void 0 === i && (i = 1),
				void 0 === a && (a = 1),
				void 0 === o && (o = 1),
				((s = t.call(this) || this).type = 'BoxBufferGeometry'),
				(s.parameters = {
					width: e,
					height: n,
					depth: r,
					widthSegments: i,
					heightSegments: a,
					depthSegments: o,
				});
			var c = ht(s);
			(i = Math.floor(i)), (a = Math.floor(a)), (o = Math.floor(o));
			var l = [],
				u = [],
				h = [],
				d = [],
				p = 0,
				f = 0;
			function m(t, e, n, r, i, a, o, s, m, v, g) {
				for (
					var y = a / m,
						x = o / v,
						_ = a / 2,
						b = o / 2,
						w = s / 2,
						M = m + 1,
						S = v + 1,
						T = 0,
						E = 0,
						A = new wt(),
						L = 0;
					L < S;
					L++
				)
					for (var R = L * x - b, C = 0; C < M; C++) {
						var P = C * y - _;
						(A[t] = P * r),
							(A[e] = R * i),
							(A[n] = w),
							u.push(A.x, A.y, A.z),
							(A[t] = 0),
							(A[e] = 0),
							(A[n] = s > 0 ? 1 : -1),
							h.push(A.x, A.y, A.z),
							d.push(C / m),
							d.push(1 - L / v),
							(T += 1);
					}
				for (var I = 0; I < v; I++)
					for (var D = 0; D < m; D++) {
						var N = p + D + M * I,
							O = p + D + M * (I + 1),
							B = p + (D + 1) + M * (I + 1),
							z = p + (D + 1) + M * I;
						l.push(N, O, z), l.push(O, B, z), (E += 6);
					}
				c.addGroup(f, E, g), (f += E), (p += T);
			}
			return (
				m('z', 'y', 'x', -1, -1, r, n, e, o, a, 0),
				m('z', 'y', 'x', 1, -1, r, n, -e, o, a, 1),
				m('x', 'z', 'y', 1, 1, e, r, n, i, o, 2),
				m('x', 'z', 'y', 1, -1, e, r, -n, i, o, 3),
				m('x', 'y', 'z', 1, -1, e, n, r, i, a, 4),
				m('x', 'y', 'z', -1, -1, e, n, -r, i, a, 5),
				s.setIndex(l),
				s.setAttribute('position', new an(u, 3)),
				s.setAttribute('normal', new an(h, 3)),
				s.setAttribute('uv', new an(d, 2)),
				s
			);
		}
		return ut(e, t), e;
	})(vn);
	function Gn(t) {
		var e = {};
		for (var n in t)
			for (var r in ((e[n] = {}), t[n])) {
				var i = t[n][r];
				i &&
				(i.isColor ||
					i.isMatrix3 ||
					i.isMatrix4 ||
					i.isVector2 ||
					i.isVector3 ||
					i.isVector4 ||
					i.isTexture)
					? (e[n][r] = i.clone())
					: Array.isArray(i)
					? (e[n][r] = i.slice())
					: (e[n][r] = i);
			}
		return e;
	}
	function Fn(t) {
		for (var e = {}, n = 0; n < t.length; n++) {
			var r = Gn(t[n]);
			for (var i in r) e[i] = r[i];
		}
		return e;
	}
	var Un = { clone: Gn, merge: Fn };
	function Hn(t) {
		qe.call(this),
			(this.type = 'ShaderMaterial'),
			(this.defines = {}),
			(this.uniforms = {}),
			(this.vertexShader =
				'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
			(this.fragmentShader =
				'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
			(this.linewidth = 1),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.fog = !1),
			(this.lights = !1),
			(this.clipping = !1),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			(this.extensions = {
				derivatives: !1,
				fragDepth: !1,
				drawBuffers: !1,
				shaderTextureLOD: !1,
			}),
			(this.defaultAttributeValues = {
				color: [1, 1, 1],
				uv: [0, 0],
				uv2: [0, 0],
			}),
			(this.index0AttributeName = void 0),
			(this.uniformsNeedUpdate = !1),
			(this.glslVersion = null),
			void 0 !== t &&
				(void 0 !== t.attributes &&
					console.error(
						'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'
					),
				this.setValues(t));
	}
	function kn() {
		be.call(this),
			(this.type = 'Camera'),
			(this.matrixWorldInverse = new Jt()),
			(this.projectionMatrix = new Jt()),
			(this.projectionMatrixInverse = new Jt());
	}
	function Vn(t, e, n, r) {
		kn.call(this),
			(this.type = 'PerspectiveCamera'),
			(this.fov = void 0 !== t ? t : 50),
			(this.zoom = 1),
			(this.near = void 0 !== n ? n : 0.1),
			(this.far = void 0 !== r ? r : 2e3),
			(this.focus = 10),
			(this.aspect = void 0 !== e ? e : 1),
			(this.view = null),
			(this.filmGauge = 35),
			(this.filmOffset = 0),
			this.updateProjectionMatrix();
	}
	(Hn.prototype = Object.create(qe.prototype)),
		(Hn.prototype.constructor = Hn),
		(Hn.prototype.isShaderMaterial = !0),
		(Hn.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				(this.fragmentShader = t.fragmentShader),
				(this.vertexShader = t.vertexShader),
				(this.uniforms = Gn(t.uniforms)),
				(this.defines = Object.assign({}, t.defines)),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.lights = t.lights),
				(this.clipping = t.clipping),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				(this.extensions = Object.assign({}, t.extensions)),
				(this.glslVersion = t.glslVersion),
				this
			);
		}),
		(Hn.prototype.toJSON = function (t) {
			var e = qe.prototype.toJSON.call(this, t);
			for (var n in ((e.glslVersion = this.glslVersion),
			(e.uniforms = {}),
			this.uniforms)) {
				var r = this.uniforms[n].value;
				r && r.isTexture
					? (e.uniforms[n] = { type: 't', value: r.toJSON(t).uuid })
					: r && r.isColor
					? (e.uniforms[n] = { type: 'c', value: r.getHex() })
					: r && r.isVector2
					? (e.uniforms[n] = { type: 'v2', value: r.toArray() })
					: r && r.isVector3
					? (e.uniforms[n] = { type: 'v3', value: r.toArray() })
					: r && r.isVector4
					? (e.uniforms[n] = { type: 'v4', value: r.toArray() })
					: r && r.isMatrix3
					? (e.uniforms[n] = { type: 'm3', value: r.toArray() })
					: r && r.isMatrix4
					? (e.uniforms[n] = { type: 'm4', value: r.toArray() })
					: (e.uniforms[n] = { value: r });
			}
			Object.keys(this.defines).length > 0 && (e.defines = this.defines),
				(e.vertexShader = this.vertexShader),
				(e.fragmentShader = this.fragmentShader);
			var i = {};
			for (var a in this.extensions) !0 === this.extensions[a] && (i[a] = !0);
			return Object.keys(i).length > 0 && (e.extensions = i), e;
		}),
		(kn.prototype = Object.assign(Object.create(be.prototype), {
			constructor: kn,
			isCamera: !0,
			copy: function (t, e) {
				return (
					be.prototype.copy.call(this, t, e),
					this.matrixWorldInverse.copy(t.matrixWorldInverse),
					this.projectionMatrix.copy(t.projectionMatrix),
					this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
					this
				);
			},
			getWorldDirection: function (t) {
				void 0 === t &&
					(console.warn(
						'THREE.Camera: .getWorldDirection() target is now required'
					),
					(t = new wt())),
					this.updateMatrixWorld(!0);
				var e = this.matrixWorld.elements;
				return t.set(-e[8], -e[9], -e[10]).normalize();
			},
			updateMatrixWorld: function (t) {
				be.prototype.updateMatrixWorld.call(this, t),
					this.matrixWorldInverse.getInverse(this.matrixWorld);
			},
			updateWorldMatrix: function (t, e) {
				be.prototype.updateWorldMatrix.call(this, t, e),
					this.matrixWorldInverse.getInverse(this.matrixWorld);
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
		})),
		(Vn.prototype = Object.assign(Object.create(kn.prototype), {
			constructor: Vn,
			isPerspectiveCamera: !0,
			copy: function (t, e) {
				return (
					kn.prototype.copy.call(this, t, e),
					(this.fov = t.fov),
					(this.zoom = t.zoom),
					(this.near = t.near),
					(this.far = t.far),
					(this.focus = t.focus),
					(this.aspect = t.aspect),
					(this.view = null === t.view ? null : Object.assign({}, t.view)),
					(this.filmGauge = t.filmGauge),
					(this.filmOffset = t.filmOffset),
					this
				);
			},
			setFocalLength: function (t) {
				var e = (0.5 * this.getFilmHeight()) / t;
				(this.fov = 2 * st.RAD2DEG * Math.atan(e)),
					this.updateProjectionMatrix();
			},
			getFocalLength: function () {
				var t = Math.tan(0.5 * st.DEG2RAD * this.fov);
				return (0.5 * this.getFilmHeight()) / t;
			},
			getEffectiveFOV: function () {
				return (
					2 *
					st.RAD2DEG *
					Math.atan(Math.tan(0.5 * st.DEG2RAD * this.fov) / this.zoom)
				);
			},
			getFilmWidth: function () {
				return this.filmGauge * Math.min(this.aspect, 1);
			},
			getFilmHeight: function () {
				return this.filmGauge / Math.max(this.aspect, 1);
			},
			setViewOffset: function (t, e, n, r, i, a) {
				(this.aspect = t / e),
					null === this.view &&
						(this.view = {
							enabled: !0,
							fullWidth: 1,
							fullHeight: 1,
							offsetX: 0,
							offsetY: 0,
							width: 1,
							height: 1,
						}),
					(this.view.enabled = !0),
					(this.view.fullWidth = t),
					(this.view.fullHeight = e),
					(this.view.offsetX = n),
					(this.view.offsetY = r),
					(this.view.width = i),
					(this.view.height = a),
					this.updateProjectionMatrix();
			},
			clearViewOffset: function () {
				null !== this.view && (this.view.enabled = !1),
					this.updateProjectionMatrix();
			},
			updateProjectionMatrix: function () {
				var t = this.near,
					e = (t * Math.tan(0.5 * st.DEG2RAD * this.fov)) / this.zoom,
					n = 2 * e,
					r = this.aspect * n,
					i = -0.5 * r,
					a = this.view;
				if (null !== this.view && this.view.enabled) {
					var o = a.fullWidth,
						s = a.fullHeight;
					(i += (a.offsetX * r) / o),
						(e -= (a.offsetY * n) / s),
						(r *= a.width / o),
						(n *= a.height / s);
				}
				var c = this.filmOffset;
				0 !== c && (i += (t * c) / this.getFilmWidth()),
					this.projectionMatrix.makePerspective(
						i,
						i + r,
						e,
						e - n,
						t,
						this.far
					),
					this.projectionMatrixInverse.getInverse(this.projectionMatrix);
			},
			toJSON: function (t) {
				var e = be.prototype.toJSON.call(this, t);
				return (
					(e.object.fov = this.fov),
					(e.object.zoom = this.zoom),
					(e.object.near = this.near),
					(e.object.far = this.far),
					(e.object.focus = this.focus),
					(e.object.aspect = this.aspect),
					null !== this.view && (e.object.view = Object.assign({}, this.view)),
					(e.object.filmGauge = this.filmGauge),
					(e.object.filmOffset = this.filmOffset),
					e
				);
			},
		}));
	var Wn = 90;
	function jn(t, e, n) {
		if (
			(be.call(this),
			(this.type = 'CubeCamera'),
			!0 === n.isWebGLCubeRenderTarget)
		) {
			this.renderTarget = n;
			var r = new Vn(Wn, 1, t, e);
			(r.layers = this.layers),
				r.up.set(0, -1, 0),
				r.lookAt(new wt(1, 0, 0)),
				this.add(r);
			var i = new Vn(Wn, 1, t, e);
			(i.layers = this.layers),
				i.up.set(0, -1, 0),
				i.lookAt(new wt(-1, 0, 0)),
				this.add(i);
			var a = new Vn(Wn, 1, t, e);
			(a.layers = this.layers),
				a.up.set(0, 0, 1),
				a.lookAt(new wt(0, 1, 0)),
				this.add(a);
			var o = new Vn(Wn, 1, t, e);
			(o.layers = this.layers),
				o.up.set(0, 0, -1),
				o.lookAt(new wt(0, -1, 0)),
				this.add(o);
			var s = new Vn(Wn, 1, t, e);
			(s.layers = this.layers),
				s.up.set(0, -1, 0),
				s.lookAt(new wt(0, 0, 1)),
				this.add(s);
			var c = new Vn(Wn, 1, t, e);
			(c.layers = this.layers),
				c.up.set(0, -1, 0),
				c.lookAt(new wt(0, 0, -1)),
				this.add(c),
				(this.update = function (t, e) {
					null === this.parent && this.updateMatrixWorld();
					var l = t.xr.enabled,
						u = t.getRenderTarget();
					t.xr.enabled = !1;
					var h = n.texture.generateMipmaps;
					(n.texture.generateMipmaps = !1),
						t.setRenderTarget(n, 0),
						t.render(e, r),
						t.setRenderTarget(n, 1),
						t.render(e, i),
						t.setRenderTarget(n, 2),
						t.render(e, a),
						t.setRenderTarget(n, 3),
						t.render(e, o),
						t.setRenderTarget(n, 4),
						t.render(e, s),
						(n.texture.generateMipmaps = h),
						t.setRenderTarget(n, 5),
						t.render(e, c),
						t.setRenderTarget(u),
						(t.xr.enabled = l);
				}),
				(this.clear = function (t, e, r, i) {
					for (var a = t.getRenderTarget(), o = 0; o < 6; o++)
						t.setRenderTarget(n, o), t.clear(e, r, i);
					t.setRenderTarget(a);
				});
		} else console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
	}
	function qn(t, e, n, i, a, o, s, c, l, u) {
		(t = void 0 !== t ? t : []),
			(e = void 0 !== e ? e : r),
			(s = void 0 !== s ? s : S),
			gt.call(this, t, e, n, i, a, o, s, c, l, u),
			(this.flipY = !1),
			(this._needsFlipEnvMap = !0);
	}
	function Xn(t, e, n) {
		Number.isInteger(e) &&
			(console.warn(
				'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )'
			),
			(e = n)),
			xt.call(this, t, t, e),
			(e = e || {}),
			(this.texture = new qn(
				void 0,
				e.mapping,
				e.wrapS,
				e.wrapT,
				e.magFilter,
				e.minFilter,
				e.format,
				e.type,
				e.anisotropy,
				e.encoding
			)),
			(this.texture._needsFlipEnvMap = !1);
	}
	function Yn(t, e, n, r, i, a, o, s, c, l, u, h) {
		gt.call(this, null, a, o, s, c, l, r, i, u, h),
			(this.image = { data: t || null, width: e || 1, height: n || 1 }),
			(this.magFilter = void 0 !== c ? c : d),
			(this.minFilter = void 0 !== l ? l : d),
			(this.generateMipmaps = !1),
			(this.flipY = !1),
			(this.unpackAlignment = 1),
			(this.needsUpdate = !0);
	}
	(jn.prototype = Object.create(be.prototype)),
		(jn.prototype.constructor = jn),
		(qn.prototype = Object.create(gt.prototype)),
		(qn.prototype.constructor = qn),
		(qn.prototype.isCubeTexture = !0),
		Object.defineProperty(qn.prototype, 'images', {
			get: function () {
				return this.image;
			},
			set: function (t) {
				this.image = t;
			},
		}),
		(Xn.prototype = Object.create(xt.prototype)),
		(Xn.prototype.constructor = Xn),
		(Xn.prototype.isWebGLCubeRenderTarget = !0),
		(Xn.prototype.fromEquirectangularTexture = function (t, e) {
			(this.texture.type = e.type),
				(this.texture.format = T),
				(this.texture.encoding = e.encoding),
				(this.texture.generateMipmaps = e.generateMipmaps),
				(this.texture.minFilter = e.minFilter),
				(this.texture.magFilter = e.magFilter);
			var n = { tEquirect: { value: null } },
				r =
					'\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t',
				i =
					'\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t',
				a = new zn(5, 5, 5),
				o = new Hn({
					name: 'CubemapFromEquirect',
					uniforms: Gn(n),
					vertexShader: r,
					fragmentShader: i,
					side: 1,
					blending: 0,
				});
			o.uniforms.tEquirect.value = e;
			var s = new Nn(a, o),
				c = e.minFilter;
			return (
				e.minFilter === g && (e.minFilter = m),
				new jn(1, 10, this).update(t, s),
				(e.minFilter = c),
				s.geometry.dispose(),
				s.material.dispose(),
				this
			);
		}),
		(Yn.prototype = Object.create(gt.prototype)),
		(Yn.prototype.constructor = Yn),
		(Yn.prototype.isDataTexture = !0);
	var Zn = new Ht(),
		Jn = new wt(),
		Qn = (function () {
			function t(t, e, n, r, i, a) {
				this.planes = [
					void 0 !== t ? t : new Te(),
					void 0 !== e ? e : new Te(),
					void 0 !== n ? n : new Te(),
					void 0 !== r ? r : new Te(),
					void 0 !== i ? i : new Te(),
					void 0 !== a ? a : new Te(),
				];
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n, r, i, a) {
					var o = this.planes;
					return (
						o[0].copy(t),
						o[1].copy(e),
						o[2].copy(n),
						o[3].copy(r),
						o[4].copy(i),
						o[5].copy(a),
						this
					);
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
					return this;
				}),
				(e.setFromProjectionMatrix = function (t) {
					var e = this.planes,
						n = t.elements,
						r = n[0],
						i = n[1],
						a = n[2],
						o = n[3],
						s = n[4],
						c = n[5],
						l = n[6],
						u = n[7],
						h = n[8],
						d = n[9],
						p = n[10],
						f = n[11],
						m = n[12],
						v = n[13],
						g = n[14],
						y = n[15];
					return (
						e[0].setComponents(o - r, u - s, f - h, y - m).normalize(),
						e[1].setComponents(o + r, u + s, f + h, y + m).normalize(),
						e[2].setComponents(o + i, u + c, f + d, y + v).normalize(),
						e[3].setComponents(o - i, u - c, f - d, y - v).normalize(),
						e[4].setComponents(o - a, u - l, f - p, y - g).normalize(),
						e[5].setComponents(o + a, u + l, f + p, y + g).normalize(),
						this
					);
				}),
				(e.intersectsObject = function (t) {
					var e = t.geometry;
					return (
						null === e.boundingSphere && e.computeBoundingSphere(),
						Zn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
						this.intersectsSphere(Zn)
					);
				}),
				(e.intersectsSprite = function (t) {
					return (
						Zn.center.set(0, 0, 0),
						(Zn.radius = 0.7071067811865476),
						Zn.applyMatrix4(t.matrixWorld),
						this.intersectsSphere(Zn)
					);
				}),
				(e.intersectsSphere = function (t) {
					for (
						var e = this.planes, n = t.center, r = -t.radius, i = 0;
						i < 6;
						i++
					) {
						if (e[i].distanceToPoint(n) < r) return !1;
					}
					return !0;
				}),
				(e.intersectsBox = function (t) {
					for (var e = this.planes, n = 0; n < 6; n++) {
						var r = e[n];
						if (
							((Jn.x = r.normal.x > 0 ? t.max.x : t.min.x),
							(Jn.y = r.normal.y > 0 ? t.max.y : t.min.y),
							(Jn.z = r.normal.z > 0 ? t.max.z : t.min.z),
							r.distanceToPoint(Jn) < 0)
						)
							return !1;
					}
					return !0;
				}),
				(e.containsPoint = function (t) {
					for (var e = this.planes, n = 0; n < 6; n++)
						if (e[n].distanceToPoint(t) < 0) return !1;
					return !0;
				}),
				t
			);
		})();
	function Kn() {
		var t = null,
			e = !1,
			n = null,
			r = null;
		function i(e, a) {
			n(e, a), (r = t.requestAnimationFrame(i));
		}
		return {
			start: function () {
				!0 !== e && null !== n && ((r = t.requestAnimationFrame(i)), (e = !0));
			},
			stop: function () {
				t.cancelAnimationFrame(r), (e = !1);
			},
			setAnimationLoop: function (t) {
				n = t;
			},
			setContext: function (e) {
				t = e;
			},
		};
	}
	function $n(t, e) {
		var n = e.isWebGL2,
			r = new WeakMap();
		return {
			get: function (t) {
				return t.isInterleavedBufferAttribute && (t = t.data), r.get(t);
			},
			remove: function (e) {
				e.isInterleavedBufferAttribute && (e = e.data);
				var n = r.get(e);
				n && (t.deleteBuffer(n.buffer), r.delete(e));
			},
			update: function (e, i) {
				if (e.isGLBufferAttribute) {
					var a = r.get(e);
					(!a || a.version < e.version) &&
						r.set(e, {
							buffer: e.buffer,
							type: e.type,
							bytesPerElement: e.elementSize,
							version: e.version,
						});
				} else {
					e.isInterleavedBufferAttribute && (e = e.data);
					var o = r.get(e);
					void 0 === o
						? r.set(
								e,
								(function (e, n) {
									var r = e.array,
										i = e.usage,
										a = t.createBuffer();
									t.bindBuffer(n, a),
										t.bufferData(n, r, i),
										e.onUploadCallback();
									var o = 5126;
									return (
										r instanceof Float32Array
											? (o = 5126)
											: r instanceof Float64Array
											? console.warn(
													'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.'
											  )
											: r instanceof Uint16Array
											? (o = 5123)
											: r instanceof Int16Array
											? (o = 5122)
											: r instanceof Uint32Array
											? (o = 5125)
											: r instanceof Int32Array
											? (o = 5124)
											: r instanceof Int8Array
											? (o = 5120)
											: r instanceof Uint8Array && (o = 5121),
										{
											buffer: a,
											type: o,
											bytesPerElement: r.BYTES_PER_ELEMENT,
											version: e.version,
										}
									);
								})(e, i)
						  )
						: o.version < e.version &&
						  (!(function (e, r, i) {
								var a = r.array,
									o = r.updateRange;
								t.bindBuffer(i, e),
									-1 === o.count
										? t.bufferSubData(i, 0, a)
										: (n
												? t.bufferSubData(
														i,
														o.offset * a.BYTES_PER_ELEMENT,
														a,
														o.offset,
														o.count
												  )
												: t.bufferSubData(
														i,
														o.offset * a.BYTES_PER_ELEMENT,
														a.subarray(o.offset, o.offset + o.count)
												  ),
										  (o.count = -1));
						  })(o.buffer, e, i),
						  (o.version = e.version));
				}
			},
		};
	}
	var tr = (function (t) {
			function e(e, n, r, i) {
				var a;
				((a = t.call(this) || this).type = 'PlaneBufferGeometry'),
					(a.parameters = {
						width: e,
						height: n,
						widthSegments: r,
						heightSegments: i,
					});
				for (
					var o = (e = e || 1) / 2,
						s = (n = n || 1) / 2,
						c = Math.floor(r) || 1,
						l = Math.floor(i) || 1,
						u = c + 1,
						h = l + 1,
						d = e / c,
						p = n / l,
						f = [],
						m = [],
						v = [],
						g = [],
						y = 0;
					y < h;
					y++
				)
					for (var x = y * p - s, _ = 0; _ < u; _++) {
						var b = _ * d - o;
						m.push(b, -x, 0), v.push(0, 0, 1), g.push(_ / c), g.push(1 - y / l);
					}
				for (var w = 0; w < l; w++)
					for (var M = 0; M < c; M++) {
						var S = M + u * w,
							T = M + u * (w + 1),
							E = M + 1 + u * (w + 1),
							A = M + 1 + u * w;
						f.push(S, T, A), f.push(T, E, A);
					}
				return (
					a.setIndex(f),
					a.setAttribute('position', new an(m, 3)),
					a.setAttribute('normal', new an(v, 3)),
					a.setAttribute('uv', new an(g, 2)),
					a
				);
			}
			return ut(e, t), e;
		})(vn),
		er = {
			alphamap_fragment:
				'#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
			alphamap_pars_fragment:
				'#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
			alphatest_fragment:
				'#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
			aomap_fragment:
				'#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
			aomap_pars_fragment:
				'#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
			begin_vertex: 'vec3 transformed = vec3( position );',
			beginnormal_vertex:
				'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
			bsdfs:
				'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif',
			bumpmap_pars_fragment:
				'#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
			clipping_planes_fragment:
				'#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
			clipping_planes_pars_fragment:
				'#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
			clipping_planes_pars_vertex:
				'#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
			clipping_planes_vertex:
				'#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
			color_fragment: '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
			color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
			color_pars_vertex:
				'#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
			color_vertex:
				'#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
			common:
				'#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
			cube_uv_reflection_fragment:
				'#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
			defaultnormal_vertex:
				'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
			displacementmap_pars_vertex:
				'#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
			displacementmap_vertex:
				'#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
			emissivemap_fragment:
				'#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
			emissivemap_pars_fragment:
				'#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
			encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
			encodings_pars_fragment:
				'\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
			envmap_fragment:
				'#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
			envmap_common_pars_fragment:
				'#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
			envmap_pars_fragment:
				'#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
			envmap_pars_vertex:
				'#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
			envmap_physical_pars_fragment:
				'#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
			envmap_vertex:
				'#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
			fog_vertex: '#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif',
			fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
			fog_fragment:
				'#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
			fog_pars_fragment:
				'#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
			gradientmap_pars_fragment:
				'#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
			lightmap_fragment:
				'#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif',
			lightmap_pars_fragment:
				'#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
			lights_lambert_vertex:
				'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
			lights_pars_begin:
				'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
			lights_toon_fragment:
				'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
			lights_toon_pars_fragment:
				'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
			lights_phong_fragment:
				'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
			lights_phong_pars_fragment:
				'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
			lights_physical_fragment:
				'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif',
			lights_physical_pars_fragment:
				'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
			lights_fragment_begin:
				'\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
			lights_fragment_maps:
				'#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif',
			lights_fragment_end:
				'#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
			logdepthbuf_fragment:
				'#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
			logdepthbuf_pars_fragment:
				'#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
			logdepthbuf_pars_vertex:
				'#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
			logdepthbuf_vertex:
				'#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
			map_fragment:
				'#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
			map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
			map_particle_fragment:
				'#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
			map_particle_pars_fragment:
				'#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
			metalnessmap_fragment:
				'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
			metalnessmap_pars_fragment:
				'#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
			morphnormal_vertex:
				'#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif',
			morphtarget_pars_vertex:
				'#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
			morphtarget_vertex:
				'#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
			normal_fragment_begin:
				'#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
			normal_fragment_maps:
				'#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif',
			normalmap_pars_fragment:
				'#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif',
			clearcoat_normal_fragment_begin:
				'#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
			clearcoat_normal_fragment_maps:
				'#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif',
			clearcoat_pars_fragment:
				'#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
			packing:
				'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
			premultiplied_alpha_fragment:
				'#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
			project_vertex:
				'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
			dithering_fragment:
				'#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
			dithering_pars_fragment:
				'#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
			roughnessmap_fragment:
				'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
			roughnessmap_pars_fragment:
				'#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
			shadowmap_pars_fragment:
				'#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
			shadowmap_pars_vertex:
				'#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
			shadowmap_vertex:
				'#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
			shadowmask_pars_fragment:
				'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
			skinbase_vertex:
				'#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
			skinning_pars_vertex:
				'#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
			skinning_vertex:
				'#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
			skinnormal_vertex:
				'#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
			specularmap_fragment:
				'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
			specularmap_pars_fragment:
				'#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
			tonemapping_fragment:
				'#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
			tonemapping_pars_fragment:
				'#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
			transmissionmap_fragment:
				'#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif',
			transmissionmap_pars_fragment:
				'#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif',
			uv_pars_fragment:
				'#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
			uv_pars_vertex:
				'#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
			uv_vertex:
				'#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
			uv2_pars_fragment:
				'#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
			uv2_pars_vertex:
				'#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
			uv2_vertex:
				'#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
			worldpos_vertex:
				'#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
			background_frag:
				'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
			background_vert:
				'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
			cube_frag:
				'#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
			cube_vert:
				'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
			depth_frag:
				'#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
			depth_vert:
				'#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
			distanceRGBA_frag:
				'#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
			distanceRGBA_vert:
				'#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
			equirect_frag:
				'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
			equirect_vert:
				'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
			linedashed_frag:
				'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
			linedashed_vert:
				'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
			meshbasic_frag:
				'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
			meshbasic_vert:
				'#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
			meshlambert_frag:
				'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
			meshlambert_vert:
				'#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
			meshmatcap_frag:
				'#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
			meshmatcap_vert:
				'#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
			meshtoon_frag:
				'#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
			meshtoon_vert:
				'#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
			meshphong_frag:
				'#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
			meshphong_vert:
				'#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
			meshphysical_frag:
				'#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
			meshphysical_vert:
				'#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
			normal_frag:
				'#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
			normal_vert:
				'#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
			points_frag:
				'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
			points_vert:
				'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
			shadow_frag:
				'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
			shadow_vert:
				'#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
			sprite_frag:
				'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
			sprite_vert:
				'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
		},
		nr = {
			common: {
				diffuse: { value: new Ve(15658734) },
				opacity: { value: 1 },
				map: { value: null },
				uvTransform: { value: new ft() },
				uv2Transform: { value: new ft() },
				alphaMap: { value: null },
			},
			specularmap: { specularMap: { value: null } },
			envmap: {
				envMap: { value: null },
				flipEnvMap: { value: -1 },
				reflectivity: { value: 1 },
				refractionRatio: { value: 0.98 },
				maxMipLevel: { value: 0 },
			},
			aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
			lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
			emissivemap: { emissiveMap: { value: null } },
			bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
			normalmap: {
				normalMap: { value: null },
				normalScale: { value: new pt(1, 1) },
			},
			displacementmap: {
				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 },
			},
			roughnessmap: { roughnessMap: { value: null } },
			metalnessmap: { metalnessMap: { value: null } },
			gradientmap: { gradientMap: { value: null } },
			fog: {
				fogDensity: { value: 25e-5 },
				fogNear: { value: 1 },
				fogFar: { value: 2e3 },
				fogColor: { value: new Ve(16777215) },
			},
			lights: {
				ambientLightColor: { value: [] },
				lightProbe: { value: [] },
				directionalLights: {
					value: [],
					properties: { direction: {}, color: {} },
				},
				directionalLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
					},
				},
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {},
					},
				},
				spotLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
					},
				},
				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },
				pointLights: {
					value: [],
					properties: { color: {}, position: {}, decay: {}, distance: {} },
				},
				pointLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {},
					},
				},
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
				hemisphereLights: {
					value: [],
					properties: { direction: {}, skyColor: {}, groundColor: {} },
				},
				rectAreaLights: {
					value: [],
					properties: { color: {}, position: {}, width: {}, height: {} },
				},
				ltc_1: { value: null },
				ltc_2: { value: null },
			},
			points: {
				diffuse: { value: new Ve(15658734) },
				opacity: { value: 1 },
				size: { value: 1 },
				scale: { value: 1 },
				map: { value: null },
				alphaMap: { value: null },
				uvTransform: { value: new ft() },
			},
			sprite: {
				diffuse: { value: new Ve(15658734) },
				opacity: { value: 1 },
				center: { value: new pt(0.5, 0.5) },
				rotation: { value: 0 },
				map: { value: null },
				alphaMap: { value: null },
				uvTransform: { value: new ft() },
			},
		},
		rr = {
			basic: {
				uniforms: Fn([
					nr.common,
					nr.specularmap,
					nr.envmap,
					nr.aomap,
					nr.lightmap,
					nr.fog,
				]),
				vertexShader: er.meshbasic_vert,
				fragmentShader: er.meshbasic_frag,
			},
			lambert: {
				uniforms: Fn([
					nr.common,
					nr.specularmap,
					nr.envmap,
					nr.aomap,
					nr.lightmap,
					nr.emissivemap,
					nr.fog,
					nr.lights,
					{ emissive: { value: new Ve(0) } },
				]),
				vertexShader: er.meshlambert_vert,
				fragmentShader: er.meshlambert_frag,
			},
			phong: {
				uniforms: Fn([
					nr.common,
					nr.specularmap,
					nr.envmap,
					nr.aomap,
					nr.lightmap,
					nr.emissivemap,
					nr.bumpmap,
					nr.normalmap,
					nr.displacementmap,
					nr.fog,
					nr.lights,
					{
						emissive: { value: new Ve(0) },
						specular: { value: new Ve(1118481) },
						shininess: { value: 30 },
					},
				]),
				vertexShader: er.meshphong_vert,
				fragmentShader: er.meshphong_frag,
			},
			standard: {
				uniforms: Fn([
					nr.common,
					nr.envmap,
					nr.aomap,
					nr.lightmap,
					nr.emissivemap,
					nr.bumpmap,
					nr.normalmap,
					nr.displacementmap,
					nr.roughnessmap,
					nr.metalnessmap,
					nr.fog,
					nr.lights,
					{
						emissive: { value: new Ve(0) },
						roughness: { value: 1 },
						metalness: { value: 0 },
						envMapIntensity: { value: 1 },
					},
				]),
				vertexShader: er.meshphysical_vert,
				fragmentShader: er.meshphysical_frag,
			},
			toon: {
				uniforms: Fn([
					nr.common,
					nr.aomap,
					nr.lightmap,
					nr.emissivemap,
					nr.bumpmap,
					nr.normalmap,
					nr.displacementmap,
					nr.gradientmap,
					nr.fog,
					nr.lights,
					{ emissive: { value: new Ve(0) } },
				]),
				vertexShader: er.meshtoon_vert,
				fragmentShader: er.meshtoon_frag,
			},
			matcap: {
				uniforms: Fn([
					nr.common,
					nr.bumpmap,
					nr.normalmap,
					nr.displacementmap,
					nr.fog,
					{ matcap: { value: null } },
				]),
				vertexShader: er.meshmatcap_vert,
				fragmentShader: er.meshmatcap_frag,
			},
			points: {
				uniforms: Fn([nr.points, nr.fog]),
				vertexShader: er.points_vert,
				fragmentShader: er.points_frag,
			},
			dashed: {
				uniforms: Fn([
					nr.common,
					nr.fog,
					{
						scale: { value: 1 },
						dashSize: { value: 1 },
						totalSize: { value: 2 },
					},
				]),
				vertexShader: er.linedashed_vert,
				fragmentShader: er.linedashed_frag,
			},
			depth: {
				uniforms: Fn([nr.common, nr.displacementmap]),
				vertexShader: er.depth_vert,
				fragmentShader: er.depth_frag,
			},
			normal: {
				uniforms: Fn([
					nr.common,
					nr.bumpmap,
					nr.normalmap,
					nr.displacementmap,
					{ opacity: { value: 1 } },
				]),
				vertexShader: er.normal_vert,
				fragmentShader: er.normal_frag,
			},
			sprite: {
				uniforms: Fn([nr.sprite, nr.fog]),
				vertexShader: er.sprite_vert,
				fragmentShader: er.sprite_frag,
			},
			background: {
				uniforms: { uvTransform: { value: new ft() }, t2D: { value: null } },
				vertexShader: er.background_vert,
				fragmentShader: er.background_frag,
			},
			cube: {
				uniforms: Fn([nr.envmap, { opacity: { value: 1 } }]),
				vertexShader: er.cube_vert,
				fragmentShader: er.cube_frag,
			},
			equirect: {
				uniforms: { tEquirect: { value: null } },
				vertexShader: er.equirect_vert,
				fragmentShader: er.equirect_frag,
			},
			distanceRGBA: {
				uniforms: Fn([
					nr.common,
					nr.displacementmap,
					{
						referencePosition: { value: new wt() },
						nearDistance: { value: 1 },
						farDistance: { value: 1e3 },
					},
				]),
				vertexShader: er.distanceRGBA_vert,
				fragmentShader: er.distanceRGBA_frag,
			},
			shadow: {
				uniforms: Fn([
					nr.lights,
					nr.fog,
					{ color: { value: new Ve(0) }, opacity: { value: 1 } },
				]),
				vertexShader: er.shadow_vert,
				fragmentShader: er.shadow_frag,
			},
		};
	function ir(t, e, n, r, i) {
		var a,
			o,
			c = new Ve(0),
			l = 0,
			u = null,
			h = 0,
			d = null;
		function p(t, e) {
			n.buffers.color.setClear(t.r, t.g, t.b, e, i);
		}
		return {
			getClearColor: function () {
				return c;
			},
			setClearColor: function (t, e) {
				c.set(t), p(c, (l = void 0 !== e ? e : 1));
			},
			getClearAlpha: function () {
				return l;
			},
			setClearAlpha: function (t) {
				p(c, (l = t));
			},
			render: function (n, i, f, m) {
				var v = !0 === i.isScene ? i.background : null;
				v && v.isTexture && (v = e.get(v));
				var g = t.xr,
					y = g.getSession && g.getSession();
				y && 'additive' === y.environmentBlendMode && (v = null),
					null === v ? p(c, l) : v && v.isColor && (p(v, 1), (m = !0)),
					(t.autoClear || m) &&
						t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
					v && (v.isCubeTexture || v.isWebGLCubeRenderTarget || v.mapping === s)
						? (void 0 === o &&
								((o = new Nn(
									new zn(1, 1, 1),
									new Hn({
										name: 'BackgroundCubeMaterial',
										uniforms: Gn(rr.cube.uniforms),
										vertexShader: rr.cube.vertexShader,
										fragmentShader: rr.cube.fragmentShader,
										side: 1,
										depthTest: !1,
										depthWrite: !1,
										fog: !1,
									})
								)).geometry.deleteAttribute('normal'),
								o.geometry.deleteAttribute('uv'),
								(o.onBeforeRender = function (t, e, n) {
									this.matrixWorld.copyPosition(n.matrixWorld);
								}),
								Object.defineProperty(o.material, 'envMap', {
									get: function () {
										return this.uniforms.envMap.value;
									},
								}),
								r.update(o)),
						  v.isWebGLCubeRenderTarget && (v = v.texture),
						  (o.material.uniforms.envMap.value = v),
						  (o.material.uniforms.flipEnvMap.value =
								v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1),
						  (u === v && h === v.version && d === t.toneMapping) ||
								((o.material.needsUpdate = !0),
								(u = v),
								(h = v.version),
								(d = t.toneMapping)),
						  n.unshift(o, o.geometry, o.material, 0, 0, null))
						: v &&
						  v.isTexture &&
						  (void 0 === a &&
								((a = new Nn(
									new tr(2, 2),
									new Hn({
										name: 'BackgroundMaterial',
										uniforms: Gn(rr.background.uniforms),
										vertexShader: rr.background.vertexShader,
										fragmentShader: rr.background.fragmentShader,
										side: 0,
										depthTest: !1,
										depthWrite: !1,
										fog: !1,
									})
								)).geometry.deleteAttribute('normal'),
								Object.defineProperty(a.material, 'map', {
									get: function () {
										return this.uniforms.t2D.value;
									},
								}),
								r.update(a)),
						  (a.material.uniforms.t2D.value = v),
						  !0 === v.matrixAutoUpdate && v.updateMatrix(),
						  a.material.uniforms.uvTransform.value.copy(v.matrix),
						  (u === v && h === v.version && d === t.toneMapping) ||
								((a.material.needsUpdate = !0),
								(u = v),
								(h = v.version),
								(d = t.toneMapping)),
						  n.unshift(a, a.geometry, a.material, 0, 0, null));
			},
		};
	}
	function ar(t, e, n, r) {
		var i = t.getParameter(34921),
			a = r.isWebGL2 ? null : e.get('OES_vertex_array_object'),
			o = r.isWebGL2 || null !== a,
			s = {},
			c = d(null),
			l = c;
		function u(e) {
			return r.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e);
		}
		function h(e) {
			return r.isWebGL2 ? t.deleteVertexArray(e) : a.deleteVertexArrayOES(e);
		}
		function d(t) {
			for (var e = [], n = [], r = [], a = 0; a < i; a++)
				(e[a] = 0), (n[a] = 0), (r[a] = 0);
			return {
				geometry: null,
				program: null,
				wireframe: !1,
				newAttributes: e,
				enabledAttributes: n,
				attributeDivisors: r,
				object: t,
				attributes: {},
				index: null,
			};
		}
		function p() {
			for (var t = l.newAttributes, e = 0, n = t.length; e < n; e++) t[e] = 0;
		}
		function f(t) {
			m(t, 0);
		}
		function m(n, i) {
			var a = l.newAttributes,
				o = l.enabledAttributes,
				s = l.attributeDivisors;
			((a[n] = 1),
			0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
			s[n] !== i) &&
				((r.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
					r.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
				](n, i),
				(s[n] = i));
		}
		function v() {
			for (
				var e = l.newAttributes, n = l.enabledAttributes, r = 0, i = n.length;
				r < i;
				r++
			)
				n[r] !== e[r] && (t.disableVertexAttribArray(r), (n[r] = 0));
		}
		function g(e, n, i, a, o, s) {
			!0 !== r.isWebGL2 || (5124 !== i && 5125 !== i)
				? t.vertexAttribPointer(e, n, i, a, o, s)
				: t.vertexAttribIPointer(e, n, i, o, s);
		}
		function y() {
			x(), l !== c && u((l = c).object);
		}
		function x() {
			(c.geometry = null), (c.program = null), (c.wireframe = !1);
		}
		return {
			setup: function (i, c, h, y, x) {
				var _ = !1;
				if (o) {
					var b = (function (e, n, i) {
						var o = !0 === i.wireframe,
							c = s[e.id];
						void 0 === c && ((c = {}), (s[e.id] = c));
						var l = c[n.id];
						void 0 === l && ((l = {}), (c[n.id] = l));
						var u = l[o];
						void 0 === u &&
							((u = d(
								r.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES()
							)),
							(l[o] = u));
						return u;
					})(y, h, c);
					l !== b && u((l = b).object),
						(_ = (function (t, e) {
							var n = l.attributes,
								r = t.attributes;
							if (Object.keys(n).length !== Object.keys(r).length) return !0;
							for (var i in r) {
								var a = n[i],
									o = r[i];
								if (void 0 === a) return !0;
								if (a.attribute !== o) return !0;
								if (a.data !== o.data) return !0;
							}
							return l.index !== e;
						})(y, x)) &&
							(function (t, e) {
								var n = {},
									r = t.attributes;
								for (var i in r) {
									var a = r[i],
										o = {};
									(o.attribute = a), a.data && (o.data = a.data), (n[i] = o);
								}
								(l.attributes = n), (l.index = e);
							})(y, x);
				} else {
					var w = !0 === c.wireframe;
					(l.geometry === y.id && l.program === h.id && l.wireframe === w) ||
						((l.geometry = y.id),
						(l.program = h.id),
						(l.wireframe = w),
						(_ = !0));
				}
				!0 === i.isInstancedMesh && (_ = !0),
					null !== x && n.update(x, 34963),
					_ &&
						(!(function (i, a, o, s) {
							if (
								!1 === r.isWebGL2 &&
								(i.isInstancedMesh || s.isInstancedBufferGeometry) &&
								null === e.get('ANGLE_instanced_arrays')
							)
								return;
							p();
							var c = s.attributes,
								l = o.getAttributes(),
								u = a.defaultAttributeValues;
							for (var h in l) {
								var d = l[h];
								if (d >= 0) {
									var y = c[h];
									if (void 0 !== y) {
										var x = y.normalized,
											_ = y.itemSize,
											b = n.get(y);
										if (void 0 === b) continue;
										var w = b.buffer,
											M = b.type,
											S = b.bytesPerElement;
										if (y.isInterleavedBufferAttribute) {
											var T = y.data,
												E = T.stride,
												A = y.offset;
											T && T.isInstancedInterleavedBuffer
												? (m(d, T.meshPerAttribute),
												  void 0 === s._maxInstanceCount &&
														(s._maxInstanceCount =
															T.meshPerAttribute * T.count))
												: f(d),
												t.bindBuffer(34962, w),
												g(d, _, M, x, E * S, A * S);
										} else
											y.isInstancedBufferAttribute
												? (m(d, y.meshPerAttribute),
												  void 0 === s._maxInstanceCount &&
														(s._maxInstanceCount =
															y.meshPerAttribute * y.count))
												: f(d),
												t.bindBuffer(34962, w),
												g(d, _, M, x, 0, 0);
									} else if ('instanceMatrix' === h) {
										var L = n.get(i.instanceMatrix);
										if (void 0 === L) continue;
										var R = L.buffer,
											C = L.type;
										m(d + 0, 1),
											m(d + 1, 1),
											m(d + 2, 1),
											m(d + 3, 1),
											t.bindBuffer(34962, R),
											t.vertexAttribPointer(d + 0, 4, C, !1, 64, 0),
											t.vertexAttribPointer(d + 1, 4, C, !1, 64, 16),
											t.vertexAttribPointer(d + 2, 4, C, !1, 64, 32),
											t.vertexAttribPointer(d + 3, 4, C, !1, 64, 48);
									} else if ('instanceColor' === h) {
										var P = n.get(i.instanceColor);
										if (void 0 === P) continue;
										var I = P.buffer,
											D = P.type;
										m(d, 1),
											t.bindBuffer(34962, I),
											t.vertexAttribPointer(d, 3, D, !1, 12, 0);
									} else if (void 0 !== u) {
										var N = u[h];
										if (void 0 !== N)
											switch (N.length) {
												case 2:
													t.vertexAttrib2fv(d, N);
													break;
												case 3:
													t.vertexAttrib3fv(d, N);
													break;
												case 4:
													t.vertexAttrib4fv(d, N);
													break;
												default:
													t.vertexAttrib1fv(d, N);
											}
									}
								}
							}
							v();
						})(i, c, h, y),
						null !== x && t.bindBuffer(34963, n.get(x).buffer));
			},
			reset: y,
			resetDefaultState: x,
			dispose: function () {
				for (var t in (y(), s)) {
					var e = s[t];
					for (var n in e) {
						var r = e[n];
						for (var i in r) h(r[i].object), delete r[i];
						delete e[n];
					}
					delete s[t];
				}
			},
			releaseStatesOfGeometry: function (t) {
				if (void 0 !== s[t.id]) {
					var e = s[t.id];
					for (var n in e) {
						var r = e[n];
						for (var i in r) h(r[i].object), delete r[i];
						delete e[n];
					}
					delete s[t.id];
				}
			},
			releaseStatesOfProgram: function (t) {
				for (var e in s) {
					var n = s[e];
					if (void 0 !== n[t.id]) {
						var r = n[t.id];
						for (var i in r) h(r[i].object), delete r[i];
						delete n[t.id];
					}
				}
			},
			initAttributes: p,
			enableAttribute: f,
			disableUnusedAttributes: v,
		};
	}
	function or(t, e, n, r) {
		var i,
			a = r.isWebGL2;
		(this.setMode = function (t) {
			i = t;
		}),
			(this.render = function (e, r) {
				t.drawArrays(i, e, r), n.update(r, i, 1);
			}),
			(this.renderInstances = function (r, o, s) {
				if (0 !== s) {
					var c, l;
					if (a) (c = t), (l = 'drawArraysInstanced');
					else if (
						((l = 'drawArraysInstancedANGLE'),
						null === (c = e.get('ANGLE_instanced_arrays')))
					)
						return void console.error(
							'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
						);
					c[l](i, r, o, s), n.update(o, i, s);
				}
			});
	}
	function sr(t, e, n) {
		var r;
		function i(e) {
			if ('highp' === e) {
				if (
					t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
					t.getShaderPrecisionFormat(35632, 36338).precision > 0
				)
					return 'highp';
				e = 'mediump';
			}
			return 'mediump' === e &&
				t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
				t.getShaderPrecisionFormat(35632, 36337).precision > 0
				? 'mediump'
				: 'lowp';
		}
		var a =
				('undefined' != typeof WebGL2RenderingContext &&
					t instanceof WebGL2RenderingContext) ||
				('undefined' != typeof WebGL2ComputeRenderingContext &&
					t instanceof WebGL2ComputeRenderingContext),
			o = void 0 !== n.precision ? n.precision : 'highp',
			s = i(o);
		s !== o &&
			(console.warn(
				'THREE.WebGLRenderer:',
				o,
				'not supported, using',
				s,
				'instead.'
			),
			(o = s));
		var c = !0 === n.logarithmicDepthBuffer,
			l = t.getParameter(34930),
			u = t.getParameter(35660),
			h = t.getParameter(3379),
			d = t.getParameter(34076),
			p = t.getParameter(34921),
			f = t.getParameter(36347),
			m = t.getParameter(36348),
			v = t.getParameter(36349),
			g = u > 0,
			y = a || !!e.get('OES_texture_float');
		return {
			isWebGL2: a,
			getMaxAnisotropy: function () {
				if (void 0 !== r) return r;
				var n = e.get('EXT_texture_filter_anisotropic');
				return (r =
					null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
			},
			getMaxPrecision: i,
			precision: o,
			logarithmicDepthBuffer: c,
			maxTextures: l,
			maxVertexTextures: u,
			maxTextureSize: h,
			maxCubemapSize: d,
			maxAttributes: p,
			maxVertexUniforms: f,
			maxVaryings: m,
			maxFragmentUniforms: v,
			vertexTextures: g,
			floatFragmentTextures: y,
			floatVertexTextures: g && y,
			maxSamples: a ? t.getParameter(36183) : 0,
		};
	}
	function cr(t) {
		var e = this,
			n = null,
			r = 0,
			i = !1,
			a = !1,
			o = new Te(),
			s = new ft(),
			c = { value: null, needsUpdate: !1 };
		function l() {
			c.value !== n && ((c.value = n), (c.needsUpdate = r > 0)),
				(e.numPlanes = r),
				(e.numIntersection = 0);
		}
		function u(t, n, r, i) {
			var a = null !== t ? t.length : 0,
				l = null;
			if (0 !== a) {
				if (((l = c.value), !0 !== i || null === l)) {
					var u = r + 4 * a,
						h = n.matrixWorldInverse;
					s.getNormalMatrix(h),
						(null === l || l.length < u) && (l = new Float32Array(u));
					for (var d = 0, p = r; d !== a; ++d, p += 4)
						o.copy(t[d]).applyMatrix4(h, s),
							o.normal.toArray(l, p),
							(l[p + 3] = o.constant);
				}
				(c.value = l), (c.needsUpdate = !0);
			}
			return (e.numPlanes = a), (e.numIntersection = 0), l;
		}
		(this.uniform = c),
			(this.numPlanes = 0),
			(this.numIntersection = 0),
			(this.init = function (t, e, a) {
				var o = 0 !== t.length || e || 0 !== r || i;
				return (i = e), (n = u(t, a, 0)), (r = t.length), o;
			}),
			(this.beginShadows = function () {
				(a = !0), u(null);
			}),
			(this.endShadows = function () {
				(a = !1), l();
			}),
			(this.setState = function (e, o, s) {
				var h = e.clippingPlanes,
					d = e.clipIntersection,
					p = e.clipShadows,
					f = t.get(e);
				if (!i || null === h || 0 === h.length || (a && !p)) a ? u(null) : l();
				else {
					var m = a ? 0 : r,
						v = 4 * m,
						g = f.clippingState || null;
					(c.value = g), (g = u(h, o, v, s));
					for (var y = 0; y !== v; ++y) g[y] = n[y];
					(f.clippingState = g),
						(this.numIntersection = d ? this.numPlanes : 0),
						(this.numPlanes += m);
				}
			});
	}
	function lr(t) {
		var e = new WeakMap();
		function n(t, e) {
			return e === a ? (t.mapping = r) : e === o && (t.mapping = i), t;
		}
		return {
			get: function (r) {
				if (r && r.isTexture) {
					var i = r.mapping;
					if (i === a || i === o) {
						if (e.has(r)) return n(e.get(r).texture, r.mapping);
						var s = r.image;
						if (s && s.height > 0) {
							var c = t.getRenderList(),
								l = t.getRenderTarget(),
								u = t.getRenderState(),
								h = new Xn(s.height / 2);
							return (
								h.fromEquirectangularTexture(t, r),
								e.set(r, h),
								t.setRenderTarget(l),
								t.setRenderList(c),
								t.setRenderState(u),
								n(h.texture, r.mapping)
							);
						}
						return null;
					}
				}
				return r;
			},
			dispose: function () {
				e = new WeakMap();
			},
		};
	}
	function ur(t) {
		var e = {};
		return {
			has: function (n) {
				if (void 0 !== e[n]) return null !== e[n];
				var r;
				switch (n) {
					case 'WEBGL_depth_texture':
						r =
							t.getExtension('WEBGL_depth_texture') ||
							t.getExtension('MOZ_WEBGL_depth_texture') ||
							t.getExtension('WEBKIT_WEBGL_depth_texture');
						break;
					case 'EXT_texture_filter_anisotropic':
						r =
							t.getExtension('EXT_texture_filter_anisotropic') ||
							t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
							t.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
						break;
					case 'WEBGL_compressed_texture_s3tc':
						r =
							t.getExtension('WEBGL_compressed_texture_s3tc') ||
							t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
							t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
						break;
					case 'WEBGL_compressed_texture_pvrtc':
						r =
							t.getExtension('WEBGL_compressed_texture_pvrtc') ||
							t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
						break;
					default:
						r = t.getExtension(n);
				}
				return (e[n] = r), null !== r;
			},
			get: function (t) {
				return (
					this.has(t) ||
						console.warn(
							'THREE.WebGLRenderer: ' + t + ' extension not supported.'
						),
					e[t]
				);
			},
		};
	}
	function hr(t, e, n, r) {
		var i = new WeakMap(),
			a = new WeakMap();
		function o(t) {
			var s = t.target,
				c = i.get(s);
			for (var l in (null !== c.index && e.remove(c.index), c.attributes))
				e.remove(c.attributes[l]);
			s.removeEventListener('dispose', o), i.delete(s);
			var u = a.get(c);
			u && (e.remove(u), a.delete(c)),
				r.releaseStatesOfGeometry(s),
				!0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
				n.memory.geometries--;
		}
		function s(t) {
			var n = [],
				r = t.index,
				i = t.attributes.position,
				o = 0;
			if (null !== r) {
				var s = r.array;
				o = r.version;
				for (var c = 0, l = s.length; c < l; c += 3) {
					var u = s[c + 0],
						h = s[c + 1],
						d = s[c + 2];
					n.push(u, h, h, d, d, u);
				}
			} else {
				var p = i.array;
				o = i.version;
				for (var f = 0, m = p.length / 3 - 1; f < m; f += 3) {
					var v = f + 0,
						g = f + 1,
						y = f + 2;
					n.push(v, g, g, y, y, v);
				}
			}
			var x = new (cn(n) > 65535 ? rn : en)(n, 1);
			x.version = o;
			var _ = a.get(t);
			_ && e.remove(_), a.set(t, x);
		}
		return {
			get: function (t, e) {
				var r = i.get(e);
				return (
					r ||
					(e.addEventListener('dispose', o),
					e.isBufferGeometry
						? (r = e)
						: e.isGeometry &&
						  (void 0 === e._bufferGeometry &&
								(e._bufferGeometry = new vn().setFromObject(t)),
						  (r = e._bufferGeometry)),
					i.set(e, r),
					n.memory.geometries++,
					r)
				);
			},
			update: function (t) {
				var n = t.attributes;
				for (var r in n) e.update(n[r], 34962);
				var i = t.morphAttributes;
				for (var a in i)
					for (var o = i[a], s = 0, c = o.length; s < c; s++)
						e.update(o[s], 34962);
			},
			getWireframeAttribute: function (t) {
				var e = a.get(t);
				if (e) {
					var n = t.index;
					null !== n && e.version < n.version && s(t);
				} else s(t);
				return a.get(t);
			},
		};
	}
	function dr(t, e, n, r) {
		var i,
			a,
			o,
			s = r.isWebGL2;
		(this.setMode = function (t) {
			i = t;
		}),
			(this.setIndex = function (t) {
				(a = t.type), (o = t.bytesPerElement);
			}),
			(this.render = function (e, r) {
				t.drawElements(i, r, a, e * o), n.update(r, i, 1);
			}),
			(this.renderInstances = function (r, c, l) {
				if (0 !== l) {
					var u, h;
					if (s) (u = t), (h = 'drawElementsInstanced');
					else if (
						((h = 'drawElementsInstancedANGLE'),
						null === (u = e.get('ANGLE_instanced_arrays')))
					)
						return void console.error(
							'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
						);
					u[h](i, c, a, r * o, l), n.update(c, i, l);
				}
			});
	}
	function pr(t) {
		var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
		return {
			memory: { geometries: 0, textures: 0 },
			render: e,
			programs: null,
			autoReset: !0,
			reset: function () {
				e.frame++,
					(e.calls = 0),
					(e.triangles = 0),
					(e.points = 0),
					(e.lines = 0);
			},
			update: function (t, n, r) {
				switch ((e.calls++, n)) {
					case 4:
						e.triangles += r * (t / 3);
						break;
					case 1:
						e.lines += r * (t / 2);
						break;
					case 3:
						e.lines += r * (t - 1);
						break;
					case 2:
						e.lines += r * t;
						break;
					case 0:
						e.points += r * t;
						break;
					default:
						console.error('THREE.WebGLInfo: Unknown draw mode:', n);
				}
			},
		};
	}
	function fr(t, e) {
		return t[0] - e[0];
	}
	function mr(t, e) {
		return Math.abs(e[1]) - Math.abs(t[1]);
	}
	function vr(t) {
		for (var e = {}, n = new Float32Array(8), r = [], i = 0; i < 8; i++)
			r[i] = [i, 0];
		return {
			update: function (i, a, o, s) {
				var c = i.morphTargetInfluences,
					l = void 0 === c ? 0 : c.length,
					u = e[a.id];
				if (void 0 === u) {
					u = [];
					for (var h = 0; h < l; h++) u[h] = [h, 0];
					e[a.id] = u;
				}
				for (var d = 0; d < l; d++) {
					var p = u[d];
					(p[0] = d), (p[1] = c[d]);
				}
				u.sort(mr);
				for (var f = 0; f < 8; f++)
					f < l && u[f][1]
						? ((r[f][0] = u[f][0]), (r[f][1] = u[f][1]))
						: ((r[f][0] = Number.MAX_SAFE_INTEGER), (r[f][1] = 0));
				r.sort(fr);
				for (
					var m = o.morphTargets && a.morphAttributes.position,
						v = o.morphNormals && a.morphAttributes.normal,
						g = 0,
						y = 0;
					y < 8;
					y++
				) {
					var x = r[y],
						_ = x[0],
						b = x[1];
					_ !== Number.MAX_SAFE_INTEGER && b
						? (m &&
								a.getAttribute('morphTarget' + y) !== m[_] &&
								a.setAttribute('morphTarget' + y, m[_]),
						  v &&
								a.getAttribute('morphNormal' + y) !== v[_] &&
								a.setAttribute('morphNormal' + y, v[_]),
						  (n[y] = b),
						  (g += b))
						: (m &&
								void 0 !== a.getAttribute('morphTarget' + y) &&
								a.deleteAttribute('morphTarget' + y),
						  v &&
								void 0 !== a.getAttribute('morphNormal' + y) &&
								a.deleteAttribute('morphNormal' + y),
						  (n[y] = 0));
				}
				var w = a.morphTargetsRelative ? 1 : 1 - g;
				s.getUniforms().setValue(t, 'morphTargetBaseInfluence', w),
					s.getUniforms().setValue(t, 'morphTargetInfluences', n);
			},
		};
	}
	function gr(t, e, n, r) {
		var i = new WeakMap();
		return {
			update: function (t) {
				var a = r.render.frame,
					o = t.geometry,
					s = e.get(t, o);
				return (
					i.get(s) !== a &&
						(o.isGeometry && s.updateFromObject(t), e.update(s), i.set(s, a)),
					t.isInstancedMesh &&
						(n.update(t.instanceMatrix, 34962),
						null !== t.instanceColor && n.update(t.instanceColor, 34962)),
					s
				);
			},
			dispose: function () {
				i = new WeakMap();
			},
		};
	}
	function yr(t, e, n, r) {
		gt.call(this, null),
			(this.image = {
				data: t || null,
				width: e || 1,
				height: n || 1,
				depth: r || 1,
			}),
			(this.magFilter = d),
			(this.minFilter = d),
			(this.wrapR = u),
			(this.generateMipmaps = !1),
			(this.flipY = !1),
			(this.needsUpdate = !0);
	}
	function xr(t, e, n, r) {
		gt.call(this, null),
			(this.image = {
				data: t || null,
				width: e || 1,
				height: n || 1,
				depth: r || 1,
			}),
			(this.magFilter = d),
			(this.minFilter = d),
			(this.wrapR = u),
			(this.generateMipmaps = !1),
			(this.flipY = !1),
			(this.needsUpdate = !0);
	}
	(rr.physical = {
		uniforms: Fn([
			rr.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new pt(1, 1) },
				clearcoatNormalMap: { value: null },
				sheen: { value: new Ve(0) },
				transmission: { value: 0 },
				transmissionMap: { value: null },
			},
		]),
		vertexShader: er.meshphysical_vert,
		fragmentShader: er.meshphysical_frag,
	}),
		(yr.prototype = Object.create(gt.prototype)),
		(yr.prototype.constructor = yr),
		(yr.prototype.isDataTexture2DArray = !0),
		(xr.prototype = Object.create(gt.prototype)),
		(xr.prototype.constructor = xr),
		(xr.prototype.isDataTexture3D = !0);
	var _r = new gt(),
		br = new yr(),
		wr = new xr(),
		Mr = new qn(),
		Sr = [],
		Tr = [],
		Er = new Float32Array(16),
		Ar = new Float32Array(9),
		Lr = new Float32Array(4);
	function Rr(t, e, n) {
		var r = t[0];
		if (r <= 0 || r > 0) return t;
		var i = e * n,
			a = Sr[i];
		if ((void 0 === a && ((a = new Float32Array(i)), (Sr[i] = a)), 0 !== e)) {
			r.toArray(a, 0);
			for (var o = 1, s = 0; o !== e; ++o) (s += n), t[o].toArray(a, s);
		}
		return a;
	}
	function Cr(t, e) {
		if (t.length !== e.length) return !1;
		for (var n = 0, r = t.length; n < r; n++) if (t[n] !== e[n]) return !1;
		return !0;
	}
	function Pr(t, e) {
		for (var n = 0, r = e.length; n < r; n++) t[n] = e[n];
	}
	function Ir(t, e) {
		var n = Tr[e];
		void 0 === n && ((n = new Int32Array(e)), (Tr[e] = n));
		for (var r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
		return n;
	}
	function Dr(t, e) {
		var n = this.cache;
		n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
	}
	function Nr(t, e) {
		var n = this.cache;
		if (void 0 !== e.x)
			(n[0] === e.x && n[1] === e.y) ||
				(t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
		else {
			if (Cr(n, e)) return;
			t.uniform2fv(this.addr, e), Pr(n, e);
		}
	}
	function Or(t, e) {
		var n = this.cache;
		if (void 0 !== e.x)
			(n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
				(t.uniform3f(this.addr, e.x, e.y, e.z),
				(n[0] = e.x),
				(n[1] = e.y),
				(n[2] = e.z));
		else if (void 0 !== e.r)
			(n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
				(t.uniform3f(this.addr, e.r, e.g, e.b),
				(n[0] = e.r),
				(n[1] = e.g),
				(n[2] = e.b));
		else {
			if (Cr(n, e)) return;
			t.uniform3fv(this.addr, e), Pr(n, e);
		}
	}
	function Br(t, e) {
		var n = this.cache;
		if (void 0 !== e.x)
			(n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
				(t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
				(n[0] = e.x),
				(n[1] = e.y),
				(n[2] = e.z),
				(n[3] = e.w));
		else {
			if (Cr(n, e)) return;
			t.uniform4fv(this.addr, e), Pr(n, e);
		}
	}
	function zr(t, e) {
		var n = this.cache,
			r = e.elements;
		if (void 0 === r) {
			if (Cr(n, e)) return;
			t.uniformMatrix2fv(this.addr, !1, e), Pr(n, e);
		} else {
			if (Cr(n, r)) return;
			Lr.set(r), t.uniformMatrix2fv(this.addr, !1, Lr), Pr(n, r);
		}
	}
	function Gr(t, e) {
		var n = this.cache,
			r = e.elements;
		if (void 0 === r) {
			if (Cr(n, e)) return;
			t.uniformMatrix3fv(this.addr, !1, e), Pr(n, e);
		} else {
			if (Cr(n, r)) return;
			Ar.set(r), t.uniformMatrix3fv(this.addr, !1, Ar), Pr(n, r);
		}
	}
	function Fr(t, e) {
		var n = this.cache,
			r = e.elements;
		if (void 0 === r) {
			if (Cr(n, e)) return;
			t.uniformMatrix4fv(this.addr, !1, e), Pr(n, e);
		} else {
			if (Cr(n, r)) return;
			Er.set(r), t.uniformMatrix4fv(this.addr, !1, Er), Pr(n, r);
		}
	}
	function Ur(t, e, n) {
		var r = this.cache,
			i = n.allocateTextureUnit();
		r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
			n.safeSetTexture2D(e || _r, i);
	}
	function Hr(t, e, n) {
		var r = this.cache,
			i = n.allocateTextureUnit();
		r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
			n.setTexture2DArray(e || br, i);
	}
	function kr(t, e, n) {
		var r = this.cache,
			i = n.allocateTextureUnit();
		r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
			n.setTexture3D(e || wr, i);
	}
	function Vr(t, e, n) {
		var r = this.cache,
			i = n.allocateTextureUnit();
		r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
			n.safeSetTextureCube(e || Mr, i);
	}
	function Wr(t, e) {
		var n = this.cache;
		n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
	}
	function jr(t, e) {
		var n = this.cache;
		Cr(n, e) || (t.uniform2iv(this.addr, e), Pr(n, e));
	}
	function qr(t, e) {
		var n = this.cache;
		Cr(n, e) || (t.uniform3iv(this.addr, e), Pr(n, e));
	}
	function Xr(t, e) {
		var n = this.cache;
		Cr(n, e) || (t.uniform4iv(this.addr, e), Pr(n, e));
	}
	function Yr(t, e) {
		var n = this.cache;
		n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
	}
	function Zr(t, e) {
		t.uniform1fv(this.addr, e);
	}
	function Jr(t, e) {
		t.uniform1iv(this.addr, e);
	}
	function Qr(t, e) {
		t.uniform2iv(this.addr, e);
	}
	function Kr(t, e) {
		t.uniform3iv(this.addr, e);
	}
	function $r(t, e) {
		t.uniform4iv(this.addr, e);
	}
	function ti(t, e) {
		var n = Rr(e, this.size, 2);
		t.uniform2fv(this.addr, n);
	}
	function ei(t, e) {
		var n = Rr(e, this.size, 3);
		t.uniform3fv(this.addr, n);
	}
	function ni(t, e) {
		var n = Rr(e, this.size, 4);
		t.uniform4fv(this.addr, n);
	}
	function ri(t, e) {
		var n = Rr(e, this.size, 4);
		t.uniformMatrix2fv(this.addr, !1, n);
	}
	function ii(t, e) {
		var n = Rr(e, this.size, 9);
		t.uniformMatrix3fv(this.addr, !1, n);
	}
	function ai(t, e) {
		var n = Rr(e, this.size, 16);
		t.uniformMatrix4fv(this.addr, !1, n);
	}
	function oi(t, e, n) {
		var r = e.length,
			i = Ir(n, r);
		t.uniform1iv(this.addr, i);
		for (var a = 0; a !== r; ++a) n.safeSetTexture2D(e[a] || _r, i[a]);
	}
	function si(t, e, n) {
		var r = e.length,
			i = Ir(n, r);
		t.uniform1iv(this.addr, i);
		for (var a = 0; a !== r; ++a) n.safeSetTextureCube(e[a] || Mr, i[a]);
	}
	function ci(t, e, n) {
		(this.id = t),
			(this.addr = n),
			(this.cache = []),
			(this.setValue = (function (t) {
				switch (t) {
					case 5126:
						return Dr;
					case 35664:
						return Nr;
					case 35665:
						return Or;
					case 35666:
						return Br;
					case 35674:
						return zr;
					case 35675:
						return Gr;
					case 35676:
						return Fr;
					case 5124:
					case 35670:
						return Wr;
					case 35667:
					case 35671:
						return jr;
					case 35668:
					case 35672:
						return qr;
					case 35669:
					case 35673:
						return Xr;
					case 5125:
						return Yr;
					case 35678:
					case 36198:
					case 36298:
					case 36306:
					case 35682:
						return Ur;
					case 35679:
					case 36299:
					case 36307:
						return kr;
					case 35680:
					case 36300:
					case 36308:
					case 36293:
						return Vr;
					case 36289:
					case 36303:
					case 36311:
					case 36292:
						return Hr;
				}
			})(e.type));
	}
	function li(t, e, n) {
		(this.id = t),
			(this.addr = n),
			(this.cache = []),
			(this.size = e.size),
			(this.setValue = (function (t) {
				switch (t) {
					case 5126:
						return Zr;
					case 35664:
						return ti;
					case 35665:
						return ei;
					case 35666:
						return ni;
					case 35674:
						return ri;
					case 35675:
						return ii;
					case 35676:
						return ai;
					case 5124:
					case 35670:
						return Jr;
					case 35667:
					case 35671:
						return Qr;
					case 35668:
					case 35672:
						return Kr;
					case 35669:
					case 35673:
						return $r;
					case 35678:
					case 36198:
					case 36298:
					case 36306:
					case 35682:
						return oi;
					case 35680:
					case 36300:
					case 36308:
					case 36293:
						return si;
				}
			})(e.type));
	}
	function ui(t) {
		(this.id = t), (this.seq = []), (this.map = {});
	}
	(li.prototype.updateCache = function (t) {
		var e = this.cache;
		t instanceof Float32Array &&
			e.length !== t.length &&
			(this.cache = new Float32Array(t.length)),
			Pr(e, t);
	}),
		(ui.prototype.setValue = function (t, e, n) {
			for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
				var o = r[i];
				o.setValue(t, e[o.id], n);
			}
		});
	var hi = /([\w\d_]+)(\])?(\[|\.)?/g;
	function di(t, e) {
		t.seq.push(e), (t.map[e.id] = e);
	}
	function pi(t, e, n) {
		var r = t.name,
			i = r.length;
		for (hi.lastIndex = 0; ; ) {
			var a = hi.exec(r),
				o = hi.lastIndex,
				s = a[1],
				c = ']' === a[2],
				l = a[3];
			if ((c && (s |= 0), void 0 === l || ('[' === l && o + 2 === i))) {
				di(n, void 0 === l ? new ci(s, t, e) : new li(s, t, e));
				break;
			}
			var u = n.map[s];
			void 0 === u && di(n, (u = new ui(s))), (n = u);
		}
	}
	function fi(t, e) {
		(this.seq = []), (this.map = {});
		for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
			var i = t.getActiveUniform(e, r);
			pi(i, t.getUniformLocation(e, i.name), this);
		}
	}
	function mi(t, e, n) {
		var r = t.createShader(e);
		return t.shaderSource(r, n), t.compileShader(r), r;
	}
	(fi.prototype.setValue = function (t, e, n, r) {
		var i = this.map[e];
		void 0 !== i && i.setValue(t, n, r);
	}),
		(fi.prototype.setOptional = function (t, e, n) {
			var r = e[n];
			void 0 !== r && this.setValue(t, n, r);
		}),
		(fi.upload = function (t, e, n, r) {
			for (var i = 0, a = e.length; i !== a; ++i) {
				var o = e[i],
					s = n[o.id];
				!1 !== s.needsUpdate && o.setValue(t, s.value, r);
			}
		}),
		(fi.seqWithValue = function (t, e) {
			for (var n = [], r = 0, i = t.length; r !== i; ++r) {
				var a = t[r];
				a.id in e && n.push(a);
			}
			return n;
		});
	var vi = 0;
	function gi(t) {
		switch (t) {
			case q:
				return ['Linear', '( value )'];
			case X:
				return ['sRGB', '( value )'];
			case Z:
				return ['RGBE', '( value )'];
			case J:
				return ['RGBM', '( value, 7.0 )'];
			case Q:
				return ['RGBM', '( value, 16.0 )'];
			case K:
				return ['RGBD', '( value, 256.0 )'];
			case Y:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
			case 3003:
				return ['LogLuv', '( value )'];
			default:
				return (
					console.warn('THREE.WebGLProgram: Unsupported encoding:', t),
					['Linear', '( value )']
				);
		}
	}
	function yi(t, e, n) {
		var r = t.getShaderParameter(e, 35713),
			i = t.getShaderInfoLog(e).trim();
		return r && '' === i
			? ''
			: 'THREE.WebGLShader: gl.getShaderInfoLog() ' +
					n +
					'\n' +
					i +
					(function (t) {
						for (var e = t.split('\n'), n = 0; n < e.length; n++)
							e[n] = n + 1 + ': ' + e[n];
						return e.join('\n');
					})(t.getShaderSource(e));
	}
	function xi(t, e) {
		var n = gi(e);
		return (
			'vec4 ' +
			t +
			'( vec4 value ) { return ' +
			n[0] +
			'ToLinear' +
			n[1] +
			'; }'
		);
	}
	function _i(t, e) {
		var n;
		switch (e) {
			case 1:
				n = 'Linear';
				break;
			case 2:
				n = 'Reinhard';
				break;
			case 3:
				n = 'OptimizedCineon';
				break;
			case 4:
				n = 'ACESFilmic';
				break;
			case 5:
				n = 'Custom';
				break;
			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
					(n = 'Linear');
		}
		return (
			'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
		);
	}
	function bi(t) {
		return '' !== t;
	}
	function wi(t, e) {
		return t
			.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
			.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
			.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
			.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
	}
	function Mi(t, e) {
		return t
			.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
			.replace(
				/UNION_CLIPPING_PLANES/g,
				e.numClippingPlanes - e.numClipIntersection
			);
	}
	var Si = /^[ \t]*#include +<([\w\d./]+)>/gm;
	function Ti(t) {
		return t.replace(Si, Ei);
	}
	function Ei(t, e) {
		var n = er[e];
		if (void 0 === n) throw new Error('Can not resolve #include <' + e + '>');
		return Ti(n);
	}
	var Ai =
			/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
		Li =
			/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
	function Ri(t) {
		return t.replace(Li, Pi).replace(Ai, Ci);
	}
	function Ci(t, e, n, r) {
		return (
			console.warn(
				'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.'
			),
			Pi(t, e, n, r)
		);
	}
	function Pi(t, e, n, r) {
		for (var i = '', a = parseInt(e); a < parseInt(n); a++)
			i += r
				.replace(/\[\s*i\s*\]/g, '[ ' + a + ' ]')
				.replace(/UNROLLED_LOOP_INDEX/g, a);
		return i;
	}
	function Ii(t) {
		var e =
			'precision ' +
			t.precision +
			' float;\nprecision ' +
			t.precision +
			' int;';
		return (
			'highp' === t.precision
				? (e += '\n#define HIGH_PRECISION')
				: 'mediump' === t.precision
				? (e += '\n#define MEDIUM_PRECISION')
				: 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
			e
		);
	}
	function Di(t, e, n, a) {
		var o,
			l,
			u,
			h,
			d,
			p = t.getContext(),
			f = n.defines,
			m = n.vertexShader,
			v = n.fragmentShader,
			g = (function (t) {
				var e = 'SHADOWMAP_TYPE_BASIC';
				return (
					1 === t.shadowMapType
						? (e = 'SHADOWMAP_TYPE_PCF')
						: 2 === t.shadowMapType
						? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
						: 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
					e
				);
			})(n),
			y = (function (t) {
				var e = 'ENVMAP_TYPE_CUBE';
				if (t.envMap)
					switch (t.envMapMode) {
						case r:
						case i:
							e = 'ENVMAP_TYPE_CUBE';
							break;
						case s:
						case c:
							e = 'ENVMAP_TYPE_CUBE_UV';
					}
				return e;
			})(n),
			x = (function (t) {
				var e = 'ENVMAP_MODE_REFLECTION';
				if (t.envMap)
					switch (t.envMapMode) {
						case i:
						case c:
							e = 'ENVMAP_MODE_REFRACTION';
					}
				return e;
			})(n),
			_ = (function (t) {
				var e = 'ENVMAP_BLENDING_NONE';
				if (t.envMap)
					switch (t.combine) {
						case 0:
							e = 'ENVMAP_BLENDING_MULTIPLY';
							break;
						case 1:
							e = 'ENVMAP_BLENDING_MIX';
							break;
						case 2:
							e = 'ENVMAP_BLENDING_ADD';
					}
				return e;
			})(n),
			b = t.gammaFactor > 0 ? t.gammaFactor : 1,
			w = n.isWebGL2
				? ''
				: (function (t) {
						return [
							t.extensionDerivatives ||
							t.envMapCubeUV ||
							t.bumpMap ||
							t.tangentSpaceNormalMap ||
							t.clearcoatNormalMap ||
							t.flatShading ||
							'physical' === t.shaderID
								? '#extension GL_OES_standard_derivatives : enable'
								: '',
							(t.extensionFragDepth || t.logarithmicDepthBuffer) &&
							t.rendererExtensionFragDepth
								? '#extension GL_EXT_frag_depth : enable'
								: '',
							t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
								? '#extension GL_EXT_draw_buffers : require'
								: '',
							(t.extensionShaderTextureLOD || t.envMap) &&
							t.rendererExtensionShaderTextureLod
								? '#extension GL_EXT_shader_texture_lod : enable'
								: '',
						]
							.filter(bi)
							.join('\n');
				  })(n),
			M = (function (t) {
				var e = [];
				for (var n in t) {
					var r = t[n];
					!1 !== r && e.push('#define ' + n + ' ' + r);
				}
				return e.join('\n');
			})(f),
			S = p.createProgram(),
			T = n.glslVersion ? '#version ' + n.glslVersion + '\n' : '';
		n.isRawShaderMaterial
			? ((o = [M].filter(bi).join('\n')).length > 0 && (o += '\n'),
			  (l = [w, M].filter(bi).join('\n')).length > 0 && (l += '\n'))
			: ((o = [
					Ii(n),
					'#define SHADER_NAME ' + n.shaderName,
					M,
					n.instancing ? '#define USE_INSTANCING' : '',
					n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
					n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
					'#define GAMMA_FACTOR ' + b,
					'#define MAX_BONES ' + n.maxBones,
					n.useFog && n.fog ? '#define USE_FOG' : '',
					n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
					n.map ? '#define USE_MAP' : '',
					n.envMap ? '#define USE_ENVMAP' : '',
					n.envMap ? '#define ' + x : '',
					n.lightMap ? '#define USE_LIGHTMAP' : '',
					n.aoMap ? '#define USE_AOMAP' : '',
					n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					n.bumpMap ? '#define USE_BUMPMAP' : '',
					n.normalMap ? '#define USE_NORMALMAP' : '',
					n.normalMap && n.objectSpaceNormalMap
						? '#define OBJECTSPACE_NORMALMAP'
						: '',
					n.normalMap && n.tangentSpaceNormalMap
						? '#define TANGENTSPACE_NORMALMAP'
						: '',
					n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
					n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
					n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
					n.displacementMap && n.supportsVertexTextures
						? '#define USE_DISPLACEMENTMAP'
						: '',
					n.specularMap ? '#define USE_SPECULARMAP' : '',
					n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					n.metalnessMap ? '#define USE_METALNESSMAP' : '',
					n.alphaMap ? '#define USE_ALPHAMAP' : '',
					n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
					n.vertexTangents ? '#define USE_TANGENT' : '',
					n.vertexColors ? '#define USE_COLOR' : '',
					n.vertexUvs ? '#define USE_UV' : '',
					n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
					n.flatShading ? '#define FLAT_SHADED' : '',
					n.skinning ? '#define USE_SKINNING' : '',
					n.useVertexTexture ? '#define BONE_TEXTURE' : '',
					n.morphTargets ? '#define USE_MORPHTARGETS' : '',
					n.morphNormals && !1 === n.flatShading
						? '#define USE_MORPHNORMALS'
						: '',
					n.doubleSided ? '#define DOUBLE_SIDED' : '',
					n.flipSided ? '#define FLIP_SIDED' : '',
					n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					n.shadowMapEnabled ? '#define ' + g : '',
					n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
					n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
						? '#define USE_LOGDEPTHBUF_EXT'
						: '',
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
					'uniform bool isOrthographic;',
					'#ifdef USE_INSTANCING',
					'\tattribute mat4 instanceMatrix;',
					'#endif',
					'#ifdef USE_INSTANCING_COLOR',
					'\tattribute vec3 instanceColor;',
					'#endif',
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
					'#ifdef USE_TANGENT',
					'\tattribute vec4 tangent;',
					'#endif',
					'#ifdef USE_COLOR',
					'\tattribute vec3 color;',
					'#endif',
					'#ifdef USE_MORPHTARGETS',
					'\tattribute vec3 morphTarget0;',
					'\tattribute vec3 morphTarget1;',
					'\tattribute vec3 morphTarget2;',
					'\tattribute vec3 morphTarget3;',
					'\t#ifdef USE_MORPHNORMALS',
					'\t\tattribute vec3 morphNormal0;',
					'\t\tattribute vec3 morphNormal1;',
					'\t\tattribute vec3 morphNormal2;',
					'\t\tattribute vec3 morphNormal3;',
					'\t#else',
					'\t\tattribute vec3 morphTarget4;',
					'\t\tattribute vec3 morphTarget5;',
					'\t\tattribute vec3 morphTarget6;',
					'\t\tattribute vec3 morphTarget7;',
					'\t#endif',
					'#endif',
					'#ifdef USE_SKINNING',
					'\tattribute vec4 skinIndex;',
					'\tattribute vec4 skinWeight;',
					'#endif',
					'\n',
			  ]
					.filter(bi)
					.join('\n')),
			  (l = [
					w,
					Ii(n),
					'#define SHADER_NAME ' + n.shaderName,
					M,
					n.alphaTest
						? '#define ALPHATEST ' + n.alphaTest + (n.alphaTest % 1 ? '' : '.0')
						: '',
					'#define GAMMA_FACTOR ' + b,
					n.useFog && n.fog ? '#define USE_FOG' : '',
					n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
					n.map ? '#define USE_MAP' : '',
					n.matcap ? '#define USE_MATCAP' : '',
					n.envMap ? '#define USE_ENVMAP' : '',
					n.envMap ? '#define ' + y : '',
					n.envMap ? '#define ' + x : '',
					n.envMap ? '#define ' + _ : '',
					n.lightMap ? '#define USE_LIGHTMAP' : '',
					n.aoMap ? '#define USE_AOMAP' : '',
					n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					n.bumpMap ? '#define USE_BUMPMAP' : '',
					n.normalMap ? '#define USE_NORMALMAP' : '',
					n.normalMap && n.objectSpaceNormalMap
						? '#define OBJECTSPACE_NORMALMAP'
						: '',
					n.normalMap && n.tangentSpaceNormalMap
						? '#define TANGENTSPACE_NORMALMAP'
						: '',
					n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
					n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
					n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
					n.specularMap ? '#define USE_SPECULARMAP' : '',
					n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					n.metalnessMap ? '#define USE_METALNESSMAP' : '',
					n.alphaMap ? '#define USE_ALPHAMAP' : '',
					n.sheen ? '#define USE_SHEEN' : '',
					n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
					n.vertexTangents ? '#define USE_TANGENT' : '',
					n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
					n.vertexUvs ? '#define USE_UV' : '',
					n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
					n.gradientMap ? '#define USE_GRADIENTMAP' : '',
					n.flatShading ? '#define FLAT_SHADED' : '',
					n.doubleSided ? '#define DOUBLE_SIDED' : '',
					n.flipSided ? '#define FLIP_SIDED' : '',
					n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					n.shadowMapEnabled ? '#define ' + g : '',
					n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
					n.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
					n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
						? '#define USE_LOGDEPTHBUF_EXT'
						: '',
					(n.extensionShaderTextureLOD || n.envMap) &&
					n.rendererExtensionShaderTextureLod
						? '#define TEXTURE_LOD_EXT'
						: '',
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
					'uniform bool isOrthographic;',
					0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
					0 !== n.toneMapping ? er.tonemapping_pars_fragment : '',
					0 !== n.toneMapping ? _i('toneMapping', n.toneMapping) : '',
					n.dithering ? '#define DITHERING' : '',
					er.encodings_pars_fragment,
					n.map ? xi('mapTexelToLinear', n.mapEncoding) : '',
					n.matcap ? xi('matcapTexelToLinear', n.matcapEncoding) : '',
					n.envMap ? xi('envMapTexelToLinear', n.envMapEncoding) : '',
					n.emissiveMap
						? xi('emissiveMapTexelToLinear', n.emissiveMapEncoding)
						: '',
					n.lightMap ? xi('lightMapTexelToLinear', n.lightMapEncoding) : '',
					((u = 'linearToOutputTexel'),
					(h = n.outputEncoding),
					(d = gi(h)),
					'vec4 ' +
						u +
						'( vec4 value ) { return LinearTo' +
						d[0] +
						d[1] +
						'; }'),
					n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
					'\n',
			  ]
					.filter(bi)
					.join('\n'))),
			(m = Mi((m = wi((m = Ti(m)), n)), n)),
			(v = Mi((v = wi((v = Ti(v)), n)), n)),
			(m = Ri(m)),
			(v = Ri(v)),
			n.isWebGL2 &&
				!0 !== n.isRawShaderMaterial &&
				((T = '#version 300 es\n'),
				(o =
					[
						'#define attribute in',
						'#define varying out',
						'#define texture2D texture',
					].join('\n') +
					'\n' +
					o),
				(l =
					[
						'#define varying in',
						n.glslVersion === nt ? '' : 'out highp vec4 pc_fragColor;',
						n.glslVersion === nt ? '' : '#define gl_FragColor pc_fragColor',
						'#define gl_FragDepthEXT gl_FragDepth',
						'#define texture2D texture',
						'#define textureCube texture',
						'#define texture2DProj textureProj',
						'#define texture2DLodEXT textureLod',
						'#define texture2DProjLodEXT textureProjLod',
						'#define textureCubeLodEXT textureLod',
						'#define texture2DGradEXT textureGrad',
						'#define texture2DProjGradEXT textureProjGrad',
						'#define textureCubeGradEXT textureGrad',
					].join('\n') +
					'\n' +
					l));
		var E,
			A,
			L = T + l + v,
			R = mi(p, 35633, T + o + m),
			C = mi(p, 35632, L);
		if (
			(p.attachShader(S, R),
			p.attachShader(S, C),
			void 0 !== n.index0AttributeName
				? p.bindAttribLocation(S, 0, n.index0AttributeName)
				: !0 === n.morphTargets && p.bindAttribLocation(S, 0, 'position'),
			p.linkProgram(S),
			t.debug.checkShaderErrors)
		) {
			var P = p.getProgramInfoLog(S).trim(),
				I = p.getShaderInfoLog(R).trim(),
				D = p.getShaderInfoLog(C).trim(),
				N = !0,
				O = !0;
			if (!1 === p.getProgramParameter(S, 35714)) {
				N = !1;
				var B = yi(p, R, 'vertex'),
					z = yi(p, C, 'fragment');
				console.error(
					'THREE.WebGLProgram: shader error: ',
					p.getError(),
					'35715',
					p.getProgramParameter(S, 35715),
					'gl.getProgramInfoLog',
					P,
					B,
					z
				);
			} else
				'' !== P
					? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', P)
					: ('' !== I && '' !== D) || (O = !1);
			O &&
				(this.diagnostics = {
					runnable: N,
					programLog: P,
					vertexShader: { log: I, prefix: o },
					fragmentShader: { log: D, prefix: l },
				});
		}
		return (
			p.deleteShader(R),
			p.deleteShader(C),
			(this.getUniforms = function () {
				return void 0 === E && (E = new fi(p, S)), E;
			}),
			(this.getAttributes = function () {
				return (
					void 0 === A &&
						(A = (function (t, e) {
							for (
								var n = {}, r = t.getProgramParameter(e, 35721), i = 0;
								i < r;
								i++
							) {
								var a = t.getActiveAttrib(e, i).name;
								n[a] = t.getAttribLocation(e, a);
							}
							return n;
						})(p, S)),
					A
				);
			}),
			(this.destroy = function () {
				a.releaseStatesOfProgram(this),
					p.deleteProgram(S),
					(this.program = void 0);
			}),
			(this.name = n.shaderName),
			(this.id = vi++),
			(this.cacheKey = e),
			(this.usedTimes = 1),
			(this.program = S),
			(this.vertexShader = R),
			(this.fragmentShader = C),
			this
		);
	}
	function Ni(t, e, n, r, i, a) {
		var o = [],
			l = r.isWebGL2,
			u = r.logarithmicDepthBuffer,
			h = r.floatVertexTextures,
			d = r.maxVertexUniforms,
			p = r.vertexTextures,
			f = r.precision,
			m = {
				MeshDepthMaterial: 'depth',
				MeshDistanceMaterial: 'distanceRGBA',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshToonMaterial: 'toon',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				MeshMatcapMaterial: 'matcap',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points',
				ShadowMaterial: 'shadow',
				SpriteMaterial: 'sprite',
			},
			v = [
				'precision',
				'isWebGL2',
				'supportsVertexTextures',
				'outputEncoding',
				'instancing',
				'instancingColor',
				'map',
				'mapEncoding',
				'matcap',
				'matcapEncoding',
				'envMap',
				'envMapMode',
				'envMapEncoding',
				'envMapCubeUV',
				'lightMap',
				'lightMapEncoding',
				'aoMap',
				'emissiveMap',
				'emissiveMapEncoding',
				'bumpMap',
				'normalMap',
				'objectSpaceNormalMap',
				'tangentSpaceNormalMap',
				'clearcoatMap',
				'clearcoatRoughnessMap',
				'clearcoatNormalMap',
				'displacementMap',
				'specularMap',
				'roughnessMap',
				'metalnessMap',
				'gradientMap',
				'alphaMap',
				'combine',
				'vertexColors',
				'vertexTangents',
				'vertexUvs',
				'uvsVertexOnly',
				'fog',
				'useFog',
				'fogExp2',
				'flatShading',
				'sizeAttenuation',
				'logarithmicDepthBuffer',
				'skinning',
				'maxBones',
				'useVertexTexture',
				'morphTargets',
				'morphNormals',
				'maxMorphTargets',
				'maxMorphNormals',
				'premultipliedAlpha',
				'numDirLights',
				'numPointLights',
				'numSpotLights',
				'numHemiLights',
				'numRectAreaLights',
				'numDirLightShadows',
				'numPointLightShadows',
				'numSpotLightShadows',
				'shadowMapEnabled',
				'shadowMapType',
				'toneMapping',
				'physicallyCorrectLights',
				'alphaTest',
				'doubleSided',
				'flipSided',
				'numClippingPlanes',
				'numClipIntersection',
				'depthPacking',
				'dithering',
				'sheen',
				'transmissionMap',
			];
		function g(t) {
			var e;
			return (
				t
					? t.isTexture
						? (e = t.encoding)
						: t.isWebGLRenderTarget &&
						  (console.warn(
								"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
						  ),
						  (e = t.texture.encoding))
					: (e = q),
				e
			);
		}
		return {
			getParameters: function (i, o, v, y, x) {
				var _,
					b,
					w = y.fog,
					M = i.isMeshStandardMaterial ? y.environment : null,
					S = e.get(i.envMap || M),
					T = m[i.type],
					E = x.isSkinnedMesh
						? (function (t) {
								var e = t.skeleton.bones;
								if (h) return 1024;
								var n = d,
									r = Math.floor((n - 20) / 4),
									i = Math.min(r, e.length);
								return i < e.length
									? (console.warn(
											'THREE.WebGLRenderer: Skeleton has ' +
												e.length +
												' bones. This GPU supports ' +
												i +
												'.'
									  ),
									  0)
									: i;
						  })(x)
						: 0;
				if (
					(null !== i.precision &&
						(f = r.getMaxPrecision(i.precision)) !== i.precision &&
						console.warn(
							'THREE.WebGLProgram.getParameters:',
							i.precision,
							'not supported, using',
							f,
							'instead.'
						),
					T)
				) {
					var A = rr[T];
					(_ = A.vertexShader), (b = A.fragmentShader);
				} else (_ = i.vertexShader), (b = i.fragmentShader);
				var L = t.getRenderTarget();
				return {
					isWebGL2: l,
					shaderID: T,
					shaderName: i.type,
					vertexShader: _,
					fragmentShader: b,
					defines: i.defines,
					isRawShaderMaterial: !0 === i.isRawShaderMaterial,
					glslVersion: i.glslVersion,
					precision: f,
					instancing: !0 === x.isInstancedMesh,
					instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor,
					supportsVertexTextures: p,
					outputEncoding: null !== L ? g(L.texture) : t.outputEncoding,
					map: !!i.map,
					mapEncoding: g(i.map),
					matcap: !!i.matcap,
					matcapEncoding: g(i.matcap),
					envMap: !!S,
					envMapMode: S && S.mapping,
					envMapEncoding: g(S),
					envMapCubeUV: !!S && (S.mapping === s || S.mapping === c),
					lightMap: !!i.lightMap,
					lightMapEncoding: g(i.lightMap),
					aoMap: !!i.aoMap,
					emissiveMap: !!i.emissiveMap,
					emissiveMapEncoding: g(i.emissiveMap),
					bumpMap: !!i.bumpMap,
					normalMap: !!i.normalMap,
					objectSpaceNormalMap: 1 === i.normalMapType,
					tangentSpaceNormalMap: 0 === i.normalMapType,
					clearcoatMap: !!i.clearcoatMap,
					clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
					clearcoatNormalMap: !!i.clearcoatNormalMap,
					displacementMap: !!i.displacementMap,
					roughnessMap: !!i.roughnessMap,
					metalnessMap: !!i.metalnessMap,
					specularMap: !!i.specularMap,
					alphaMap: !!i.alphaMap,
					gradientMap: !!i.gradientMap,
					sheen: !!i.sheen,
					transmissionMap: !!i.transmissionMap,
					combine: i.combine,
					vertexTangents: i.normalMap && i.vertexTangents,
					vertexColors: i.vertexColors,
					vertexUvs: !!(
						i.map ||
						i.bumpMap ||
						i.normalMap ||
						i.specularMap ||
						i.alphaMap ||
						i.emissiveMap ||
						i.roughnessMap ||
						i.metalnessMap ||
						i.clearcoatMap ||
						i.clearcoatRoughnessMap ||
						i.clearcoatNormalMap ||
						i.displacementMap ||
						i.transmissionMap
					),
					uvsVertexOnly: !(
						i.map ||
						i.bumpMap ||
						i.normalMap ||
						i.specularMap ||
						i.alphaMap ||
						i.emissiveMap ||
						i.roughnessMap ||
						i.metalnessMap ||
						i.clearcoatNormalMap ||
						i.transmissionMap ||
						!i.displacementMap
					),
					fog: !!w,
					useFog: i.fog,
					fogExp2: w && w.isFogExp2,
					flatShading: i.flatShading,
					sizeAttenuation: i.sizeAttenuation,
					logarithmicDepthBuffer: u,
					skinning: i.skinning && E > 0,
					maxBones: E,
					useVertexTexture: h,
					morphTargets: i.morphTargets,
					morphNormals: i.morphNormals,
					maxMorphTargets: t.maxMorphTargets,
					maxMorphNormals: t.maxMorphNormals,
					numDirLights: o.directional.length,
					numPointLights: o.point.length,
					numSpotLights: o.spot.length,
					numRectAreaLights: o.rectArea.length,
					numHemiLights: o.hemi.length,
					numDirLightShadows: o.directionalShadowMap.length,
					numPointLightShadows: o.pointShadowMap.length,
					numSpotLightShadows: o.spotShadowMap.length,
					numClippingPlanes: a.numPlanes,
					numClipIntersection: a.numIntersection,
					dithering: i.dithering,
					shadowMapEnabled: t.shadowMap.enabled && v.length > 0,
					shadowMapType: t.shadowMap.type,
					toneMapping: i.toneMapped ? t.toneMapping : 0,
					physicallyCorrectLights: t.physicallyCorrectLights,
					premultipliedAlpha: i.premultipliedAlpha,
					alphaTest: i.alphaTest,
					doubleSided: 2 === i.side,
					flipSided: 1 === i.side,
					depthPacking: void 0 !== i.depthPacking && i.depthPacking,
					index0AttributeName: i.index0AttributeName,
					extensionDerivatives: i.extensions && i.extensions.derivatives,
					extensionFragDepth: i.extensions && i.extensions.fragDepth,
					extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
					extensionShaderTextureLOD:
						i.extensions && i.extensions.shaderTextureLOD,
					rendererExtensionFragDepth: l || n.has('EXT_frag_depth'),
					rendererExtensionDrawBuffers: l || n.has('WEBGL_draw_buffers'),
					rendererExtensionShaderTextureLod:
						l || n.has('EXT_shader_texture_lod'),
					customProgramCacheKey: i.customProgramCacheKey(),
				};
			},
			getProgramCacheKey: function (e) {
				var n = [];
				if (
					(e.shaderID
						? n.push(e.shaderID)
						: (n.push(e.fragmentShader), n.push(e.vertexShader)),
					void 0 !== e.defines)
				)
					for (var r in e.defines) n.push(r), n.push(e.defines[r]);
				if (!1 === e.isRawShaderMaterial) {
					for (var i = 0; i < v.length; i++) n.push(e[v[i]]);
					n.push(t.outputEncoding), n.push(t.gammaFactor);
				}
				return n.push(e.customProgramCacheKey), n.join();
			},
			getUniforms: function (t) {
				var e,
					n = m[t.type];
				if (n) {
					var r = rr[n];
					e = Un.clone(r.uniforms);
				} else e = t.uniforms;
				return e;
			},
			acquireProgram: function (e, n) {
				for (var r, a = 0, s = o.length; a < s; a++) {
					var c = o[a];
					if (c.cacheKey === n) {
						++(r = c).usedTimes;
						break;
					}
				}
				return void 0 === r && ((r = new Di(t, n, e, i)), o.push(r)), r;
			},
			releaseProgram: function (t) {
				if (0 == --t.usedTimes) {
					var e = o.indexOf(t);
					(o[e] = o[o.length - 1]), o.pop(), t.destroy();
				}
			},
			programs: o,
		};
	}
	function Oi() {
		var t = new WeakMap();
		return {
			get: function (e) {
				var n = t.get(e);
				return void 0 === n && ((n = {}), t.set(e, n)), n;
			},
			remove: function (e) {
				t.delete(e);
			},
			update: function (e, n, r) {
				t.get(e)[n] = r;
			},
			dispose: function () {
				t = new WeakMap();
			},
		};
	}
	function Bi(t, e) {
		return t.groupOrder !== e.groupOrder
			? t.groupOrder - e.groupOrder
			: t.renderOrder !== e.renderOrder
			? t.renderOrder - e.renderOrder
			: t.program !== e.program
			? t.program.id - e.program.id
			: t.material.id !== e.material.id
			? t.material.id - e.material.id
			: t.z !== e.z
			? t.z - e.z
			: t.id - e.id;
	}
	function zi(t, e) {
		return t.groupOrder !== e.groupOrder
			? t.groupOrder - e.groupOrder
			: t.renderOrder !== e.renderOrder
			? t.renderOrder - e.renderOrder
			: t.z !== e.z
			? e.z - t.z
			: t.id - e.id;
	}
	function Gi(t) {
		var e = [],
			n = 0,
			r = [],
			i = [],
			a = { id: -1 };
		function o(r, i, o, s, c, l) {
			var u = e[n],
				h = t.get(o);
			return (
				void 0 === u
					? ((u = {
							id: r.id,
							object: r,
							geometry: i,
							material: o,
							program: h.program || a,
							groupOrder: s,
							renderOrder: r.renderOrder,
							z: c,
							group: l,
					  }),
					  (e[n] = u))
					: ((u.id = r.id),
					  (u.object = r),
					  (u.geometry = i),
					  (u.material = o),
					  (u.program = h.program || a),
					  (u.groupOrder = s),
					  (u.renderOrder = r.renderOrder),
					  (u.z = c),
					  (u.group = l)),
				n++,
				u
			);
		}
		return {
			opaque: r,
			transparent: i,
			init: function () {
				(n = 0), (r.length = 0), (i.length = 0);
			},
			push: function (t, e, n, a, s, c) {
				var l = o(t, e, n, a, s, c);
				(!0 === n.transparent ? i : r).push(l);
			},
			unshift: function (t, e, n, a, s, c) {
				var l = o(t, e, n, a, s, c);
				(!0 === n.transparent ? i : r).unshift(l);
			},
			finish: function () {
				for (var t = n, r = e.length; t < r; t++) {
					var i = e[t];
					if (null === i.id) break;
					(i.id = null),
						(i.object = null),
						(i.geometry = null),
						(i.material = null),
						(i.program = null),
						(i.group = null);
				}
			},
			sort: function (t, e) {
				r.length > 1 && r.sort(t || Bi), i.length > 1 && i.sort(e || zi);
			},
		};
	}
	function Fi(t) {
		var e = new WeakMap();
		return {
			get: function (n, r) {
				var i,
					a = e.get(n);
				return (
					void 0 === a
						? ((i = new Gi(t)), e.set(n, new WeakMap()), e.get(n).set(r, i))
						: void 0 === (i = a.get(r)) && ((i = new Gi(t)), a.set(r, i)),
					i
				);
			},
			dispose: function () {
				e = new WeakMap();
			},
		};
	}
	function Ui() {
		var t = {};
		return {
			get: function (e) {
				if (void 0 !== t[e.id]) return t[e.id];
				var n;
				switch (e.type) {
					case 'DirectionalLight':
						n = { direction: new wt(), color: new Ve() };
						break;
					case 'SpotLight':
						n = {
							position: new wt(),
							direction: new wt(),
							color: new Ve(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,
						};
						break;
					case 'PointLight':
						n = { position: new wt(), color: new Ve(), distance: 0, decay: 0 };
						break;
					case 'HemisphereLight':
						n = {
							direction: new wt(),
							skyColor: new Ve(),
							groundColor: new Ve(),
						};
						break;
					case 'RectAreaLight':
						n = {
							color: new Ve(),
							position: new wt(),
							halfWidth: new wt(),
							halfHeight: new wt(),
						};
				}
				return (t[e.id] = n), n;
			},
		};
	}
	var Hi = 0;
	function ki(t, e) {
		return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
	}
	function Vi() {
		for (
			var t,
				e = new Ui(),
				n =
					((t = {}),
					{
						get: function (e) {
							if (void 0 !== t[e.id]) return t[e.id];
							var n;
							switch (e.type) {
								case 'DirectionalLight':
								case 'SpotLight':
									n = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new pt(),
									};
									break;
								case 'PointLight':
									n = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new pt(),
										shadowCameraNear: 1,
										shadowCameraFar: 1e3,
									};
							}
							return (t[e.id] = n), n;
						},
					}),
				r = {
					version: 0,
					hash: {
						directionalLength: -1,
						pointLength: -1,
						spotLength: -1,
						rectAreaLength: -1,
						hemiLength: -1,
						numDirectionalShadows: -1,
						numPointShadows: -1,
						numSpotShadows: -1,
					},
					ambient: [0, 0, 0],
					probe: [],
					directional: [],
					directionalShadow: [],
					directionalShadowMap: [],
					directionalShadowMatrix: [],
					spot: [],
					spotShadow: [],
					spotShadowMap: [],
					spotShadowMatrix: [],
					rectArea: [],
					rectAreaLTC1: null,
					rectAreaLTC2: null,
					point: [],
					pointShadow: [],
					pointShadowMap: [],
					pointShadowMatrix: [],
					hemi: [],
				},
				i = 0;
			i < 9;
			i++
		)
			r.probe.push(new wt());
		var a = new wt(),
			o = new Jt(),
			s = new Jt();
		return {
			setup: function (t, i, c) {
				for (var l = 0, u = 0, h = 0, d = 0; d < 9; d++)
					r.probe[d].set(0, 0, 0);
				var p = 0,
					f = 0,
					m = 0,
					v = 0,
					g = 0,
					y = 0,
					x = 0,
					_ = 0,
					b = c.matrixWorldInverse;
				t.sort(ki);
				for (var w = 0, M = t.length; w < M; w++) {
					var S = t[w],
						T = S.color,
						E = S.intensity,
						A = S.distance,
						L = S.shadow && S.shadow.map ? S.shadow.map.texture : null;
					if (S.isAmbientLight) (l += T.r * E), (u += T.g * E), (h += T.b * E);
					else if (S.isLightProbe)
						for (var R = 0; R < 9; R++)
							r.probe[R].addScaledVector(S.sh.coefficients[R], E);
					else if (S.isDirectionalLight) {
						var C = e.get(S);
						if (
							(C.color.copy(S.color).multiplyScalar(S.intensity),
							C.direction.setFromMatrixPosition(S.matrixWorld),
							a.setFromMatrixPosition(S.target.matrixWorld),
							C.direction.sub(a),
							C.direction.transformDirection(b),
							S.castShadow)
						) {
							var P = S.shadow,
								I = n.get(S);
							(I.shadowBias = P.bias),
								(I.shadowNormalBias = P.normalBias),
								(I.shadowRadius = P.radius),
								(I.shadowMapSize = P.mapSize),
								(r.directionalShadow[p] = I),
								(r.directionalShadowMap[p] = L),
								(r.directionalShadowMatrix[p] = S.shadow.matrix),
								y++;
						}
						(r.directional[p] = C), p++;
					} else if (S.isSpotLight) {
						var D = e.get(S);
						if (
							(D.position.setFromMatrixPosition(S.matrixWorld),
							D.position.applyMatrix4(b),
							D.color.copy(T).multiplyScalar(E),
							(D.distance = A),
							D.direction.setFromMatrixPosition(S.matrixWorld),
							a.setFromMatrixPosition(S.target.matrixWorld),
							D.direction.sub(a),
							D.direction.transformDirection(b),
							(D.coneCos = Math.cos(S.angle)),
							(D.penumbraCos = Math.cos(S.angle * (1 - S.penumbra))),
							(D.decay = S.decay),
							S.castShadow)
						) {
							var N = S.shadow,
								O = n.get(S);
							(O.shadowBias = N.bias),
								(O.shadowNormalBias = N.normalBias),
								(O.shadowRadius = N.radius),
								(O.shadowMapSize = N.mapSize),
								(r.spotShadow[m] = O),
								(r.spotShadowMap[m] = L),
								(r.spotShadowMatrix[m] = S.shadow.matrix),
								_++;
						}
						(r.spot[m] = D), m++;
					} else if (S.isRectAreaLight) {
						var B = e.get(S);
						B.color.copy(T).multiplyScalar(E),
							B.position.setFromMatrixPosition(S.matrixWorld),
							B.position.applyMatrix4(b),
							s.identity(),
							o.copy(S.matrixWorld),
							o.premultiply(b),
							s.extractRotation(o),
							B.halfWidth.set(0.5 * S.width, 0, 0),
							B.halfHeight.set(0, 0.5 * S.height, 0),
							B.halfWidth.applyMatrix4(s),
							B.halfHeight.applyMatrix4(s),
							(r.rectArea[v] = B),
							v++;
					} else if (S.isPointLight) {
						var z = e.get(S);
						if (
							(z.position.setFromMatrixPosition(S.matrixWorld),
							z.position.applyMatrix4(b),
							z.color.copy(S.color).multiplyScalar(S.intensity),
							(z.distance = S.distance),
							(z.decay = S.decay),
							S.castShadow)
						) {
							var G = S.shadow,
								F = n.get(S);
							(F.shadowBias = G.bias),
								(F.shadowNormalBias = G.normalBias),
								(F.shadowRadius = G.radius),
								(F.shadowMapSize = G.mapSize),
								(F.shadowCameraNear = G.camera.near),
								(F.shadowCameraFar = G.camera.far),
								(r.pointShadow[f] = F),
								(r.pointShadowMap[f] = L),
								(r.pointShadowMatrix[f] = S.shadow.matrix),
								x++;
						}
						(r.point[f] = z), f++;
					} else if (S.isHemisphereLight) {
						var U = e.get(S);
						U.direction.setFromMatrixPosition(S.matrixWorld),
							U.direction.transformDirection(b),
							U.direction.normalize(),
							U.skyColor.copy(S.color).multiplyScalar(E),
							U.groundColor.copy(S.groundColor).multiplyScalar(E),
							(r.hemi[g] = U),
							g++;
					}
				}
				v > 0 && ((r.rectAreaLTC1 = nr.LTC_1), (r.rectAreaLTC2 = nr.LTC_2)),
					(r.ambient[0] = l),
					(r.ambient[1] = u),
					(r.ambient[2] = h);
				var H = r.hash;
				(H.directionalLength === p &&
					H.pointLength === f &&
					H.spotLength === m &&
					H.rectAreaLength === v &&
					H.hemiLength === g &&
					H.numDirectionalShadows === y &&
					H.numPointShadows === x &&
					H.numSpotShadows === _) ||
					((r.directional.length = p),
					(r.spot.length = m),
					(r.rectArea.length = v),
					(r.point.length = f),
					(r.hemi.length = g),
					(r.directionalShadow.length = y),
					(r.directionalShadowMap.length = y),
					(r.pointShadow.length = x),
					(r.pointShadowMap.length = x),
					(r.spotShadow.length = _),
					(r.spotShadowMap.length = _),
					(r.directionalShadowMatrix.length = y),
					(r.pointShadowMatrix.length = x),
					(r.spotShadowMatrix.length = _),
					(H.directionalLength = p),
					(H.pointLength = f),
					(H.spotLength = m),
					(H.rectAreaLength = v),
					(H.hemiLength = g),
					(H.numDirectionalShadows = y),
					(H.numPointShadows = x),
					(H.numSpotShadows = _),
					(r.version = Hi++));
			},
			state: r,
		};
	}
	function Wi() {
		var t = new Vi(),
			e = [],
			n = [];
		return {
			init: function () {
				(e.length = 0), (n.length = 0);
			},
			state: { lightsArray: e, shadowsArray: n, lights: t },
			setupLights: function (r) {
				t.setup(e, n, r);
			},
			pushLight: function (t) {
				e.push(t);
			},
			pushShadow: function (t) {
				n.push(t);
			},
		};
	}
	function ji() {
		var t = new WeakMap();
		return {
			get: function (e, n) {
				var r;
				return (
					!1 === t.has(e)
						? ((r = new Wi()), t.set(e, new WeakMap()), t.get(e).set(n, r))
						: !1 === t.get(e).has(n)
						? ((r = new Wi()), t.get(e).set(n, r))
						: (r = t.get(e).get(n)),
					r
				);
			},
			dispose: function () {
				t = new WeakMap();
			},
		};
	}
	function qi(t) {
		qe.call(this),
			(this.type = 'MeshDepthMaterial'),
			(this.depthPacking = 3200),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.map = null),
			(this.alphaMap = null),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.fog = !1),
			this.setValues(t);
	}
	function Xi(t) {
		qe.call(this),
			(this.type = 'MeshDistanceMaterial'),
			(this.referencePosition = new wt()),
			(this.nearDistance = 1),
			(this.farDistance = 1e3),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.map = null),
			(this.alphaMap = null),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.fog = !1),
			this.setValues(t);
	}
	(qi.prototype = Object.create(qe.prototype)),
		(qi.prototype.constructor = qi),
		(qi.prototype.isMeshDepthMaterial = !0),
		(qi.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				(this.depthPacking = t.depthPacking),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.map = t.map),
				(this.alphaMap = t.alphaMap),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				this
			);
		}),
		(Xi.prototype = Object.create(qe.prototype)),
		(Xi.prototype.constructor = Xi),
		(Xi.prototype.isMeshDistanceMaterial = !0),
		(Xi.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.referencePosition.copy(t.referencePosition),
				(this.nearDistance = t.nearDistance),
				(this.farDistance = t.farDistance),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.map = t.map),
				(this.alphaMap = t.alphaMap),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				this
			);
		});
	function Yi(t, e, n) {
		var r = new Qn(),
			i = new pt(),
			a = new pt(),
			o = new yt(),
			s = [],
			c = [],
			l = {},
			u = { 0: 1, 1: 0, 2: 2 },
			h = new Hn({
				defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
				uniforms: {
					shadow_pass: { value: null },
					resolution: { value: new pt() },
					radius: { value: 4 },
				},
				vertexShader:
					'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
				fragmentShader:
					'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
			}),
			p = h.clone();
		p.defines.HORIZONAL_PASS = 1;
		var f = new vn();
		f.setAttribute(
			'position',
			new Je(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
		);
		var v = new Nn(f, h),
			g = this;
		function y(n, r) {
			var i = e.update(v);
			(h.uniforms.shadow_pass.value = n.map.texture),
				(h.uniforms.resolution.value = n.mapSize),
				(h.uniforms.radius.value = n.radius),
				t.setRenderTarget(n.mapPass),
				t.clear(),
				t.renderBufferDirect(r, null, i, h, v, null),
				(p.uniforms.shadow_pass.value = n.mapPass.texture),
				(p.uniforms.resolution.value = n.mapSize),
				(p.uniforms.radius.value = n.radius),
				t.setRenderTarget(n.map),
				t.clear(),
				t.renderBufferDirect(r, null, i, p, v, null);
		}
		function x(t, e, n) {
			var r = (t << 0) | (e << 1) | (n << 2),
				i = s[r];
			return (
				void 0 === i &&
					((i = new qi({ depthPacking: 3201, morphTargets: t, skinning: e })),
					(s[r] = i)),
				i
			);
		}
		function _(t, e, n) {
			var r = (t << 0) | (e << 1) | (n << 2),
				i = c[r];
			return (
				void 0 === i &&
					((i = new Xi({ morphTargets: t, skinning: e })), (c[r] = i)),
				i
			);
		}
		function b(e, n, r, i, a, o, s) {
			var c = null,
				h = x,
				d = e.customDepthMaterial;
			if (
				(!0 === i.isPointLight && ((h = _), (d = e.customDistanceMaterial)),
				void 0 === d)
			) {
				var p = !1;
				!0 === r.morphTargets &&
					(p =
						n.morphAttributes &&
						n.morphAttributes.position &&
						n.morphAttributes.position.length > 0);
				var f = !1;
				!0 === e.isSkinnedMesh &&
					(!0 === r.skinning
						? (f = !0)
						: console.warn(
								'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',
								e
						  )),
					(c = h(p, f, !0 === e.isInstancedMesh));
			} else c = d;
			if (
				t.localClippingEnabled &&
				!0 === r.clipShadows &&
				0 !== r.clippingPlanes.length
			) {
				var m = c.uuid,
					v = r.uuid,
					g = l[m];
				void 0 === g && ((g = {}), (l[m] = g));
				var y = g[v];
				void 0 === y && ((y = c.clone()), (g[v] = y)), (c = y);
			}
			return (
				(c.visible = r.visible),
				(c.wireframe = r.wireframe),
				(c.side =
					3 === s
						? null !== r.shadowSide
							? r.shadowSide
							: r.side
						: null !== r.shadowSide
						? r.shadowSide
						: u[r.side]),
				(c.clipShadows = r.clipShadows),
				(c.clippingPlanes = r.clippingPlanes),
				(c.clipIntersection = r.clipIntersection),
				(c.wireframeLinewidth = r.wireframeLinewidth),
				(c.linewidth = r.linewidth),
				!0 === i.isPointLight &&
					!0 === c.isMeshDistanceMaterial &&
					(c.referencePosition.setFromMatrixPosition(i.matrixWorld),
					(c.nearDistance = a),
					(c.farDistance = o)),
				c
			);
		}
		function w(n, i, a, o, s) {
			if (!1 !== n.visible) {
				if (
					n.layers.test(i.layers) &&
					(n.isMesh || n.isLine || n.isPoints) &&
					(n.castShadow || (n.receiveShadow && 3 === s)) &&
					(!n.frustumCulled || r.intersectsObject(n))
				) {
					n.modelViewMatrix.multiplyMatrices(
						a.matrixWorldInverse,
						n.matrixWorld
					);
					var c = e.update(n),
						l = n.material;
					if (Array.isArray(l))
						for (var u = c.groups, h = 0, d = u.length; h < d; h++) {
							var p = u[h],
								f = l[p.materialIndex];
							if (f && f.visible) {
								var m = b(n, c, f, o, a.near, a.far, s);
								t.renderBufferDirect(a, null, c, m, n, p);
							}
						}
					else if (l.visible) {
						var v = b(n, c, l, o, a.near, a.far, s);
						t.renderBufferDirect(a, null, c, v, n, null);
					}
				}
				for (var g = n.children, y = 0, x = g.length; y < x; y++)
					w(g[y], i, a, o, s);
			}
		}
		(this.enabled = !1),
			(this.autoUpdate = !0),
			(this.needsUpdate = !1),
			(this.type = 1),
			(this.render = function (e, s, c) {
				if (
					!1 !== g.enabled &&
					(!1 !== g.autoUpdate || !1 !== g.needsUpdate) &&
					0 !== e.length
				) {
					var l = t.getRenderTarget(),
						u = t.getActiveCubeFace(),
						h = t.getActiveMipmapLevel(),
						p = t.state;
					p.setBlending(0),
						p.buffers.color.setClear(1, 1, 1, 1),
						p.buffers.depth.setTest(!0),
						p.setScissorTest(!1);
					for (var f = 0, v = e.length; f < v; f++) {
						var x = e[f],
							_ = x.shadow;
						if (void 0 !== _) {
							if (!1 !== _.autoUpdate || !1 !== _.needsUpdate) {
								i.copy(_.mapSize);
								var b = _.getFrameExtents();
								if (
									(i.multiply(b),
									a.copy(_.mapSize),
									(i.x > n || i.y > n) &&
										(i.x > n &&
											((a.x = Math.floor(n / b.x)),
											(i.x = a.x * b.x),
											(_.mapSize.x = a.x)),
										i.y > n &&
											((a.y = Math.floor(n / b.y)),
											(i.y = a.y * b.y),
											(_.mapSize.y = a.y))),
									null === _.map && !_.isPointLightShadow && 3 === this.type)
								) {
									var M = { minFilter: m, magFilter: m, format: T };
									(_.map = new xt(i.x, i.y, M)),
										(_.map.texture.name = x.name + '.shadowMap'),
										(_.mapPass = new xt(i.x, i.y, M)),
										_.camera.updateProjectionMatrix();
								}
								if (null === _.map) {
									var S = { minFilter: d, magFilter: d, format: T };
									(_.map = new xt(i.x, i.y, S)),
										(_.map.texture.name = x.name + '.shadowMap'),
										_.camera.updateProjectionMatrix();
								}
								t.setRenderTarget(_.map), t.clear();
								for (var E = _.getViewportCount(), A = 0; A < E; A++) {
									var L = _.getViewport(A);
									o.set(a.x * L.x, a.y * L.y, a.x * L.z, a.y * L.w),
										p.viewport(o),
										_.updateMatrices(x, A),
										(r = _.getFrustum()),
										w(s, c, _.camera, x, this.type);
								}
								_.isPointLightShadow || 3 !== this.type || y(_, c),
									(_.needsUpdate = !1);
							}
						} else console.warn('THREE.WebGLShadowMap:', x, 'has no shadow.');
					}
					(g.needsUpdate = !1), t.setRenderTarget(l, u, h);
				}
			});
	}
	function Zi(t, n, r) {
		var i,
			a,
			o = r.isWebGL2;
		var s = new (function () {
				var e = !1,
					n = new yt(),
					r = null,
					i = new yt(0, 0, 0, 0);
				return {
					setMask: function (n) {
						r === n || e || (t.colorMask(n, n, n, n), (r = n));
					},
					setLocked: function (t) {
						e = t;
					},
					setClear: function (e, r, a, o, s) {
						!0 === s && ((e *= o), (r *= o), (a *= o)),
							n.set(e, r, a, o),
							!1 === i.equals(n) && (t.clearColor(e, r, a, o), i.copy(n));
					},
					reset: function () {
						(e = !1), (r = null), i.set(-1, 0, 0, 0);
					},
				};
			})(),
			c = new (function () {
				var e = !1,
					n = null,
					r = null,
					i = null;
				return {
					setTest: function (t) {
						t ? B(2929) : z(2929);
					},
					setMask: function (r) {
						n === r || e || (t.depthMask(r), (n = r));
					},
					setFunc: function (e) {
						if (r !== e) {
							if (e)
								switch (e) {
									case 0:
										t.depthFunc(512);
										break;
									case 1:
										t.depthFunc(519);
										break;
									case 2:
										t.depthFunc(513);
										break;
									case 3:
										t.depthFunc(515);
										break;
									case 4:
										t.depthFunc(514);
										break;
									case 5:
										t.depthFunc(518);
										break;
									case 6:
										t.depthFunc(516);
										break;
									case 7:
										t.depthFunc(517);
										break;
									default:
										t.depthFunc(515);
								}
							else t.depthFunc(515);
							r = e;
						}
					},
					setLocked: function (t) {
						e = t;
					},
					setClear: function (e) {
						i !== e && (t.clearDepth(e), (i = e));
					},
					reset: function () {
						(e = !1), (n = null), (r = null), (i = null);
					},
				};
			})(),
			l = new (function () {
				var e = !1,
					n = null,
					r = null,
					i = null,
					a = null,
					o = null,
					s = null,
					c = null,
					l = null;
				return {
					setTest: function (t) {
						e || (t ? B(2960) : z(2960));
					},
					setMask: function (r) {
						n === r || e || (t.stencilMask(r), (n = r));
					},
					setFunc: function (e, n, o) {
						(r === e && i === n && a === o) ||
							(t.stencilFunc(e, n, o), (r = e), (i = n), (a = o));
					},
					setOp: function (e, n, r) {
						(o === e && s === n && c === r) ||
							(t.stencilOp(e, n, r), (o = e), (s = n), (c = r));
					},
					setLocked: function (t) {
						e = t;
					},
					setClear: function (e) {
						l !== e && (t.clearStencil(e), (l = e));
					},
					reset: function () {
						(e = !1),
							(n = null),
							(r = null),
							(i = null),
							(a = null),
							(o = null),
							(s = null),
							(c = null),
							(l = null);
					},
				};
			})(),
			u = {},
			h = null,
			d = null,
			p = null,
			f = null,
			m = null,
			v = null,
			g = null,
			y = null,
			x = null,
			_ = !1,
			b = null,
			w = null,
			M = null,
			S = null,
			T = null,
			E = t.getParameter(35661),
			A = !1,
			L = 0,
			R = t.getParameter(7938);
		-1 !== R.indexOf('WebGL')
			? ((L = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1])), (A = L >= 1))
			: -1 !== R.indexOf('OpenGL ES') &&
			  ((L = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1])), (A = L >= 2));
		var C = null,
			P = {},
			I = new yt(),
			D = new yt();
		function N(e, n, r) {
			var i = new Uint8Array(4),
				a = t.createTexture();
			t.bindTexture(e, a),
				t.texParameteri(e, 10241, 9728),
				t.texParameteri(e, 10240, 9728);
			for (var o = 0; o < r; o++)
				t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
			return a;
		}
		var O = {};
		function B(e) {
			!0 !== u[e] && (t.enable(e), (u[e] = !0));
		}
		function z(e) {
			!1 !== u[e] && (t.disable(e), (u[e] = !1));
		}
		(O[3553] = N(3553, 3553, 1)),
			(O[34067] = N(34067, 34069, 6)),
			s.setClear(0, 0, 0, 1),
			c.setClear(1),
			l.setClear(0),
			B(2929),
			c.setFunc(3),
			k(!1),
			V(1),
			B(2884),
			H(0);
		var G = (((i = {})[100] = 32774), (i[101] = 32778), (i[102] = 32779), i);
		if (o) (G[103] = 32775), (G[104] = 32776);
		else {
			var F = n.get('EXT_blend_minmax');
			null !== F && ((G[103] = F.MIN_EXT), (G[104] = F.MAX_EXT));
		}
		var U =
			(((a = {})[200] = 0),
			(a[201] = 1),
			(a[202] = 768),
			(a[204] = 770),
			(a[210] = 776),
			(a[208] = 774),
			(a[206] = 772),
			(a[203] = 769),
			(a[205] = 771),
			(a[209] = 775),
			(a[207] = 773),
			a);
		function H(n, r, i, a, o, s, c, l) {
			if (0 !== n) {
				if ((d || (B(3042), (d = !0)), 5 === n))
					(o = o || r),
						(s = s || i),
						(c = c || a),
						(r === f && o === g) ||
							(t.blendEquationSeparate(G[r], G[o]), (f = r), (g = o)),
						(i === m && a === v && s === y && c === x) ||
							(t.blendFuncSeparate(U[i], U[a], U[s], U[c]),
							(m = i),
							(v = a),
							(y = s),
							(x = c)),
						(p = n),
						(_ = null);
				else if (n !== p || l !== _) {
					if (
						((f === e && g === e) || (t.blendEquation(32774), (f = e), (g = e)),
						l)
					)
						switch (n) {
							case 1:
								t.blendFuncSeparate(1, 771, 1, 771);
								break;
							case 2:
								t.blendFunc(1, 1);
								break;
							case 3:
								t.blendFuncSeparate(0, 0, 769, 771);
								break;
							case 4:
								t.blendFuncSeparate(0, 768, 0, 770);
								break;
							default:
								console.error('THREE.WebGLState: Invalid blending: ', n);
						}
					else
						switch (n) {
							case 1:
								t.blendFuncSeparate(770, 771, 1, 771);
								break;
							case 2:
								t.blendFunc(770, 1);
								break;
							case 3:
								t.blendFunc(0, 769);
								break;
							case 4:
								t.blendFunc(0, 768);
								break;
							default:
								console.error('THREE.WebGLState: Invalid blending: ', n);
						}
					(m = null), (v = null), (y = null), (x = null), (p = n), (_ = l);
				}
			} else d && (z(3042), (d = !1));
		}
		function k(e) {
			b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (b = e));
		}
		function V(e) {
			0 !== e
				? (B(2884),
				  e !== w &&
						(1 === e
							? t.cullFace(1029)
							: 2 === e
							? t.cullFace(1028)
							: t.cullFace(1032)))
				: z(2884),
				(w = e);
		}
		function W(e, n, r) {
			e
				? (B(32823),
				  (S === n && T === r) || (t.polygonOffset(n, r), (S = n), (T = r)))
				: z(32823);
		}
		function j(e) {
			void 0 === e && (e = 33984 + E - 1),
				C !== e && (t.activeTexture(e), (C = e));
		}
		return {
			buffers: { color: s, depth: c, stencil: l },
			enable: B,
			disable: z,
			useProgram: function (e) {
				return h !== e && (t.useProgram(e), (h = e), !0);
			},
			setBlending: H,
			setMaterial: function (t, e) {
				2 === t.side ? z(2884) : B(2884);
				var n = 1 === t.side;
				e && (n = !n),
					k(n),
					1 === t.blending && !1 === t.transparent
						? H(0)
						: H(
								t.blending,
								t.blendEquation,
								t.blendSrc,
								t.blendDst,
								t.blendEquationAlpha,
								t.blendSrcAlpha,
								t.blendDstAlpha,
								t.premultipliedAlpha
						  ),
					c.setFunc(t.depthFunc),
					c.setTest(t.depthTest),
					c.setMask(t.depthWrite),
					s.setMask(t.colorWrite);
				var r = t.stencilWrite;
				l.setTest(r),
					r &&
						(l.setMask(t.stencilWriteMask),
						l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
						l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
					W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
			},
			setFlipSided: k,
			setCullFace: V,
			setLineWidth: function (e) {
				e !== M && (A && t.lineWidth(e), (M = e));
			},
			setPolygonOffset: W,
			setScissorTest: function (t) {
				t ? B(3089) : z(3089);
			},
			activeTexture: j,
			bindTexture: function (e, n) {
				null === C && j();
				var r = P[C];
				void 0 === r && ((r = { type: void 0, texture: void 0 }), (P[C] = r)),
					(r.type === e && r.texture === n) ||
						(t.bindTexture(e, n || O[e]), (r.type = e), (r.texture = n));
			},
			unbindTexture: function () {
				var e = P[C];
				void 0 !== e &&
					void 0 !== e.type &&
					(t.bindTexture(e.type, null),
					(e.type = void 0),
					(e.texture = void 0));
			},
			compressedTexImage2D: function () {
				try {
					t.compressedTexImage2D.apply(t, arguments);
				} catch (t) {
					console.error('THREE.WebGLState:', t);
				}
			},
			texImage2D: function () {
				try {
					t.texImage2D.apply(t, arguments);
				} catch (t) {
					console.error('THREE.WebGLState:', t);
				}
			},
			texImage3D: function () {
				try {
					t.texImage3D.apply(t, arguments);
				} catch (t) {
					console.error('THREE.WebGLState:', t);
				}
			},
			scissor: function (e) {
				!1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), I.copy(e));
			},
			viewport: function (e) {
				!1 === D.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), D.copy(e));
			},
			reset: function () {
				(u = {}),
					(C = null),
					(P = {}),
					(h = null),
					(p = null),
					(b = null),
					(w = null),
					s.reset(),
					c.reset(),
					l.reset();
			},
		};
	}
	function Ji(t, e, n, r, i, a, o) {
		var s,
			c,
			l,
			h = i.isWebGL2,
			v = i.maxTextures,
			g = i.maxCubemapSize,
			y = i.maxTextureSize,
			L = i.maxSamples,
			R = new WeakMap(),
			C = !1;
		try {
			C =
				'undefined' != typeof OffscreenCanvas &&
				null !== new OffscreenCanvas(1, 1).getContext('2d');
		} catch (t) {}
		function P(t, e) {
			return C
				? new OffscreenCanvas(t, e)
				: document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		}
		function I(t, e, n, r) {
			var i = 1;
			if (
				((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)),
				i < 1 || !0 === e)
			) {
				if (
					('undefined' != typeof HTMLImageElement &&
						t instanceof HTMLImageElement) ||
					('undefined' != typeof HTMLCanvasElement &&
						t instanceof HTMLCanvasElement) ||
					('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
				) {
					var a = e ? st.floorPowerOfTwo : Math.floor,
						o = a(i * t.width),
						s = a(i * t.height);
					void 0 === l && (l = P(o, s));
					var c = n ? P(o, s) : l;
					return (
						(c.width = o),
						(c.height = s),
						c.getContext('2d').drawImage(t, 0, 0, o, s),
						console.warn(
							'THREE.WebGLRenderer: Texture has been resized from (' +
								t.width +
								'x' +
								t.height +
								') to (' +
								o +
								'x' +
								s +
								').'
						),
						c
					);
				}
				return (
					'data' in t &&
						console.warn(
							'THREE.WebGLRenderer: Image in DataTexture is too big (' +
								t.width +
								'x' +
								t.height +
								').'
						),
					t
				);
			}
			return t;
		}
		function D(t) {
			return st.isPowerOfTwo(t.width) && st.isPowerOfTwo(t.height);
		}
		function N(t, e) {
			return t.generateMipmaps && e && t.minFilter !== d && t.minFilter !== m;
		}
		function O(e, n, i, a) {
			t.generateMipmap(e),
				(r.get(n).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E);
		}
		function B(n, r, i) {
			if (!1 === h) return r;
			if (null !== n) {
				if (void 0 !== t[n]) return t[n];
				console.warn(
					"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
						n +
						"'"
				);
			}
			var a = r;
			return (
				6403 === r &&
					(5126 === i && (a = 33326),
					5131 === i && (a = 33325),
					5121 === i && (a = 33321)),
				6407 === r &&
					(5126 === i && (a = 34837),
					5131 === i && (a = 34843),
					5121 === i && (a = 32849)),
				6408 === r &&
					(5126 === i && (a = 34836),
					5131 === i && (a = 34842),
					5121 === i && (a = 32856)),
				(33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a) ||
					e.get('EXT_color_buffer_float'),
				a
			);
		}
		function z(t) {
			return t === d || t === p || t === f ? 9728 : 9729;
		}
		function G(e) {
			var n = e.target;
			n.removeEventListener('dispose', G),
				(function (e) {
					var n = r.get(e);
					if (void 0 === n.__webglInit) return;
					t.deleteTexture(n.__webglTexture), r.remove(e);
				})(n),
				n.isVideoTexture && R.delete(n),
				o.memory.textures--;
		}
		function F(e) {
			var n = e.target;
			n.removeEventListener('dispose', F),
				(function (e) {
					var n = r.get(e),
						i = r.get(e.texture);
					if (!e) return;
					void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture);
					e.depthTexture && e.depthTexture.dispose();
					if (e.isWebGLCubeRenderTarget)
						for (var a = 0; a < 6; a++)
							t.deleteFramebuffer(n.__webglFramebuffer[a]),
								n.__webglDepthbuffer &&
									t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
					else
						t.deleteFramebuffer(n.__webglFramebuffer),
							n.__webglDepthbuffer &&
								t.deleteRenderbuffer(n.__webglDepthbuffer),
							n.__webglMultisampledFramebuffer &&
								t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
							n.__webglColorRenderbuffer &&
								t.deleteRenderbuffer(n.__webglColorRenderbuffer),
							n.__webglDepthRenderbuffer &&
								t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
					r.remove(e.texture), r.remove(e);
				})(n),
				o.memory.textures--;
		}
		var U = 0;
		function H(t, e) {
			var i = r.get(t);
			if (
				(t.isVideoTexture &&
					(function (t) {
						var e = o.render.frame;
						R.get(t) !== e && (R.set(t, e), t.update());
					})(t),
				t.version > 0 && i.__version !== t.version)
			) {
				var a = t.image;
				if (void 0 === a)
					console.warn(
						'THREE.WebGLRenderer: Texture marked for update but image is undefined'
					);
				else {
					if (!1 !== a.complete) return void X(i, t, e);
					console.warn(
						'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
					);
				}
			}
			n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture);
		}
		function k(e, i) {
			var o = r.get(e);
			e.version > 0 && o.__version !== e.version
				? (function (e, r, i) {
						if (6 !== r.image.length) return;
						q(e, r),
							n.activeTexture(33984 + i),
							n.bindTexture(34067, e.__webglTexture),
							t.pixelStorei(37440, r.flipY);
						for (
							var o =
									r &&
									(r.isCompressedTexture || r.image[0].isCompressedTexture),
								s = r.image[0] && r.image[0].isDataTexture,
								c = [],
								l = 0;
							l < 6;
							l++
						)
							c[l] =
								o || s
									? s
										? r.image[l].image
										: r.image[l]
									: I(r.image[l], !1, !0, g);
						var u,
							d = c[0],
							p = D(d) || h,
							f = a.convert(r.format),
							m = a.convert(r.type),
							v = B(r.internalFormat, f, m);
						if ((j(34067, r, p), o)) {
							for (var y = 0; y < 6; y++) {
								u = c[y].mipmaps;
								for (var x = 0; x < u.length; x++) {
									var _ = u[x];
									r.format !== T && r.format !== S
										? null !== f
											? n.compressedTexImage2D(
													34069 + y,
													x,
													v,
													_.width,
													_.height,
													0,
													_.data
											  )
											: console.warn(
													'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
											  )
										: n.texImage2D(
												34069 + y,
												x,
												v,
												_.width,
												_.height,
												0,
												f,
												m,
												_.data
										  );
								}
							}
							e.__maxMipLevel = u.length - 1;
						} else {
							u = r.mipmaps;
							for (var b = 0; b < 6; b++)
								if (s) {
									n.texImage2D(
										34069 + b,
										0,
										v,
										c[b].width,
										c[b].height,
										0,
										f,
										m,
										c[b].data
									);
									for (var w = 0; w < u.length; w++) {
										var M = u[w].image[b].image;
										n.texImage2D(
											34069 + b,
											w + 1,
											v,
											M.width,
											M.height,
											0,
											f,
											m,
											M.data
										);
									}
								} else {
									n.texImage2D(34069 + b, 0, v, f, m, c[b]);
									for (var E = 0; E < u.length; E++) {
										var A = u[E];
										n.texImage2D(34069 + b, E + 1, v, f, m, A.image[b]);
									}
								}
							e.__maxMipLevel = u.length;
						}
						N(r, p) && O(34067, r, d.width, d.height);
						(e.__version = r.version), r.onUpdate && r.onUpdate(r);
				  })(o, e, i)
				: (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture));
		}
		var V = (((s = {})[1e3] = 10497), (s[1001] = 33071), (s[1002] = 33648), s),
			W =
				(((c = {})[1003] = 9728),
				(c[1004] = 9984),
				(c[1005] = 9986),
				(c[1006] = 9729),
				(c[1007] = 9985),
				(c[1008] = 9987),
				c);
		function j(n, a, o) {
			o
				? (t.texParameteri(n, 10242, V[a.wrapS]),
				  t.texParameteri(n, 10243, V[a.wrapT]),
				  (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, V[a.wrapR]),
				  t.texParameteri(n, 10240, W[a.magFilter]),
				  t.texParameteri(n, 10241, W[a.minFilter]))
				: (t.texParameteri(n, 10242, 33071),
				  t.texParameteri(n, 10243, 33071),
				  (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
				  (a.wrapS === u && a.wrapT === u) ||
						console.warn(
							'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
						),
				  t.texParameteri(n, 10240, z(a.magFilter)),
				  t.texParameteri(n, 10241, z(a.minFilter)),
				  a.minFilter !== d &&
						a.minFilter !== m &&
						console.warn(
							'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
						));
			var s = e.get('EXT_texture_filter_anisotropic');
			if (s) {
				if (a.type === b && null === e.get('OES_texture_float_linear')) return;
				if (
					a.type === w &&
					null === (h || e.get('OES_texture_half_float_linear'))
				)
					return;
				(a.anisotropy > 1 || r.get(a).__currentAnisotropy) &&
					(t.texParameterf(
						n,
						s.TEXTURE_MAX_ANISOTROPY_EXT,
						Math.min(a.anisotropy, i.getMaxAnisotropy())
					),
					(r.get(a).__currentAnisotropy = a.anisotropy));
			}
		}
		function q(e, n) {
			void 0 === e.__webglInit &&
				((e.__webglInit = !0),
				n.addEventListener('dispose', G),
				(e.__webglTexture = t.createTexture()),
				o.memory.textures++);
		}
		function X(e, r, i) {
			var o = 3553;
			r.isDataTexture2DArray && (o = 35866),
				r.isDataTexture3D && (o = 32879),
				q(e, r),
				n.activeTexture(33984 + i),
				n.bindTexture(o, e.__webglTexture),
				t.pixelStorei(37440, r.flipY),
				t.pixelStorei(37441, r.premultiplyAlpha),
				t.pixelStorei(3317, r.unpackAlignment);
			var s,
				c =
					(function (t) {
						return (
							!h &&
							(t.wrapS !== u ||
								t.wrapT !== u ||
								(t.minFilter !== d && t.minFilter !== m))
						);
					})(r) && !1 === D(r.image),
				l = I(r.image, c, !1, y),
				p = D(l) || h,
				f = a.convert(r.format),
				v = a.convert(r.type),
				g = B(r.internalFormat, f, v);
			j(o, r, p);
			var w = r.mipmaps;
			if (r.isDepthTexture)
				(g = 6402),
					h
						? (g =
								r.type === b
									? 36012
									: r.type === _
									? 33190
									: r.type === M
									? 35056
									: 33189)
						: r.type === b &&
						  console.error(
								'WebGLRenderer: Floating point depth texture requires WebGL2.'
						  ),
					r.format === E &&
						6402 === g &&
						r.type !== x &&
						r.type !== _ &&
						(console.warn(
							'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
						),
						(r.type = x),
						(v = a.convert(r.type))),
					r.format === A &&
						6402 === g &&
						((g = 34041),
						r.type !== M &&
							(console.warn(
								'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
							),
							(r.type = M),
							(v = a.convert(r.type)))),
					n.texImage2D(3553, 0, g, l.width, l.height, 0, f, v, null);
			else if (r.isDataTexture)
				if (w.length > 0 && p) {
					for (var L = 0, R = w.length; L < R; L++)
						(s = w[L]),
							n.texImage2D(3553, L, g, s.width, s.height, 0, f, v, s.data);
					(r.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
				} else
					n.texImage2D(3553, 0, g, l.width, l.height, 0, f, v, l.data),
						(e.__maxMipLevel = 0);
			else if (r.isCompressedTexture) {
				for (var C = 0, P = w.length; C < P; C++)
					(s = w[C]),
						r.format !== T && r.format !== S
							? null !== f
								? n.compressedTexImage2D(
										3553,
										C,
										g,
										s.width,
										s.height,
										0,
										s.data
								  )
								: console.warn(
										'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
								  )
							: n.texImage2D(3553, C, g, s.width, s.height, 0, f, v, s.data);
				e.__maxMipLevel = w.length - 1;
			} else if (r.isDataTexture2DArray)
				n.texImage3D(35866, 0, g, l.width, l.height, l.depth, 0, f, v, l.data),
					(e.__maxMipLevel = 0);
			else if (r.isDataTexture3D)
				n.texImage3D(32879, 0, g, l.width, l.height, l.depth, 0, f, v, l.data),
					(e.__maxMipLevel = 0);
			else if (w.length > 0 && p) {
				for (var z = 0, G = w.length; z < G; z++)
					(s = w[z]), n.texImage2D(3553, z, g, f, v, s);
				(r.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
			} else n.texImage2D(3553, 0, g, f, v, l), (e.__maxMipLevel = 0);
			N(r, p) && O(o, r, l.width, l.height),
				(e.__version = r.version),
				r.onUpdate && r.onUpdate(r);
		}
		function Y(e, i, o, s) {
			var c = a.convert(i.texture.format),
				l = a.convert(i.texture.type),
				u = B(i.texture.internalFormat, c, l);
			n.texImage2D(s, 0, u, i.width, i.height, 0, c, l, null),
				t.bindFramebuffer(36160, e),
				t.framebufferTexture2D(36160, o, s, r.get(i.texture).__webglTexture, 0),
				t.bindFramebuffer(36160, null);
		}
		function Z(e, n, r) {
			if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
				var i = 33189;
				if (r) {
					var o = n.depthTexture;
					o &&
						o.isDepthTexture &&
						(o.type === b ? (i = 36012) : o.type === _ && (i = 33190));
					var s = Q(n);
					t.renderbufferStorageMultisample(36161, s, i, n.width, n.height);
				} else t.renderbufferStorage(36161, i, n.width, n.height);
				t.framebufferRenderbuffer(36160, 36096, 36161, e);
			} else if (n.depthBuffer && n.stencilBuffer) {
				if (r) {
					var c = Q(n);
					t.renderbufferStorageMultisample(36161, c, 35056, n.width, n.height);
				} else t.renderbufferStorage(36161, 34041, n.width, n.height);
				t.framebufferRenderbuffer(36160, 33306, 36161, e);
			} else {
				var l = a.convert(n.texture.format),
					u = a.convert(n.texture.type),
					h = B(n.texture.internalFormat, l, u);
				if (r) {
					var d = Q(n);
					t.renderbufferStorageMultisample(36161, d, h, n.width, n.height);
				} else t.renderbufferStorage(36161, h, n.width, n.height);
			}
			t.bindRenderbuffer(36161, null);
		}
		function J(e) {
			var n = r.get(e),
				i = !0 === e.isWebGLCubeRenderTarget;
			if (e.depthTexture) {
				if (i)
					throw new Error(
						'target.depthTexture not supported in Cube render targets'
					);
				!(function (e, n) {
					if (n && n.isWebGLCubeRenderTarget)
						throw new Error(
							'Depth Texture with cube render targets is not supported'
						);
					if (
						(t.bindFramebuffer(36160, e),
						!n.depthTexture || !n.depthTexture.isDepthTexture)
					)
						throw new Error(
							'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
						);
					(r.get(n.depthTexture).__webglTexture &&
						n.depthTexture.image.width === n.width &&
						n.depthTexture.image.height === n.height) ||
						((n.depthTexture.image.width = n.width),
						(n.depthTexture.image.height = n.height),
						(n.depthTexture.needsUpdate = !0)),
						H(n.depthTexture, 0);
					var i = r.get(n.depthTexture).__webglTexture;
					if (n.depthTexture.format === E)
						t.framebufferTexture2D(36160, 36096, 3553, i, 0);
					else {
						if (n.depthTexture.format !== A)
							throw new Error('Unknown depthTexture format');
						t.framebufferTexture2D(36160, 33306, 3553, i, 0);
					}
				})(n.__webglFramebuffer, e);
			} else if (i) {
				n.__webglDepthbuffer = [];
				for (var a = 0; a < 6; a++)
					t.bindFramebuffer(36160, n.__webglFramebuffer[a]),
						(n.__webglDepthbuffer[a] = t.createRenderbuffer()),
						Z(n.__webglDepthbuffer[a], e, !1);
			} else
				t.bindFramebuffer(36160, n.__webglFramebuffer),
					(n.__webglDepthbuffer = t.createRenderbuffer()),
					Z(n.__webglDepthbuffer, e, !1);
			t.bindFramebuffer(36160, null);
		}
		function Q(t) {
			return h && t.isWebGLMultisampleRenderTarget ? Math.min(L, t.samples) : 0;
		}
		var K = !1,
			$ = !1;
		(this.allocateTextureUnit = function () {
			var t = U;
			return (
				t >= v &&
					console.warn(
						'THREE.WebGLTextures: Trying to use ' +
							t +
							' texture units while this GPU supports only ' +
							v
					),
				(U += 1),
				t
			);
		}),
			(this.resetTextureUnits = function () {
				U = 0;
			}),
			(this.setTexture2D = H),
			(this.setTexture2DArray = function (t, e) {
				var i = r.get(t);
				t.version > 0 && i.__version !== t.version
					? X(i, t, e)
					: (n.activeTexture(33984 + e),
					  n.bindTexture(35866, i.__webglTexture));
			}),
			(this.setTexture3D = function (t, e) {
				var i = r.get(t);
				t.version > 0 && i.__version !== t.version
					? X(i, t, e)
					: (n.activeTexture(33984 + e),
					  n.bindTexture(32879, i.__webglTexture));
			}),
			(this.setTextureCube = k),
			(this.setupRenderTarget = function (e) {
				var i = r.get(e),
					s = r.get(e.texture);
				e.addEventListener('dispose', F),
					(s.__webglTexture = t.createTexture()),
					o.memory.textures++;
				var c = !0 === e.isWebGLCubeRenderTarget,
					l = !0 === e.isWebGLMultisampleRenderTarget,
					u = D(e) || h;
				if (
					(!h ||
						e.texture.format !== S ||
						(e.texture.type !== b && e.texture.type !== w) ||
						((e.texture.format = T),
						console.warn(
							'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.'
						)),
					c)
				) {
					i.__webglFramebuffer = [];
					for (var d = 0; d < 6; d++)
						i.__webglFramebuffer[d] = t.createFramebuffer();
				} else if (((i.__webglFramebuffer = t.createFramebuffer()), l))
					if (h) {
						(i.__webglMultisampledFramebuffer = t.createFramebuffer()),
							(i.__webglColorRenderbuffer = t.createRenderbuffer()),
							t.bindRenderbuffer(36161, i.__webglColorRenderbuffer);
						var p = a.convert(e.texture.format),
							f = a.convert(e.texture.type),
							m = B(e.texture.internalFormat, p, f),
							v = Q(e);
						t.renderbufferStorageMultisample(36161, v, m, e.width, e.height),
							t.bindFramebuffer(36160, i.__webglMultisampledFramebuffer),
							t.framebufferRenderbuffer(
								36160,
								36064,
								36161,
								i.__webglColorRenderbuffer
							),
							t.bindRenderbuffer(36161, null),
							e.depthBuffer &&
								((i.__webglDepthRenderbuffer = t.createRenderbuffer()),
								Z(i.__webglDepthRenderbuffer, e, !0)),
							t.bindFramebuffer(36160, null);
					} else
						console.warn(
							'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.'
						);
				if (c) {
					n.bindTexture(34067, s.__webglTexture), j(34067, e.texture, u);
					for (var g = 0; g < 6; g++)
						Y(i.__webglFramebuffer[g], e, 36064, 34069 + g);
					N(e.texture, u) && O(34067, e.texture, e.width, e.height),
						n.bindTexture(34067, null);
				} else
					n.bindTexture(3553, s.__webglTexture),
						j(3553, e.texture, u),
						Y(i.__webglFramebuffer, e, 36064, 3553),
						N(e.texture, u) && O(3553, e.texture, e.width, e.height),
						n.bindTexture(3553, null);
				e.depthBuffer && J(e);
			}),
			(this.updateRenderTargetMipmap = function (t) {
				var e = t.texture;
				if (N(e, D(t) || h)) {
					var i = t.isWebGLCubeRenderTarget ? 34067 : 3553,
						a = r.get(e).__webglTexture;
					n.bindTexture(i, a),
						O(i, e, t.width, t.height),
						n.bindTexture(i, null);
				}
			}),
			(this.updateMultisampleRenderTarget = function (e) {
				if (e.isWebGLMultisampleRenderTarget)
					if (h) {
						var n = r.get(e);
						t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
							t.bindFramebuffer(36009, n.__webglFramebuffer);
						var i = e.width,
							a = e.height,
							o = 16384;
						e.depthBuffer && (o |= 256),
							e.stencilBuffer && (o |= 1024),
							t.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728),
							t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
					} else
						console.warn(
							'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.'
						);
			}),
			(this.safeSetTexture2D = function (t, e) {
				t &&
					t.isWebGLRenderTarget &&
					(!1 === K &&
						(console.warn(
							"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
						),
						(K = !0)),
					(t = t.texture)),
					H(t, e);
			}),
			(this.safeSetTextureCube = function (t, e) {
				t &&
					t.isWebGLCubeRenderTarget &&
					(!1 === $ &&
						(console.warn(
							"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
						),
						($ = !0)),
					(t = t.texture)),
					k(t, e);
			});
	}
	function Qi(t, e, n) {
		var r = n.isWebGL2;
		return {
			convert: function (t) {
				var n;
				if (t === y) return 5121;
				if (1017 === t) return 32819;
				if (1018 === t) return 32820;
				if (1019 === t) return 33635;
				if (1010 === t) return 5120;
				if (1011 === t) return 5122;
				if (t === x) return 5123;
				if (1013 === t) return 5124;
				if (t === _) return 5125;
				if (t === b) return 5126;
				if (t === w)
					return r
						? 5131
						: null !== (n = e.get('OES_texture_half_float'))
						? n.HALF_FLOAT_OES
						: null;
				if (1021 === t) return 6406;
				if (t === S) return 6407;
				if (t === T) return 6408;
				if (1024 === t) return 6409;
				if (1025 === t) return 6410;
				if (t === E) return 6402;
				if (t === A) return 34041;
				if (1028 === t) return 6403;
				if (1029 === t) return 36244;
				if (1030 === t) return 33319;
				if (1031 === t) return 33320;
				if (1032 === t) return 36248;
				if (1033 === t) return 36249;
				if (t === L || t === R || t === C || t === P) {
					if (null === (n = e.get('WEBGL_compressed_texture_s3tc')))
						return null;
					if (t === L) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (t === R) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (t === C) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (t === P) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				}
				if (t === I || t === D || t === N || t === O) {
					if (null === (n = e.get('WEBGL_compressed_texture_pvrtc')))
						return null;
					if (t === I) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (t === D) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (t === N) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (t === O) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				}
				if (36196 === t)
					return null !== (n = e.get('WEBGL_compressed_texture_etc1'))
						? n.COMPRESSED_RGB_ETC1_WEBGL
						: null;
				if (
					(t === B || t === z) &&
					null !== (n = e.get('WEBGL_compressed_texture_etc'))
				) {
					if (t === B) return n.COMPRESSED_RGB8_ETC2;
					if (t === z) return n.COMPRESSED_RGBA8_ETC2_EAC;
				}
				return 37808 === t ||
					37809 === t ||
					37810 === t ||
					37811 === t ||
					37812 === t ||
					37813 === t ||
					37814 === t ||
					37815 === t ||
					37816 === t ||
					37817 === t ||
					37818 === t ||
					37819 === t ||
					37820 === t ||
					37821 === t ||
					37840 === t ||
					37841 === t ||
					37842 === t ||
					37843 === t ||
					37844 === t ||
					37845 === t ||
					37846 === t ||
					37847 === t ||
					37848 === t ||
					37849 === t ||
					37850 === t ||
					37851 === t ||
					37852 === t ||
					37853 === t
					? null !== (n = e.get('WEBGL_compressed_texture_astc'))
						? t
						: null
					: 36492 === t
					? null !== (n = e.get('EXT_texture_compression_bptc'))
						? t
						: null
					: t === M
					? r
						? 34042
						: null !== (n = e.get('WEBGL_depth_texture'))
						? n.UNSIGNED_INT_24_8_WEBGL
						: null
					: void 0;
			},
		};
	}
	function Ki(t) {
		Vn.call(this), (this.cameras = t || []);
	}
	function $i() {
		be.call(this), (this.type = 'Group');
	}
	function ta() {
		(this._targetRay = null), (this._grip = null), (this._hand = null);
	}
	function ea(t, e) {
		var n = this,
			r = null,
			i = 1,
			a = null,
			o = 'local-floor',
			s = null,
			c = [],
			l = new Map(),
			u = new Vn();
		u.layers.enable(1), (u.viewport = new yt());
		var h = new Vn();
		h.layers.enable(2), (h.viewport = new yt());
		var d = [u, h],
			p = new Ki();
		p.layers.enable(1), p.layers.enable(2);
		var f = null,
			m = null;
		function v(t) {
			var e = l.get(t.inputSource);
			e && e.dispatchEvent({ type: t.type, data: t.inputSource });
		}
		function g() {
			l.forEach(function (t, e) {
				t.disconnect(e);
			}),
				l.clear(),
				t.setFramebuffer(null),
				t.setRenderTarget(t.getRenderTarget()),
				S.stop(),
				(n.isPresenting = !1),
				n.dispatchEvent({ type: 'sessionend' });
		}
		function y(t) {
			(a = t),
				S.setContext(r),
				S.start(),
				(n.isPresenting = !0),
				n.dispatchEvent({ type: 'sessionstart' });
		}
		function x(t) {
			for (var e = r.inputSources, n = 0; n < c.length; n++) l.set(e[n], c[n]);
			for (var i = 0; i < t.removed.length; i++) {
				var a = t.removed[i],
					o = l.get(a);
				o && (o.dispatchEvent({ type: 'disconnected', data: a }), l.delete(a));
			}
			for (var s = 0; s < t.added.length; s++) {
				var u = t.added[s],
					h = l.get(u);
				h && h.dispatchEvent({ type: 'connected', data: u });
			}
		}
		(this.enabled = !1),
			(this.isPresenting = !1),
			(this.getController = function (t) {
				var e = c[t];
				return (
					void 0 === e && ((e = new ta()), (c[t] = e)), e.getTargetRaySpace()
				);
			}),
			(this.getControllerGrip = function (t) {
				var e = c[t];
				return void 0 === e && ((e = new ta()), (c[t] = e)), e.getGripSpace();
			}),
			(this.getHand = function (t) {
				var e = c[t];
				return void 0 === e && ((e = new ta()), (c[t] = e)), e.getHandSpace();
			}),
			(this.setFramebufferScaleFactor = function (t) {
				(i = t),
					!0 === n.isPresenting &&
						console.warn(
							'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
						);
			}),
			(this.setReferenceSpaceType = function (t) {
				(o = t),
					!0 === n.isPresenting &&
						console.warn(
							'THREE.WebXRManager: Cannot change reference space type while presenting.'
						);
			}),
			(this.getReferenceSpace = function () {
				return a;
			}),
			(this.getSession = function () {
				return r;
			}),
			(this.setSession = function (t) {
				if (null !== (r = t)) {
					r.addEventListener('select', v),
						r.addEventListener('selectstart', v),
						r.addEventListener('selectend', v),
						r.addEventListener('squeeze', v),
						r.addEventListener('squeezestart', v),
						r.addEventListener('squeezeend', v),
						r.addEventListener('end', g);
					var n = e.getContextAttributes();
					!0 !== n.xrCompatible && e.makeXRCompatible();
					var a = {
							antialias: n.antialias,
							alpha: n.alpha,
							depth: n.depth,
							stencil: n.stencil,
							framebufferScaleFactor: i,
						},
						s = new XRWebGLLayer(r, e, a);
					r.updateRenderState({ baseLayer: s }),
						r.requestReferenceSpace(o).then(y),
						r.addEventListener('inputsourceschange', x);
				}
			});
		var _ = new wt(),
			b = new wt();
		function w(t, e) {
			null === e
				? t.matrixWorld.copy(t.matrix)
				: t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
				t.matrixWorldInverse.getInverse(t.matrixWorld);
		}
		this.getCamera = function (t) {
			(p.near = h.near = u.near = t.near),
				(p.far = h.far = u.far = t.far),
				(f === p.near && m === p.far) ||
					(r.updateRenderState({ depthNear: p.near, depthFar: p.far }),
					(f = p.near),
					(m = p.far));
			var e = t.parent,
				n = p.cameras;
			w(p, e);
			for (var i = 0; i < n.length; i++) w(n[i], e);
			t.matrixWorld.copy(p.matrixWorld);
			for (var a = t.children, o = 0, s = a.length; o < s; o++)
				a[o].updateMatrixWorld(!0);
			return (
				2 === n.length
					? (function (t, e, n) {
							_.setFromMatrixPosition(e.matrixWorld),
								b.setFromMatrixPosition(n.matrixWorld);
							var r = _.distanceTo(b),
								i = e.projectionMatrix.elements,
								a = n.projectionMatrix.elements,
								o = i[14] / (i[10] - 1),
								s = i[14] / (i[10] + 1),
								c = (i[9] + 1) / i[5],
								l = (i[9] - 1) / i[5],
								u = (i[8] - 1) / i[0],
								h = (a[8] + 1) / a[0],
								d = o * u,
								p = o * h,
								f = r / (-u + h),
								m = f * -u;
							e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
								t.translateX(m),
								t.translateZ(f),
								t.matrixWorld.compose(t.position, t.quaternion, t.scale),
								t.matrixWorldInverse.getInverse(t.matrixWorld);
							var v = o + f,
								g = s + f,
								y = d - m,
								x = p + (r - m),
								w = ((c * s) / g) * v,
								M = ((l * s) / g) * v;
							t.projectionMatrix.makePerspective(y, x, w, M, v, g);
					  })(p, u, h)
					: p.projectionMatrix.copy(u.projectionMatrix),
				p
			);
		};
		var M = null;
		var S = new Kn();
		S.setAnimationLoop(function (e, n) {
			if (null !== (s = n.getViewerPose(a))) {
				var i = s.views,
					o = r.renderState.baseLayer;
				t.setFramebuffer(o.framebuffer);
				var l = !1;
				i.length !== p.cameras.length && ((p.cameras.length = 0), (l = !0));
				for (var u = 0; u < i.length; u++) {
					var h = i[u],
						f = o.getViewport(h),
						m = d[u];
					m.matrix.fromArray(h.transform.matrix),
						m.projectionMatrix.fromArray(h.projectionMatrix),
						m.viewport.set(f.x, f.y, f.width, f.height),
						0 === u && p.matrix.copy(m.matrix),
						!0 === l && p.cameras.push(m);
				}
			}
			for (var v = r.inputSources, g = 0; g < c.length; g++) {
				var y = c[g],
					x = v[g];
				y.update(x, n, a);
			}
			M && M(e, n);
		}),
			(this.setAnimationLoop = function (t) {
				M = t;
			}),
			(this.dispose = function () {});
	}
	function na(t) {
		function e(e, n) {
			(e.opacity.value = n.opacity),
				n.color && e.diffuse.value.copy(n.color),
				n.emissive &&
					e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
				n.map && (e.map.value = n.map),
				n.alphaMap && (e.alphaMap.value = n.alphaMap),
				n.specularMap && (e.specularMap.value = n.specularMap);
			var r,
				i,
				a = t.get(n).envMap;
			if (a) {
				(e.envMap.value = a),
					(e.flipEnvMap.value = a.isCubeTexture && a._needsFlipEnvMap ? -1 : 1),
					(e.reflectivity.value = n.reflectivity),
					(e.refractionRatio.value = n.refractionRatio);
				var o = t.get(a).__maxMipLevel;
				void 0 !== o && (e.maxMipLevel.value = o);
			}
			n.lightMap &&
				((e.lightMap.value = n.lightMap),
				(e.lightMapIntensity.value = n.lightMapIntensity)),
				n.aoMap &&
					((e.aoMap.value = n.aoMap),
					(e.aoMapIntensity.value = n.aoMapIntensity)),
				n.map
					? (r = n.map)
					: n.specularMap
					? (r = n.specularMap)
					: n.displacementMap
					? (r = n.displacementMap)
					: n.normalMap
					? (r = n.normalMap)
					: n.bumpMap
					? (r = n.bumpMap)
					: n.roughnessMap
					? (r = n.roughnessMap)
					: n.metalnessMap
					? (r = n.metalnessMap)
					: n.alphaMap
					? (r = n.alphaMap)
					: n.emissiveMap
					? (r = n.emissiveMap)
					: n.clearcoatMap
					? (r = n.clearcoatMap)
					: n.clearcoatNormalMap
					? (r = n.clearcoatNormalMap)
					: n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
				void 0 !== r &&
					(r.isWebGLRenderTarget && (r = r.texture),
					!0 === r.matrixAutoUpdate && r.updateMatrix(),
					e.uvTransform.value.copy(r.matrix)),
				n.aoMap ? (i = n.aoMap) : n.lightMap && (i = n.lightMap),
				void 0 !== i &&
					(i.isWebGLRenderTarget && (i = i.texture),
					!0 === i.matrixAutoUpdate && i.updateMatrix(),
					e.uv2Transform.value.copy(i.matrix));
		}
		function n(e, n) {
			(e.roughness.value = n.roughness),
				(e.metalness.value = n.metalness),
				n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
				n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
				n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
				n.bumpMap &&
					((e.bumpMap.value = n.bumpMap),
					(e.bumpScale.value = n.bumpScale),
					1 === n.side && (e.bumpScale.value *= -1)),
				n.normalMap &&
					((e.normalMap.value = n.normalMap),
					e.normalScale.value.copy(n.normalScale),
					1 === n.side && e.normalScale.value.negate()),
				n.displacementMap &&
					((e.displacementMap.value = n.displacementMap),
					(e.displacementScale.value = n.displacementScale),
					(e.displacementBias.value = n.displacementBias)),
				t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
		}
		return {
			refreshFogUniforms: function (t, e) {
				t.fogColor.value.copy(e.color),
					e.isFog
						? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
						: e.isFogExp2 && (t.fogDensity.value = e.density);
			},
			refreshMaterialUniforms: function (t, r, i, a) {
				r.isMeshBasicMaterial
					? e(t, r)
					: r.isMeshLambertMaterial
					? (e(t, r),
					  (function (t, e) {
							e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
					  })(t, r))
					: r.isMeshToonMaterial
					? (e(t, r),
					  (function (t, e) {
							e.gradientMap && (t.gradientMap.value = e.gradientMap);
							e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
							e.bumpMap &&
								((t.bumpMap.value = e.bumpMap),
								(t.bumpScale.value = e.bumpScale),
								1 === e.side && (t.bumpScale.value *= -1));
							e.normalMap &&
								((t.normalMap.value = e.normalMap),
								t.normalScale.value.copy(e.normalScale),
								1 === e.side && t.normalScale.value.negate());
							e.displacementMap &&
								((t.displacementMap.value = e.displacementMap),
								(t.displacementScale.value = e.displacementScale),
								(t.displacementBias.value = e.displacementBias));
					  })(t, r))
					: r.isMeshPhongMaterial
					? (e(t, r),
					  (function (t, e) {
							t.specular.value.copy(e.specular),
								(t.shininess.value = Math.max(e.shininess, 1e-4)),
								e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
							e.bumpMap &&
								((t.bumpMap.value = e.bumpMap),
								(t.bumpScale.value = e.bumpScale),
								1 === e.side && (t.bumpScale.value *= -1));
							e.normalMap &&
								((t.normalMap.value = e.normalMap),
								t.normalScale.value.copy(e.normalScale),
								1 === e.side && t.normalScale.value.negate());
							e.displacementMap &&
								((t.displacementMap.value = e.displacementMap),
								(t.displacementScale.value = e.displacementScale),
								(t.displacementBias.value = e.displacementBias));
					  })(t, r))
					: r.isMeshStandardMaterial
					? (e(t, r),
					  r.isMeshPhysicalMaterial
							? (function (t, e) {
									n(t, e),
										(t.reflectivity.value = e.reflectivity),
										(t.clearcoat.value = e.clearcoat),
										(t.clearcoatRoughness.value = e.clearcoatRoughness),
										e.sheen && t.sheen.value.copy(e.sheen);
									e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
									e.clearcoatRoughnessMap &&
										(t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
									e.clearcoatNormalMap &&
										(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
										(t.clearcoatNormalMap.value = e.clearcoatNormalMap),
										1 === e.side && t.clearcoatNormalScale.value.negate());
									(t.transmission.value = e.transmission),
										e.transmissionMap &&
											(t.transmissionMap.value = e.transmissionMap);
							  })(t, r)
							: n(t, r))
					: r.isMeshMatcapMaterial
					? (e(t, r),
					  (function (t, e) {
							e.matcap && (t.matcap.value = e.matcap);
							e.bumpMap &&
								((t.bumpMap.value = e.bumpMap),
								(t.bumpScale.value = e.bumpScale),
								1 === e.side && (t.bumpScale.value *= -1));
							e.normalMap &&
								((t.normalMap.value = e.normalMap),
								t.normalScale.value.copy(e.normalScale),
								1 === e.side && t.normalScale.value.negate());
							e.displacementMap &&
								((t.displacementMap.value = e.displacementMap),
								(t.displacementScale.value = e.displacementScale),
								(t.displacementBias.value = e.displacementBias));
					  })(t, r))
					: r.isMeshDepthMaterial
					? (e(t, r),
					  (function (t, e) {
							e.displacementMap &&
								((t.displacementMap.value = e.displacementMap),
								(t.displacementScale.value = e.displacementScale),
								(t.displacementBias.value = e.displacementBias));
					  })(t, r))
					: r.isMeshDistanceMaterial
					? (e(t, r),
					  (function (t, e) {
							e.displacementMap &&
								((t.displacementMap.value = e.displacementMap),
								(t.displacementScale.value = e.displacementScale),
								(t.displacementBias.value = e.displacementBias));
							t.referencePosition.value.copy(e.referencePosition),
								(t.nearDistance.value = e.nearDistance),
								(t.farDistance.value = e.farDistance);
					  })(t, r))
					: r.isMeshNormalMaterial
					? (e(t, r),
					  (function (t, e) {
							e.bumpMap &&
								((t.bumpMap.value = e.bumpMap),
								(t.bumpScale.value = e.bumpScale),
								1 === e.side && (t.bumpScale.value *= -1));
							e.normalMap &&
								((t.normalMap.value = e.normalMap),
								t.normalScale.value.copy(e.normalScale),
								1 === e.side && t.normalScale.value.negate());
							e.displacementMap &&
								((t.displacementMap.value = e.displacementMap),
								(t.displacementScale.value = e.displacementScale),
								(t.displacementBias.value = e.displacementBias));
					  })(t, r))
					: r.isLineBasicMaterial
					? ((function (t, e) {
							t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
					  })(t, r),
					  r.isLineDashedMaterial &&
							(function (t, e) {
								(t.dashSize.value = e.dashSize),
									(t.totalSize.value = e.dashSize + e.gapSize),
									(t.scale.value = e.scale);
							})(t, r))
					: r.isPointsMaterial
					? (function (t, e, n, r) {
							t.diffuse.value.copy(e.color),
								(t.opacity.value = e.opacity),
								(t.size.value = e.size * n),
								(t.scale.value = 0.5 * r),
								e.map && (t.map.value = e.map);
							e.alphaMap && (t.alphaMap.value = e.alphaMap);
							var i;
							e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap);
							void 0 !== i &&
								(!0 === i.matrixAutoUpdate && i.updateMatrix(),
								t.uvTransform.value.copy(i.matrix));
					  })(t, r, i, a)
					: r.isSpriteMaterial
					? (function (t, e) {
							t.diffuse.value.copy(e.color),
								(t.opacity.value = e.opacity),
								(t.rotation.value = e.rotation),
								e.map && (t.map.value = e.map);
							e.alphaMap && (t.alphaMap.value = e.alphaMap);
							var n;
							e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
							void 0 !== n &&
								(!0 === n.matrixAutoUpdate && n.updateMatrix(),
								t.uvTransform.value.copy(n.matrix));
					  })(t, r)
					: r.isShadowMaterial
					? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
					: r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
			},
		};
	}
	function ra(t) {
		var e =
				void 0 !== (t = t || {}).canvas
					? t.canvas
					: document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
			n = void 0 !== t.context ? t.context : null,
			r = void 0 !== t.alpha && t.alpha,
			i = void 0 === t.depth || t.depth,
			a = void 0 === t.stencil || t.stencil,
			o = void 0 !== t.antialias && t.antialias,
			s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
			c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
			l = void 0 !== t.powerPreference ? t.powerPreference : 'default',
			u =
				void 0 !== t.failIfMajorPerformanceCaveat &&
				t.failIfMajorPerformanceCaveat,
			h = null,
			d = null;
		(this.domElement = e),
			(this.debug = { checkShaderErrors: !0 }),
			(this.autoClear = !0),
			(this.autoClearColor = !0),
			(this.autoClearDepth = !0),
			(this.autoClearStencil = !0),
			(this.sortObjects = !0),
			(this.clippingPlanes = []),
			(this.localClippingEnabled = !1),
			(this.gammaFactor = 2),
			(this.outputEncoding = q),
			(this.physicallyCorrectLights = !1),
			(this.toneMapping = 0),
			(this.toneMappingExposure = 1),
			(this.maxMorphTargets = 8),
			(this.maxMorphNormals = 4);
		var p = this,
			f = !1,
			m = null,
			v = 0,
			g = 0,
			x = null,
			_ = null,
			M = -1,
			S = null,
			E = null,
			A = new yt(),
			L = new yt(),
			R = null,
			C = e.width,
			P = e.height,
			I = 1,
			D = null,
			N = null,
			O = new yt(0, 0, C, P),
			B = new yt(0, 0, C, P),
			z = !1,
			G = new Qn(),
			F = !1,
			U = !1,
			H = new Jt(),
			k = new wt(),
			V = {
				background: null,
				fog: null,
				environment: null,
				overrideMaterial: null,
				isScene: !0,
			};
		function W() {
			return null === x ? I : 1;
		}
		var j,
			X,
			Y,
			Z,
			J,
			Q,
			K,
			$,
			tt,
			et,
			nt,
			rt,
			it,
			at,
			ot,
			ct,
			lt,
			ut,
			ht,
			dt,
			ft,
			mt = n;
		function vt(t, n) {
			for (var r = 0; r < t.length; r++) {
				var i = t[r],
					a = e.getContext(i, n);
				if (null !== a) return a;
			}
			return null;
		}
		try {
			var gt = {
				alpha: r,
				depth: i,
				stencil: a,
				antialias: o,
				premultipliedAlpha: s,
				preserveDrawingBuffer: c,
				powerPreference: l,
				failIfMajorPerformanceCaveat: u,
			};
			if (
				(e.addEventListener('webglcontextlost', St, !1),
				e.addEventListener('webglcontextrestored', Tt, !1),
				null === mt)
			) {
				var xt = ['webgl2', 'webgl', 'experimental-webgl'];
				if (
					(!0 === p.isWebGL1Renderer && xt.shift(), null === (mt = vt(xt, gt)))
				)
					throw vt(xt)
						? new Error(
								'Error creating WebGL context with your selected attributes.'
						  )
						: new Error('Error creating WebGL context.');
			}
			void 0 === mt.getShaderPrecisionFormat &&
				(mt.getShaderPrecisionFormat = function () {
					return { rangeMin: 1, rangeMax: 1, precision: 1 };
				});
		} catch (t) {
			throw (console.error('THREE.WebGLRenderer: ' + t.message), t);
		}
		function _t() {
			(j = new ur(mt)),
				!1 === (X = new sr(mt, j, t)).isWebGL2 &&
					(j.get('WEBGL_depth_texture'),
					j.get('OES_texture_float'),
					j.get('OES_texture_half_float'),
					j.get('OES_texture_half_float_linear'),
					j.get('OES_standard_derivatives'),
					j.get('OES_element_index_uint'),
					j.get('OES_vertex_array_object'),
					j.get('ANGLE_instanced_arrays')),
				j.get('OES_texture_float_linear'),
				(dt = new Qi(mt, j, X)),
				(Y = new Zi(mt, j, X)).scissor(L.copy(B).multiplyScalar(I).floor()),
				Y.viewport(A.copy(O).multiplyScalar(I).floor()),
				(Z = new pr(mt)),
				(J = new Oi()),
				(Q = new Ji(mt, j, Y, J, X, dt, Z)),
				(K = new lr(p)),
				($ = new $n(mt, X)),
				(ft = new ar(mt, j, $, X)),
				(tt = new hr(mt, $, Z, ft)),
				(et = new gr(mt, tt, $, Z)),
				(lt = new vr(mt)),
				(ot = new cr(J)),
				(nt = new Ni(p, K, j, X, ft, ot)),
				(rt = new na(J)),
				(it = new Fi(J)),
				(at = new ji()),
				(ct = new ir(p, K, Y, et, s)),
				(ut = new or(mt, j, Z, X)),
				(ht = new dr(mt, j, Z, X)),
				(Z.programs = nt.programs),
				(p.capabilities = X),
				(p.extensions = j),
				(p.properties = J),
				(p.renderLists = it),
				(p.state = Y),
				(p.info = Z);
		}
		_t();
		var bt = new ea(p, mt);
		this.xr = bt;
		var Mt = new Yi(p, et, X.maxTextureSize);
		function St(t) {
			t.preventDefault(),
				console.log('THREE.WebGLRenderer: Context Lost.'),
				(f = !0);
		}
		function Tt() {
			console.log('THREE.WebGLRenderer: Context Restored.'), (f = !1), _t();
		}
		function Et(t) {
			var e = t.target;
			e.removeEventListener('dispose', Et),
				(function (t) {
					At(t), J.remove(t);
				})(e);
		}
		function At(t) {
			var e = J.get(t).program;
			void 0 !== e && nt.releaseProgram(e);
		}
		(this.shadowMap = Mt),
			(this.getContext = function () {
				return mt;
			}),
			(this.getContextAttributes = function () {
				return mt.getContextAttributes();
			}),
			(this.forceContextLoss = function () {
				var t = j.get('WEBGL_lose_context');
				t && t.loseContext();
			}),
			(this.forceContextRestore = function () {
				var t = j.get('WEBGL_lose_context');
				t && t.restoreContext();
			}),
			(this.getPixelRatio = function () {
				return I;
			}),
			(this.setPixelRatio = function (t) {
				void 0 !== t && ((I = t), this.setSize(C, P, !1));
			}),
			(this.getSize = function (t) {
				return (
					void 0 === t &&
						(console.warn(
							'WebGLRenderer: .getsize() now requires a Vector2 as an argument'
						),
						(t = new pt())),
					t.set(C, P)
				);
			}),
			(this.setSize = function (t, n, r) {
				bt.isPresenting
					? console.warn(
							"THREE.WebGLRenderer: Can't change size while VR device is presenting."
					  )
					: ((C = t),
					  (P = n),
					  (e.width = Math.floor(t * I)),
					  (e.height = Math.floor(n * I)),
					  !1 !== r &&
							((e.style.width = t + 'px'), (e.style.height = n + 'px')),
					  this.setViewport(0, 0, t, n));
			}),
			(this.getDrawingBufferSize = function (t) {
				return (
					void 0 === t &&
						(console.warn(
							'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument'
						),
						(t = new pt())),
					t.set(C * I, P * I).floor()
				);
			}),
			(this.setDrawingBufferSize = function (t, n, r) {
				(C = t),
					(P = n),
					(I = r),
					(e.width = Math.floor(t * r)),
					(e.height = Math.floor(n * r)),
					this.setViewport(0, 0, t, n);
			}),
			(this.getCurrentViewport = function (t) {
				return (
					void 0 === t &&
						(console.warn(
							'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument'
						),
						(t = new yt())),
					t.copy(A)
				);
			}),
			(this.getViewport = function (t) {
				return t.copy(O);
			}),
			(this.setViewport = function (t, e, n, r) {
				t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, r),
					Y.viewport(A.copy(O).multiplyScalar(I).floor());
			}),
			(this.getScissor = function (t) {
				return t.copy(B);
			}),
			(this.setScissor = function (t, e, n, r) {
				t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, r),
					Y.scissor(L.copy(B).multiplyScalar(I).floor());
			}),
			(this.getScissorTest = function () {
				return z;
			}),
			(this.setScissorTest = function (t) {
				Y.setScissorTest((z = t));
			}),
			(this.setOpaqueSort = function (t) {
				D = t;
			}),
			(this.setTransparentSort = function (t) {
				N = t;
			}),
			(this.getClearColor = function () {
				return ct.getClearColor();
			}),
			(this.setClearColor = function () {
				ct.setClearColor.apply(ct, arguments);
			}),
			(this.getClearAlpha = function () {
				return ct.getClearAlpha();
			}),
			(this.setClearAlpha = function () {
				ct.setClearAlpha.apply(ct, arguments);
			}),
			(this.clear = function (t, e, n) {
				var r = 0;
				(void 0 === t || t) && (r |= 16384),
					(void 0 === e || e) && (r |= 256),
					(void 0 === n || n) && (r |= 1024),
					mt.clear(r);
			}),
			(this.clearColor = function () {
				this.clear(!0, !1, !1);
			}),
			(this.clearDepth = function () {
				this.clear(!1, !0, !1);
			}),
			(this.clearStencil = function () {
				this.clear(!1, !1, !0);
			}),
			(this.dispose = function () {
				e.removeEventListener('webglcontextlost', St, !1),
					e.removeEventListener('webglcontextrestored', Tt, !1),
					it.dispose(),
					at.dispose(),
					J.dispose(),
					K.dispose(),
					et.dispose(),
					ft.dispose(),
					bt.dispose(),
					Rt.stop();
			}),
			(this.renderBufferImmediate = function (t, e) {
				ft.initAttributes();
				var n = J.get(t);
				t.hasPositions && !n.position && (n.position = mt.createBuffer()),
					t.hasNormals && !n.normal && (n.normal = mt.createBuffer()),
					t.hasUvs && !n.uv && (n.uv = mt.createBuffer()),
					t.hasColors && !n.color && (n.color = mt.createBuffer());
				var r = e.getAttributes();
				t.hasPositions &&
					(mt.bindBuffer(34962, n.position),
					mt.bufferData(34962, t.positionArray, 35048),
					ft.enableAttribute(r.position),
					mt.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
					t.hasNormals &&
						(mt.bindBuffer(34962, n.normal),
						mt.bufferData(34962, t.normalArray, 35048),
						ft.enableAttribute(r.normal),
						mt.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
					t.hasUvs &&
						(mt.bindBuffer(34962, n.uv),
						mt.bufferData(34962, t.uvArray, 35048),
						ft.enableAttribute(r.uv),
						mt.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
					t.hasColors &&
						(mt.bindBuffer(34962, n.color),
						mt.bufferData(34962, t.colorArray, 35048),
						ft.enableAttribute(r.color),
						mt.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
					ft.disableUnusedAttributes(),
					mt.drawArrays(4, 0, t.count),
					(t.count = 0);
			}),
			(this.renderBufferDirect = function (t, e, n, r, i, a) {
				null === e && (e = V);
				var o = i.isMesh && i.matrixWorld.determinant() < 0,
					s = Nt(t, e, r, i);
				Y.setMaterial(r, o);
				var c = n.index,
					l = n.attributes.position;
				if (null === c) {
					if (void 0 === l || 0 === l.count) return;
				} else if (0 === c.count) return;
				var u,
					h = 1;
				!0 === r.wireframe && ((c = tt.getWireframeAttribute(n)), (h = 2)),
					(r.morphTargets || r.morphNormals) && lt.update(i, n, r, s),
					ft.setup(i, r, s, n, c);
				var d = ut;
				null !== c && ((u = $.get(c)), (d = ht).setIndex(u));
				var p = null !== c ? c.count : l.count,
					f = n.drawRange.start * h,
					m = n.drawRange.count * h,
					v = null !== a ? a.start * h : 0,
					g = null !== a ? a.count * h : 1 / 0,
					y = Math.max(f, v),
					x = Math.min(p, f + m, v + g) - 1,
					_ = Math.max(0, x - y + 1);
				if (0 !== _) {
					if (i.isMesh)
						!0 === r.wireframe
							? (Y.setLineWidth(r.wireframeLinewidth * W()), d.setMode(1))
							: d.setMode(4);
					else if (i.isLine) {
						var b = r.linewidth;
						void 0 === b && (b = 1),
							Y.setLineWidth(b * W()),
							i.isLineSegments
								? d.setMode(1)
								: i.isLineLoop
								? d.setMode(2)
								: d.setMode(3);
					} else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
					if (i.isInstancedMesh) d.renderInstances(y, _, i.count);
					else if (n.isInstancedBufferGeometry) {
						var w = Math.min(n.instanceCount, n._maxInstanceCount);
						d.renderInstances(y, _, w);
					} else d.render(y, _);
				}
			}),
			(this.compile = function (t, e) {
				(d = at.get(t, e)).init(),
					t.traverse(function (t) {
						t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t));
					}),
					d.setupLights(e);
				var n = new WeakMap();
				t.traverse(function (e) {
					var r = e.material;
					if (r)
						if (Array.isArray(r))
							for (var i = 0; i < r.length; i++) {
								var a = r[i];
								!1 === n.has(a) && (Dt(a, t, e), n.set(a));
							}
						else !1 === n.has(r) && (Dt(r, t, e), n.set(r));
				});
			});
		var Lt = null;
		var Rt = new Kn();
		function Ct(t, e, n, r) {
			if (!1 !== t.visible) {
				if (t.layers.test(e.layers))
					if (t.isGroup) n = t.renderOrder;
					else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
					else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
					else if (t.isSprite) {
						if (!t.frustumCulled || G.intersectsSprite(t)) {
							r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
							var i = et.update(t),
								a = t.material;
							a.visible && h.push(t, i, a, n, k.z, null);
						}
					} else if (t.isImmediateRenderObject)
						r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H),
							h.push(t, null, t.material, n, k.z, null);
					else if (
						(t.isMesh || t.isLine || t.isPoints) &&
						(t.isSkinnedMesh &&
							t.skeleton.frame !== Z.render.frame &&
							(t.skeleton.update(), (t.skeleton.frame = Z.render.frame)),
						!t.frustumCulled || G.intersectsObject(t))
					) {
						r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
						var o = et.update(t),
							s = t.material;
						if (Array.isArray(s))
							for (var c = o.groups, l = 0, u = c.length; l < u; l++) {
								var p = c[l],
									f = s[p.materialIndex];
								f && f.visible && h.push(t, o, f, n, k.z, p);
							}
						else s.visible && h.push(t, o, s, n, k.z, null);
					}
				for (var m = t.children, v = 0, g = m.length; v < g; v++)
					Ct(m[v], e, n, r);
			}
		}
		function Pt(t, e, n) {
			for (
				var r = !0 === e.isScene ? e.overrideMaterial : null,
					i = 0,
					a = t.length;
				i < a;
				i++
			) {
				var o = t[i],
					s = o.object,
					c = o.geometry,
					l = null === r ? o.material : r,
					u = o.group;
				if (n.isArrayCamera) {
					E = n;
					for (var h = n.cameras, p = 0, f = h.length; p < f; p++) {
						var m = h[p];
						s.layers.test(m.layers) &&
							(Y.viewport(A.copy(m.viewport)),
							d.setupLights(m),
							It(s, e, m, c, l, u));
					}
				} else (E = null), It(s, e, n, c, l, u);
			}
		}
		function It(t, e, n, r, i, a) {
			if (
				(t.onBeforeRender(p, e, n, r, i, a),
				(d = at.get(e, E || n)),
				t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
				t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
				t.isImmediateRenderObject)
			) {
				var o = Nt(n, e, i, t);
				Y.setMaterial(i),
					ft.reset(),
					(function (t, e) {
						t.render(function (t) {
							p.renderBufferImmediate(t, e);
						});
					})(t, o);
			} else p.renderBufferDirect(n, e, r, i, t, a);
			t.onAfterRender(p, e, n, r, i, a), (d = at.get(e, E || n));
		}
		function Dt(t, e, n) {
			!0 !== e.isScene && (e = V);
			var r = J.get(t),
				i = d.state.lights,
				a = d.state.shadowsArray,
				o = i.state.version,
				s = nt.getParameters(t, i.state, a, e, n),
				c = nt.getProgramCacheKey(s),
				l = r.program,
				u = !0;
			if (void 0 === l) t.addEventListener('dispose', Et);
			else if (l.cacheKey !== c) At(t);
			else if (r.lightsStateVersion !== o) u = !1;
			else {
				if (void 0 !== s.shaderID) {
					var h = t.isMeshStandardMaterial ? e.environment : null;
					return void (r.envMap = K.get(t.envMap || h));
				}
				u = !1;
			}
			u &&
				((s.uniforms = nt.getUniforms(t)),
				t.onBeforeCompile(s, p),
				(l = nt.acquireProgram(s, c)),
				(r.program = l),
				(r.uniforms = s.uniforms),
				(r.outputEncoding = s.outputEncoding));
			var f = r.uniforms;
			((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
				((r.numClippingPlanes = ot.numPlanes),
				(r.numIntersection = ot.numIntersection),
				(f.clippingPlanes = ot.uniform)),
				(r.environment = t.isMeshStandardMaterial ? e.environment : null),
				(r.fog = e.fog),
				(r.envMap = K.get(t.envMap || r.environment)),
				(r.needsLights = (function (t) {
					return (
						t.isMeshLambertMaterial ||
						t.isMeshToonMaterial ||
						t.isMeshPhongMaterial ||
						t.isMeshStandardMaterial ||
						t.isShadowMaterial ||
						(t.isShaderMaterial && !0 === t.lights)
					);
				})(t)),
				(r.lightsStateVersion = o),
				r.needsLights &&
					((f.ambientLightColor.value = i.state.ambient),
					(f.lightProbe.value = i.state.probe),
					(f.directionalLights.value = i.state.directional),
					(f.directionalLightShadows.value = i.state.directionalShadow),
					(f.spotLights.value = i.state.spot),
					(f.spotLightShadows.value = i.state.spotShadow),
					(f.rectAreaLights.value = i.state.rectArea),
					(f.ltc_1.value = i.state.rectAreaLTC1),
					(f.ltc_2.value = i.state.rectAreaLTC2),
					(f.pointLights.value = i.state.point),
					(f.pointLightShadows.value = i.state.pointShadow),
					(f.hemisphereLights.value = i.state.hemi),
					(f.directionalShadowMap.value = i.state.directionalShadowMap),
					(f.directionalShadowMatrix.value = i.state.directionalShadowMatrix),
					(f.spotShadowMap.value = i.state.spotShadowMap),
					(f.spotShadowMatrix.value = i.state.spotShadowMatrix),
					(f.pointShadowMap.value = i.state.pointShadowMap),
					(f.pointShadowMatrix.value = i.state.pointShadowMatrix));
			var m = r.program.getUniforms(),
				v = fi.seqWithValue(m.seq, f);
			r.uniformsList = v;
		}
		function Nt(t, e, n, r) {
			!0 !== e.isScene && (e = V), Q.resetTextureUnits();
			var i = e.fog,
				a = n.isMeshStandardMaterial ? e.environment : null,
				o = null === x ? p.outputEncoding : x.texture.encoding,
				s = K.get(n.envMap || a),
				c = J.get(n),
				l = d.state.lights;
			if (!0 === F && (!0 === U || t !== S)) {
				var u = t === S && n.id === M;
				ot.setState(n, t, u);
			}
			n.version === c.__version
				? (n.fog && c.fog !== i) ||
				  c.environment !== a ||
				  (c.needsLights && c.lightsStateVersion !== l.state.version)
					? Dt(n, e, r)
					: void 0 === c.numClippingPlanes ||
					  (c.numClippingPlanes === ot.numPlanes &&
							c.numIntersection === ot.numIntersection)
					? (c.outputEncoding !== o || c.envMap !== s) && Dt(n, e, r)
					: Dt(n, e, r)
				: (Dt(n, e, r), (c.__version = n.version));
			var h,
				f,
				m = !1,
				v = !1,
				g = !1,
				y = c.program,
				_ = y.getUniforms(),
				w = c.uniforms;
			if (
				(Y.useProgram(y.program) && ((m = !0), (v = !0), (g = !0)),
				n.id !== M && ((M = n.id), (v = !0)),
				m || S !== t)
			) {
				if (
					(_.setValue(mt, 'projectionMatrix', t.projectionMatrix),
					X.logarithmicDepthBuffer &&
						_.setValue(
							mt,
							'logDepthBufFC',
							2 / (Math.log(t.far + 1) / Math.LN2)
						),
					S !== t && ((S = t), (v = !0), (g = !0)),
					n.isShaderMaterial ||
						n.isMeshPhongMaterial ||
						n.isMeshToonMaterial ||
						n.isMeshStandardMaterial ||
						n.envMap)
				) {
					var E = _.map.cameraPosition;
					void 0 !== E &&
						E.setValue(mt, k.setFromMatrixPosition(t.matrixWorld));
				}
				(n.isMeshPhongMaterial ||
					n.isMeshToonMaterial ||
					n.isMeshLambertMaterial ||
					n.isMeshBasicMaterial ||
					n.isMeshStandardMaterial ||
					n.isShaderMaterial) &&
					_.setValue(mt, 'isOrthographic', !0 === t.isOrthographicCamera),
					(n.isMeshPhongMaterial ||
						n.isMeshToonMaterial ||
						n.isMeshLambertMaterial ||
						n.isMeshBasicMaterial ||
						n.isMeshStandardMaterial ||
						n.isShaderMaterial ||
						n.isShadowMaterial ||
						n.skinning) &&
						_.setValue(mt, 'viewMatrix', t.matrixWorldInverse);
			}
			if (n.skinning) {
				_.setOptional(mt, r, 'bindMatrix'),
					_.setOptional(mt, r, 'bindMatrixInverse');
				var A = r.skeleton;
				if (A) {
					var L = A.bones;
					if (X.floatVertexTextures) {
						if (void 0 === A.boneTexture) {
							var R = Math.sqrt(4 * L.length);
							(R = st.ceilPowerOfTwo(R)), (R = Math.max(R, 4));
							var C = new Float32Array(R * R * 4);
							C.set(A.boneMatrices);
							var D = new Yn(C, R, R, T, b);
							(A.boneMatrices = C),
								(A.boneTexture = D),
								(A.boneTextureSize = R);
						}
						_.setValue(mt, 'boneTexture', A.boneTexture, Q),
							_.setValue(mt, 'boneTextureSize', A.boneTextureSize);
					} else _.setOptional(mt, A, 'boneMatrices');
				}
			}
			return (
				(v || c.receiveShadow !== r.receiveShadow) &&
					((c.receiveShadow = r.receiveShadow),
					_.setValue(mt, 'receiveShadow', r.receiveShadow)),
				v &&
					(_.setValue(mt, 'toneMappingExposure', p.toneMappingExposure),
					c.needsLights &&
						((f = g),
						((h = w).ambientLightColor.needsUpdate = f),
						(h.lightProbe.needsUpdate = f),
						(h.directionalLights.needsUpdate = f),
						(h.directionalLightShadows.needsUpdate = f),
						(h.pointLights.needsUpdate = f),
						(h.pointLightShadows.needsUpdate = f),
						(h.spotLights.needsUpdate = f),
						(h.spotLightShadows.needsUpdate = f),
						(h.rectAreaLights.needsUpdate = f),
						(h.hemisphereLights.needsUpdate = f)),
					i && n.fog && rt.refreshFogUniforms(w, i),
					rt.refreshMaterialUniforms(w, n, I, P),
					fi.upload(mt, c.uniformsList, w, Q)),
				n.isShaderMaterial &&
					!0 === n.uniformsNeedUpdate &&
					(fi.upload(mt, c.uniformsList, w, Q), (n.uniformsNeedUpdate = !1)),
				n.isSpriteMaterial && _.setValue(mt, 'center', r.center),
				_.setValue(mt, 'modelViewMatrix', r.modelViewMatrix),
				_.setValue(mt, 'normalMatrix', r.normalMatrix),
				_.setValue(mt, 'modelMatrix', r.matrixWorld),
				y
			);
		}
		Rt.setAnimationLoop(function (t) {
			bt.isPresenting || (Lt && Lt(t));
		}),
			'undefined' != typeof window && Rt.setContext(window),
			(this.setAnimationLoop = function (t) {
				(Lt = t), bt.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start();
			}),
			(this.render = function (t, e) {
				var n, r;
				if (
					(void 0 !== arguments[2] &&
						(console.warn(
							'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.'
						),
						(n = arguments[2])),
					void 0 !== arguments[3] &&
						(console.warn(
							'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.'
						),
						(r = arguments[3])),
					void 0 === e || !0 === e.isCamera)
				) {
					if (!0 !== f) {
						ft.resetDefaultState(),
							(M = -1),
							(S = null),
							!0 === t.autoUpdate && t.updateMatrixWorld(),
							null === e.parent && e.updateMatrixWorld(),
							!0 === bt.enabled &&
								!0 === bt.isPresenting &&
								(e = bt.getCamera(e)),
							!0 === t.isScene && t.onBeforeRender(p, t, e, n || x),
							(d = at.get(t, e)).init(),
							H.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
							G.setFromProjectionMatrix(H),
							(U = this.localClippingEnabled),
							(F = ot.init(this.clippingPlanes, U, e)),
							(h = it.get(t, e)).init(),
							Ct(t, e, 0, p.sortObjects),
							h.finish(),
							!0 === p.sortObjects && h.sort(D, N),
							!0 === F && ot.beginShadows();
						var i = d.state.shadowsArray;
						Mt.render(i, t, e),
							d.setupLights(e),
							!0 === F && ot.endShadows(),
							!0 === this.info.autoReset && this.info.reset(),
							void 0 !== n && this.setRenderTarget(n),
							ct.render(h, t, e, r);
						var a = h.opaque,
							o = h.transparent;
						a.length > 0 && Pt(a, t, e),
							o.length > 0 && Pt(o, t, e),
							!0 === t.isScene && t.onAfterRender(p, t, e),
							null !== x &&
								(Q.updateRenderTargetMipmap(x),
								Q.updateMultisampleRenderTarget(x)),
							Y.buffers.depth.setTest(!0),
							Y.buffers.depth.setMask(!0),
							Y.buffers.color.setMask(!0),
							Y.setPolygonOffset(!1),
							(h = null),
							(d = null);
					}
				} else
					console.error(
						'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
					);
			}),
			(this.setFramebuffer = function (t) {
				m !== t && null === x && mt.bindFramebuffer(36160, t), (m = t);
			}),
			(this.getActiveCubeFace = function () {
				return v;
			}),
			(this.getActiveMipmapLevel = function () {
				return g;
			}),
			(this.getRenderList = function () {
				return h;
			}),
			(this.setRenderList = function (t) {
				h = t;
			}),
			(this.getRenderState = function () {
				return d;
			}),
			(this.setRenderState = function (t) {
				d = t;
			}),
			(this.getRenderTarget = function () {
				return x;
			}),
			(this.setRenderTarget = function (t, e, n) {
				void 0 === e && (e = 0),
					void 0 === n && (n = 0),
					(x = t),
					(v = e),
					(g = n),
					t && void 0 === J.get(t).__webglFramebuffer && Q.setupRenderTarget(t);
				var r = m,
					i = !1;
				if (t) {
					var a = J.get(t).__webglFramebuffer;
					t.isWebGLCubeRenderTarget
						? ((r = a[e]), (i = !0))
						: (r = t.isWebGLMultisampleRenderTarget
								? J.get(t).__webglMultisampledFramebuffer
								: a),
						A.copy(t.viewport),
						L.copy(t.scissor),
						(R = t.scissorTest);
				} else
					A.copy(O).multiplyScalar(I).floor(),
						L.copy(B).multiplyScalar(I).floor(),
						(R = z);
				if (
					(_ !== r && (mt.bindFramebuffer(36160, r), (_ = r)),
					Y.viewport(A),
					Y.scissor(L),
					Y.setScissorTest(R),
					i)
				) {
					var o = J.get(t.texture);
					mt.framebufferTexture2D(36160, 36064, 34069 + e, o.__webglTexture, n);
				}
			}),
			(this.readRenderTargetPixels = function (t, e, n, r, i, a, o) {
				if (t && t.isWebGLRenderTarget) {
					var s = J.get(t).__webglFramebuffer;
					if ((t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s)) {
						var c = !1;
						s !== _ && (mt.bindFramebuffer(36160, s), (c = !0));
						try {
							var l = t.texture,
								u = l.format,
								h = l.type;
							if (u !== T && dt.convert(u) !== mt.getParameter(35739))
								return void console.error(
									'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
								);
							if (
								!(
									h === y ||
									dt.convert(h) === mt.getParameter(35738) ||
									(h === b &&
										(X.isWebGL2 ||
											j.get('OES_texture_float') ||
											j.get('WEBGL_color_buffer_float'))) ||
									(h === w &&
										(X.isWebGL2
											? j.get('EXT_color_buffer_float')
											: j.get('EXT_color_buffer_half_float')))
								)
							)
								return void console.error(
									'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
								);
							36053 === mt.checkFramebufferStatus(36160)
								? e >= 0 &&
								  e <= t.width - r &&
								  n >= 0 &&
								  n <= t.height - i &&
								  mt.readPixels(e, n, r, i, dt.convert(u), dt.convert(h), a)
								: console.error(
										'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.'
								  );
						} finally {
							c && mt.bindFramebuffer(36160, _);
						}
					}
				} else
					console.error(
						'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
					);
			}),
			(this.copyFramebufferToTexture = function (t, e, n) {
				void 0 === n && (n = 0);
				var r = Math.pow(2, -n),
					i = Math.floor(e.image.width * r),
					a = Math.floor(e.image.height * r),
					o = dt.convert(e.format);
				Q.setTexture2D(e, 0),
					mt.copyTexImage2D(3553, n, o, t.x, t.y, i, a, 0),
					Y.unbindTexture();
			}),
			(this.copyTextureToTexture = function (t, e, n, r) {
				void 0 === r && (r = 0);
				var i = e.image.width,
					a = e.image.height,
					o = dt.convert(n.format),
					s = dt.convert(n.type);
				Q.setTexture2D(n, 0),
					mt.pixelStorei(37440, n.flipY),
					mt.pixelStorei(37441, n.premultiplyAlpha),
					mt.pixelStorei(3317, n.unpackAlignment),
					e.isDataTexture
						? mt.texSubImage2D(3553, r, t.x, t.y, i, a, o, s, e.image.data)
						: e.isCompressedTexture
						? mt.compressedTexSubImage2D(
								3553,
								r,
								t.x,
								t.y,
								e.mipmaps[0].width,
								e.mipmaps[0].height,
								o,
								e.mipmaps[0].data
						  )
						: mt.texSubImage2D(3553, r, t.x, t.y, o, s, e.image),
					0 === r && n.generateMipmaps && mt.generateMipmap(3553),
					Y.unbindTexture();
			}),
			(this.initTexture = function (t) {
				Q.setTexture2D(t, 0), Y.unbindTexture();
			}),
			'undefined' != typeof __THREE_DEVTOOLS__ &&
				__THREE_DEVTOOLS__.dispatchEvent(
					new CustomEvent('observe', { detail: this })
				);
	}
	function ia(t) {
		ra.call(this, t);
	}
	(Ki.prototype = Object.assign(Object.create(Vn.prototype), {
		constructor: Ki,
		isArrayCamera: !0,
	})),
		($i.prototype = Object.assign(Object.create(be.prototype), {
			constructor: $i,
			isGroup: !0,
		})),
		Object.assign(ta.prototype, {
			constructor: ta,
			getHandSpace: function () {
				if (
					null === this._hand &&
					((this._hand = new $i()),
					(this._hand.matrixAutoUpdate = !1),
					(this._hand.visible = !1),
					(this._hand.joints = []),
					(this._hand.inputState = { pinching: !1 }),
					window.XRHand)
				)
					for (var t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
						var e = new $i();
						(e.matrixAutoUpdate = !1),
							(e.visible = !1),
							this._hand.joints.push(e),
							this._hand.add(e);
					}
				return this._hand;
			},
			getTargetRaySpace: function () {
				return (
					null === this._targetRay &&
						((this._targetRay = new $i()),
						(this._targetRay.matrixAutoUpdate = !1),
						(this._targetRay.visible = !1)),
					this._targetRay
				);
			},
			getGripSpace: function () {
				return (
					null === this._grip &&
						((this._grip = new $i()),
						(this._grip.matrixAutoUpdate = !1),
						(this._grip.visible = !1)),
					this._grip
				);
			},
			dispatchEvent: function (t) {
				return (
					null !== this._targetRay && this._targetRay.dispatchEvent(t),
					null !== this._grip && this._grip.dispatchEvent(t),
					null !== this._hand && this._hand.dispatchEvent(t),
					this
				);
			},
			disconnect: function (t) {
				return (
					this.dispatchEvent({ type: 'disconnected', data: t }),
					null !== this._targetRay && (this._targetRay.visible = !1),
					null !== this._grip && (this._grip.visible = !1),
					null !== this._hand && (this._hand.visible = !1),
					this
				);
			},
			update: function (t, e, n) {
				var r = null,
					i = null,
					a = null,
					o = this._targetRay,
					s = this._grip,
					c = this._hand;
				if (t)
					if (c && t.hand) {
						a = !0;
						for (var l = 0; l <= window.XRHand.LITTLE_PHALANX_TIP; l++)
							if (t.hand[l]) {
								var u = e.getJointPose(t.hand[l], n),
									h = c.joints[l];
								null !== u &&
									(h.matrix.fromArray(u.transform.matrix),
									h.matrix.decompose(h.position, h.rotation, h.scale),
									(h.jointRadius = u.radius)),
									(h.visible = null !== u);
								var d = c.joints[window.XRHand.INDEX_PHALANX_TIP],
									p = c.joints[window.XRHand.THUMB_PHALANX_TIP],
									f = d.position.distanceTo(p.position);
								c.inputState.pinching && f > 0.025
									? ((c.inputState.pinching = !1),
									  this.dispatchEvent({
											type: 'pinchend',
											handedness: t.handedness,
											target: this,
									  }))
									: !c.inputState.pinching &&
									  f <= 0.015 &&
									  ((c.inputState.pinching = !0),
									  this.dispatchEvent({
											type: 'pinchstart',
											handedness: t.handedness,
											target: this,
									  }));
							}
					} else
						null !== o &&
							null !== (r = e.getPose(t.targetRaySpace, n)) &&
							(o.matrix.fromArray(r.transform.matrix),
							o.matrix.decompose(o.position, o.rotation, o.scale)),
							null !== s &&
								t.gripSpace &&
								null !== (i = e.getPose(t.gripSpace, n)) &&
								(s.matrix.fromArray(i.transform.matrix),
								s.matrix.decompose(s.position, s.rotation, s.scale));
				return (
					null !== o && (o.visible = null !== r),
					null !== s && (s.visible = null !== i),
					null !== c && (c.visible = null !== a),
					this
				);
			},
		}),
		Object.assign(ea.prototype, rt.prototype),
		(ia.prototype = Object.assign(Object.create(ra.prototype), {
			constructor: ia,
			isWebGL1Renderer: !0,
		}));
	var aa = (function () {
			function t(t, e) {
				Object.defineProperty(this, 'isFogExp2', { value: !0 }),
					(this.name = ''),
					(this.color = new Ve(t)),
					(this.density = void 0 !== e ? e : 25e-5);
			}
			var e = t.prototype;
			return (
				(e.clone = function () {
					return new t(this.color, this.density);
				}),
				(e.toJSON = function () {
					return {
						type: 'FogExp2',
						color: this.color.getHex(),
						density: this.density,
					};
				}),
				t
			);
		})(),
		oa = (function () {
			function t(t, e, n) {
				Object.defineProperty(this, 'isFog', { value: !0 }),
					(this.name = ''),
					(this.color = new Ve(t)),
					(this.near = void 0 !== e ? e : 1),
					(this.far = void 0 !== n ? n : 1e3);
			}
			var e = t.prototype;
			return (
				(e.clone = function () {
					return new t(this.color, this.near, this.far);
				}),
				(e.toJSON = function () {
					return {
						type: 'Fog',
						color: this.color.getHex(),
						near: this.near,
						far: this.far,
					};
				}),
				t
			);
		})(),
		sa = (function (t) {
			function e() {
				var e;
				return (
					(e = t.call(this) || this),
					Object.defineProperty(ht(e), 'isScene', { value: !0 }),
					(e.type = 'Scene'),
					(e.background = null),
					(e.environment = null),
					(e.fog = null),
					(e.overrideMaterial = null),
					(e.autoUpdate = !0),
					'undefined' != typeof __THREE_DEVTOOLS__ &&
						__THREE_DEVTOOLS__.dispatchEvent(
							new CustomEvent('observe', { detail: ht(e) })
						),
					e
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.copy = function (e, n) {
					return (
						t.prototype.copy.call(this, e, n),
						null !== e.background && (this.background = e.background.clone()),
						null !== e.environment &&
							(this.environment = e.environment.clone()),
						null !== e.fog && (this.fog = e.fog.clone()),
						null !== e.overrideMaterial &&
							(this.overrideMaterial = e.overrideMaterial.clone()),
						(this.autoUpdate = e.autoUpdate),
						(this.matrixAutoUpdate = e.matrixAutoUpdate),
						this
					);
				}),
				(n.toJSON = function (e) {
					var n = t.prototype.toJSON.call(this, e);
					return (
						null !== this.background &&
							(n.object.background = this.background.toJSON(e)),
						null !== this.environment &&
							(n.object.environment = this.environment.toJSON(e)),
						null !== this.fog && (n.object.fog = this.fog.toJSON()),
						n
					);
				}),
				e
			);
		})(be);
	function ca(t, e) {
		(this.array = t),
			(this.stride = e),
			(this.count = void 0 !== t ? t.length / e : 0),
			(this.usage = tt),
			(this.updateRange = { offset: 0, count: -1 }),
			(this.version = 0),
			(this.uuid = st.generateUUID());
	}
	Object.defineProperty(ca.prototype, 'needsUpdate', {
		set: function (t) {
			!0 === t && this.version++;
		},
	}),
		Object.assign(ca.prototype, {
			isInterleavedBuffer: !0,
			onUploadCallback: function () {},
			setUsage: function (t) {
				return (this.usage = t), this;
			},
			copy: function (t) {
				return (
					(this.array = new t.array.constructor(t.array)),
					(this.count = t.count),
					(this.stride = t.stride),
					(this.usage = t.usage),
					this
				);
			},
			copyAt: function (t, e, n) {
				(t *= this.stride), (n *= e.stride);
				for (var r = 0, i = this.stride; r < i; r++)
					this.array[t + r] = e.array[n + r];
				return this;
			},
			set: function (t, e) {
				return void 0 === e && (e = 0), this.array.set(t, e), this;
			},
			clone: function (t) {
				void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
					void 0 === this.array.buffer._uuid &&
						(this.array.buffer._uuid = st.generateUUID()),
					void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
						(t.arrayBuffers[this.array.buffer._uuid] =
							this.array.slice(0).buffer);
				var e = new ca(
					new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
					this.stride
				);
				return e.setUsage(this.usage), e;
			},
			onUpload: function (t) {
				return (this.onUploadCallback = t), this;
			},
			toJSON: function (t) {
				return (
					void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
					void 0 === this.array.buffer._uuid &&
						(this.array.buffer._uuid = st.generateUUID()),
					void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
						(t.arrayBuffers[this.array.buffer._uuid] =
							Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
					{
						uuid: this.uuid,
						buffer: this.array.buffer._uuid,
						type: this.array.constructor.name,
						stride: this.stride,
					}
				);
			},
		});
	var la,
		ua = new wt();
	function ha(t, e, n, r) {
		(this.name = ''),
			(this.data = t),
			(this.itemSize = e),
			(this.offset = n),
			(this.normalized = !0 === r);
	}
	function da(t) {
		qe.call(this),
			(this.type = 'SpriteMaterial'),
			(this.color = new Ve(16777215)),
			(this.map = null),
			(this.alphaMap = null),
			(this.rotation = 0),
			(this.sizeAttenuation = !0),
			(this.transparent = !0),
			this.setValues(t);
	}
	Object.defineProperties(ha.prototype, {
		count: {
			get: function () {
				return this.data.count;
			},
		},
		array: {
			get: function () {
				return this.data.array;
			},
		},
		needsUpdate: {
			set: function (t) {
				this.data.needsUpdate = t;
			},
		},
	}),
		Object.assign(ha.prototype, {
			isInterleavedBufferAttribute: !0,
			applyMatrix4: function (t) {
				for (var e = 0, n = this.data.count; e < n; e++)
					(ua.x = this.getX(e)),
						(ua.y = this.getY(e)),
						(ua.z = this.getZ(e)),
						ua.applyMatrix4(t),
						this.setXYZ(e, ua.x, ua.y, ua.z);
				return this;
			},
			setX: function (t, e) {
				return (this.data.array[t * this.data.stride + this.offset] = e), this;
			},
			setY: function (t, e) {
				return (
					(this.data.array[t * this.data.stride + this.offset + 1] = e), this
				);
			},
			setZ: function (t, e) {
				return (
					(this.data.array[t * this.data.stride + this.offset + 2] = e), this
				);
			},
			setW: function (t, e) {
				return (
					(this.data.array[t * this.data.stride + this.offset + 3] = e), this
				);
			},
			getX: function (t) {
				return this.data.array[t * this.data.stride + this.offset];
			},
			getY: function (t) {
				return this.data.array[t * this.data.stride + this.offset + 1];
			},
			getZ: function (t) {
				return this.data.array[t * this.data.stride + this.offset + 2];
			},
			getW: function (t) {
				return this.data.array[t * this.data.stride + this.offset + 3];
			},
			setXY: function (t, e, n) {
				return (
					(t = t * this.data.stride + this.offset),
					(this.data.array[t + 0] = e),
					(this.data.array[t + 1] = n),
					this
				);
			},
			setXYZ: function (t, e, n, r) {
				return (
					(t = t * this.data.stride + this.offset),
					(this.data.array[t + 0] = e),
					(this.data.array[t + 1] = n),
					(this.data.array[t + 2] = r),
					this
				);
			},
			setXYZW: function (t, e, n, r, i) {
				return (
					(t = t * this.data.stride + this.offset),
					(this.data.array[t + 0] = e),
					(this.data.array[t + 1] = n),
					(this.data.array[t + 2] = r),
					(this.data.array[t + 3] = i),
					this
				);
			},
			clone: function (t) {
				if (void 0 === t) {
					console.log(
						'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.'
					);
					for (var e = [], n = 0; n < this.count; n++)
						for (
							var r = n * this.data.stride + this.offset, i = 0;
							i < this.itemSize;
							i++
						)
							e.push(this.data.array[r + i]);
					return new Je(
						new this.array.constructor(e),
						this.itemSize,
						this.normalized
					);
				}
				return (
					void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
					void 0 === t.interleavedBuffers[this.data.uuid] &&
						(t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
					new ha(
						t.interleavedBuffers[this.data.uuid],
						this.itemSize,
						this.offset,
						this.normalized
					)
				);
			},
			toJSON: function (t) {
				if (void 0 === t) {
					console.log(
						'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.'
					);
					for (var e = [], n = 0; n < this.count; n++)
						for (
							var r = n * this.data.stride + this.offset, i = 0;
							i < this.itemSize;
							i++
						)
							e.push(this.data.array[r + i]);
					return {
						itemSize: this.itemSize,
						type: this.array.constructor.name,
						array: e,
						normalized: this.normalized,
					};
				}
				return (
					void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
					void 0 === t.interleavedBuffers[this.data.uuid] &&
						(t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
					{
						isInterleavedBufferAttribute: !0,
						itemSize: this.itemSize,
						data: this.data.uuid,
						offset: this.offset,
						normalized: this.normalized,
					}
				);
			},
		}),
		(da.prototype = Object.create(qe.prototype)),
		(da.prototype.constructor = da),
		(da.prototype.isSpriteMaterial = !0),
		(da.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				(this.map = t.map),
				(this.alphaMap = t.alphaMap),
				(this.rotation = t.rotation),
				(this.sizeAttenuation = t.sizeAttenuation),
				this
			);
		});
	var pa = new wt(),
		fa = new wt(),
		ma = new wt(),
		va = new pt(),
		ga = new pt(),
		ya = new Jt(),
		xa = new wt(),
		_a = new wt(),
		ba = new wt(),
		wa = new pt(),
		Ma = new pt(),
		Sa = new pt();
	function Ta(t) {
		if ((be.call(this), (this.type = 'Sprite'), void 0 === la)) {
			la = new vn();
			var e = new ca(
				new Float32Array([
					-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
					0, 0, 1,
				]),
				5
			);
			la.setIndex([0, 1, 2, 0, 2, 3]),
				la.setAttribute('position', new ha(e, 3, 0, !1)),
				la.setAttribute('uv', new ha(e, 2, 3, !1));
		}
		(this.geometry = la),
			(this.material = void 0 !== t ? t : new da()),
			(this.center = new pt(0.5, 0.5));
	}
	function Ea(t, e, n, r, i, a) {
		va.subVectors(t, n).addScalar(0.5).multiply(r),
			void 0 !== i
				? ((ga.x = a * va.x - i * va.y), (ga.y = i * va.x + a * va.y))
				: ga.copy(va),
			t.copy(e),
			(t.x += ga.x),
			(t.y += ga.y),
			t.applyMatrix4(ya);
	}
	Ta.prototype = Object.assign(Object.create(be.prototype), {
		constructor: Ta,
		isSprite: !0,
		raycast: function (t, e) {
			null === t.camera &&
				console.error(
					'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
				),
				fa.setFromMatrixScale(this.matrixWorld),
				ya.copy(t.camera.matrixWorld),
				this.modelViewMatrix.multiplyMatrices(
					t.camera.matrixWorldInverse,
					this.matrixWorld
				),
				ma.setFromMatrixPosition(this.modelViewMatrix),
				t.camera.isPerspectiveCamera &&
					!1 === this.material.sizeAttenuation &&
					fa.multiplyScalar(-ma.z);
			var n,
				r,
				i = this.material.rotation;
			0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)));
			var a = this.center;
			Ea(xa.set(-0.5, -0.5, 0), ma, a, fa, n, r),
				Ea(_a.set(0.5, -0.5, 0), ma, a, fa, n, r),
				Ea(ba.set(0.5, 0.5, 0), ma, a, fa, n, r),
				wa.set(0, 0),
				Ma.set(1, 0),
				Sa.set(1, 1);
			var o = t.ray.intersectTriangle(xa, _a, ba, !1, pa);
			if (
				null !== o ||
				(Ea(_a.set(-0.5, 0.5, 0), ma, a, fa, n, r),
				Ma.set(0, 1),
				null !== (o = t.ray.intersectTriangle(xa, ba, _a, !1, pa)))
			) {
				var s = t.ray.origin.distanceTo(pa);
				s < t.near ||
					s > t.far ||
					e.push({
						distance: s,
						point: pa.clone(),
						uv: Be.getUV(pa, xa, _a, ba, wa, Ma, Sa, new pt()),
						face: null,
						object: this,
					});
			}
		},
		copy: function (t) {
			return (
				be.prototype.copy.call(this, t),
				void 0 !== t.center && this.center.copy(t.center),
				(this.material = t.material),
				this
			);
		},
	});
	var Aa,
		La,
		Ra,
		Ca,
		Pa,
		Ia = new wt(),
		Da = new wt();
	function Na() {
		be.call(this),
			(this._currentLevel = 0),
			(this.type = 'LOD'),
			Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
			(this.autoUpdate = !0);
	}
	function Oa(t, e) {
		t &&
			t.isGeometry &&
			console.error(
				'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
			),
			Nn.call(this, t, e),
			(this.type = 'SkinnedMesh'),
			(this.bindMode = 'attached'),
			(this.bindMatrix = new Jt()),
			(this.bindMatrixInverse = new Jt());
	}
	(Na.prototype = Object.assign(Object.create(be.prototype), {
		constructor: Na,
		isLOD: !0,
		copy: function (t) {
			be.prototype.copy.call(this, t, !1);
			for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
				var i = e[n];
				this.addLevel(i.object.clone(), i.distance);
			}
			return (this.autoUpdate = t.autoUpdate), this;
		},
		addLevel: function (t, e) {
			void 0 === e && (e = 0), (e = Math.abs(e));
			var n,
				r = this.levels;
			for (n = 0; n < r.length && !(e < r[n].distance); n++);
			return r.splice(n, 0, { distance: e, object: t }), this.add(t), this;
		},
		getCurrentLevel: function () {
			return this._currentLevel;
		},
		getObjectForDistance: function (t) {
			var e = this.levels;
			if (e.length > 0) {
				var n, r;
				for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++);
				return e[n - 1].object;
			}
			return null;
		},
		raycast: function (t, e) {
			if (this.levels.length > 0) {
				Ia.setFromMatrixPosition(this.matrixWorld);
				var n = t.ray.origin.distanceTo(Ia);
				this.getObjectForDistance(n).raycast(t, e);
			}
		},
		update: function (t) {
			var e = this.levels;
			if (e.length > 1) {
				Ia.setFromMatrixPosition(t.matrixWorld),
					Da.setFromMatrixPosition(this.matrixWorld);
				var n,
					r,
					i = Ia.distanceTo(Da) / t.zoom;
				for (
					e[0].object.visible = !0, n = 1, r = e.length;
					n < r && i >= e[n].distance;
					n++
				)
					(e[n - 1].object.visible = !1), (e[n].object.visible = !0);
				for (this._currentLevel = n - 1; n < r; n++) e[n].object.visible = !1;
			}
		},
		toJSON: function (t) {
			var e = be.prototype.toJSON.call(this, t);
			!1 === this.autoUpdate && (e.object.autoUpdate = !1),
				(e.object.levels = []);
			for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
				var a = n[r];
				e.object.levels.push({ object: a.object.uuid, distance: a.distance });
			}
			return e;
		},
	})),
		(Oa.prototype = Object.assign(Object.create(Nn.prototype), {
			constructor: Oa,
			isSkinnedMesh: !0,
			copy: function (t) {
				return (
					Nn.prototype.copy.call(this, t),
					(this.bindMode = t.bindMode),
					this.bindMatrix.copy(t.bindMatrix),
					this.bindMatrixInverse.copy(t.bindMatrixInverse),
					(this.skeleton = t.skeleton),
					this
				);
			},
			bind: function (t, e) {
				(this.skeleton = t),
					void 0 === e &&
						(this.updateMatrixWorld(!0),
						this.skeleton.calculateInverses(),
						(e = this.matrixWorld)),
					this.bindMatrix.copy(e),
					this.bindMatrixInverse.getInverse(e);
			},
			pose: function () {
				this.skeleton.pose();
			},
			normalizeSkinWeights: function () {
				for (
					var t = new yt(),
						e = this.geometry.attributes.skinWeight,
						n = 0,
						r = e.count;
					n < r;
					n++
				) {
					(t.x = e.getX(n)),
						(t.y = e.getY(n)),
						(t.z = e.getZ(n)),
						(t.w = e.getW(n));
					var i = 1 / t.manhattanLength();
					i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
						e.setXYZW(n, t.x, t.y, t.z, t.w);
				}
			},
			updateMatrixWorld: function (t) {
				Nn.prototype.updateMatrixWorld.call(this, t),
					'attached' === this.bindMode
						? this.bindMatrixInverse.getInverse(this.matrixWorld)
						: 'detached' === this.bindMode
						? this.bindMatrixInverse.getInverse(this.bindMatrix)
						: console.warn(
								'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode
						  );
			},
			boneTransform:
				((Aa = new wt()),
				(La = new yt()),
				(Ra = new yt()),
				(Ca = new wt()),
				(Pa = new Jt()),
				function (t, e) {
					var n = this.skeleton,
						r = this.geometry;
					La.fromBufferAttribute(r.attributes.skinIndex, t),
						Ra.fromBufferAttribute(r.attributes.skinWeight, t),
						Aa.fromBufferAttribute(r.attributes.position, t).applyMatrix4(
							this.bindMatrix
						),
						e.set(0, 0, 0);
					for (var i = 0; i < 4; i++) {
						var a = Ra.getComponent(i);
						if (0 !== a) {
							var o = La.getComponent(i);
							Pa.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]),
								e.addScaledVector(Ca.copy(Aa).applyMatrix4(Pa), a);
						}
					}
					return e.applyMatrix4(this.bindMatrixInverse);
				}),
		}));
	var Ba = new Jt(),
		za = new Jt();
	function Ga(t, e) {
		if (
			((t = t || []),
			(this.bones = t.slice(0)),
			(this.boneMatrices = new Float32Array(16 * this.bones.length)),
			(this.frame = -1),
			void 0 === e)
		)
			this.calculateInverses();
		else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
		else {
			console.warn('THREE.Skeleton boneInverses is the wrong length.'),
				(this.boneInverses = []);
			for (var n = 0, r = this.bones.length; n < r; n++)
				this.boneInverses.push(new Jt());
		}
	}
	function Fa() {
		be.call(this), (this.type = 'Bone');
	}
	Object.assign(Ga.prototype, {
		calculateInverses: function () {
			this.boneInverses = [];
			for (var t = 0, e = this.bones.length; t < e; t++) {
				var n = new Jt();
				this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
					this.boneInverses.push(n);
			}
		},
		pose: function () {
			for (var t = 0, e = this.bones.length; t < e; t++) {
				var n = this.bones[t];
				n && n.matrixWorld.getInverse(this.boneInverses[t]);
			}
			for (var r = 0, i = this.bones.length; r < i; r++) {
				var a = this.bones[r];
				a &&
					(a.parent && a.parent.isBone
						? (a.matrix.getInverse(a.parent.matrixWorld),
						  a.matrix.multiply(a.matrixWorld))
						: a.matrix.copy(a.matrixWorld),
					a.matrix.decompose(a.position, a.quaternion, a.scale));
			}
		},
		update: function () {
			for (
				var t = this.bones,
					e = this.boneInverses,
					n = this.boneMatrices,
					r = this.boneTexture,
					i = 0,
					a = t.length;
				i < a;
				i++
			) {
				var o = t[i] ? t[i].matrixWorld : za;
				Ba.multiplyMatrices(o, e[i]), Ba.toArray(n, 16 * i);
			}
			void 0 !== r && (r.needsUpdate = !0);
		},
		clone: function () {
			return new Ga(this.bones, this.boneInverses);
		},
		getBoneByName: function (t) {
			for (var e = 0, n = this.bones.length; e < n; e++) {
				var r = this.bones[e];
				if (r.name === t) return r;
			}
		},
		dispose: function () {
			this.boneTexture &&
				(this.boneTexture.dispose(), (this.boneTexture = void 0));
		},
	}),
		(Fa.prototype = Object.assign(Object.create(be.prototype), {
			constructor: Fa,
			isBone: !0,
		}));
	var Ua = new Jt(),
		Ha = new Jt(),
		ka = [],
		Va = new Nn();
	function Wa(t, e, n) {
		Nn.call(this, t, e),
			(this.instanceMatrix = new Je(new Float32Array(16 * n), 16)),
			(this.instanceColor = null),
			(this.count = n),
			(this.frustumCulled = !1);
	}
	function ja(t) {
		qe.call(this),
			(this.type = 'LineBasicMaterial'),
			(this.color = new Ve(16777215)),
			(this.linewidth = 1),
			(this.linecap = 'round'),
			(this.linejoin = 'round'),
			(this.morphTargets = !1),
			this.setValues(t);
	}
	(Wa.prototype = Object.assign(Object.create(Nn.prototype), {
		constructor: Wa,
		isInstancedMesh: !0,
		copy: function (t) {
			return (
				Nn.prototype.copy.call(this, t),
				this.instanceMatrix.copy(t.instanceMatrix),
				(this.count = t.count),
				this
			);
		},
		setColorAt: function (t, e) {
			null === this.instanceColor &&
				(this.instanceColor = new Je(new Float32Array(3 * this.count), 3)),
				e.toArray(this.instanceColor.array, 3 * t);
		},
		getMatrixAt: function (t, e) {
			e.fromArray(this.instanceMatrix.array, 16 * t);
		},
		raycast: function (t, e) {
			var n = this.matrixWorld,
				r = this.count;
			if (
				((Va.geometry = this.geometry),
				(Va.material = this.material),
				void 0 !== Va.material)
			)
				for (var i = 0; i < r; i++) {
					this.getMatrixAt(i, Ua),
						Ha.multiplyMatrices(n, Ua),
						(Va.matrixWorld = Ha),
						Va.raycast(t, ka);
					for (var a = 0, o = ka.length; a < o; a++) {
						var s = ka[a];
						(s.instanceId = i), (s.object = this), e.push(s);
					}
					ka.length = 0;
				}
		},
		setMatrixAt: function (t, e) {
			e.toArray(this.instanceMatrix.array, 16 * t);
		},
		updateMorphTargets: function () {},
	})),
		(ja.prototype = Object.create(qe.prototype)),
		(ja.prototype.constructor = ja),
		(ja.prototype.isLineBasicMaterial = !0),
		(ja.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				(this.linewidth = t.linewidth),
				(this.linecap = t.linecap),
				(this.linejoin = t.linejoin),
				(this.morphTargets = t.morphTargets),
				this
			);
		});
	var qa = new wt(),
		Xa = new wt(),
		Ya = new Jt(),
		Za = new Zt(),
		Ja = new Ht();
	function Qa(t, e, n) {
		1 === n &&
			console.error(
				'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.'
			),
			be.call(this),
			(this.type = 'Line'),
			(this.geometry = void 0 !== t ? t : new vn()),
			(this.material = void 0 !== e ? e : new ja()),
			this.updateMorphTargets();
	}
	Qa.prototype = Object.assign(Object.create(be.prototype), {
		constructor: Qa,
		isLine: !0,
		copy: function (t) {
			return (
				be.prototype.copy.call(this, t),
				(this.material = t.material),
				(this.geometry = t.geometry),
				this
			);
		},
		computeLineDistances: function () {
			var t = this.geometry;
			if (t.isBufferGeometry)
				if (null === t.index) {
					for (
						var e = t.attributes.position, n = [0], r = 1, i = e.count;
						r < i;
						r++
					)
						qa.fromBufferAttribute(e, r - 1),
							Xa.fromBufferAttribute(e, r),
							(n[r] = n[r - 1]),
							(n[r] += qa.distanceTo(Xa));
					t.setAttribute('lineDistance', new an(n, 1));
				} else
					console.warn(
						'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
					);
			else if (t.isGeometry) {
				var a = t.vertices,
					o = t.lineDistances;
				o[0] = 0;
				for (var s = 1, c = a.length; s < c; s++)
					(o[s] = o[s - 1]), (o[s] += a[s - 1].distanceTo(a[s]));
			}
			return this;
		},
		raycast: function (t, e) {
			var n = this.geometry,
				r = this.matrixWorld,
				i = t.params.Line.threshold;
			if (
				(null === n.boundingSphere && n.computeBoundingSphere(),
				Ja.copy(n.boundingSphere),
				Ja.applyMatrix4(r),
				(Ja.radius += i),
				!1 !== t.ray.intersectsSphere(Ja))
			) {
				Ya.getInverse(r), Za.copy(t.ray).applyMatrix4(Ya);
				var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					o = a * a,
					s = new wt(),
					c = new wt(),
					l = new wt(),
					u = new wt(),
					h = this.isLineSegments ? 2 : 1;
				if (n.isBufferGeometry) {
					var d = n.index,
						p = n.attributes.position;
					if (null !== d)
						for (var f = d.array, m = 0, v = f.length - 1; m < v; m += h) {
							var g = f[m],
								y = f[m + 1];
							if (
								(s.fromBufferAttribute(p, g),
								c.fromBufferAttribute(p, y),
								!(Za.distanceSqToSegment(s, c, u, l) > o))
							) {
								u.applyMatrix4(this.matrixWorld);
								var x = t.ray.origin.distanceTo(u);
								x < t.near ||
									x > t.far ||
									e.push({
										distance: x,
										point: l.clone().applyMatrix4(this.matrixWorld),
										index: m,
										face: null,
										faceIndex: null,
										object: this,
									});
							}
						}
					else
						for (var _ = 0, b = p.count - 1; _ < b; _ += h) {
							if (
								(s.fromBufferAttribute(p, _),
								c.fromBufferAttribute(p, _ + 1),
								!(Za.distanceSqToSegment(s, c, u, l) > o))
							) {
								u.applyMatrix4(this.matrixWorld);
								var w = t.ray.origin.distanceTo(u);
								w < t.near ||
									w > t.far ||
									e.push({
										distance: w,
										point: l.clone().applyMatrix4(this.matrixWorld),
										index: _,
										face: null,
										faceIndex: null,
										object: this,
									});
							}
						}
				} else if (n.isGeometry)
					for (var M = n.vertices, S = M.length, T = 0; T < S - 1; T += h) {
						if (!(Za.distanceSqToSegment(M[T], M[T + 1], u, l) > o)) {
							u.applyMatrix4(this.matrixWorld);
							var E = t.ray.origin.distanceTo(u);
							E < t.near ||
								E > t.far ||
								e.push({
									distance: E,
									point: l.clone().applyMatrix4(this.matrixWorld),
									index: T,
									face: null,
									faceIndex: null,
									object: this,
								});
						}
					}
			}
		},
		updateMorphTargets: function () {
			var t = this.geometry;
			if (t.isBufferGeometry) {
				var e = t.morphAttributes,
					n = Object.keys(e);
				if (n.length > 0) {
					var r = e[n[0]];
					if (void 0 !== r) {
						(this.morphTargetInfluences = []),
							(this.morphTargetDictionary = {});
						for (var i = 0, a = r.length; i < a; i++) {
							var o = r[i].name || String(i);
							this.morphTargetInfluences.push(0),
								(this.morphTargetDictionary[o] = i);
						}
					}
				}
			} else {
				var s = t.morphTargets;
				void 0 !== s &&
					s.length > 0 &&
					console.error(
						'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
					);
			}
		},
	});
	var Ka = new wt(),
		$a = new wt();
	function to(t, e) {
		Qa.call(this, t, e), (this.type = 'LineSegments');
	}
	function eo(t, e) {
		Qa.call(this, t, e), (this.type = 'LineLoop');
	}
	function no(t) {
		qe.call(this),
			(this.type = 'PointsMaterial'),
			(this.color = new Ve(16777215)),
			(this.map = null),
			(this.alphaMap = null),
			(this.size = 1),
			(this.sizeAttenuation = !0),
			(this.morphTargets = !1),
			this.setValues(t);
	}
	(to.prototype = Object.assign(Object.create(Qa.prototype), {
		constructor: to,
		isLineSegments: !0,
		computeLineDistances: function () {
			var t = this.geometry;
			if (t.isBufferGeometry)
				if (null === t.index) {
					for (
						var e = t.attributes.position, n = [], r = 0, i = e.count;
						r < i;
						r += 2
					)
						Ka.fromBufferAttribute(e, r),
							$a.fromBufferAttribute(e, r + 1),
							(n[r] = 0 === r ? 0 : n[r - 1]),
							(n[r + 1] = n[r] + Ka.distanceTo($a));
					t.setAttribute('lineDistance', new an(n, 1));
				} else
					console.warn(
						'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
					);
			else if (t.isGeometry)
				for (
					var a = t.vertices, o = t.lineDistances, s = 0, c = a.length;
					s < c;
					s += 2
				)
					Ka.copy(a[s]),
						$a.copy(a[s + 1]),
						(o[s] = 0 === s ? 0 : o[s - 1]),
						(o[s + 1] = o[s] + Ka.distanceTo($a));
			return this;
		},
	})),
		(eo.prototype = Object.assign(Object.create(Qa.prototype), {
			constructor: eo,
			isLineLoop: !0,
		})),
		(no.prototype = Object.create(qe.prototype)),
		(no.prototype.constructor = no),
		(no.prototype.isPointsMaterial = !0),
		(no.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				(this.map = t.map),
				(this.alphaMap = t.alphaMap),
				(this.size = t.size),
				(this.sizeAttenuation = t.sizeAttenuation),
				(this.morphTargets = t.morphTargets),
				this
			);
		});
	var ro = new Jt(),
		io = new Zt(),
		ao = new Ht(),
		oo = new wt();
	function so(t, e) {
		be.call(this),
			(this.type = 'Points'),
			(this.geometry = void 0 !== t ? t : new vn()),
			(this.material = void 0 !== e ? e : new no()),
			this.updateMorphTargets();
	}
	function co(t, e, n, r, i, a, o) {
		var s = io.distanceSqToPoint(t);
		if (s < n) {
			var c = new wt();
			io.closestPointToPoint(t, c), c.applyMatrix4(r);
			var l = i.ray.origin.distanceTo(c);
			if (l < i.near || l > i.far) return;
			a.push({
				distance: l,
				distanceToRay: Math.sqrt(s),
				point: c,
				index: e,
				face: null,
				object: o,
			});
		}
	}
	function lo(t, e, n, r, i, a, o, s, c) {
		gt.call(this, t, e, n, r, i, a, o, s, c),
			(this.format = void 0 !== o ? o : S),
			(this.minFilter = void 0 !== a ? a : m),
			(this.magFilter = void 0 !== i ? i : m),
			(this.generateMipmaps = !1);
		var l = this;
		'requestVideoFrameCallback' in t &&
			t.requestVideoFrameCallback(function e() {
				(l.needsUpdate = !0), t.requestVideoFrameCallback(e);
			});
	}
	function uo(t, e, n, r, i, a, o, s, c, l, u, h) {
		gt.call(this, null, a, o, s, c, l, r, i, u, h),
			(this.image = { width: e, height: n }),
			(this.mipmaps = t),
			(this.flipY = !1),
			(this.generateMipmaps = !1);
	}
	function ho(t, e, n, r, i, a, o, s, c) {
		gt.call(this, t, e, n, r, i, a, o, s, c), (this.needsUpdate = !0);
	}
	function po(t, e, n, r, i, a, o, s, c, l) {
		if ((l = void 0 !== l ? l : E) !== E && l !== A)
			throw new Error(
				'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
			);
		void 0 === n && l === E && (n = x),
			void 0 === n && l === A && (n = M),
			gt.call(this, null, r, i, a, o, s, l, n, c),
			(this.image = { width: t, height: e }),
			(this.magFilter = void 0 !== o ? o : d),
			(this.minFilter = void 0 !== s ? s : d),
			(this.flipY = !1),
			(this.generateMipmaps = !1);
	}
	(so.prototype = Object.assign(Object.create(be.prototype), {
		constructor: so,
		isPoints: !0,
		copy: function (t) {
			return (
				be.prototype.copy.call(this, t),
				(this.material = t.material),
				(this.geometry = t.geometry),
				this
			);
		},
		raycast: function (t, e) {
			var n = this.geometry,
				r = this.matrixWorld,
				i = t.params.Points.threshold;
			if (
				(null === n.boundingSphere && n.computeBoundingSphere(),
				ao.copy(n.boundingSphere),
				ao.applyMatrix4(r),
				(ao.radius += i),
				!1 !== t.ray.intersectsSphere(ao))
			) {
				ro.getInverse(r), io.copy(t.ray).applyMatrix4(ro);
				var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					o = a * a;
				if (n.isBufferGeometry) {
					var s = n.index,
						c = n.attributes.position;
					if (null !== s)
						for (var l = s.array, u = 0, h = l.length; u < h; u++) {
							var d = l[u];
							oo.fromBufferAttribute(c, d), co(oo, d, o, r, t, e, this);
						}
					else
						for (var p = 0, f = c.count; p < f; p++)
							oo.fromBufferAttribute(c, p), co(oo, p, o, r, t, e, this);
				} else
					for (var m = n.vertices, v = 0, g = m.length; v < g; v++)
						co(m[v], v, o, r, t, e, this);
			}
		},
		updateMorphTargets: function () {
			var t = this.geometry;
			if (t.isBufferGeometry) {
				var e = t.morphAttributes,
					n = Object.keys(e);
				if (n.length > 0) {
					var r = e[n[0]];
					if (void 0 !== r) {
						(this.morphTargetInfluences = []),
							(this.morphTargetDictionary = {});
						for (var i = 0, a = r.length; i < a; i++) {
							var o = r[i].name || String(i);
							this.morphTargetInfluences.push(0),
								(this.morphTargetDictionary[o] = i);
						}
					}
				}
			} else {
				var s = t.morphTargets;
				void 0 !== s &&
					s.length > 0 &&
					console.error(
						'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
					);
			}
		},
	})),
		(lo.prototype = Object.assign(Object.create(gt.prototype), {
			constructor: lo,
			isVideoTexture: !0,
			update: function () {
				var t = this.image;
				!1 === 'requestVideoFrameCallback' in t &&
					t.readyState >= t.HAVE_CURRENT_DATA &&
					(this.needsUpdate = !0);
			},
		})),
		(uo.prototype = Object.create(gt.prototype)),
		(uo.prototype.constructor = uo),
		(uo.prototype.isCompressedTexture = !0),
		(ho.prototype = Object.create(gt.prototype)),
		(ho.prototype.constructor = ho),
		(ho.prototype.isCanvasTexture = !0),
		(po.prototype = Object.create(gt.prototype)),
		(po.prototype.constructor = po),
		(po.prototype.isDepthTexture = !0);
	var fo = 0,
		mo = new Jt(),
		vo = new be(),
		go = new wt();
	function yo() {
		Object.defineProperty(this, 'id', { value: (fo += 2) }),
			(this.uuid = st.generateUUID()),
			(this.name = ''),
			(this.type = 'Geometry'),
			(this.vertices = []),
			(this.colors = []),
			(this.faces = []),
			(this.faceVertexUvs = [[]]),
			(this.morphTargets = []),
			(this.morphNormals = []),
			(this.skinWeights = []),
			(this.skinIndices = []),
			(this.lineDistances = []),
			(this.boundingBox = null),
			(this.boundingSphere = null),
			(this.elementsNeedUpdate = !1),
			(this.verticesNeedUpdate = !1),
			(this.uvsNeedUpdate = !1),
			(this.normalsNeedUpdate = !1),
			(this.colorsNeedUpdate = !1),
			(this.lineDistancesNeedUpdate = !1),
			(this.groupsNeedUpdate = !1);
	}
	yo.prototype = Object.assign(Object.create(rt.prototype), {
		constructor: yo,
		isGeometry: !0,
		applyMatrix4: function (t) {
			for (
				var e = new ft().getNormalMatrix(t), n = 0, r = this.vertices.length;
				n < r;
				n++
			) {
				this.vertices[n].applyMatrix4(t);
			}
			for (var i = 0, a = this.faces.length; i < a; i++) {
				var o = this.faces[i];
				o.normal.applyMatrix3(e).normalize();
				for (var s = 0, c = o.vertexNormals.length; s < c; s++)
					o.vertexNormals[s].applyMatrix3(e).normalize();
			}
			return (
				null !== this.boundingBox && this.computeBoundingBox(),
				null !== this.boundingSphere && this.computeBoundingSphere(),
				(this.verticesNeedUpdate = !0),
				(this.normalsNeedUpdate = !0),
				this
			);
		},
		rotateX: function (t) {
			return mo.makeRotationX(t), this.applyMatrix4(mo), this;
		},
		rotateY: function (t) {
			return mo.makeRotationY(t), this.applyMatrix4(mo), this;
		},
		rotateZ: function (t) {
			return mo.makeRotationZ(t), this.applyMatrix4(mo), this;
		},
		translate: function (t, e, n) {
			return mo.makeTranslation(t, e, n), this.applyMatrix4(mo), this;
		},
		scale: function (t, e, n) {
			return mo.makeScale(t, e, n), this.applyMatrix4(mo), this;
		},
		lookAt: function (t) {
			return (
				vo.lookAt(t), vo.updateMatrix(), this.applyMatrix4(vo.matrix), this
			);
		},
		fromBufferGeometry: function (t) {
			var e = this,
				n = null !== t.index ? t.index : void 0,
				r = t.attributes;
			if (void 0 === r.position)
				return (
					console.error(
						'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.'
					),
					this
				);
			var i = r.position,
				a = r.normal,
				o = r.color,
				s = r.uv,
				c = r.uv2;
			void 0 !== c && (this.faceVertexUvs[1] = []);
			for (var l = 0; l < i.count; l++)
				e.vertices.push(new wt().fromBufferAttribute(i, l)),
					void 0 !== o && e.colors.push(new Ve().fromBufferAttribute(o, l));
			function u(t, n, r, i) {
				var l =
						void 0 === o
							? []
							: [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()],
					u =
						void 0 === a
							? []
							: [
									new wt().fromBufferAttribute(a, t),
									new wt().fromBufferAttribute(a, n),
									new wt().fromBufferAttribute(a, r),
							  ],
					h = new We(t, n, r, u, l, i);
				e.faces.push(h),
					void 0 !== s &&
						e.faceVertexUvs[0].push([
							new pt().fromBufferAttribute(s, t),
							new pt().fromBufferAttribute(s, n),
							new pt().fromBufferAttribute(s, r),
						]),
					void 0 !== c &&
						e.faceVertexUvs[1].push([
							new pt().fromBufferAttribute(c, t),
							new pt().fromBufferAttribute(c, n),
							new pt().fromBufferAttribute(c, r),
						]);
			}
			var h = t.groups;
			if (h.length > 0)
				for (var d = 0; d < h.length; d++)
					for (var p = h[d], f = p.start, m = f, v = f + p.count; m < v; m += 3)
						void 0 !== n
							? u(n.getX(m), n.getX(m + 1), n.getX(m + 2), p.materialIndex)
							: u(m, m + 1, m + 2, p.materialIndex);
			else if (void 0 !== n)
				for (var g = 0; g < n.count; g += 3)
					u(n.getX(g), n.getX(g + 1), n.getX(g + 2));
			else for (var y = 0; y < i.count; y += 3) u(y, y + 1, y + 2);
			return (
				this.computeFaceNormals(),
				null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
				null !== t.boundingSphere &&
					(this.boundingSphere = t.boundingSphere.clone()),
				this
			);
		},
		center: function () {
			return (
				this.computeBoundingBox(),
				this.boundingBox.getCenter(go).negate(),
				this.translate(go.x, go.y, go.z),
				this
			);
		},
		normalize: function () {
			this.computeBoundingSphere();
			var t = this.boundingSphere.center,
				e = this.boundingSphere.radius,
				n = 0 === e ? 1 : 1 / e,
				r = new Jt();
			return (
				r.set(
					n,
					0,
					0,
					-n * t.x,
					0,
					n,
					0,
					-n * t.y,
					0,
					0,
					n,
					-n * t.z,
					0,
					0,
					0,
					1
				),
				this.applyMatrix4(r),
				this
			);
		},
		computeFaceNormals: function () {
			for (
				var t = new wt(), e = new wt(), n = 0, r = this.faces.length;
				n < r;
				n++
			) {
				var i = this.faces[n],
					a = this.vertices[i.a],
					o = this.vertices[i.b],
					s = this.vertices[i.c];
				t.subVectors(s, o),
					e.subVectors(a, o),
					t.cross(e),
					t.normalize(),
					i.normal.copy(t);
			}
		},
		computeVertexNormals: function (t) {
			void 0 === t && (t = !0);
			for (
				var e = new Array(this.vertices.length),
					n = 0,
					r = this.vertices.length;
				n < r;
				n++
			)
				e[n] = new wt();
			if (t)
				for (
					var i = new wt(), a = new wt(), o = 0, s = this.faces.length;
					o < s;
					o++
				) {
					var c = this.faces[o],
						l = this.vertices[c.a],
						u = this.vertices[c.b],
						h = this.vertices[c.c];
					i.subVectors(h, u),
						a.subVectors(l, u),
						i.cross(a),
						e[c.a].add(i),
						e[c.b].add(i),
						e[c.c].add(i);
				}
			else {
				this.computeFaceNormals();
				for (var d = 0, p = this.faces.length; d < p; d++) {
					var f = this.faces[d];
					e[f.a].add(f.normal), e[f.b].add(f.normal), e[f.c].add(f.normal);
				}
			}
			for (var m = 0, v = this.vertices.length; m < v; m++) e[m].normalize();
			for (var g = 0, y = this.faces.length; g < y; g++) {
				var x = this.faces[g],
					_ = x.vertexNormals;
				3 === _.length
					? (_[0].copy(e[x.a]), _[1].copy(e[x.b]), _[2].copy(e[x.c]))
					: ((_[0] = e[x.a].clone()),
					  (_[1] = e[x.b].clone()),
					  (_[2] = e[x.c].clone()));
			}
			this.faces.length > 0 && (this.normalsNeedUpdate = !0);
		},
		computeFlatVertexNormals: function () {
			this.computeFaceNormals();
			for (var t = 0, e = this.faces.length; t < e; t++) {
				var n = this.faces[t],
					r = n.vertexNormals;
				3 === r.length
					? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal))
					: ((r[0] = n.normal.clone()),
					  (r[1] = n.normal.clone()),
					  (r[2] = n.normal.clone()));
			}
			this.faces.length > 0 && (this.normalsNeedUpdate = !0);
		},
		computeMorphNormals: function () {
			for (var t = 0, e = this.faces.length; t < e; t++) {
				var n = this.faces[t];
				n.__originalFaceNormal
					? n.__originalFaceNormal.copy(n.normal)
					: (n.__originalFaceNormal = n.normal.clone()),
					n.__originalVertexNormals || (n.__originalVertexNormals = []);
				for (var r = 0, i = n.vertexNormals.length; r < i; r++)
					n.__originalVertexNormals[r]
						? n.__originalVertexNormals[r].copy(n.vertexNormals[r])
						: (n.__originalVertexNormals[r] = n.vertexNormals[r].clone());
			}
			var a = new yo();
			a.faces = this.faces;
			for (var o = 0, s = this.morphTargets.length; o < s; o++) {
				if (!this.morphNormals[o]) {
					(this.morphNormals[o] = {}),
						(this.morphNormals[o].faceNormals = []),
						(this.morphNormals[o].vertexNormals = []);
					for (
						var c = this.morphNormals[o].faceNormals,
							l = this.morphNormals[o].vertexNormals,
							u = 0,
							h = this.faces.length;
						u < h;
						u++
					) {
						var d = new wt(),
							p = { a: new wt(), b: new wt(), c: new wt() };
						c.push(d), l.push(p);
					}
				}
				var f = this.morphNormals[o];
				(a.vertices = this.morphTargets[o].vertices),
					a.computeFaceNormals(),
					a.computeVertexNormals();
				for (var m = 0, v = this.faces.length; m < v; m++) {
					var g = this.faces[m],
						y = f.faceNormals[m],
						x = f.vertexNormals[m];
					y.copy(g.normal),
						x.a.copy(g.vertexNormals[0]),
						x.b.copy(g.vertexNormals[1]),
						x.c.copy(g.vertexNormals[2]);
				}
			}
			for (var _ = 0, b = this.faces.length; _ < b; _++) {
				var w = this.faces[_];
				(w.normal = w.__originalFaceNormal),
					(w.vertexNormals = w.__originalVertexNormals);
			}
		},
		computeBoundingBox: function () {
			null === this.boundingBox && (this.boundingBox = new Tt()),
				this.boundingBox.setFromPoints(this.vertices);
		},
		computeBoundingSphere: function () {
			null === this.boundingSphere && (this.boundingSphere = new Ht()),
				this.boundingSphere.setFromPoints(this.vertices);
		},
		merge: function (t, e, n) {
			if (t && t.isGeometry) {
				var r,
					i = this.vertices.length,
					a = this.vertices,
					o = t.vertices,
					s = this.faces,
					c = t.faces,
					l = this.colors,
					u = t.colors;
				void 0 === n && (n = 0),
					void 0 !== e && (r = new ft().getNormalMatrix(e));
				for (var h = 0, d = o.length; h < d; h++) {
					var p = o[h].clone();
					void 0 !== e && p.applyMatrix4(e), a.push(p);
				}
				for (var f = 0, m = u.length; f < m; f++) l.push(u[f].clone());
				for (var v = 0, g = c.length; v < g; v++) {
					var y = c[v],
						x = void 0,
						_ = void 0,
						b = y.vertexNormals,
						w = y.vertexColors,
						M = new We(y.a + i, y.b + i, y.c + i);
					M.normal.copy(y.normal),
						void 0 !== r && M.normal.applyMatrix3(r).normalize();
					for (var S = 0, T = b.length; S < T; S++)
						(x = b[S].clone()),
							void 0 !== r && x.applyMatrix3(r).normalize(),
							M.vertexNormals.push(x);
					M.color.copy(y.color);
					for (var E = 0, A = w.length; E < A; E++)
						(_ = w[E]), M.vertexColors.push(_.clone());
					(M.materialIndex = y.materialIndex + n), s.push(M);
				}
				for (var L = 0, R = t.faceVertexUvs.length; L < R; L++) {
					var C = t.faceVertexUvs[L];
					void 0 === this.faceVertexUvs[L] && (this.faceVertexUvs[L] = []);
					for (var P = 0, I = C.length; P < I; P++) {
						for (var D = C[P], N = [], O = 0, B = D.length; O < B; O++)
							N.push(D[O].clone());
						this.faceVertexUvs[L].push(N);
					}
				}
			} else
				console.error(
					'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',
					t
				);
		},
		mergeMesh: function (t) {
			t && t.isMesh
				? (t.matrixAutoUpdate && t.updateMatrix(),
				  this.merge(t.geometry, t.matrix))
				: console.error(
						'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',
						t
				  );
		},
		mergeVertices: function () {
			for (
				var t = {},
					e = [],
					n = [],
					r = Math.pow(10, 4),
					i = 0,
					a = this.vertices.length;
				i < a;
				i++
			) {
				var o = this.vertices[i],
					s =
						Math.round(o.x * r) +
						'_' +
						Math.round(o.y * r) +
						'_' +
						Math.round(o.z * r);
				void 0 === t[s]
					? ((t[s] = i), e.push(this.vertices[i]), (n[i] = e.length - 1))
					: (n[i] = n[t[s]]);
			}
			for (var c = [], l = 0, u = this.faces.length; l < u; l++) {
				var h = this.faces[l];
				(h.a = n[h.a]), (h.b = n[h.b]), (h.c = n[h.c]);
				for (var d = [h.a, h.b, h.c], p = 0; p < 3; p++)
					if (d[p] === d[(p + 1) % 3]) {
						c.push(l);
						break;
					}
			}
			for (var f = c.length - 1; f >= 0; f--) {
				var m = c[f];
				this.faces.splice(m, 1);
				for (var v = 0, g = this.faceVertexUvs.length; v < g; v++)
					this.faceVertexUvs[v].splice(m, 1);
			}
			var y = this.vertices.length - e.length;
			return (this.vertices = e), y;
		},
		setFromPoints: function (t) {
			this.vertices = [];
			for (var e = 0, n = t.length; e < n; e++) {
				var r = t[e];
				this.vertices.push(new wt(r.x, r.y, r.z || 0));
			}
			return this;
		},
		sortFacesByMaterialIndex: function () {
			for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
			t.sort(function (t, e) {
				return t.materialIndex - e.materialIndex;
			});
			var r,
				i,
				a = this.faceVertexUvs[0],
				o = this.faceVertexUvs[1];
			a && a.length === e && (r = []), o && o.length === e && (i = []);
			for (var s = 0; s < e; s++) {
				var c = t[s]._id;
				r && r.push(a[c]), i && i.push(o[c]);
			}
			r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i);
		},
		toJSON: function () {
			var t = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON',
				},
			};
			if (
				((t.uuid = this.uuid),
				(t.type = this.type),
				'' !== this.name && (t.name = this.name),
				void 0 !== this.parameters)
			) {
				var e = this.parameters;
				for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
				return t;
			}
			for (var r = [], i = 0; i < this.vertices.length; i++) {
				var a = this.vertices[i];
				r.push(a.x, a.y, a.z);
			}
			for (
				var o = [], s = [], c = {}, l = [], u = {}, h = [], d = {}, p = 0;
				p < this.faces.length;
				p++
			) {
				var f = this.faces[p],
					m = void 0 !== this.faceVertexUvs[0][p],
					v = f.normal.length() > 0,
					g = f.vertexNormals.length > 0,
					y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
					x = f.vertexColors.length > 0,
					_ = 0;
				if (
					((_ = S(_, 0, 0)),
					(_ = S(_, 1, !0)),
					(_ = S(_, 2, !1)),
					(_ = S(_, 3, m)),
					(_ = S(_, 4, v)),
					(_ = S(_, 5, g)),
					(_ = S(_, 6, y)),
					(_ = S(_, 7, x)),
					o.push(_),
					o.push(f.a, f.b, f.c),
					o.push(f.materialIndex),
					m)
				) {
					var b = this.faceVertexUvs[0][p];
					o.push(A(b[0]), A(b[1]), A(b[2]));
				}
				if ((v && o.push(T(f.normal)), g)) {
					var w = f.vertexNormals;
					o.push(T(w[0]), T(w[1]), T(w[2]));
				}
				if ((y && o.push(E(f.color)), x)) {
					var M = f.vertexColors;
					o.push(E(M[0]), E(M[1]), E(M[2]));
				}
			}
			function S(t, e, n) {
				return n ? t | (1 << e) : t & ~(1 << e);
			}
			function T(t) {
				var e = t.x.toString() + t.y.toString() + t.z.toString();
				return (
					void 0 !== c[e] || ((c[e] = s.length / 3), s.push(t.x, t.y, t.z)),
					c[e]
				);
			}
			function E(t) {
				var e = t.r.toString() + t.g.toString() + t.b.toString();
				return void 0 !== u[e] || ((u[e] = l.length), l.push(t.getHex())), u[e];
			}
			function A(t) {
				var e = t.x.toString() + t.y.toString();
				return (
					void 0 !== d[e] || ((d[e] = h.length / 2), h.push(t.x, t.y)), d[e]
				);
			}
			return (
				(t.data = {}),
				(t.data.vertices = r),
				(t.data.normals = s),
				l.length > 0 && (t.data.colors = l),
				h.length > 0 && (t.data.uvs = [h]),
				(t.data.faces = o),
				t
			);
		},
		clone: function () {
			return new yo().copy(this);
		},
		copy: function (t) {
			(this.vertices = []),
				(this.colors = []),
				(this.faces = []),
				(this.faceVertexUvs = [[]]),
				(this.morphTargets = []),
				(this.morphNormals = []),
				(this.skinWeights = []),
				(this.skinIndices = []),
				(this.lineDistances = []),
				(this.boundingBox = null),
				(this.boundingSphere = null),
				(this.name = t.name);
			for (var e = t.vertices, n = 0, r = e.length; n < r; n++)
				this.vertices.push(e[n].clone());
			for (var i = t.colors, a = 0, o = i.length; a < o; a++)
				this.colors.push(i[a].clone());
			for (var s = t.faces, c = 0, l = s.length; c < l; c++)
				this.faces.push(s[c].clone());
			for (var u = 0, h = t.faceVertexUvs.length; u < h; u++) {
				var d = t.faceVertexUvs[u];
				void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
				for (var p = 0, f = d.length; p < f; p++) {
					for (var m = d[p], v = [], g = 0, y = m.length; g < y; g++) {
						var x = m[g];
						v.push(x.clone());
					}
					this.faceVertexUvs[u].push(v);
				}
			}
			for (var _ = t.morphTargets, b = 0, w = _.length; b < w; b++) {
				var M = {};
				if (((M.name = _[b].name), void 0 !== _[b].vertices)) {
					M.vertices = [];
					for (var S = 0, T = _[b].vertices.length; S < T; S++)
						M.vertices.push(_[b].vertices[S].clone());
				}
				if (void 0 !== _[b].normals) {
					M.normals = [];
					for (var E = 0, A = _[b].normals.length; E < A; E++)
						M.normals.push(_[b].normals[E].clone());
				}
				this.morphTargets.push(M);
			}
			for (var L = t.morphNormals, R = 0, C = L.length; R < C; R++) {
				var P = {};
				if (void 0 !== L[R].vertexNormals) {
					P.vertexNormals = [];
					for (var I = 0, D = L[R].vertexNormals.length; I < D; I++) {
						var N = L[R].vertexNormals[I],
							O = {};
						(O.a = N.a.clone()),
							(O.b = N.b.clone()),
							(O.c = N.c.clone()),
							P.vertexNormals.push(O);
					}
				}
				if (void 0 !== L[R].faceNormals) {
					P.faceNormals = [];
					for (var B = 0, z = L[R].faceNormals.length; B < z; B++)
						P.faceNormals.push(L[R].faceNormals[B].clone());
				}
				this.morphNormals.push(P);
			}
			for (var G = t.skinWeights, F = 0, U = G.length; F < U; F++)
				this.skinWeights.push(G[F].clone());
			for (var H = t.skinIndices, k = 0, V = H.length; k < V; k++)
				this.skinIndices.push(H[k].clone());
			for (var W = t.lineDistances, j = 0, q = W.length; j < q; j++)
				this.lineDistances.push(W[j]);
			var X = t.boundingBox;
			null !== X && (this.boundingBox = X.clone());
			var Y = t.boundingSphere;
			return (
				null !== Y && (this.boundingSphere = Y.clone()),
				(this.elementsNeedUpdate = t.elementsNeedUpdate),
				(this.verticesNeedUpdate = t.verticesNeedUpdate),
				(this.uvsNeedUpdate = t.uvsNeedUpdate),
				(this.normalsNeedUpdate = t.normalsNeedUpdate),
				(this.colorsNeedUpdate = t.colorsNeedUpdate),
				(this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
				(this.groupsNeedUpdate = t.groupsNeedUpdate),
				this
			);
		},
		dispose: function () {
			this.dispatchEvent({ type: 'dispose' });
		},
	});
	var xo = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				return (
					((s = t.call(this) || this).type = 'BoxGeometry'),
					(s.parameters = {
						width: e,
						height: n,
						depth: r,
						widthSegments: i,
						heightSegments: a,
						depthSegments: o,
					}),
					s.fromBufferGeometry(new zn(e, n, r, i, a, o)),
					s.mergeVertices(),
					s
				);
			}
			return ut(e, t), e;
		})(yo),
		_o = (function (t) {
			function e(e, n, r, i) {
				var a;
				((a = t.call(this) || this).type = 'CircleBufferGeometry'),
					(a.parameters = {
						radius: e,
						segments: n,
						thetaStart: r,
						thetaLength: i,
					}),
					(e = e || 1),
					(n = void 0 !== n ? Math.max(3, n) : 8),
					(r = void 0 !== r ? r : 0),
					(i = void 0 !== i ? i : 2 * Math.PI);
				var o = [],
					s = [],
					c = [],
					l = [],
					u = new wt(),
					h = new pt();
				s.push(0, 0, 0), c.push(0, 0, 1), l.push(0.5, 0.5);
				for (var d = 0, p = 3; d <= n; d++, p += 3) {
					var f = r + (d / n) * i;
					(u.x = e * Math.cos(f)),
						(u.y = e * Math.sin(f)),
						s.push(u.x, u.y, u.z),
						c.push(0, 0, 1),
						(h.x = (s[p] / e + 1) / 2),
						(h.y = (s[p + 1] / e + 1) / 2),
						l.push(h.x, h.y);
				}
				for (var m = 1; m <= n; m++) o.push(m, m + 1, 0);
				return (
					a.setIndex(o),
					a.setAttribute('position', new an(s, 3)),
					a.setAttribute('normal', new an(c, 3)),
					a.setAttribute('uv', new an(l, 2)),
					a
				);
			}
			return ut(e, t), e;
		})(vn),
		bo = (function (t) {
			function e(e, n, r, i) {
				var a;
				return (
					((a = t.call(this) || this).type = 'CircleGeometry'),
					(a.parameters = {
						radius: e,
						segments: n,
						thetaStart: r,
						thetaLength: i,
					}),
					a.fromBufferGeometry(new _o(e, n, r, i)),
					a.mergeVertices(),
					a
				);
			}
			return ut(e, t), e;
		})(yo),
		wo = (function (t) {
			function e(e, n, r, i, a, o, s, c) {
				var l;
				((l = t.call(this) || this).type = 'CylinderBufferGeometry'),
					(l.parameters = {
						radiusTop: e,
						radiusBottom: n,
						height: r,
						radialSegments: i,
						heightSegments: a,
						openEnded: o,
						thetaStart: s,
						thetaLength: c,
					});
				var u = ht(l);
				(e = void 0 !== e ? e : 1),
					(n = void 0 !== n ? n : 1),
					(r = r || 1),
					(i = Math.floor(i) || 8),
					(a = Math.floor(a) || 1),
					(o = void 0 !== o && o),
					(s = void 0 !== s ? s : 0),
					(c = void 0 !== c ? c : 2 * Math.PI);
				var h = [],
					d = [],
					p = [],
					f = [],
					m = 0,
					v = [],
					g = r / 2,
					y = 0;
				function x(t) {
					for (
						var r = m,
							a = new pt(),
							o = new wt(),
							l = 0,
							v = !0 === t ? e : n,
							x = !0 === t ? 1 : -1,
							_ = 1;
						_ <= i;
						_++
					)
						d.push(0, g * x, 0), p.push(0, x, 0), f.push(0.5, 0.5), m++;
					for (var b = m, w = 0; w <= i; w++) {
						var M = (w / i) * c + s,
							S = Math.cos(M),
							T = Math.sin(M);
						(o.x = v * T),
							(o.y = g * x),
							(o.z = v * S),
							d.push(o.x, o.y, o.z),
							p.push(0, x, 0),
							(a.x = 0.5 * S + 0.5),
							(a.y = 0.5 * T * x + 0.5),
							f.push(a.x, a.y),
							m++;
					}
					for (var E = 0; E < i; E++) {
						var A = r + E,
							L = b + E;
						!0 === t ? h.push(L, L + 1, A) : h.push(L + 1, L, A), (l += 3);
					}
					u.addGroup(y, l, !0 === t ? 1 : 2), (y += l);
				}
				return (
					(function () {
						for (
							var t = new wt(), o = new wt(), l = 0, x = (n - e) / r, _ = 0;
							_ <= a;
							_++
						) {
							for (
								var b = [], w = _ / a, M = w * (n - e) + e, S = 0;
								S <= i;
								S++
							) {
								var T = S / i,
									E = T * c + s,
									A = Math.sin(E),
									L = Math.cos(E);
								(o.x = M * A),
									(o.y = -w * r + g),
									(o.z = M * L),
									d.push(o.x, o.y, o.z),
									t.set(A, x, L).normalize(),
									p.push(t.x, t.y, t.z),
									f.push(T, 1 - w),
									b.push(m++);
							}
							v.push(b);
						}
						for (var R = 0; R < i; R++)
							for (var C = 0; C < a; C++) {
								var P = v[C][R],
									I = v[C + 1][R],
									D = v[C + 1][R + 1],
									N = v[C][R + 1];
								h.push(P, I, N), h.push(I, D, N), (l += 6);
							}
						u.addGroup(y, l, 0), (y += l);
					})(),
					!1 === o && (e > 0 && x(!0), n > 0 && x(!1)),
					l.setIndex(h),
					l.setAttribute('position', new an(d, 3)),
					l.setAttribute('normal', new an(p, 3)),
					l.setAttribute('uv', new an(f, 2)),
					l
				);
			}
			return ut(e, t), e;
		})(vn),
		Mo = (function (t) {
			function e(e, n, r, i, a, o, s, c) {
				var l;
				return (
					((l = t.call(this) || this).type = 'CylinderGeometry'),
					(l.parameters = {
						radiusTop: e,
						radiusBottom: n,
						height: r,
						radialSegments: i,
						heightSegments: a,
						openEnded: o,
						thetaStart: s,
						thetaLength: c,
					}),
					l.fromBufferGeometry(new wo(e, n, r, i, a, o, s, c)),
					l.mergeVertices(),
					l
				);
			}
			return ut(e, t), e;
		})(yo),
		So = (function (t) {
			function e(e, n, r, i, a, o, s) {
				var c;
				return (
					((c = t.call(this, 0, e, n, r, i, a, o, s) || this).type =
						'ConeGeometry'),
					(c.parameters = {
						radius: e,
						height: n,
						radialSegments: r,
						heightSegments: i,
						openEnded: a,
						thetaStart: o,
						thetaLength: s,
					}),
					c
				);
			}
			return ut(e, t), e;
		})(Mo),
		To = (function (t) {
			function e(e, n, r, i, a, o, s) {
				var c;
				return (
					((c = t.call(this, 0, e, n, r, i, a, o, s) || this).type =
						'ConeBufferGeometry'),
					(c.parameters = {
						radius: e,
						height: n,
						radialSegments: r,
						heightSegments: i,
						openEnded: a,
						thetaStart: o,
						thetaLength: s,
					}),
					c
				);
			}
			return ut(e, t), e;
		})(wo),
		Eo = (function (t) {
			function e(e, n, r, i) {
				var a;
				((a = t.call(this) || this).type = 'PolyhedronBufferGeometry'),
					(a.parameters = { vertices: e, indices: n, radius: r, detail: i }),
					(r = r || 1);
				var o = [],
					s = [];
				function c(t, e, n, r) {
					for (var i = r + 1, a = [], o = 0; o <= i; o++) {
						a[o] = [];
						for (
							var s = t.clone().lerp(n, o / i),
								c = e.clone().lerp(n, o / i),
								u = i - o,
								h = 0;
							h <= u;
							h++
						)
							a[o][h] = 0 === h && o === i ? s : s.clone().lerp(c, h / u);
					}
					for (var d = 0; d < i; d++)
						for (var p = 0; p < 2 * (i - d) - 1; p++) {
							var f = Math.floor(p / 2);
							p % 2 == 0
								? (l(a[d][f + 1]), l(a[d + 1][f]), l(a[d][f]))
								: (l(a[d][f + 1]), l(a[d + 1][f + 1]), l(a[d + 1][f]));
						}
				}
				function l(t) {
					o.push(t.x, t.y, t.z);
				}
				function u(t, n) {
					var r = 3 * t;
					(n.x = e[r + 0]), (n.y = e[r + 1]), (n.z = e[r + 2]);
				}
				function h(t, e, n, r) {
					r < 0 && 1 === t.x && (s[e] = t.x - 1),
						0 === n.x && 0 === n.z && (s[e] = r / 2 / Math.PI + 0.5);
				}
				function d(t) {
					return Math.atan2(t.z, -t.x);
				}
				function p(t) {
					return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
				}
				return (
					(function (t) {
						for (
							var e = new wt(), r = new wt(), i = new wt(), a = 0;
							a < n.length;
							a += 3
						)
							u(n[a + 0], e), u(n[a + 1], r), u(n[a + 2], i), c(e, r, i, t);
					})((i = i || 0)),
					(function (t) {
						for (var e = new wt(), n = 0; n < o.length; n += 3)
							(e.x = o[n + 0]),
								(e.y = o[n + 1]),
								(e.z = o[n + 2]),
								e.normalize().multiplyScalar(t),
								(o[n + 0] = e.x),
								(o[n + 1] = e.y),
								(o[n + 2] = e.z);
					})(r),
					(function () {
						for (var t = new wt(), e = 0; e < o.length; e += 3) {
							(t.x = o[e + 0]), (t.y = o[e + 1]), (t.z = o[e + 2]);
							var n = d(t) / 2 / Math.PI + 0.5,
								r = p(t) / Math.PI + 0.5;
							s.push(n, 1 - r);
						}
						(function () {
							for (
								var t = new wt(),
									e = new wt(),
									n = new wt(),
									r = new wt(),
									i = new pt(),
									a = new pt(),
									c = new pt(),
									l = 0,
									u = 0;
								l < o.length;
								l += 9, u += 6
							) {
								t.set(o[l + 0], o[l + 1], o[l + 2]),
									e.set(o[l + 3], o[l + 4], o[l + 5]),
									n.set(o[l + 6], o[l + 7], o[l + 8]),
									i.set(s[u + 0], s[u + 1]),
									a.set(s[u + 2], s[u + 3]),
									c.set(s[u + 4], s[u + 5]),
									r.copy(t).add(e).add(n).divideScalar(3);
								var p = d(r);
								h(i, u + 0, t, p), h(a, u + 2, e, p), h(c, u + 4, n, p);
							}
						})(),
							(function () {
								for (var t = 0; t < s.length; t += 6) {
									var e = s[t + 0],
										n = s[t + 2],
										r = s[t + 4],
										i = Math.max(e, n, r),
										a = Math.min(e, n, r);
									i > 0.9 &&
										a < 0.1 &&
										(e < 0.2 && (s[t + 0] += 1),
										n < 0.2 && (s[t + 2] += 1),
										r < 0.2 && (s[t + 4] += 1));
								}
							})();
					})(),
					a.setAttribute('position', new an(o, 3)),
					a.setAttribute('normal', new an(o.slice(), 3)),
					a.setAttribute('uv', new an(s, 2)),
					0 === i ? a.computeVertexNormals() : a.normalizeNormals(),
					a
				);
			}
			return ut(e, t), e;
		})(vn),
		Ao = (function (t) {
			function e(e, n) {
				var r,
					i = (1 + Math.sqrt(5)) / 2,
					a = 1 / i,
					o = [
						-1,
						-1,
						-1,
						-1,
						-1,
						1,
						-1,
						1,
						-1,
						-1,
						1,
						1,
						1,
						-1,
						-1,
						1,
						-1,
						1,
						1,
						1,
						-1,
						1,
						1,
						1,
						0,
						-a,
						-i,
						0,
						-a,
						i,
						0,
						a,
						-i,
						0,
						a,
						i,
						-a,
						-i,
						0,
						-a,
						i,
						0,
						a,
						-i,
						0,
						a,
						i,
						0,
						-i,
						0,
						-a,
						i,
						0,
						-a,
						-i,
						0,
						a,
						i,
						0,
						a,
					];
				return (
					((r =
						t.call(
							this,
							o,
							[
								3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
								17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
								12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
								16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
								14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
								5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
							],
							e,
							n
						) || this).type = 'DodecahedronBufferGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r
				);
			}
			return ut(e, t), e;
		})(Eo),
		Lo = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r = t.call(this) || this).type = 'DodecahedronGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r.fromBufferGeometry(new Ao(e, n)),
					r.mergeVertices(),
					r
				);
			}
			return ut(e, t), e;
		})(yo),
		Ro = new wt(),
		Co = new wt(),
		Po = new wt(),
		Io = new Be(),
		Do = (function (t) {
			function e(e, n) {
				var r;
				((r = t.call(this) || this).type = 'EdgesGeometry'),
					(r.parameters = { thresholdAngle: n }),
					(n = void 0 !== n ? n : 1),
					e.isGeometry && (e = new vn().fromGeometry(e));
				for (
					var i = Math.pow(10, 4),
						a = Math.cos(st.DEG2RAD * n),
						o = e.getIndex(),
						s = e.getAttribute('position'),
						c = o ? o.count : s.count,
						l = [0, 0, 0],
						u = ['a', 'b', 'c'],
						h = new Array(3),
						d = {},
						p = [],
						f = 0;
					f < c;
					f += 3
				) {
					o
						? ((l[0] = o.getX(f)),
						  (l[1] = o.getX(f + 1)),
						  (l[2] = o.getX(f + 2)))
						: ((l[0] = f), (l[1] = f + 1), (l[2] = f + 2));
					var m = Io.a,
						v = Io.b,
						g = Io.c;
					if (
						(m.fromBufferAttribute(s, l[0]),
						v.fromBufferAttribute(s, l[1]),
						g.fromBufferAttribute(s, l[2]),
						Io.getNormal(Po),
						(h[0] =
							Math.round(m.x * i) +
							',' +
							Math.round(m.y * i) +
							',' +
							Math.round(m.z * i)),
						(h[1] =
							Math.round(v.x * i) +
							',' +
							Math.round(v.y * i) +
							',' +
							Math.round(v.z * i)),
						(h[2] =
							Math.round(g.x * i) +
							',' +
							Math.round(g.y * i) +
							',' +
							Math.round(g.z * i)),
						h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
					)
						for (var y = 0; y < 3; y++) {
							var x = (y + 1) % 3,
								_ = h[y],
								b = h[x],
								w = Io[u[y]],
								M = Io[u[x]],
								S = _ + '_' + b,
								T = b + '_' + _;
							T in d && d[T]
								? (Po.dot(d[T].normal) <= a &&
										(p.push(w.x, w.y, w.z), p.push(M.x, M.y, M.z)),
								  (d[T] = null))
								: S in d ||
								  (d[S] = { index0: l[y], index1: l[x], normal: Po.clone() });
						}
				}
				for (var E in d)
					if (d[E]) {
						var A = d[E],
							L = A.index0,
							R = A.index1;
						Ro.fromBufferAttribute(s, L),
							Co.fromBufferAttribute(s, R),
							p.push(Ro.x, Ro.y, Ro.z),
							p.push(Co.x, Co.y, Co.z);
					}
				return r.setAttribute('position', new an(p, 3)), r;
			}
			return ut(e, t), e;
		})(vn),
		No = function (t, e, n) {
			n = n || 2;
			var r,
				i,
				a,
				o,
				s,
				c,
				l,
				u = e && e.length,
				h = u ? e[0] * n : t.length,
				d = Oo(t, 0, h, n, !0),
				p = [];
			if (!d || d.next === d.prev) return p;
			if (
				(u &&
					(d = (function (t, e, n, r) {
						var i,
							a,
							o,
							s = [];
						for (i = 0, a = e.length; i < a; i++)
							(o = Oo(
								t,
								e[i] * r,
								i < a - 1 ? e[i + 1] * r : t.length,
								r,
								!1
							)) === o.next && (o.steiner = !0),
								s.push(qo(o));
						for (s.sort(ko), i = 0; i < s.length; i++)
							Vo(s[i], n), (n = Bo(n, n.next));
						return n;
					})(t, e, d, n)),
				t.length > 80 * n)
			) {
				(r = a = t[0]), (i = o = t[1]);
				for (var f = n; f < h; f += n)
					(s = t[f]) < r && (r = s),
						(c = t[f + 1]) < i && (i = c),
						s > a && (a = s),
						c > o && (o = c);
				l = 0 !== (l = Math.max(a - r, o - i)) ? 1 / l : 0;
			}
			return zo(d, p, n, r, i, l), p;
		};
	function Oo(t, e, n, r, i) {
		var a, o;
		if (
			i ===
			(function (t, e, n, r) {
				for (var i = 0, a = e, o = n - r; a < n; a += r)
					(i += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
				return i;
			})(t, e, n, r) >
				0
		)
			for (a = e; a < n; a += r) o = ns(a, t[a], t[a + 1], o);
		else for (a = n - r; a >= e; a -= r) o = ns(a, t[a], t[a + 1], o);
		return o && Jo(o, o.next) && (rs(o), (o = o.next)), o;
	}
	function Bo(t, e) {
		if (!t) return t;
		e || (e = t);
		var n,
			r = t;
		do {
			if (
				((n = !1), r.steiner || (!Jo(r, r.next) && 0 !== Zo(r.prev, r, r.next)))
			)
				r = r.next;
			else {
				if ((rs(r), (r = e = r.prev) === r.next)) break;
				n = !0;
			}
		} while (n || r !== e);
		return e;
	}
	function zo(t, e, n, r, i, a, o) {
		if (t) {
			!o &&
				a &&
				(function (t, e, n, r) {
					var i = t;
					do {
						null === i.z && (i.z = jo(i.x, i.y, e, n, r)),
							(i.prevZ = i.prev),
							(i.nextZ = i.next),
							(i = i.next);
					} while (i !== t);
					(i.prevZ.nextZ = null),
						(i.prevZ = null),
						(function (t) {
							var e,
								n,
								r,
								i,
								a,
								o,
								s,
								c,
								l = 1;
							do {
								for (n = t, t = null, a = null, o = 0; n; ) {
									for (
										o++, r = n, s = 0, e = 0;
										e < l && (s++, (r = r.nextZ));
										e++
									);
									for (c = l; s > 0 || (c > 0 && r); )
										0 !== s && (0 === c || !r || n.z <= r.z)
											? ((i = n), (n = n.nextZ), s--)
											: ((i = r), (r = r.nextZ), c--),
											a ? (a.nextZ = i) : (t = i),
											(i.prevZ = a),
											(a = i);
									n = r;
								}
								(a.nextZ = null), (l *= 2);
							} while (o > 1);
						})(i);
				})(t, r, i, a);
			for (var s, c, l = t; t.prev !== t.next; )
				if (((s = t.prev), (c = t.next), a ? Fo(t, r, i, a) : Go(t)))
					e.push(s.i / n),
						e.push(t.i / n),
						e.push(c.i / n),
						rs(t),
						(t = c.next),
						(l = c.next);
				else if ((t = c) === l) {
					o
						? 1 === o
							? zo((t = Uo(Bo(t), e, n)), e, n, r, i, a, 2)
							: 2 === o && Ho(t, e, n, r, i, a)
						: zo(Bo(t), e, n, r, i, a, 1);
					break;
				}
		}
	}
	function Go(t) {
		var e = t.prev,
			n = t,
			r = t.next;
		if (Zo(e, n, r) >= 0) return !1;
		for (var i = t.next.next; i !== t.prev; ) {
			if (
				Xo(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
				Zo(i.prev, i, i.next) >= 0
			)
				return !1;
			i = i.next;
		}
		return !0;
	}
	function Fo(t, e, n, r) {
		var i = t.prev,
			a = t,
			o = t.next;
		if (Zo(i, a, o) >= 0) return !1;
		for (
			var s = i.x < a.x ? (i.x < o.x ? i.x : o.x) : a.x < o.x ? a.x : o.x,
				c = i.y < a.y ? (i.y < o.y ? i.y : o.y) : a.y < o.y ? a.y : o.y,
				l = i.x > a.x ? (i.x > o.x ? i.x : o.x) : a.x > o.x ? a.x : o.x,
				u = i.y > a.y ? (i.y > o.y ? i.y : o.y) : a.y > o.y ? a.y : o.y,
				h = jo(s, c, e, n, r),
				d = jo(l, u, e, n, r),
				p = t.prevZ,
				f = t.nextZ;
			p && p.z >= h && f && f.z <= d;

		) {
			if (
				p !== t.prev &&
				p !== t.next &&
				Xo(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
				Zo(p.prev, p, p.next) >= 0
			)
				return !1;
			if (
				((p = p.prevZ),
				f !== t.prev &&
					f !== t.next &&
					Xo(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
					Zo(f.prev, f, f.next) >= 0)
			)
				return !1;
			f = f.nextZ;
		}
		for (; p && p.z >= h; ) {
			if (
				p !== t.prev &&
				p !== t.next &&
				Xo(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
				Zo(p.prev, p, p.next) >= 0
			)
				return !1;
			p = p.prevZ;
		}
		for (; f && f.z <= d; ) {
			if (
				f !== t.prev &&
				f !== t.next &&
				Xo(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
				Zo(f.prev, f, f.next) >= 0
			)
				return !1;
			f = f.nextZ;
		}
		return !0;
	}
	function Uo(t, e, n) {
		var r = t;
		do {
			var i = r.prev,
				a = r.next.next;
			!Jo(i, a) &&
				Qo(i, r, r.next, a) &&
				ts(i, a) &&
				ts(a, i) &&
				(e.push(i.i / n),
				e.push(r.i / n),
				e.push(a.i / n),
				rs(r),
				rs(r.next),
				(r = t = a)),
				(r = r.next);
		} while (r !== t);
		return Bo(r);
	}
	function Ho(t, e, n, r, i, a) {
		var o = t;
		do {
			for (var s = o.next.next; s !== o.prev; ) {
				if (o.i !== s.i && Yo(o, s)) {
					var c = es(o, s);
					return (
						(o = Bo(o, o.next)),
						(c = Bo(c, c.next)),
						zo(o, e, n, r, i, a),
						void zo(c, e, n, r, i, a)
					);
				}
				s = s.next;
			}
			o = o.next;
		} while (o !== t);
	}
	function ko(t, e) {
		return t.x - e.x;
	}
	function Vo(t, e) {
		if (
			(e = (function (t, e) {
				var n,
					r = e,
					i = t.x,
					a = t.y,
					o = -1 / 0;
				do {
					if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
						var s = r.x + ((a - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
						if (s <= i && s > o) {
							if (((o = s), s === i)) {
								if (a === r.y) return r;
								if (a === r.next.y) return r.next;
							}
							n = r.x < r.next.x ? r : r.next;
						}
					}
					r = r.next;
				} while (r !== e);
				if (!n) return null;
				if (i === o) return n;
				var c,
					l = n,
					u = n.x,
					h = n.y,
					d = 1 / 0;
				r = n;
				do {
					i >= r.x &&
						r.x >= u &&
						i !== r.x &&
						Xo(a < h ? i : o, a, u, h, a < h ? o : i, a, r.x, r.y) &&
						((c = Math.abs(a - r.y) / (i - r.x)),
						ts(r, t) &&
							(c < d ||
								(c === d && (r.x > n.x || (r.x === n.x && Wo(n, r))))) &&
							((n = r), (d = c))),
						(r = r.next);
				} while (r !== l);
				return n;
			})(t, e))
		) {
			var n = es(e, t);
			Bo(e, e.next), Bo(n, n.next);
		}
	}
	function Wo(t, e) {
		return Zo(t.prev, t, e.prev) < 0 && Zo(e.next, t, t.next) < 0;
	}
	function jo(t, e, n, r, i) {
		return (
			(t =
				1431655765 &
				((t =
					858993459 &
					((t =
						252645135 &
						((t = 16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) |
							(t << 4))) |
						(t << 2))) |
					(t << 1))) |
			((e =
				1431655765 &
				((e =
					858993459 &
					((e =
						252645135 &
						((e = 16711935 & ((e = 32767 * (e - r) * i) | (e << 8))) |
							(e << 4))) |
						(e << 2))) |
					(e << 1))) <<
				1)
		);
	}
	function qo(t) {
		var e = t,
			n = t;
		do {
			(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
		} while (e !== t);
		return n;
	}
	function Xo(t, e, n, r, i, a, o, s) {
		return (
			(i - o) * (e - s) - (t - o) * (a - s) >= 0 &&
			(t - o) * (r - s) - (n - o) * (e - s) >= 0 &&
			(n - o) * (a - s) - (i - o) * (r - s) >= 0
		);
	}
	function Yo(t, e) {
		return (
			t.next.i !== e.i &&
			t.prev.i !== e.i &&
			!(function (t, e) {
				var n = t;
				do {
					if (
						n.i !== t.i &&
						n.next.i !== t.i &&
						n.i !== e.i &&
						n.next.i !== e.i &&
						Qo(n, n.next, t, e)
					)
						return !0;
					n = n.next;
				} while (n !== t);
				return !1;
			})(t, e) &&
			((ts(t, e) &&
				ts(e, t) &&
				(function (t, e) {
					var n = t,
						r = !1,
						i = (t.x + e.x) / 2,
						a = (t.y + e.y) / 2;
					do {
						n.y > a != n.next.y > a &&
							n.next.y !== n.y &&
							i < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
							(r = !r),
							(n = n.next);
					} while (n !== t);
					return r;
				})(t, e) &&
				(Zo(t.prev, t, e.prev) || Zo(t, e.prev, e))) ||
				(Jo(t, e) && Zo(t.prev, t, t.next) > 0 && Zo(e.prev, e, e.next) > 0))
		);
	}
	function Zo(t, e, n) {
		return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
	}
	function Jo(t, e) {
		return t.x === e.x && t.y === e.y;
	}
	function Qo(t, e, n, r) {
		var i = $o(Zo(t, e, n)),
			a = $o(Zo(t, e, r)),
			o = $o(Zo(n, r, t)),
			s = $o(Zo(n, r, e));
		return (
			(i !== a && o !== s) ||
			!(0 !== i || !Ko(t, n, e)) ||
			!(0 !== a || !Ko(t, r, e)) ||
			!(0 !== o || !Ko(n, t, r)) ||
			!(0 !== s || !Ko(n, e, r))
		);
	}
	function Ko(t, e, n) {
		return (
			e.x <= Math.max(t.x, n.x) &&
			e.x >= Math.min(t.x, n.x) &&
			e.y <= Math.max(t.y, n.y) &&
			e.y >= Math.min(t.y, n.y)
		);
	}
	function $o(t) {
		return t > 0 ? 1 : t < 0 ? -1 : 0;
	}
	function ts(t, e) {
		return Zo(t.prev, t, t.next) < 0
			? Zo(t, e, t.next) >= 0 && Zo(t, t.prev, e) >= 0
			: Zo(t, e, t.prev) < 0 || Zo(t, t.next, e) < 0;
	}
	function es(t, e) {
		var n = new is(t.i, t.x, t.y),
			r = new is(e.i, e.x, e.y),
			i = t.next,
			a = e.prev;
		return (
			(t.next = e),
			(e.prev = t),
			(n.next = i),
			(i.prev = n),
			(r.next = n),
			(n.prev = r),
			(a.next = r),
			(r.prev = a),
			r
		);
	}
	function ns(t, e, n, r) {
		var i = new is(t, e, n);
		return (
			r
				? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
				: ((i.prev = i), (i.next = i)),
			i
		);
	}
	function rs(t) {
		(t.next.prev = t.prev),
			(t.prev.next = t.next),
			t.prevZ && (t.prevZ.nextZ = t.nextZ),
			t.nextZ && (t.nextZ.prevZ = t.prevZ);
	}
	function is(t, e, n) {
		(this.i = t),
			(this.x = e),
			(this.y = n),
			(this.prev = null),
			(this.next = null),
			(this.z = null),
			(this.prevZ = null),
			(this.nextZ = null),
			(this.steiner = !1);
	}
	var as = {
		area: function (t) {
			for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++)
				n += t[r].x * t[i].y - t[i].x * t[r].y;
			return 0.5 * n;
		},
		isClockWise: function (t) {
			return as.area(t) < 0;
		},
		triangulateShape: function (t, e) {
			var n = [],
				r = [],
				i = [];
			os(t), ss(n, t);
			var a = t.length;
			e.forEach(os);
			for (var o = 0; o < e.length; o++)
				r.push(a), (a += e[o].length), ss(n, e[o]);
			for (var s = No(n, r), c = 0; c < s.length; c += 3)
				i.push(s.slice(c, c + 3));
			return i;
		},
	};
	function os(t) {
		var e = t.length;
		e > 2 && t[e - 1].equals(t[0]) && t.pop();
	}
	function ss(t, e) {
		for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
	}
	var cs = (function (t) {
			function e(e, n) {
				var r;
				((r = t.call(this) || this).type = 'ExtrudeBufferGeometry'),
					(r.parameters = { shapes: e, options: n }),
					(e = Array.isArray(e) ? e : [e]);
				for (var i = ht(r), a = [], o = [], s = 0, c = e.length; s < c; s++) {
					l(e[s]);
				}
				function l(t) {
					var e = [],
						r = void 0 !== n.curveSegments ? n.curveSegments : 12,
						s = void 0 !== n.steps ? n.steps : 1,
						c = void 0 !== n.depth ? n.depth : 100,
						l = void 0 === n.bevelEnabled || n.bevelEnabled,
						u = void 0 !== n.bevelThickness ? n.bevelThickness : 6,
						h = void 0 !== n.bevelSize ? n.bevelSize : u - 2,
						d = void 0 !== n.bevelOffset ? n.bevelOffset : 0,
						p = void 0 !== n.bevelSegments ? n.bevelSegments : 3,
						f = n.extrudePath,
						m = void 0 !== n.UVGenerator ? n.UVGenerator : ls;
					void 0 !== n.amount &&
						(console.warn(
							'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'
						),
						(c = n.amount));
					var v,
						g,
						y,
						x,
						_,
						b = !1;
					f &&
						((v = f.getSpacedPoints(s)),
						(b = !0),
						(l = !1),
						(g = f.computeFrenetFrames(s, !1)),
						(y = new wt()),
						(x = new wt()),
						(_ = new wt())),
						l || ((p = 0), (u = 0), (h = 0), (d = 0));
					var w = t.extractPoints(r),
						M = w.shape,
						S = w.holes;
					if (!as.isClockWise(M)) {
						M = M.reverse();
						for (var T = 0, E = S.length; T < E; T++) {
							var A = S[T];
							as.isClockWise(A) && (S[T] = A.reverse());
						}
					}
					for (
						var L = as.triangulateShape(M, S), R = M, C = 0, P = S.length;
						C < P;
						C++
					) {
						var I = S[C];
						M = M.concat(I);
					}
					function D(t, e, n) {
						return (
							e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
							e.clone().multiplyScalar(n).add(t)
						);
					}
					var N = M.length,
						O = L.length;
					function B(t, e, n) {
						var r,
							i,
							a,
							o = t.x - e.x,
							s = t.y - e.y,
							c = n.x - t.x,
							l = n.y - t.y,
							u = o * o + s * s,
							h = o * l - s * c;
						if (Math.abs(h) > Number.EPSILON) {
							var d = Math.sqrt(u),
								p = Math.sqrt(c * c + l * l),
								f = e.x - s / d,
								m = e.y + o / d,
								v =
									((n.x - l / p - f) * l - (n.y + c / p - m) * c) /
									(o * l - s * c),
								g = (r = f + o * v - t.x) * r + (i = m + s * v - t.y) * i;
							if (g <= 2) return new pt(r, i);
							a = Math.sqrt(g / 2);
						} else {
							var y = !1;
							o > Number.EPSILON
								? c > Number.EPSILON && (y = !0)
								: o < -Number.EPSILON
								? c < -Number.EPSILON && (y = !0)
								: Math.sign(s) === Math.sign(l) && (y = !0),
								y
									? ((r = -s), (i = o), (a = Math.sqrt(u)))
									: ((r = o), (i = s), (a = Math.sqrt(u / 2)));
						}
						return new pt(r / a, i / a);
					}
					for (
						var z = [], G = 0, F = R.length, U = F - 1, H = G + 1;
						G < F;
						G++, U++, H++
					)
						U === F && (U = 0),
							H === F && (H = 0),
							(z[G] = B(R[G], R[U], R[H]));
					for (var k, V = [], W = z.concat(), j = 0, q = S.length; j < q; j++) {
						var X = S[j];
						k = [];
						for (
							var Y = 0, Z = X.length, J = Z - 1, Q = Y + 1;
							Y < Z;
							Y++, J++, Q++
						)
							J === Z && (J = 0),
								Q === Z && (Q = 0),
								(k[Y] = B(X[Y], X[J], X[Q]));
						V.push(k), (W = W.concat(k));
					}
					for (var K = 0; K < p; K++) {
						for (
							var $ = K / p,
								tt = u * Math.cos(($ * Math.PI) / 2),
								et = h * Math.sin(($ * Math.PI) / 2) + d,
								nt = 0,
								rt = R.length;
							nt < rt;
							nt++
						) {
							var it = D(R[nt], z[nt], et);
							Dt(it.x, it.y, -tt);
						}
						for (var at = 0, ot = S.length; at < ot; at++) {
							var st = S[at];
							k = V[at];
							for (var ct = 0, lt = st.length; ct < lt; ct++) {
								var ut = D(st[ct], k[ct], et);
								Dt(ut.x, ut.y, -tt);
							}
						}
					}
					for (var ht = h + d, dt = 0; dt < N; dt++) {
						var ft = l ? D(M[dt], W[dt], ht) : M[dt];
						b
							? (x.copy(g.normals[0]).multiplyScalar(ft.x),
							  y.copy(g.binormals[0]).multiplyScalar(ft.y),
							  _.copy(v[0]).add(x).add(y),
							  Dt(_.x, _.y, _.z))
							: Dt(ft.x, ft.y, 0);
					}
					for (var mt = 1; mt <= s; mt++)
						for (var vt = 0; vt < N; vt++) {
							var gt = l ? D(M[vt], W[vt], ht) : M[vt];
							b
								? (x.copy(g.normals[mt]).multiplyScalar(gt.x),
								  y.copy(g.binormals[mt]).multiplyScalar(gt.y),
								  _.copy(v[mt]).add(x).add(y),
								  Dt(_.x, _.y, _.z))
								: Dt(gt.x, gt.y, (c / s) * mt);
						}
					for (var yt = p - 1; yt >= 0; yt--) {
						for (
							var xt = yt / p,
								_t = u * Math.cos((xt * Math.PI) / 2),
								bt = h * Math.sin((xt * Math.PI) / 2) + d,
								Mt = 0,
								St = R.length;
							Mt < St;
							Mt++
						) {
							var Tt = D(R[Mt], z[Mt], bt);
							Dt(Tt.x, Tt.y, c + _t);
						}
						for (var Et = 0, At = S.length; Et < At; Et++) {
							var Lt = S[Et];
							k = V[Et];
							for (var Rt = 0, Ct = Lt.length; Rt < Ct; Rt++) {
								var Pt = D(Lt[Rt], k[Rt], bt);
								b
									? Dt(Pt.x, Pt.y + v[s - 1].y, v[s - 1].x + _t)
									: Dt(Pt.x, Pt.y, c + _t);
							}
						}
					}
					function It(t, e) {
						for (var n = t.length; --n >= 0; ) {
							var r = n,
								i = n - 1;
							i < 0 && (i = t.length - 1);
							for (var a = 0, o = s + 2 * p; a < o; a++) {
								var c = N * a,
									l = N * (a + 1);
								Ot(e + r + c, e + i + c, e + i + l, e + r + l);
							}
						}
					}
					function Dt(t, n, r) {
						e.push(t), e.push(n), e.push(r);
					}
					function Nt(t, e, n) {
						Bt(t), Bt(e), Bt(n);
						var r = a.length / 3,
							o = m.generateTopUV(i, a, r - 3, r - 2, r - 1);
						zt(o[0]), zt(o[1]), zt(o[2]);
					}
					function Ot(t, e, n, r) {
						Bt(t), Bt(e), Bt(r), Bt(e), Bt(n), Bt(r);
						var o = a.length / 3,
							s = m.generateSideWallUV(i, a, o - 6, o - 3, o - 2, o - 1);
						zt(s[0]), zt(s[1]), zt(s[3]), zt(s[1]), zt(s[2]), zt(s[3]);
					}
					function Bt(t) {
						a.push(e[3 * t + 0]), a.push(e[3 * t + 1]), a.push(e[3 * t + 2]);
					}
					function zt(t) {
						o.push(t.x), o.push(t.y);
					}
					!(function () {
						var t = a.length / 3;
						if (l) {
							for (var e = 0, n = N * e, r = 0; r < O; r++) {
								var o = L[r];
								Nt(o[2] + n, o[1] + n, o[0] + n);
							}
							n = N * (e = s + 2 * p);
							for (var c = 0; c < O; c++) {
								var u = L[c];
								Nt(u[0] + n, u[1] + n, u[2] + n);
							}
						} else {
							for (var h = 0; h < O; h++) {
								var d = L[h];
								Nt(d[2], d[1], d[0]);
							}
							for (var f = 0; f < O; f++) {
								var m = L[f];
								Nt(m[0] + N * s, m[1] + N * s, m[2] + N * s);
							}
						}
						i.addGroup(t, a.length / 3 - t, 0);
					})(),
						(function () {
							var t = a.length / 3,
								e = 0;
							It(R, e), (e += R.length);
							for (var n = 0, r = S.length; n < r; n++) {
								var o = S[n];
								It(o, e), (e += o.length);
							}
							i.addGroup(t, a.length / 3 - t, 1);
						})();
				}
				return (
					r.setAttribute('position', new an(a, 3)),
					r.setAttribute('uv', new an(o, 2)),
					r.computeVertexNormals(),
					r
				);
			}
			return (
				ut(e, t),
				(e.prototype.toJSON = function () {
					var t = vn.prototype.toJSON.call(this);
					return (function (t, e, n) {
						if (((n.shapes = []), Array.isArray(t)))
							for (var r = 0, i = t.length; r < i; r++) {
								var a = t[r];
								n.shapes.push(a.uuid);
							}
						else n.shapes.push(t.uuid);
						void 0 !== e.extrudePath &&
							(n.options.extrudePath = e.extrudePath.toJSON());
						return n;
					})(this.parameters.shapes, this.parameters.options, t);
				}),
				e
			);
		})(vn),
		ls = {
			generateTopUV: function (t, e, n, r, i) {
				var a = e[3 * n],
					o = e[3 * n + 1],
					s = e[3 * r],
					c = e[3 * r + 1],
					l = e[3 * i],
					u = e[3 * i + 1];
				return [new pt(a, o), new pt(s, c), new pt(l, u)];
			},
			generateSideWallUV: function (t, e, n, r, i, a) {
				var o = e[3 * n],
					s = e[3 * n + 1],
					c = e[3 * n + 2],
					l = e[3 * r],
					u = e[3 * r + 1],
					h = e[3 * r + 2],
					d = e[3 * i],
					p = e[3 * i + 1],
					f = e[3 * i + 2],
					m = e[3 * a],
					v = e[3 * a + 1],
					g = e[3 * a + 2];
				return Math.abs(s - u) < 0.01
					? [
							new pt(o, 1 - c),
							new pt(l, 1 - h),
							new pt(d, 1 - f),
							new pt(m, 1 - g),
					  ]
					: [
							new pt(s, 1 - c),
							new pt(u, 1 - h),
							new pt(p, 1 - f),
							new pt(v, 1 - g),
					  ];
			},
		};
	var us = (function (t) {
		function e(e, n) {
			var r;
			return (
				((r = t.call(this) || this).type = 'ExtrudeGeometry'),
				(r.parameters = { shapes: e, options: n }),
				r.fromBufferGeometry(new cs(e, n)),
				r.mergeVertices(),
				r
			);
		}
		return (
			ut(e, t),
			(e.prototype.toJSON = function () {
				var e = t.prototype.toJSON.call(this);
				return (function (t, e, n) {
					if (((n.shapes = []), Array.isArray(t)))
						for (var r = 0, i = t.length; r < i; r++) {
							var a = t[r];
							n.shapes.push(a.uuid);
						}
					else n.shapes.push(t.uuid);
					void 0 !== e.extrudePath &&
						(n.options.extrudePath = e.extrudePath.toJSON());
					return n;
				})(this.parameters.shapes, this.parameters.options, e);
			}),
			e
		);
	})(yo);
	var hs = (function (t) {
			function e(e, n) {
				var r,
					i = (1 + Math.sqrt(5)) / 2,
					a = [
						-1,
						i,
						0,
						1,
						i,
						0,
						-1,
						-i,
						0,
						1,
						-i,
						0,
						0,
						-1,
						i,
						0,
						1,
						i,
						0,
						-1,
						-i,
						0,
						1,
						-i,
						i,
						0,
						-1,
						i,
						0,
						1,
						-i,
						0,
						-1,
						-i,
						0,
						1,
					];
				return (
					((r =
						t.call(
							this,
							a,
							[
								0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
								4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
								6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
							],
							e,
							n
						) || this).type = 'IcosahedronBufferGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r
				);
			}
			return ut(e, t), e;
		})(Eo),
		ds = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r = t.call(this) || this).type = 'IcosahedronGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r.fromBufferGeometry(new hs(e, n)),
					r.mergeVertices(),
					r
				);
			}
			return ut(e, t), e;
		})(yo),
		ps = (function (t) {
			function e(e, n, r, i) {
				var a;
				((a = t.call(this) || this).type = 'LatheBufferGeometry'),
					(a.parameters = {
						points: e,
						segments: n,
						phiStart: r,
						phiLength: i,
					}),
					(n = Math.floor(n) || 12),
					(r = r || 0),
					(i = i || 2 * Math.PI),
					(i = st.clamp(i, 0, 2 * Math.PI));
				for (
					var o = [],
						s = [],
						c = [],
						l = 1 / n,
						u = new wt(),
						h = new pt(),
						d = 0;
					d <= n;
					d++
				)
					for (
						var p = r + d * l * i, f = Math.sin(p), m = Math.cos(p), v = 0;
						v <= e.length - 1;
						v++
					)
						(u.x = e[v].x * f),
							(u.y = e[v].y),
							(u.z = e[v].x * m),
							s.push(u.x, u.y, u.z),
							(h.x = d / n),
							(h.y = v / (e.length - 1)),
							c.push(h.x, h.y);
				for (var g = 0; g < n; g++)
					for (var y = 0; y < e.length - 1; y++) {
						var x = y + g * e.length,
							_ = x,
							b = x + e.length,
							w = x + e.length + 1,
							M = x + 1;
						o.push(_, b, M), o.push(b, w, M);
					}
				if (
					(a.setIndex(o),
					a.setAttribute('position', new an(s, 3)),
					a.setAttribute('uv', new an(c, 2)),
					a.computeVertexNormals(),
					i === 2 * Math.PI)
				)
					for (
						var S = a.attributes.normal.array,
							T = new wt(),
							E = new wt(),
							A = new wt(),
							L = n * e.length * 3,
							R = 0,
							C = 0;
						R < e.length;
						R++, C += 3
					)
						(T.x = S[C + 0]),
							(T.y = S[C + 1]),
							(T.z = S[C + 2]),
							(E.x = S[L + C + 0]),
							(E.y = S[L + C + 1]),
							(E.z = S[L + C + 2]),
							A.addVectors(T, E).normalize(),
							(S[C + 0] = S[L + C + 0] = A.x),
							(S[C + 1] = S[L + C + 1] = A.y),
							(S[C + 2] = S[L + C + 2] = A.z);
				return a;
			}
			return ut(e, t), e;
		})(vn),
		fs = (function (t) {
			function e(e, n, r, i) {
				var a;
				return (
					((a = t.call(this) || this).type = 'LatheGeometry'),
					(a.parameters = {
						points: e,
						segments: n,
						phiStart: r,
						phiLength: i,
					}),
					a.fromBufferGeometry(new ps(e, n, r, i)),
					a.mergeVertices(),
					a
				);
			}
			return ut(e, t), e;
		})(yo),
		ms = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r =
						t.call(
							this,
							[1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
							[
								0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
								1, 4, 2,
							],
							e,
							n
						) || this).type = 'OctahedronBufferGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r
				);
			}
			return ut(e, t), e;
		})(Eo),
		vs = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r = t.call(this) || this).type = 'OctahedronGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r.fromBufferGeometry(new ms(e, n)),
					r.mergeVertices(),
					r
				);
			}
			return ut(e, t), e;
		})(yo);
	function gs(t, e, n) {
		vn.call(this),
			(this.type = 'ParametricBufferGeometry'),
			(this.parameters = { func: t, slices: e, stacks: n });
		var r = [],
			i = [],
			a = [],
			o = [],
			s = 1e-5,
			c = new wt(),
			l = new wt(),
			u = new wt(),
			h = new wt(),
			d = new wt();
		t.length < 3 &&
			console.error(
				'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.'
			);
		for (var p = e + 1, f = 0; f <= n; f++)
			for (var m = f / n, v = 0; v <= e; v++) {
				var g = v / e;
				t(g, m, l),
					i.push(l.x, l.y, l.z),
					g - s >= 0
						? (t(g - s, m, u), h.subVectors(l, u))
						: (t(g + s, m, u), h.subVectors(u, l)),
					m - s >= 0
						? (t(g, m - s, u), d.subVectors(l, u))
						: (t(g, m + s, u), d.subVectors(u, l)),
					c.crossVectors(h, d).normalize(),
					a.push(c.x, c.y, c.z),
					o.push(g, m);
			}
		for (var y = 0; y < n; y++)
			for (var x = 0; x < e; x++) {
				var _ = y * p + x,
					b = y * p + x + 1,
					w = (y + 1) * p + x + 1,
					M = (y + 1) * p + x;
				r.push(_, b, M), r.push(b, w, M);
			}
		this.setIndex(r),
			this.setAttribute('position', new an(i, 3)),
			this.setAttribute('normal', new an(a, 3)),
			this.setAttribute('uv', new an(o, 2));
	}
	function ys(t, e, n) {
		yo.call(this),
			(this.type = 'ParametricGeometry'),
			(this.parameters = { func: t, slices: e, stacks: n }),
			this.fromBufferGeometry(new gs(t, e, n)),
			this.mergeVertices();
	}
	(gs.prototype = Object.create(vn.prototype)),
		(gs.prototype.constructor = gs),
		(ys.prototype = Object.create(yo.prototype)),
		(ys.prototype.constructor = ys);
	var xs = (function (t) {
			function e(e, n, r, i) {
				var a;
				return (
					((a = t.call(this) || this).type = 'PlaneGeometry'),
					(a.parameters = {
						width: e,
						height: n,
						widthSegments: r,
						heightSegments: i,
					}),
					a.fromBufferGeometry(new tr(e, n, r, i)),
					a.mergeVertices(),
					a
				);
			}
			return ut(e, t), e;
		})(yo),
		_s = (function (t) {
			function e(e, n, r, i) {
				var a;
				return (
					((a = t.call(this) || this).type = 'PolyhedronGeometry'),
					(a.parameters = { vertices: e, indices: n, radius: r, detail: i }),
					a.fromBufferGeometry(new Eo(e, n, r, i)),
					a.mergeVertices(),
					a
				);
			}
			return ut(e, t), e;
		})(yo),
		bs = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				((s = t.call(this) || this).type = 'RingBufferGeometry'),
					(s.parameters = {
						innerRadius: e,
						outerRadius: n,
						thetaSegments: r,
						phiSegments: i,
						thetaStart: a,
						thetaLength: o,
					}),
					(e = e || 0.5),
					(n = n || 1),
					(a = void 0 !== a ? a : 0),
					(o = void 0 !== o ? o : 2 * Math.PI),
					(r = void 0 !== r ? Math.max(3, r) : 8);
				for (
					var c = [],
						l = [],
						u = [],
						h = [],
						d = e,
						p = (n - e) / (i = void 0 !== i ? Math.max(1, i) : 1),
						f = new wt(),
						m = new pt(),
						v = 0;
					v <= i;
					v++
				) {
					for (var g = 0; g <= r; g++) {
						var y = a + (g / r) * o;
						(f.x = d * Math.cos(y)),
							(f.y = d * Math.sin(y)),
							l.push(f.x, f.y, f.z),
							u.push(0, 0, 1),
							(m.x = (f.x / n + 1) / 2),
							(m.y = (f.y / n + 1) / 2),
							h.push(m.x, m.y);
					}
					d += p;
				}
				for (var x = 0; x < i; x++)
					for (var _ = x * (r + 1), b = 0; b < r; b++) {
						var w = b + _,
							M = w,
							S = w + r + 1,
							T = w + r + 2,
							E = w + 1;
						c.push(M, S, E), c.push(S, T, E);
					}
				return (
					s.setIndex(c),
					s.setAttribute('position', new an(l, 3)),
					s.setAttribute('normal', new an(u, 3)),
					s.setAttribute('uv', new an(h, 2)),
					s
				);
			}
			return ut(e, t), e;
		})(vn),
		ws = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				return (
					((s = t.call(this) || this).type = 'RingGeometry'),
					(s.parameters = {
						innerRadius: e,
						outerRadius: n,
						thetaSegments: r,
						phiSegments: i,
						thetaStart: a,
						thetaLength: o,
					}),
					s.fromBufferGeometry(new bs(e, n, r, i, a, o)),
					s.mergeVertices(),
					s
				);
			}
			return ut(e, t), e;
		})(yo),
		Ms = (function (t) {
			function e(e, n) {
				var r;
				((r = t.call(this) || this).type = 'ShapeBufferGeometry'),
					(r.parameters = { shapes: e, curveSegments: n }),
					(n = n || 12);
				var i = [],
					a = [],
					o = [],
					s = [],
					c = 0,
					l = 0;
				if (!1 === Array.isArray(e)) h(e);
				else
					for (var u = 0; u < e.length; u++)
						h(e[u]), r.addGroup(c, l, u), (c += l), (l = 0);
				function h(t) {
					var e = a.length / 3,
						r = t.extractPoints(n),
						c = r.shape,
						u = r.holes;
					!1 === as.isClockWise(c) && (c = c.reverse());
					for (var h = 0, d = u.length; h < d; h++) {
						var p = u[h];
						!0 === as.isClockWise(p) && (u[h] = p.reverse());
					}
					for (
						var f = as.triangulateShape(c, u), m = 0, v = u.length;
						m < v;
						m++
					) {
						var g = u[m];
						c = c.concat(g);
					}
					for (var y = 0, x = c.length; y < x; y++) {
						var _ = c[y];
						a.push(_.x, _.y, 0), o.push(0, 0, 1), s.push(_.x, _.y);
					}
					for (var b = 0, w = f.length; b < w; b++) {
						var M = f[b],
							S = M[0] + e,
							T = M[1] + e,
							E = M[2] + e;
						i.push(S, T, E), (l += 3);
					}
				}
				return (
					r.setIndex(i),
					r.setAttribute('position', new an(a, 3)),
					r.setAttribute('normal', new an(o, 3)),
					r.setAttribute('uv', new an(s, 2)),
					r
				);
			}
			return (
				ut(e, t),
				(e.prototype.toJSON = function () {
					var t = vn.prototype.toJSON.call(this);
					return (function (t, e) {
						if (((e.shapes = []), Array.isArray(t)))
							for (var n = 0, r = t.length; n < r; n++) {
								var i = t[n];
								e.shapes.push(i.uuid);
							}
						else e.shapes.push(t.uuid);
						return e;
					})(this.parameters.shapes, t);
				}),
				e
			);
		})(vn);
	var Ss = (function (t) {
		function e(e, n) {
			var r;
			return (
				((r = t.call(this) || this).type = 'ShapeGeometry'),
				'object' == typeof n &&
					(console.warn(
						'THREE.ShapeGeometry: Options parameter has been removed.'
					),
					(n = n.curveSegments)),
				(r.parameters = { shapes: e, curveSegments: n }),
				r.fromBufferGeometry(new Ms(e, n)),
				r.mergeVertices(),
				r
			);
		}
		return (
			ut(e, t),
			(e.prototype.toJSON = function () {
				var t = yo.prototype.toJSON.call(this);
				return (function (t, e) {
					if (((e.shapes = []), Array.isArray(t)))
						for (var n = 0, r = t.length; n < r; n++) {
							var i = t[n];
							e.shapes.push(i.uuid);
						}
					else e.shapes.push(t.uuid);
					return e;
				})(this.parameters.shapes, t);
			}),
			e
		);
	})(yo);
	var Ts = (function (t) {
			function e(e, n, r, i, a, o, s) {
				var c;
				((c = t.call(this) || this).type = 'SphereBufferGeometry'),
					(c.parameters = {
						radius: e,
						widthSegments: n,
						heightSegments: r,
						phiStart: i,
						phiLength: a,
						thetaStart: o,
						thetaLength: s,
					}),
					(e = e || 1),
					(n = Math.max(3, Math.floor(n) || 8)),
					(r = Math.max(2, Math.floor(r) || 6)),
					(i = void 0 !== i ? i : 0),
					(a = void 0 !== a ? a : 2 * Math.PI),
					(o = void 0 !== o ? o : 0),
					(s = void 0 !== s ? s : Math.PI);
				for (
					var l = Math.min(o + s, Math.PI),
						u = 0,
						h = [],
						d = new wt(),
						p = new wt(),
						f = [],
						m = [],
						v = [],
						g = [],
						y = 0;
					y <= r;
					y++
				) {
					var x = [],
						_ = y / r,
						b = 0;
					0 == y && 0 == o
						? (b = 0.5 / n)
						: y == r && l == Math.PI && (b = -0.5 / n);
					for (var w = 0; w <= n; w++) {
						var M = w / n;
						(d.x = -e * Math.cos(i + M * a) * Math.sin(o + _ * s)),
							(d.y = e * Math.cos(o + _ * s)),
							(d.z = e * Math.sin(i + M * a) * Math.sin(o + _ * s)),
							m.push(d.x, d.y, d.z),
							p.copy(d).normalize(),
							v.push(p.x, p.y, p.z),
							g.push(M + b, 1 - _),
							x.push(u++);
					}
					h.push(x);
				}
				for (var S = 0; S < r; S++)
					for (var T = 0; T < n; T++) {
						var E = h[S][T + 1],
							A = h[S][T],
							L = h[S + 1][T],
							R = h[S + 1][T + 1];
						(0 !== S || o > 0) && f.push(E, A, R),
							(S !== r - 1 || l < Math.PI) && f.push(A, L, R);
					}
				return (
					c.setIndex(f),
					c.setAttribute('position', new an(m, 3)),
					c.setAttribute('normal', new an(v, 3)),
					c.setAttribute('uv', new an(g, 2)),
					c
				);
			}
			return ut(e, t), e;
		})(vn),
		Es = (function (t) {
			function e(e, n, r, i, a, o, s) {
				var c;
				return (
					((c = t.call(this) || this).type = 'SphereGeometry'),
					(c.parameters = {
						radius: e,
						widthSegments: n,
						heightSegments: r,
						phiStart: i,
						phiLength: a,
						thetaStart: o,
						thetaLength: s,
					}),
					c.fromBufferGeometry(new Ts(e, n, r, i, a, o, s)),
					c.mergeVertices(),
					c
				);
			}
			return ut(e, t), e;
		})(yo),
		As = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r =
						t.call(
							this,
							[1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
							[2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
							e,
							n
						) || this).type = 'TetrahedronBufferGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r
				);
			}
			return ut(e, t), e;
		})(Eo),
		Ls = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r = t.call(this) || this).type = 'TetrahedronGeometry'),
					(r.parameters = { radius: e, detail: n }),
					r.fromBufferGeometry(new As(e, n)),
					r.mergeVertices(),
					r
				);
			}
			return ut(e, t), e;
		})(yo),
		Rs = (function (t) {
			function e(e, n) {
				var r,
					i = (n = n || {}).font;
				if (!i || !i.isFont)
					return (
						console.error(
							'THREE.TextGeometry: font parameter is not an instance of THREE.Font.'
						),
						new vn() || ht(r)
					);
				var a = i.generateShapes(e, n.size);
				return (
					(n.depth = void 0 !== n.height ? n.height : 50),
					void 0 === n.bevelThickness && (n.bevelThickness = 10),
					void 0 === n.bevelSize && (n.bevelSize = 8),
					void 0 === n.bevelEnabled && (n.bevelEnabled = !1),
					((r = t.call(this, a, n) || this).type = 'TextBufferGeometry'),
					r
				);
			}
			return ut(e, t), e;
		})(cs),
		Cs = (function (t) {
			function e(e, n) {
				var r;
				return (
					((r = t.call(this) || this).type = 'TextGeometry'),
					(r.parameters = { text: e, parameters: n }),
					r.fromBufferGeometry(new Rs(e, n)),
					r.mergeVertices(),
					r
				);
			}
			return ut(e, t), e;
		})(yo),
		Ps = (function (t) {
			function e(e, n, r, i, a) {
				var o;
				((o = t.call(this) || this).type = 'TorusBufferGeometry'),
					(o.parameters = {
						radius: e,
						tube: n,
						radialSegments: r,
						tubularSegments: i,
						arc: a,
					}),
					(e = e || 1),
					(n = n || 0.4),
					(r = Math.floor(r) || 8),
					(i = Math.floor(i) || 6),
					(a = a || 2 * Math.PI);
				for (
					var s = [],
						c = [],
						l = [],
						u = [],
						h = new wt(),
						d = new wt(),
						p = new wt(),
						f = 0;
					f <= r;
					f++
				)
					for (var m = 0; m <= i; m++) {
						var v = (m / i) * a,
							g = (f / r) * Math.PI * 2;
						(d.x = (e + n * Math.cos(g)) * Math.cos(v)),
							(d.y = (e + n * Math.cos(g)) * Math.sin(v)),
							(d.z = n * Math.sin(g)),
							c.push(d.x, d.y, d.z),
							(h.x = e * Math.cos(v)),
							(h.y = e * Math.sin(v)),
							p.subVectors(d, h).normalize(),
							l.push(p.x, p.y, p.z),
							u.push(m / i),
							u.push(f / r);
					}
				for (var y = 1; y <= r; y++)
					for (var x = 1; x <= i; x++) {
						var _ = (i + 1) * y + x - 1,
							b = (i + 1) * (y - 1) + x - 1,
							w = (i + 1) * (y - 1) + x,
							M = (i + 1) * y + x;
						s.push(_, b, M), s.push(b, w, M);
					}
				return (
					o.setIndex(s),
					o.setAttribute('position', new an(c, 3)),
					o.setAttribute('normal', new an(l, 3)),
					o.setAttribute('uv', new an(u, 2)),
					o
				);
			}
			return ut(e, t), e;
		})(vn),
		Is = (function (t) {
			function e(e, n, r, i, a) {
				var o;
				return (
					((o = t.call(this) || this).type = 'TorusGeometry'),
					(o.parameters = {
						radius: e,
						tube: n,
						radialSegments: r,
						tubularSegments: i,
						arc: a,
					}),
					o.fromBufferGeometry(new Ps(e, n, r, i, a)),
					o.mergeVertices(),
					o
				);
			}
			return ut(e, t), e;
		})(yo),
		Ds = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				((s = t.call(this) || this).type = 'TorusKnotBufferGeometry'),
					(s.parameters = {
						radius: e,
						tube: n,
						tubularSegments: r,
						radialSegments: i,
						p: a,
						q: o,
					}),
					(e = e || 1),
					(n = n || 0.4),
					(r = Math.floor(r) || 64),
					(i = Math.floor(i) || 8),
					(a = a || 2),
					(o = o || 3);
				for (
					var c = [],
						l = [],
						u = [],
						h = [],
						d = new wt(),
						p = new wt(),
						f = new wt(),
						m = new wt(),
						v = new wt(),
						g = new wt(),
						y = new wt(),
						x = 0;
					x <= r;
					++x
				) {
					var _ = (x / r) * a * Math.PI * 2;
					P(_, a, o, e, f),
						P(_ + 0.01, a, o, e, m),
						g.subVectors(m, f),
						y.addVectors(m, f),
						v.crossVectors(g, y),
						y.crossVectors(v, g),
						v.normalize(),
						y.normalize();
					for (var b = 0; b <= i; ++b) {
						var w = (b / i) * Math.PI * 2,
							M = -n * Math.cos(w),
							S = n * Math.sin(w);
						(d.x = f.x + (M * y.x + S * v.x)),
							(d.y = f.y + (M * y.y + S * v.y)),
							(d.z = f.z + (M * y.z + S * v.z)),
							l.push(d.x, d.y, d.z),
							p.subVectors(d, f).normalize(),
							u.push(p.x, p.y, p.z),
							h.push(x / r),
							h.push(b / i);
					}
				}
				for (var T = 1; T <= r; T++)
					for (var E = 1; E <= i; E++) {
						var A = (i + 1) * (T - 1) + (E - 1),
							L = (i + 1) * T + (E - 1),
							R = (i + 1) * T + E,
							C = (i + 1) * (T - 1) + E;
						c.push(A, L, C), c.push(L, R, C);
					}
				function P(t, e, n, r, i) {
					var a = Math.cos(t),
						o = Math.sin(t),
						s = (n / e) * t,
						c = Math.cos(s);
					(i.x = r * (2 + c) * 0.5 * a),
						(i.y = r * (2 + c) * o * 0.5),
						(i.z = r * Math.sin(s) * 0.5);
				}
				return (
					s.setIndex(c),
					s.setAttribute('position', new an(l, 3)),
					s.setAttribute('normal', new an(u, 3)),
					s.setAttribute('uv', new an(h, 2)),
					s
				);
			}
			return ut(e, t), e;
		})(vn),
		Ns = (function (t) {
			function e(e, n, r, i, a, o, s) {
				var c;
				return (
					((c = t.call(this) || this).type = 'TorusKnotGeometry'),
					(c.parameters = {
						radius: e,
						tube: n,
						tubularSegments: r,
						radialSegments: i,
						p: a,
						q: o,
					}),
					void 0 !== s &&
						console.warn(
							'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.'
						),
					c.fromBufferGeometry(new Ds(e, n, r, i, a, o)),
					c.mergeVertices(),
					c
				);
			}
			return ut(e, t), e;
		})(yo),
		Os = (function (t) {
			function e(e, n, r, i, a) {
				var o;
				((o = t.call(this) || this).type = 'TubeBufferGeometry'),
					(o.parameters = {
						path: e,
						tubularSegments: n,
						radius: r,
						radialSegments: i,
						closed: a,
					}),
					(n = n || 64),
					(r = r || 1),
					(i = i || 8),
					(a = a || !1);
				var s = e.computeFrenetFrames(n, a);
				(o.tangents = s.tangents),
					(o.normals = s.normals),
					(o.binormals = s.binormals);
				var c = new wt(),
					l = new wt(),
					u = new pt(),
					h = new wt(),
					d = [],
					p = [],
					f = [],
					m = [];
				function v(t) {
					h = e.getPointAt(t / n, h);
					for (var a = s.normals[t], o = s.binormals[t], u = 0; u <= i; u++) {
						var f = (u / i) * Math.PI * 2,
							m = Math.sin(f),
							v = -Math.cos(f);
						(l.x = v * a.x + m * o.x),
							(l.y = v * a.y + m * o.y),
							(l.z = v * a.z + m * o.z),
							l.normalize(),
							p.push(l.x, l.y, l.z),
							(c.x = h.x + r * l.x),
							(c.y = h.y + r * l.y),
							(c.z = h.z + r * l.z),
							d.push(c.x, c.y, c.z);
					}
				}
				return (
					(function () {
						for (var t = 0; t < n; t++) v(t);
						v(!1 === a ? n : 0),
							(function () {
								for (var t = 0; t <= n; t++)
									for (var e = 0; e <= i; e++)
										(u.x = t / n), (u.y = e / i), f.push(u.x, u.y);
							})(),
							(function () {
								for (var t = 1; t <= n; t++)
									for (var e = 1; e <= i; e++) {
										var r = (i + 1) * (t - 1) + (e - 1),
											a = (i + 1) * t + (e - 1),
											o = (i + 1) * t + e,
											s = (i + 1) * (t - 1) + e;
										m.push(r, a, s), m.push(a, o, s);
									}
							})();
					})(),
					o.setIndex(m),
					o.setAttribute('position', new an(d, 3)),
					o.setAttribute('normal', new an(p, 3)),
					o.setAttribute('uv', new an(f, 2)),
					o
				);
			}
			return (
				ut(e, t),
				(e.prototype.toJSON = function () {
					var t = vn.prototype.toJSON.call(this);
					return (t.path = this.parameters.path.toJSON()), t;
				}),
				e
			);
		})(vn),
		Bs = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				((s = t.call(this) || this).type = 'TubeGeometry'),
					(s.parameters = {
						path: e,
						tubularSegments: n,
						radius: r,
						radialSegments: i,
						closed: a,
					}),
					void 0 !== o &&
						console.warn('THREE.TubeGeometry: taper has been removed.');
				var c = new Os(e, n, r, i, a);
				return (
					(s.tangents = c.tangents),
					(s.normals = c.normals),
					(s.binormals = c.binormals),
					s.fromBufferGeometry(c),
					s.mergeVertices(),
					s
				);
			}
			return ut(e, t), e;
		})(yo),
		zs = (function (t) {
			function e(e) {
				var n;
				(n = t.call(this) || this).type = 'WireframeGeometry';
				var r = [],
					i = [0, 0],
					a = {},
					o = ['a', 'b', 'c'];
				if (e && e.isGeometry) {
					for (var s = e.faces, c = 0, l = s.length; c < l; c++)
						for (var u = s[c], h = 0; h < 3; h++) {
							var d = u[o[h]],
								p = u[o[(h + 1) % 3]];
							(i[0] = Math.min(d, p)), (i[1] = Math.max(d, p));
							var f = i[0] + ',' + i[1];
							void 0 === a[f] && (a[f] = { index1: i[0], index2: i[1] });
						}
					for (var m in a) {
						var v = a[m],
							g = e.vertices[v.index1];
						r.push(g.x, g.y, g.z),
							(g = e.vertices[v.index2]),
							r.push(g.x, g.y, g.z);
					}
				} else if (e && e.isBufferGeometry) {
					var y = new wt();
					if (null !== e.index) {
						var x = e.attributes.position,
							_ = e.index,
							b = e.groups;
						0 === b.length &&
							(b = [{ start: 0, count: _.count, materialIndex: 0 }]);
						for (var w = 0, M = b.length; w < M; ++w)
							for (
								var S = b[w], T = S.start, E = T, A = T + S.count;
								E < A;
								E += 3
							)
								for (var L = 0; L < 3; L++) {
									var R = _.getX(E + L),
										C = _.getX(E + ((L + 1) % 3));
									(i[0] = Math.min(R, C)), (i[1] = Math.max(R, C));
									var P = i[0] + ',' + i[1];
									void 0 === a[P] && (a[P] = { index1: i[0], index2: i[1] });
								}
						for (var I in a) {
							var D = a[I];
							y.fromBufferAttribute(x, D.index1),
								r.push(y.x, y.y, y.z),
								y.fromBufferAttribute(x, D.index2),
								r.push(y.x, y.y, y.z);
						}
					} else
						for (
							var N = e.attributes.position, O = 0, B = N.count / 3;
							O < B;
							O++
						)
							for (var z = 0; z < 3; z++) {
								var G = 3 * O + z;
								y.fromBufferAttribute(N, G), r.push(y.x, y.y, y.z);
								var F = 3 * O + ((z + 1) % 3);
								y.fromBufferAttribute(N, F), r.push(y.x, y.y, y.z);
							}
				}
				return n.setAttribute('position', new an(r, 3)), n;
			}
			return ut(e, t), e;
		})(vn),
		Gs = Object.freeze({
			__proto__: null,
			BoxGeometry: xo,
			BoxBufferGeometry: zn,
			CircleGeometry: bo,
			CircleBufferGeometry: _o,
			ConeGeometry: So,
			ConeBufferGeometry: To,
			CylinderGeometry: Mo,
			CylinderBufferGeometry: wo,
			DodecahedronGeometry: Lo,
			DodecahedronBufferGeometry: Ao,
			EdgesGeometry: Do,
			ExtrudeGeometry: us,
			ExtrudeBufferGeometry: cs,
			IcosahedronGeometry: ds,
			IcosahedronBufferGeometry: hs,
			LatheGeometry: fs,
			LatheBufferGeometry: ps,
			OctahedronGeometry: vs,
			OctahedronBufferGeometry: ms,
			ParametricGeometry: ys,
			ParametricBufferGeometry: gs,
			PlaneGeometry: xs,
			PlaneBufferGeometry: tr,
			PolyhedronGeometry: _s,
			PolyhedronBufferGeometry: Eo,
			RingGeometry: ws,
			RingBufferGeometry: bs,
			ShapeGeometry: Ss,
			ShapeBufferGeometry: Ms,
			SphereGeometry: Es,
			SphereBufferGeometry: Ts,
			TetrahedronGeometry: Ls,
			TetrahedronBufferGeometry: As,
			TextGeometry: Cs,
			TextBufferGeometry: Rs,
			TorusGeometry: Is,
			TorusBufferGeometry: Ps,
			TorusKnotGeometry: Ns,
			TorusKnotBufferGeometry: Ds,
			TubeGeometry: Bs,
			TubeBufferGeometry: Os,
			WireframeGeometry: zs,
		});
	function Fs(t) {
		qe.call(this),
			(this.type = 'ShadowMaterial'),
			(this.color = new Ve(0)),
			(this.transparent = !0),
			this.setValues(t);
	}
	function Us(t) {
		Hn.call(this, t), (this.type = 'RawShaderMaterial');
	}
	function Hs(t) {
		qe.call(this),
			(this.defines = { STANDARD: '' }),
			(this.type = 'MeshStandardMaterial'),
			(this.color = new Ve(16777215)),
			(this.roughness = 1),
			(this.metalness = 0),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ve(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = 0),
			(this.normalScale = new pt(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.roughnessMap = null),
			(this.metalnessMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.envMapIntensity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			(this.vertexTangents = !1),
			this.setValues(t);
	}
	function ks(t) {
		Hs.call(this),
			(this.defines = { STANDARD: '', PHYSICAL: '' }),
			(this.type = 'MeshPhysicalMaterial'),
			(this.clearcoat = 0),
			(this.clearcoatMap = null),
			(this.clearcoatRoughness = 0),
			(this.clearcoatRoughnessMap = null),
			(this.clearcoatNormalScale = new pt(1, 1)),
			(this.clearcoatNormalMap = null),
			(this.reflectivity = 0.5),
			Object.defineProperty(this, 'ior', {
				get: function () {
					return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
				},
				set: function (t) {
					this.reflectivity = st.clamp((2.5 * (t - 1)) / (t + 1), 0, 1);
				},
			}),
			(this.sheen = null),
			(this.transmission = 0),
			(this.transmissionMap = null),
			this.setValues(t);
	}
	function Vs(t) {
		qe.call(this),
			(this.type = 'MeshPhongMaterial'),
			(this.color = new Ve(16777215)),
			(this.specular = new Ve(1118481)),
			(this.shininess = 30),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ve(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = 0),
			(this.normalScale = new pt(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.specularMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.combine = 0),
			(this.reflectivity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			this.setValues(t);
	}
	function Ws(t) {
		qe.call(this),
			(this.defines = { TOON: '' }),
			(this.type = 'MeshToonMaterial'),
			(this.color = new Ve(16777215)),
			(this.map = null),
			(this.gradientMap = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ve(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = 0),
			(this.normalScale = new pt(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.alphaMap = null),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			this.setValues(t);
	}
	function js(t) {
		qe.call(this),
			(this.type = 'MeshNormalMaterial'),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = 0),
			(this.normalScale = new pt(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.fog = !1),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			this.setValues(t);
	}
	function qs(t) {
		qe.call(this),
			(this.type = 'MeshLambertMaterial'),
			(this.color = new Ve(16777215)),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ve(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.specularMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.combine = 0),
			(this.reflectivity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			this.setValues(t);
	}
	function Xs(t) {
		qe.call(this),
			(this.defines = { MATCAP: '' }),
			(this.type = 'MeshMatcapMaterial'),
			(this.color = new Ve(16777215)),
			(this.matcap = null),
			(this.map = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = 0),
			(this.normalScale = new pt(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.alphaMap = null),
			(this.skinning = !1),
			(this.morphTargets = !1),
			(this.morphNormals = !1),
			this.setValues(t);
	}
	function Ys(t) {
		ja.call(this),
			(this.type = 'LineDashedMaterial'),
			(this.scale = 1),
			(this.dashSize = 3),
			(this.gapSize = 1),
			this.setValues(t);
	}
	(Fs.prototype = Object.create(qe.prototype)),
		(Fs.prototype.constructor = Fs),
		(Fs.prototype.isShadowMaterial = !0),
		(Fs.prototype.copy = function (t) {
			return qe.prototype.copy.call(this, t), this.color.copy(t.color), this;
		}),
		(Us.prototype = Object.create(Hn.prototype)),
		(Us.prototype.constructor = Us),
		(Us.prototype.isRawShaderMaterial = !0),
		(Hs.prototype = Object.create(qe.prototype)),
		(Hs.prototype.constructor = Hs),
		(Hs.prototype.isMeshStandardMaterial = !0),
		(Hs.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				(this.defines = { STANDARD: '' }),
				this.color.copy(t.color),
				(this.roughness = t.roughness),
				(this.metalness = t.metalness),
				(this.map = t.map),
				(this.lightMap = t.lightMap),
				(this.lightMapIntensity = t.lightMapIntensity),
				(this.aoMap = t.aoMap),
				(this.aoMapIntensity = t.aoMapIntensity),
				this.emissive.copy(t.emissive),
				(this.emissiveMap = t.emissiveMap),
				(this.emissiveIntensity = t.emissiveIntensity),
				(this.bumpMap = t.bumpMap),
				(this.bumpScale = t.bumpScale),
				(this.normalMap = t.normalMap),
				(this.normalMapType = t.normalMapType),
				this.normalScale.copy(t.normalScale),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				(this.roughnessMap = t.roughnessMap),
				(this.metalnessMap = t.metalnessMap),
				(this.alphaMap = t.alphaMap),
				(this.envMap = t.envMap),
				(this.envMapIntensity = t.envMapIntensity),
				(this.refractionRatio = t.refractionRatio),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.wireframeLinecap = t.wireframeLinecap),
				(this.wireframeLinejoin = t.wireframeLinejoin),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				(this.vertexTangents = t.vertexTangents),
				this
			);
		}),
		(ks.prototype = Object.create(Hs.prototype)),
		(ks.prototype.constructor = ks),
		(ks.prototype.isMeshPhysicalMaterial = !0),
		(ks.prototype.copy = function (t) {
			return (
				Hs.prototype.copy.call(this, t),
				(this.defines = { STANDARD: '', PHYSICAL: '' }),
				(this.clearcoat = t.clearcoat),
				(this.clearcoatMap = t.clearcoatMap),
				(this.clearcoatRoughness = t.clearcoatRoughness),
				(this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
				(this.clearcoatNormalMap = t.clearcoatNormalMap),
				this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
				(this.reflectivity = t.reflectivity),
				t.sheen
					? (this.sheen = (this.sheen || new Ve()).copy(t.sheen))
					: (this.sheen = null),
				(this.transmission = t.transmission),
				(this.transmissionMap = t.transmissionMap),
				this
			);
		}),
		(Vs.prototype = Object.create(qe.prototype)),
		(Vs.prototype.constructor = Vs),
		(Vs.prototype.isMeshPhongMaterial = !0),
		(Vs.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				this.specular.copy(t.specular),
				(this.shininess = t.shininess),
				(this.map = t.map),
				(this.lightMap = t.lightMap),
				(this.lightMapIntensity = t.lightMapIntensity),
				(this.aoMap = t.aoMap),
				(this.aoMapIntensity = t.aoMapIntensity),
				this.emissive.copy(t.emissive),
				(this.emissiveMap = t.emissiveMap),
				(this.emissiveIntensity = t.emissiveIntensity),
				(this.bumpMap = t.bumpMap),
				(this.bumpScale = t.bumpScale),
				(this.normalMap = t.normalMap),
				(this.normalMapType = t.normalMapType),
				this.normalScale.copy(t.normalScale),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				(this.specularMap = t.specularMap),
				(this.alphaMap = t.alphaMap),
				(this.envMap = t.envMap),
				(this.combine = t.combine),
				(this.reflectivity = t.reflectivity),
				(this.refractionRatio = t.refractionRatio),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.wireframeLinecap = t.wireframeLinecap),
				(this.wireframeLinejoin = t.wireframeLinejoin),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				this
			);
		}),
		(Ws.prototype = Object.create(qe.prototype)),
		(Ws.prototype.constructor = Ws),
		(Ws.prototype.isMeshToonMaterial = !0),
		(Ws.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				(this.map = t.map),
				(this.gradientMap = t.gradientMap),
				(this.lightMap = t.lightMap),
				(this.lightMapIntensity = t.lightMapIntensity),
				(this.aoMap = t.aoMap),
				(this.aoMapIntensity = t.aoMapIntensity),
				this.emissive.copy(t.emissive),
				(this.emissiveMap = t.emissiveMap),
				(this.emissiveIntensity = t.emissiveIntensity),
				(this.bumpMap = t.bumpMap),
				(this.bumpScale = t.bumpScale),
				(this.normalMap = t.normalMap),
				(this.normalMapType = t.normalMapType),
				this.normalScale.copy(t.normalScale),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				(this.alphaMap = t.alphaMap),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.wireframeLinecap = t.wireframeLinecap),
				(this.wireframeLinejoin = t.wireframeLinejoin),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				this
			);
		}),
		(js.prototype = Object.create(qe.prototype)),
		(js.prototype.constructor = js),
		(js.prototype.isMeshNormalMaterial = !0),
		(js.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				(this.bumpMap = t.bumpMap),
				(this.bumpScale = t.bumpScale),
				(this.normalMap = t.normalMap),
				(this.normalMapType = t.normalMapType),
				this.normalScale.copy(t.normalScale),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				this
			);
		}),
		(qs.prototype = Object.create(qe.prototype)),
		(qs.prototype.constructor = qs),
		(qs.prototype.isMeshLambertMaterial = !0),
		(qs.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				this.color.copy(t.color),
				(this.map = t.map),
				(this.lightMap = t.lightMap),
				(this.lightMapIntensity = t.lightMapIntensity),
				(this.aoMap = t.aoMap),
				(this.aoMapIntensity = t.aoMapIntensity),
				this.emissive.copy(t.emissive),
				(this.emissiveMap = t.emissiveMap),
				(this.emissiveIntensity = t.emissiveIntensity),
				(this.specularMap = t.specularMap),
				(this.alphaMap = t.alphaMap),
				(this.envMap = t.envMap),
				(this.combine = t.combine),
				(this.reflectivity = t.reflectivity),
				(this.refractionRatio = t.refractionRatio),
				(this.wireframe = t.wireframe),
				(this.wireframeLinewidth = t.wireframeLinewidth),
				(this.wireframeLinecap = t.wireframeLinecap),
				(this.wireframeLinejoin = t.wireframeLinejoin),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				this
			);
		}),
		(Xs.prototype = Object.create(qe.prototype)),
		(Xs.prototype.constructor = Xs),
		(Xs.prototype.isMeshMatcapMaterial = !0),
		(Xs.prototype.copy = function (t) {
			return (
				qe.prototype.copy.call(this, t),
				(this.defines = { MATCAP: '' }),
				this.color.copy(t.color),
				(this.matcap = t.matcap),
				(this.map = t.map),
				(this.bumpMap = t.bumpMap),
				(this.bumpScale = t.bumpScale),
				(this.normalMap = t.normalMap),
				(this.normalMapType = t.normalMapType),
				this.normalScale.copy(t.normalScale),
				(this.displacementMap = t.displacementMap),
				(this.displacementScale = t.displacementScale),
				(this.displacementBias = t.displacementBias),
				(this.alphaMap = t.alphaMap),
				(this.skinning = t.skinning),
				(this.morphTargets = t.morphTargets),
				(this.morphNormals = t.morphNormals),
				this
			);
		}),
		(Ys.prototype = Object.create(ja.prototype)),
		(Ys.prototype.constructor = Ys),
		(Ys.prototype.isLineDashedMaterial = !0),
		(Ys.prototype.copy = function (t) {
			return (
				ja.prototype.copy.call(this, t),
				(this.scale = t.scale),
				(this.dashSize = t.dashSize),
				(this.gapSize = t.gapSize),
				this
			);
		});
	var Zs = Object.freeze({
			__proto__: null,
			ShadowMaterial: Fs,
			SpriteMaterial: da,
			RawShaderMaterial: Us,
			ShaderMaterial: Hn,
			PointsMaterial: no,
			MeshPhysicalMaterial: ks,
			MeshStandardMaterial: Hs,
			MeshPhongMaterial: Vs,
			MeshToonMaterial: Ws,
			MeshNormalMaterial: js,
			MeshLambertMaterial: qs,
			MeshDepthMaterial: qi,
			MeshDistanceMaterial: Xi,
			MeshBasicMaterial: Xe,
			MeshMatcapMaterial: Xs,
			LineDashedMaterial: Ys,
			LineBasicMaterial: ja,
			Material: qe,
		}),
		Js = {
			arraySlice: function (t, e, n) {
				return Js.isTypedArray(t)
					? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
					: t.slice(e, n);
			},
			convertArray: function (t, e, n) {
				return !t || (!n && t.constructor === e)
					? t
					: 'number' == typeof e.BYTES_PER_ELEMENT
					? new e(t)
					: Array.prototype.slice.call(t);
			},
			isTypedArray: function (t) {
				return ArrayBuffer.isView(t) && !(t instanceof DataView);
			},
			getKeyframeOrder: function (t) {
				for (var e = t.length, n = new Array(e), r = 0; r !== e; ++r) n[r] = r;
				return (
					n.sort(function (e, n) {
						return t[e] - t[n];
					}),
					n
				);
			},
			sortedArray: function (t, e, n) {
				for (
					var r = t.length, i = new t.constructor(r), a = 0, o = 0;
					o !== r;
					++a
				)
					for (var s = n[a] * e, c = 0; c !== e; ++c) i[o++] = t[s + c];
				return i;
			},
			flattenJSON: function (t, e, n, r) {
				for (var i = 1, a = t[0]; void 0 !== a && void 0 === a[r]; ) a = t[i++];
				if (void 0 !== a) {
					var o = a[r];
					if (void 0 !== o)
						if (Array.isArray(o))
							do {
								void 0 !== (o = a[r]) && (e.push(a.time), n.push.apply(n, o)),
									(a = t[i++]);
							} while (void 0 !== a);
						else if (void 0 !== o.toArray)
							do {
								void 0 !== (o = a[r]) &&
									(e.push(a.time), o.toArray(n, n.length)),
									(a = t[i++]);
							} while (void 0 !== a);
						else
							do {
								void 0 !== (o = a[r]) && (e.push(a.time), n.push(o)),
									(a = t[i++]);
							} while (void 0 !== a);
				}
			},
			subclip: function (t, e, n, r, i) {
				i = i || 30;
				var a = t.clone();
				a.name = e;
				for (var o = [], s = 0; s < a.tracks.length; ++s) {
					for (
						var c = a.tracks[s], l = c.getValueSize(), u = [], h = [], d = 0;
						d < c.times.length;
						++d
					) {
						var p = c.times[d] * i;
						if (!(p < n || p >= r)) {
							u.push(c.times[d]);
							for (var f = 0; f < l; ++f) h.push(c.values[d * l + f]);
						}
					}
					0 !== u.length &&
						((c.times = Js.convertArray(u, c.times.constructor)),
						(c.values = Js.convertArray(h, c.values.constructor)),
						o.push(c));
				}
				a.tracks = o;
				for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v)
					m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
				for (var g = 0; g < a.tracks.length; ++g) a.tracks[g].shift(-1 * m);
				return a.resetDuration(), a;
			},
			makeClipAdditive: function (t, e, n, r) {
				void 0 === e && (e = 0),
					void 0 === n && (n = t),
					(void 0 === r || r <= 0) && (r = 30);
				for (
					var i = n.tracks.length,
						a = e / r,
						o = function (e) {
							var r = n.tracks[e],
								i = r.ValueTypeName;
							if ('bool' === i || 'string' === i) return 'continue';
							var o = t.tracks.find(function (t) {
								return t.name === r.name && t.ValueTypeName === i;
							});
							if (void 0 === o) return 'continue';
							var s = 0,
								c = r.getValueSize();
							r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
								(s = c / 3);
							var l = 0,
								u = o.getValueSize();
							o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
								(l = u / 3);
							var h = r.times.length - 1,
								d = void 0;
							if (a <= r.times[0]) {
								var p = s,
									f = c - s;
								d = Js.arraySlice(r.values, p, f);
							} else if (a >= r.times[h]) {
								var m = h * c + s,
									v = m + c - s;
								d = Js.arraySlice(r.values, m, v);
							} else {
								var g = r.createInterpolant(),
									y = s,
									x = c - s;
								g.evaluate(a), (d = Js.arraySlice(g.resultBuffer, y, x));
							}
							'quaternion' === i &&
								new bt().fromArray(d).normalize().conjugate().toArray(d);
							for (var _ = o.times.length, b = 0; b < _; ++b) {
								var w = b * u + l;
								if ('quaternion' === i)
									bt.multiplyQuaternionsFlat(o.values, w, d, 0, o.values, w);
								else
									for (var M = u - 2 * l, S = 0; S < M; ++S)
										o.values[w + S] -= d[S];
							}
						},
						s = 0;
					s < i;
					++s
				)
					o(s);
				return (t.blendMode = j), t;
			},
		};
	function Qs(t, e, n, r) {
		(this.parameterPositions = t),
			(this._cachedIndex = 0),
			(this.resultBuffer = void 0 !== r ? r : new e.constructor(n)),
			(this.sampleValues = e),
			(this.valueSize = n);
	}
	function Ks(t, e, n, r) {
		Qs.call(this, t, e, n, r),
			(this._weightPrev = -0),
			(this._offsetPrev = -0),
			(this._weightNext = -0),
			(this._offsetNext = -0);
	}
	function $s(t, e, n, r) {
		Qs.call(this, t, e, n, r);
	}
	function tc(t, e, n, r) {
		Qs.call(this, t, e, n, r);
	}
	function ec(t, e, n, r) {
		if (void 0 === t)
			throw new Error('THREE.KeyframeTrack: track name is undefined');
		if (void 0 === e || 0 === e.length)
			throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t);
		(this.name = t),
			(this.times = Js.convertArray(e, this.TimeBufferType)),
			(this.values = Js.convertArray(n, this.ValueBufferType)),
			this.setInterpolation(r || this.DefaultInterpolation);
	}
	function nc(t, e, n) {
		ec.call(this, t, e, n);
	}
	function rc(t, e, n, r) {
		ec.call(this, t, e, n, r);
	}
	function ic(t, e, n, r) {
		ec.call(this, t, e, n, r);
	}
	function ac(t, e, n, r) {
		Qs.call(this, t, e, n, r);
	}
	function oc(t, e, n, r) {
		ec.call(this, t, e, n, r);
	}
	function sc(t, e, n, r) {
		ec.call(this, t, e, n, r);
	}
	function cc(t, e, n, r) {
		ec.call(this, t, e, n, r);
	}
	function lc(t, e, n, r) {
		(this.name = t),
			(this.tracks = n),
			(this.duration = void 0 !== e ? e : -1),
			(this.blendMode = void 0 !== r ? r : W),
			(this.uuid = st.generateUUID()),
			this.duration < 0 && this.resetDuration();
	}
	function uc(t) {
		if (void 0 === t.type)
			throw new Error(
				'THREE.KeyframeTrack: track type undefined, can not parse'
			);
		var e = (function (t) {
			switch (t.toLowerCase()) {
				case 'scalar':
				case 'double':
				case 'float':
				case 'number':
				case 'integer':
					return ic;
				case 'vector':
				case 'vector2':
				case 'vector3':
				case 'vector4':
					return cc;
				case 'color':
					return rc;
				case 'quaternion':
					return oc;
				case 'bool':
				case 'boolean':
					return nc;
				case 'string':
					return sc;
			}
			throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t);
		})(t.type);
		if (void 0 === t.times) {
			var n = [],
				r = [];
			Js.flattenJSON(t.keys, n, r, 'value'), (t.times = n), (t.values = r);
		}
		return void 0 !== e.parse
			? e.parse(t)
			: new e(t.name, t.times, t.values, t.interpolation);
	}
	Object.assign(Qs.prototype, {
		evaluate: function (t) {
			var e = this.parameterPositions,
				n = this._cachedIndex,
				r = e[n],
				i = e[n - 1];
			t: {
				e: {
					var a;
					n: {
						r: if (!(t < r)) {
							for (var o = n + 2; ; ) {
								if (void 0 === r) {
									if (t < i) break r;
									return (
										(n = e.length),
										(this._cachedIndex = n),
										this.afterEnd_(n - 1, t, i)
									);
								}
								if (n === o) break;
								if (((i = r), t < (r = e[++n]))) break e;
							}
							a = e.length;
							break n;
						}
						if (t >= i) break t;
						var s = e[1];
						t < s && ((n = 2), (i = s));
						for (var c = n - 2; ; ) {
							if (void 0 === i)
								return (this._cachedIndex = 0), this.beforeStart_(0, t, r);
							if (n === c) break;
							if (((r = i), t >= (i = e[--n - 1]))) break e;
						}
						(a = n), (n = 0);
					}
					for (; n < a; ) {
						var l = (n + a) >>> 1;
						t < e[l] ? (a = l) : (n = l + 1);
					}
					if (((r = e[n]), void 0 === (i = e[n - 1])))
						return (this._cachedIndex = 0), this.beforeStart_(0, t, r);
					if (void 0 === r)
						return (
							(n = e.length),
							(this._cachedIndex = n),
							this.afterEnd_(n - 1, i, t)
						);
				}
				(this._cachedIndex = n), this.intervalChanged_(n, i, r);
			}
			return this.interpolate_(n, i, t, r);
		},
		settings: null,
		DefaultSettings_: {},
		getSettings_: function () {
			return this.settings || this.DefaultSettings_;
		},
		copySampleValue_: function (t) {
			for (
				var e = this.resultBuffer,
					n = this.sampleValues,
					r = this.valueSize,
					i = t * r,
					a = 0;
				a !== r;
				++a
			)
				e[a] = n[i + a];
			return e;
		},
		interpolate_: function () {
			throw new Error('call to abstract method');
		},
		intervalChanged_: function () {},
	}),
		Object.assign(Qs.prototype, {
			beforeStart_: Qs.prototype.copySampleValue_,
			afterEnd_: Qs.prototype.copySampleValue_,
		}),
		(Ks.prototype = Object.assign(Object.create(Qs.prototype), {
			constructor: Ks,
			DefaultSettings_: { endingStart: H, endingEnd: H },
			intervalChanged_: function (t, e, n) {
				var r = this.parameterPositions,
					i = t - 2,
					a = t + 1,
					o = r[i],
					s = r[a];
				if (void 0 === o)
					switch (this.getSettings_().endingStart) {
						case k:
							(i = t), (o = 2 * e - n);
							break;
						case V:
							o = e + r[(i = r.length - 2)] - r[i + 1];
							break;
						default:
							(i = t), (o = n);
					}
				if (void 0 === s)
					switch (this.getSettings_().endingEnd) {
						case k:
							(a = t), (s = 2 * n - e);
							break;
						case V:
							(a = 1), (s = n + r[1] - r[0]);
							break;
						default:
							(a = t - 1), (s = e);
					}
				var c = 0.5 * (n - e),
					l = this.valueSize;
				(this._weightPrev = c / (e - o)),
					(this._weightNext = c / (s - n)),
					(this._offsetPrev = i * l),
					(this._offsetNext = a * l);
			},
			interpolate_: function (t, e, n, r) {
				for (
					var i = this.resultBuffer,
						a = this.sampleValues,
						o = this.valueSize,
						s = t * o,
						c = s - o,
						l = this._offsetPrev,
						u = this._offsetNext,
						h = this._weightPrev,
						d = this._weightNext,
						p = (n - e) / (r - e),
						f = p * p,
						m = f * p,
						v = -h * m + 2 * h * f - h * p,
						g = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
						y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
						x = d * m - d * f,
						_ = 0;
					_ !== o;
					++_
				)
					i[_] = v * a[l + _] + g * a[c + _] + y * a[s + _] + x * a[u + _];
				return i;
			},
		})),
		($s.prototype = Object.assign(Object.create(Qs.prototype), {
			constructor: $s,
			interpolate_: function (t, e, n, r) {
				for (
					var i = this.resultBuffer,
						a = this.sampleValues,
						o = this.valueSize,
						s = t * o,
						c = s - o,
						l = (n - e) / (r - e),
						u = 1 - l,
						h = 0;
					h !== o;
					++h
				)
					i[h] = a[c + h] * u + a[s + h] * l;
				return i;
			},
		})),
		(tc.prototype = Object.assign(Object.create(Qs.prototype), {
			constructor: tc,
			interpolate_: function (t) {
				return this.copySampleValue_(t - 1);
			},
		})),
		Object.assign(ec, {
			toJSON: function (t) {
				var e,
					n = t.constructor;
				if (void 0 !== n.toJSON) e = n.toJSON(t);
				else {
					e = {
						name: t.name,
						times: Js.convertArray(t.times, Array),
						values: Js.convertArray(t.values, Array),
					};
					var r = t.getInterpolation();
					r !== t.DefaultInterpolation && (e.interpolation = r);
				}
				return (e.type = t.ValueTypeName), e;
			},
		}),
		Object.assign(ec.prototype, {
			constructor: ec,
			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,
			DefaultInterpolation: F,
			InterpolantFactoryMethodDiscrete: function (t) {
				return new tc(this.times, this.values, this.getValueSize(), t);
			},
			InterpolantFactoryMethodLinear: function (t) {
				return new $s(this.times, this.values, this.getValueSize(), t);
			},
			InterpolantFactoryMethodSmooth: function (t) {
				return new Ks(this.times, this.values, this.getValueSize(), t);
			},
			setInterpolation: function (t) {
				var e;
				switch (t) {
					case G:
						e = this.InterpolantFactoryMethodDiscrete;
						break;
					case F:
						e = this.InterpolantFactoryMethodLinear;
						break;
					case U:
						e = this.InterpolantFactoryMethodSmooth;
				}
				if (void 0 === e) {
					var n =
						'unsupported interpolation for ' +
						this.ValueTypeName +
						' keyframe track named ' +
						this.name;
					if (void 0 === this.createInterpolant) {
						if (t === this.DefaultInterpolation) throw new Error(n);
						this.setInterpolation(this.DefaultInterpolation);
					}
					return console.warn('THREE.KeyframeTrack:', n), this;
				}
				return (this.createInterpolant = e), this;
			},
			getInterpolation: function () {
				switch (this.createInterpolant) {
					case this.InterpolantFactoryMethodDiscrete:
						return G;
					case this.InterpolantFactoryMethodLinear:
						return F;
					case this.InterpolantFactoryMethodSmooth:
						return U;
				}
			},
			getValueSize: function () {
				return this.values.length / this.times.length;
			},
			shift: function (t) {
				if (0 !== t)
					for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] += t;
				return this;
			},
			scale: function (t) {
				if (1 !== t)
					for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] *= t;
				return this;
			},
			trim: function (t, e) {
				for (
					var n = this.times, r = n.length, i = 0, a = r - 1;
					i !== r && n[i] < t;

				)
					++i;
				for (; -1 !== a && n[a] > e; ) --a;
				if ((++a, 0 !== i || a !== r)) {
					i >= a && (i = (a = Math.max(a, 1)) - 1);
					var o = this.getValueSize();
					(this.times = Js.arraySlice(n, i, a)),
						(this.values = Js.arraySlice(this.values, i * o, a * o));
				}
				return this;
			},
			validate: function () {
				var t = !0,
					e = this.getValueSize();
				e - Math.floor(e) != 0 &&
					(console.error(
						'THREE.KeyframeTrack: Invalid value size in track.',
						this
					),
					(t = !1));
				var n = this.times,
					r = this.values,
					i = n.length;
				0 === i &&
					(console.error('THREE.KeyframeTrack: Track is empty.', this),
					(t = !1));
				for (var a = null, o = 0; o !== i; o++) {
					var s = n[o];
					if ('number' == typeof s && isNaN(s)) {
						console.error(
							'THREE.KeyframeTrack: Time is not a valid number.',
							this,
							o,
							s
						),
							(t = !1);
						break;
					}
					if (null !== a && a > s) {
						console.error(
							'THREE.KeyframeTrack: Out of order keys.',
							this,
							o,
							s,
							a
						),
							(t = !1);
						break;
					}
					a = s;
				}
				if (void 0 !== r && Js.isTypedArray(r))
					for (var c = 0, l = r.length; c !== l; ++c) {
						var u = r[c];
						if (isNaN(u)) {
							console.error(
								'THREE.KeyframeTrack: Value is not a valid number.',
								this,
								c,
								u
							),
								(t = !1);
							break;
						}
					}
				return t;
			},
			optimize: function () {
				for (
					var t = Js.arraySlice(this.times),
						e = Js.arraySlice(this.values),
						n = this.getValueSize(),
						r = this.getInterpolation() === U,
						i = t.length - 1,
						a = 1,
						o = 1;
					o < i;
					++o
				) {
					var s = !1,
						c = t[o];
					if (c !== t[o + 1] && (1 !== o || c !== c[0]))
						if (r) s = !0;
						else
							for (var l = o * n, u = l - n, h = l + n, d = 0; d !== n; ++d) {
								var p = e[l + d];
								if (p !== e[u + d] || p !== e[h + d]) {
									s = !0;
									break;
								}
							}
					if (s) {
						if (o !== a) {
							t[a] = t[o];
							for (var f = o * n, m = a * n, v = 0; v !== n; ++v)
								e[m + v] = e[f + v];
						}
						++a;
					}
				}
				if (i > 0) {
					t[a] = t[i];
					for (var g = i * n, y = a * n, x = 0; x !== n; ++x)
						e[y + x] = e[g + x];
					++a;
				}
				return (
					a !== t.length
						? ((this.times = Js.arraySlice(t, 0, a)),
						  (this.values = Js.arraySlice(e, 0, a * n)))
						: ((this.times = t), (this.values = e)),
					this
				);
			},
			clone: function () {
				var t = Js.arraySlice(this.times, 0),
					e = Js.arraySlice(this.values, 0),
					n = new (0, this.constructor)(this.name, t, e);
				return (n.createInterpolant = this.createInterpolant), n;
			},
		}),
		(nc.prototype = Object.assign(Object.create(ec.prototype), {
			constructor: nc,
			ValueTypeName: 'bool',
			ValueBufferType: Array,
			DefaultInterpolation: G,
			InterpolantFactoryMethodLinear: void 0,
			InterpolantFactoryMethodSmooth: void 0,
		})),
		(rc.prototype = Object.assign(Object.create(ec.prototype), {
			constructor: rc,
			ValueTypeName: 'color',
		})),
		(ic.prototype = Object.assign(Object.create(ec.prototype), {
			constructor: ic,
			ValueTypeName: 'number',
		})),
		(ac.prototype = Object.assign(Object.create(Qs.prototype), {
			constructor: ac,
			interpolate_: function (t, e, n, r) {
				for (
					var i = this.resultBuffer,
						a = this.sampleValues,
						o = this.valueSize,
						s = (n - e) / (r - e),
						c = t * o,
						l = c + o;
					c !== l;
					c += 4
				)
					bt.slerpFlat(i, 0, a, c - o, a, c, s);
				return i;
			},
		})),
		(oc.prototype = Object.assign(Object.create(ec.prototype), {
			constructor: oc,
			ValueTypeName: 'quaternion',
			DefaultInterpolation: F,
			InterpolantFactoryMethodLinear: function (t) {
				return new ac(this.times, this.values, this.getValueSize(), t);
			},
			InterpolantFactoryMethodSmooth: void 0,
		})),
		(sc.prototype = Object.assign(Object.create(ec.prototype), {
			constructor: sc,
			ValueTypeName: 'string',
			ValueBufferType: Array,
			DefaultInterpolation: G,
			InterpolantFactoryMethodLinear: void 0,
			InterpolantFactoryMethodSmooth: void 0,
		})),
		(cc.prototype = Object.assign(Object.create(ec.prototype), {
			constructor: cc,
			ValueTypeName: 'vector',
		})),
		Object.assign(lc, {
			parse: function (t) {
				for (
					var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, a = n.length;
					i !== a;
					++i
				)
					e.push(uc(n[i]).scale(r));
				return new lc(t.name, t.duration, e, t.blendMode);
			},
			toJSON: function (t) {
				for (
					var e = [],
						n = t.tracks,
						r = {
							name: t.name,
							duration: t.duration,
							tracks: e,
							uuid: t.uuid,
							blendMode: t.blendMode,
						},
						i = 0,
						a = n.length;
					i !== a;
					++i
				)
					e.push(ec.toJSON(n[i]));
				return r;
			},
			CreateFromMorphTargetSequence: function (t, e, n, r) {
				for (var i = e.length, a = [], o = 0; o < i; o++) {
					var s = [],
						c = [];
					s.push((o + i - 1) % i, o, (o + 1) % i), c.push(0, 1, 0);
					var l = Js.getKeyframeOrder(s);
					(s = Js.sortedArray(s, 1, l)),
						(c = Js.sortedArray(c, 1, l)),
						r || 0 !== s[0] || (s.push(i), c.push(c[0])),
						a.push(
							new ic('.morphTargetInfluences[' + e[o].name + ']', s, c).scale(
								1 / n
							)
						);
				}
				return new lc(t, -1, a);
			},
			findByName: function (t, e) {
				var n = t;
				if (!Array.isArray(t)) {
					var r = t;
					n = (r.geometry && r.geometry.animations) || r.animations;
				}
				for (var i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
				return null;
			},
			CreateClipsFromMorphTargetSequences: function (t, e, n) {
				for (
					var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length;
					a < o;
					a++
				) {
					var s = t[a],
						c = s.name.match(i);
					if (c && c.length > 1) {
						var l = c[1],
							u = r[l];
						u || (r[l] = u = []), u.push(s);
					}
				}
				var h = [];
				for (var d in r)
					h.push(lc.CreateFromMorphTargetSequence(d, r[d], e, n));
				return h;
			},
			parseAnimation: function (t, e) {
				if (!t)
					return (
						console.error(
							'THREE.AnimationClip: No animation in JSONLoader data.'
						),
						null
					);
				for (
					var n = function (t, e, n, r, i) {
							if (0 !== n.length) {
								var a = [],
									o = [];
								Js.flattenJSON(n, a, o, r),
									0 !== a.length && i.push(new t(e, a, o));
							}
						},
						r = [],
						i = t.name || 'default',
						a = t.fps || 30,
						o = t.blendMode,
						s = t.length || -1,
						c = t.hierarchy || [],
						l = 0;
					l < c.length;
					l++
				) {
					var u = c[l].keys;
					if (u && 0 !== u.length)
						if (u[0].morphTargets) {
							var h = {},
								d = void 0;
							for (d = 0; d < u.length; d++)
								if (u[d].morphTargets)
									for (var p = 0; p < u[d].morphTargets.length; p++)
										h[u[d].morphTargets[p]] = -1;
							for (var f in h) {
								for (
									var m = [], v = [], g = 0;
									g !== u[d].morphTargets.length;
									++g
								) {
									var y = u[d];
									m.push(y.time), v.push(y.morphTarget === f ? 1 : 0);
								}
								r.push(new ic('.morphTargetInfluence[' + f + ']', m, v));
							}
							s = h.length * (a || 1);
						} else {
							var x = '.bones[' + e[l].name + ']';
							n(cc, x + '.position', u, 'pos', r),
								n(oc, x + '.quaternion', u, 'rot', r),
								n(cc, x + '.scale', u, 'scl', r);
						}
				}
				return 0 === r.length ? null : new lc(i, s, r, o);
			},
		}),
		Object.assign(lc.prototype, {
			resetDuration: function () {
				for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
					var r = this.tracks[e];
					t = Math.max(t, r.times[r.times.length - 1]);
				}
				return (this.duration = t), this;
			},
			trim: function () {
				for (var t = 0; t < this.tracks.length; t++)
					this.tracks[t].trim(0, this.duration);
				return this;
			},
			validate: function () {
				for (var t = !0, e = 0; e < this.tracks.length; e++)
					t = t && this.tracks[e].validate();
				return t;
			},
			optimize: function () {
				for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
				return this;
			},
			clone: function () {
				for (var t = [], e = 0; e < this.tracks.length; e++)
					t.push(this.tracks[e].clone());
				return new lc(this.name, this.duration, t, this.blendMode);
			},
		});
	var hc = {
		enabled: !1,
		files: {},
		add: function (t, e) {
			!1 !== this.enabled && (this.files[t] = e);
		},
		get: function (t) {
			if (!1 !== this.enabled) return this.files[t];
		},
		remove: function (t) {
			delete this.files[t];
		},
		clear: function () {
			this.files = {};
		},
	};
	function dc(t, e, n) {
		var r = this,
			i = !1,
			a = 0,
			o = 0,
			s = void 0,
			c = [];
		(this.onStart = void 0),
			(this.onLoad = t),
			(this.onProgress = e),
			(this.onError = n),
			(this.itemStart = function (t) {
				o++, !1 === i && void 0 !== r.onStart && r.onStart(t, a, o), (i = !0);
			}),
			(this.itemEnd = function (t) {
				a++,
					void 0 !== r.onProgress && r.onProgress(t, a, o),
					a === o && ((i = !1), void 0 !== r.onLoad && r.onLoad());
			}),
			(this.itemError = function (t) {
				void 0 !== r.onError && r.onError(t);
			}),
			(this.resolveURL = function (t) {
				return s ? s(t) : t;
			}),
			(this.setURLModifier = function (t) {
				return (s = t), this;
			}),
			(this.addHandler = function (t, e) {
				return c.push(t, e), this;
			}),
			(this.removeHandler = function (t) {
				var e = c.indexOf(t);
				return -1 !== e && c.splice(e, 2), this;
			}),
			(this.getHandler = function (t) {
				for (var e = 0, n = c.length; e < n; e += 2) {
					var r = c[e],
						i = c[e + 1];
					if ((r.global && (r.lastIndex = 0), r.test(t))) return i;
				}
				return null;
			});
	}
	var pc = new dc();
	function fc(t) {
		(this.manager = void 0 !== t ? t : pc),
			(this.crossOrigin = 'anonymous'),
			(this.withCredentials = !1),
			(this.path = ''),
			(this.resourcePath = ''),
			(this.requestHeader = {});
	}
	Object.assign(fc.prototype, {
		load: function () {},
		loadAsync: function (t, e) {
			var n = this;
			return new Promise(function (r, i) {
				n.load(t, r, e, i);
			});
		},
		parse: function () {},
		setCrossOrigin: function (t) {
			return (this.crossOrigin = t), this;
		},
		setWithCredentials: function (t) {
			return (this.withCredentials = t), this;
		},
		setPath: function (t) {
			return (this.path = t), this;
		},
		setResourcePath: function (t) {
			return (this.resourcePath = t), this;
		},
		setRequestHeader: function (t) {
			return (this.requestHeader = t), this;
		},
	});
	var mc = {};
	function vc(t) {
		fc.call(this, t);
	}
	function gc(t) {
		fc.call(this, t);
	}
	function yc(t) {
		fc.call(this, t);
	}
	function xc(t) {
		fc.call(this, t);
	}
	function _c(t) {
		fc.call(this, t);
	}
	function bc(t) {
		fc.call(this, t);
	}
	function wc(t) {
		fc.call(this, t);
	}
	function Mc() {
		(this.type = 'Curve'), (this.arcLengthDivisions = 200);
	}
	function Sc(t, e, n, r, i, a, o, s) {
		Mc.call(this),
			(this.type = 'EllipseCurve'),
			(this.aX = t || 0),
			(this.aY = e || 0),
			(this.xRadius = n || 1),
			(this.yRadius = r || 1),
			(this.aStartAngle = i || 0),
			(this.aEndAngle = a || 2 * Math.PI),
			(this.aClockwise = o || !1),
			(this.aRotation = s || 0);
	}
	function Tc(t, e, n, r, i, a) {
		Sc.call(this, t, e, n, n, r, i, a), (this.type = 'ArcCurve');
	}
	function Ec() {
		var t = 0,
			e = 0,
			n = 0,
			r = 0;
		function i(i, a, o, s) {
			(t = i),
				(e = o),
				(n = -3 * i + 3 * a - 2 * o - s),
				(r = 2 * i - 2 * a + o + s);
		}
		return {
			initCatmullRom: function (t, e, n, r, a) {
				i(e, n, a * (n - t), a * (r - e));
			},
			initNonuniformCatmullRom: function (t, e, n, r, a, o, s) {
				var c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
					l = (n - e) / o - (r - e) / (o + s) + (r - n) / s;
				i(e, n, (c *= o), (l *= o));
			},
			calc: function (i) {
				var a = i * i;
				return t + e * i + n * a + r * (a * i);
			},
		};
	}
	(vc.prototype = Object.assign(Object.create(fc.prototype), {
		constructor: vc,
		load: function (t, e, n, r) {
			void 0 === t && (t = ''),
				void 0 !== this.path && (t = this.path + t),
				(t = this.manager.resolveURL(t));
			var i = this,
				a = hc.get(t);
			if (void 0 !== a)
				return (
					i.manager.itemStart(t),
					setTimeout(function () {
						e && e(a), i.manager.itemEnd(t);
					}, 0),
					a
				);
			if (void 0 === mc[t]) {
				var o,
					s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
				if (s) {
					var c = s[1],
						l = !!s[2],
						u = s[3];
					(u = decodeURIComponent(u)), l && (u = atob(u));
					try {
						var h,
							d = (this.responseType || '').toLowerCase();
						switch (d) {
							case 'arraybuffer':
							case 'blob':
								for (var p = new Uint8Array(u.length), f = 0; f < u.length; f++)
									p[f] = u.charCodeAt(f);
								h = 'blob' === d ? new Blob([p.buffer], { type: c }) : p.buffer;
								break;
							case 'document':
								var m = new DOMParser();
								h = m.parseFromString(u, c);
								break;
							case 'json':
								h = JSON.parse(u);
								break;
							default:
								h = u;
						}
						setTimeout(function () {
							e && e(h), i.manager.itemEnd(t);
						}, 0);
					} catch (e) {
						setTimeout(function () {
							r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
						}, 0);
					}
				} else {
					for (var v in ((mc[t] = []),
					mc[t].push({ onLoad: e, onProgress: n, onError: r }),
					(o = new XMLHttpRequest()).open('GET', t, !0),
					o.addEventListener(
						'load',
						function (e) {
							var n = this.response,
								r = mc[t];
							if ((delete mc[t], 200 === this.status || 0 === this.status)) {
								0 === this.status &&
									console.warn('THREE.FileLoader: HTTP Status 0 received.'),
									hc.add(t, n);
								for (var a = 0, o = r.length; a < o; a++) {
									var s = r[a];
									s.onLoad && s.onLoad(n);
								}
								i.manager.itemEnd(t);
							} else {
								for (var c = 0, l = r.length; c < l; c++) {
									var u = r[c];
									u.onError && u.onError(e);
								}
								i.manager.itemError(t), i.manager.itemEnd(t);
							}
						},
						!1
					),
					o.addEventListener(
						'progress',
						function (e) {
							for (var n = mc[t], r = 0, i = n.length; r < i; r++) {
								var a = n[r];
								a.onProgress && a.onProgress(e);
							}
						},
						!1
					),
					o.addEventListener(
						'error',
						function (e) {
							var n = mc[t];
							delete mc[t];
							for (var r = 0, a = n.length; r < a; r++) {
								var o = n[r];
								o.onError && o.onError(e);
							}
							i.manager.itemError(t), i.manager.itemEnd(t);
						},
						!1
					),
					o.addEventListener(
						'abort',
						function (e) {
							var n = mc[t];
							delete mc[t];
							for (var r = 0, a = n.length; r < a; r++) {
								var o = n[r];
								o.onError && o.onError(e);
							}
							i.manager.itemError(t), i.manager.itemEnd(t);
						},
						!1
					),
					void 0 !== this.responseType && (o.responseType = this.responseType),
					void 0 !== this.withCredentials &&
						(o.withCredentials = this.withCredentials),
					o.overrideMimeType &&
						o.overrideMimeType(
							void 0 !== this.mimeType ? this.mimeType : 'text/plain'
						),
					this.requestHeader))
						o.setRequestHeader(v, this.requestHeader[v]);
					o.send(null);
				}
				return i.manager.itemStart(t), o;
			}
			mc[t].push({ onLoad: e, onProgress: n, onError: r });
		},
		setResponseType: function (t) {
			return (this.responseType = t), this;
		},
		setMimeType: function (t) {
			return (this.mimeType = t), this;
		},
	})),
		(gc.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: gc,
			load: function (t, e, n, r) {
				var i = this,
					a = new vc(i.manager);
				a.setPath(i.path),
					a.setRequestHeader(i.requestHeader),
					a.setWithCredentials(i.withCredentials),
					a.load(
						t,
						function (n) {
							try {
								e(i.parse(JSON.parse(n)));
							} catch (e) {
								r ? r(e) : console.error(e), i.manager.itemError(t);
							}
						},
						n,
						r
					);
			},
			parse: function (t) {
				for (var e = [], n = 0; n < t.length; n++) {
					var r = lc.parse(t[n]);
					e.push(r);
				}
				return e;
			},
		})),
		(yc.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: yc,
			load: function (t, e, n, r) {
				var i = this,
					a = [],
					o = new uo();
				o.image = a;
				var s = new vc(this.manager);
				s.setPath(this.path),
					s.setResponseType('arraybuffer'),
					s.setRequestHeader(this.requestHeader),
					s.setWithCredentials(i.withCredentials);
				var c = 0;
				function l(l) {
					s.load(
						t[l],
						function (t) {
							var n = i.parse(t, !0);
							(a[l] = {
								width: n.width,
								height: n.height,
								format: n.format,
								mipmaps: n.mipmaps,
							}),
								6 === (c += 1) &&
									(1 === n.mipmapCount && (o.minFilter = m),
									(o.format = n.format),
									(o.needsUpdate = !0),
									e && e(o));
						},
						n,
						r
					);
				}
				if (Array.isArray(t)) for (var u = 0, h = t.length; u < h; ++u) l(u);
				else
					s.load(
						t,
						function (t) {
							var n = i.parse(t, !0);
							if (n.isCubemap)
								for (
									var r = n.mipmaps.length / n.mipmapCount, s = 0;
									s < r;
									s++
								) {
									a[s] = { mipmaps: [] };
									for (var c = 0; c < n.mipmapCount; c++)
										a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
											(a[s].format = n.format),
											(a[s].width = n.width),
											(a[s].height = n.height);
								}
							else
								(o.image.width = n.width),
									(o.image.height = n.height),
									(o.mipmaps = n.mipmaps);
							1 === n.mipmapCount && (o.minFilter = m),
								(o.format = n.format),
								(o.needsUpdate = !0),
								e && e(o);
						},
						n,
						r
					);
				return o;
			},
		})),
		(xc.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: xc,
			load: function (t, e, n, r) {
				void 0 !== this.path && (t = this.path + t),
					(t = this.manager.resolveURL(t));
				var i = this,
					a = hc.get(t);
				if (void 0 !== a)
					return (
						i.manager.itemStart(t),
						setTimeout(function () {
							e && e(a), i.manager.itemEnd(t);
						}, 0),
						a
					);
				var o = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
				function s() {
					o.removeEventListener('load', s, !1),
						o.removeEventListener('error', c, !1),
						hc.add(t, this),
						e && e(this),
						i.manager.itemEnd(t);
				}
				function c(e) {
					o.removeEventListener('load', s, !1),
						o.removeEventListener('error', c, !1),
						r && r(e),
						i.manager.itemError(t),
						i.manager.itemEnd(t);
				}
				return (
					o.addEventListener('load', s, !1),
					o.addEventListener('error', c, !1),
					'data:' !== t.substr(0, 5) &&
						void 0 !== this.crossOrigin &&
						(o.crossOrigin = this.crossOrigin),
					i.manager.itemStart(t),
					(o.src = t),
					o
				);
			},
		})),
		(_c.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: _c,
			load: function (t, e, n, r) {
				var i = new qn(),
					a = new xc(this.manager);
				a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
				var o = 0;
				function s(n) {
					a.load(
						t[n],
						function (t) {
							(i.images[n] = t), 6 === ++o && ((i.needsUpdate = !0), e && e(i));
						},
						void 0,
						r
					);
				}
				for (var c = 0; c < t.length; ++c) s(c);
				return i;
			},
		})),
		(bc.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: bc,
			load: function (t, e, n, r) {
				var i = this,
					a = new Yn(),
					o = new vc(this.manager);
				return (
					o.setResponseType('arraybuffer'),
					o.setRequestHeader(this.requestHeader),
					o.setPath(this.path),
					o.setWithCredentials(i.withCredentials),
					o.load(
						t,
						function (t) {
							var n = i.parse(t);
							n &&
								(void 0 !== n.image
									? (a.image = n.image)
									: void 0 !== n.data &&
									  ((a.image.width = n.width),
									  (a.image.height = n.height),
									  (a.image.data = n.data)),
								(a.wrapS = void 0 !== n.wrapS ? n.wrapS : u),
								(a.wrapT = void 0 !== n.wrapT ? n.wrapT : u),
								(a.magFilter = void 0 !== n.magFilter ? n.magFilter : m),
								(a.minFilter = void 0 !== n.minFilter ? n.minFilter : m),
								(a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
								void 0 !== n.format && (a.format = n.format),
								void 0 !== n.type && (a.type = n.type),
								void 0 !== n.mipmaps &&
									((a.mipmaps = n.mipmaps), (a.minFilter = g)),
								1 === n.mipmapCount && (a.minFilter = m),
								(a.needsUpdate = !0),
								e && e(a, n));
						},
						n,
						r
					),
					a
				);
			},
		})),
		(wc.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: wc,
			load: function (t, e, n, r) {
				var i = new gt(),
					a = new xc(this.manager);
				return (
					a.setCrossOrigin(this.crossOrigin),
					a.setPath(this.path),
					a.load(
						t,
						function (n) {
							i.image = n;
							var r =
								t.search(/\.jpe?g($|\?)/i) > 0 ||
								0 === t.search(/^data\:image\/jpeg/);
							(i.format = r ? S : T),
								(i.needsUpdate = !0),
								void 0 !== e && e(i);
						},
						n,
						r
					),
					i
				);
			},
		})),
		Object.assign(Mc.prototype, {
			getPoint: function () {
				return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
			},
			getPointAt: function (t, e) {
				var n = this.getUtoTmapping(t);
				return this.getPoint(n, e);
			},
			getPoints: function (t) {
				void 0 === t && (t = 5);
				for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
				return e;
			},
			getSpacedPoints: function (t) {
				void 0 === t && (t = 5);
				for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
				return e;
			},
			getLength: function () {
				var t = this.getLengths();
				return t[t.length - 1];
			},
			getLengths: function (t) {
				if (
					(void 0 === t && (t = this.arcLengthDivisions),
					this.cacheArcLengths &&
						this.cacheArcLengths.length === t + 1 &&
						!this.needsUpdate)
				)
					return this.cacheArcLengths;
				this.needsUpdate = !1;
				var e,
					n = [],
					r = this.getPoint(0),
					i = 0;
				n.push(0);
				for (var a = 1; a <= t; a++)
					(i += (e = this.getPoint(a / t)).distanceTo(r)), n.push(i), (r = e);
				return (this.cacheArcLengths = n), n;
			},
			updateArcLengths: function () {
				(this.needsUpdate = !0), this.getLengths();
			},
			getUtoTmapping: function (t, e) {
				var n,
					r = this.getLengths(),
					i = 0,
					a = r.length;
				n = e || t * r[a - 1];
				for (var o, s = 0, c = a - 1; s <= c; )
					if ((o = r[(i = Math.floor(s + (c - s) / 2))] - n) < 0) s = i + 1;
					else {
						if (!(o > 0)) {
							c = i;
							break;
						}
						c = i - 1;
					}
				if (r[(i = c)] === n) return i / (a - 1);
				var l = r[i];
				return (i + (n - l) / (r[i + 1] - l)) / (a - 1);
			},
			getTangent: function (t, e) {
				var n = 1e-4,
					r = t - n,
					i = t + n;
				r < 0 && (r = 0), i > 1 && (i = 1);
				var a = this.getPoint(r),
					o = this.getPoint(i),
					s = e || (a.isVector2 ? new pt() : new wt());
				return s.copy(o).sub(a).normalize(), s;
			},
			getTangentAt: function (t, e) {
				var n = this.getUtoTmapping(t);
				return this.getTangent(n, e);
			},
			computeFrenetFrames: function (t, e) {
				for (
					var n = new wt(),
						r = [],
						i = [],
						a = [],
						o = new wt(),
						s = new Jt(),
						c = 0;
					c <= t;
					c++
				) {
					var l = c / t;
					(r[c] = this.getTangentAt(l, new wt())), r[c].normalize();
				}
				(i[0] = new wt()), (a[0] = new wt());
				var u = Number.MAX_VALUE,
					h = Math.abs(r[0].x),
					d = Math.abs(r[0].y),
					p = Math.abs(r[0].z);
				h <= u && ((u = h), n.set(1, 0, 0)),
					d <= u && ((u = d), n.set(0, 1, 0)),
					p <= u && n.set(0, 0, 1),
					o.crossVectors(r[0], n).normalize(),
					i[0].crossVectors(r[0], o),
					a[0].crossVectors(r[0], i[0]);
				for (var f = 1; f <= t; f++) {
					if (
						((i[f] = i[f - 1].clone()),
						(a[f] = a[f - 1].clone()),
						o.crossVectors(r[f - 1], r[f]),
						o.length() > Number.EPSILON)
					) {
						o.normalize();
						var m = Math.acos(st.clamp(r[f - 1].dot(r[f]), -1, 1));
						i[f].applyMatrix4(s.makeRotationAxis(o, m));
					}
					a[f].crossVectors(r[f], i[f]);
				}
				if (!0 === e) {
					var v = Math.acos(st.clamp(i[0].dot(i[t]), -1, 1));
					(v /= t), r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (v = -v);
					for (var g = 1; g <= t; g++)
						i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)),
							a[g].crossVectors(r[g], i[g]);
				}
				return { tangents: r, normals: i, binormals: a };
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			copy: function (t) {
				return (this.arcLengthDivisions = t.arcLengthDivisions), this;
			},
			toJSON: function () {
				var t = {
					metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' },
				};
				return (
					(t.arcLengthDivisions = this.arcLengthDivisions),
					(t.type = this.type),
					t
				);
			},
			fromJSON: function (t) {
				return (this.arcLengthDivisions = t.arcLengthDivisions), this;
			},
		}),
		(Sc.prototype = Object.create(Mc.prototype)),
		(Sc.prototype.constructor = Sc),
		(Sc.prototype.isEllipseCurve = !0),
		(Sc.prototype.getPoint = function (t, e) {
			for (
				var n = e || new pt(),
					r = 2 * Math.PI,
					i = this.aEndAngle - this.aStartAngle,
					a = Math.abs(i) < Number.EPSILON;
				i < 0;

			)
				i += r;
			for (; i > r; ) i -= r;
			i < Number.EPSILON && (i = a ? 0 : r),
				!0 !== this.aClockwise || a || (i === r ? (i = -r) : (i -= r));
			var o = this.aStartAngle + t * i,
				s = this.aX + this.xRadius * Math.cos(o),
				c = this.aY + this.yRadius * Math.sin(o);
			if (0 !== this.aRotation) {
				var l = Math.cos(this.aRotation),
					u = Math.sin(this.aRotation),
					h = s - this.aX,
					d = c - this.aY;
				(s = h * l - d * u + this.aX), (c = h * u + d * l + this.aY);
			}
			return n.set(s, c);
		}),
		(Sc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				(this.aX = t.aX),
				(this.aY = t.aY),
				(this.xRadius = t.xRadius),
				(this.yRadius = t.yRadius),
				(this.aStartAngle = t.aStartAngle),
				(this.aEndAngle = t.aEndAngle),
				(this.aClockwise = t.aClockwise),
				(this.aRotation = t.aRotation),
				this
			);
		}),
		(Sc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (
				(t.aX = this.aX),
				(t.aY = this.aY),
				(t.xRadius = this.xRadius),
				(t.yRadius = this.yRadius),
				(t.aStartAngle = this.aStartAngle),
				(t.aEndAngle = this.aEndAngle),
				(t.aClockwise = this.aClockwise),
				(t.aRotation = this.aRotation),
				t
			);
		}),
		(Sc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				(this.aX = t.aX),
				(this.aY = t.aY),
				(this.xRadius = t.xRadius),
				(this.yRadius = t.yRadius),
				(this.aStartAngle = t.aStartAngle),
				(this.aEndAngle = t.aEndAngle),
				(this.aClockwise = t.aClockwise),
				(this.aRotation = t.aRotation),
				this
			);
		}),
		(Tc.prototype = Object.create(Sc.prototype)),
		(Tc.prototype.constructor = Tc),
		(Tc.prototype.isArcCurve = !0);
	var Ac = new wt(),
		Lc = new Ec(),
		Rc = new Ec(),
		Cc = new Ec();
	function Pc(t, e, n, r) {
		Mc.call(this),
			(this.type = 'CatmullRomCurve3'),
			(this.points = t || []),
			(this.closed = e || !1),
			(this.curveType = n || 'centripetal'),
			(this.tension = void 0 !== r ? r : 0.5);
	}
	function Ic(t, e, n, r, i) {
		var a = 0.5 * (r - e),
			o = 0.5 * (i - n),
			s = t * t;
		return (
			(2 * n - 2 * r + a + o) * (t * s) +
			(-3 * n + 3 * r - 2 * a - o) * s +
			a * t +
			n
		);
	}
	function Dc(t, e, n, r) {
		return (
			(function (t, e) {
				var n = 1 - t;
				return n * n * e;
			})(t, e) +
			(function (t, e) {
				return 2 * (1 - t) * t * e;
			})(t, n) +
			(function (t, e) {
				return t * t * e;
			})(t, r)
		);
	}
	function Nc(t, e, n, r, i) {
		return (
			(function (t, e) {
				var n = 1 - t;
				return n * n * n * e;
			})(t, e) +
			(function (t, e) {
				var n = 1 - t;
				return 3 * n * n * t * e;
			})(t, n) +
			(function (t, e) {
				return 3 * (1 - t) * t * t * e;
			})(t, r) +
			(function (t, e) {
				return t * t * t * e;
			})(t, i)
		);
	}
	function Oc(t, e, n, r) {
		Mc.call(this),
			(this.type = 'CubicBezierCurve'),
			(this.v0 = t || new pt()),
			(this.v1 = e || new pt()),
			(this.v2 = n || new pt()),
			(this.v3 = r || new pt());
	}
	function Bc(t, e, n, r) {
		Mc.call(this),
			(this.type = 'CubicBezierCurve3'),
			(this.v0 = t || new wt()),
			(this.v1 = e || new wt()),
			(this.v2 = n || new wt()),
			(this.v3 = r || new wt());
	}
	function zc(t, e) {
		Mc.call(this),
			(this.type = 'LineCurve'),
			(this.v1 = t || new pt()),
			(this.v2 = e || new pt());
	}
	function Gc(t, e) {
		Mc.call(this),
			(this.type = 'LineCurve3'),
			(this.v1 = t || new wt()),
			(this.v2 = e || new wt());
	}
	function Fc(t, e, n) {
		Mc.call(this),
			(this.type = 'QuadraticBezierCurve'),
			(this.v0 = t || new pt()),
			(this.v1 = e || new pt()),
			(this.v2 = n || new pt());
	}
	function Uc(t, e, n) {
		Mc.call(this),
			(this.type = 'QuadraticBezierCurve3'),
			(this.v0 = t || new wt()),
			(this.v1 = e || new wt()),
			(this.v2 = n || new wt());
	}
	function Hc(t) {
		Mc.call(this), (this.type = 'SplineCurve'), (this.points = t || []);
	}
	(Pc.prototype = Object.create(Mc.prototype)),
		(Pc.prototype.constructor = Pc),
		(Pc.prototype.isCatmullRomCurve3 = !0),
		(Pc.prototype.getPoint = function (t, e) {
			var n,
				r,
				i = e || new wt(),
				a = this.points,
				o = a.length,
				s = (o - (this.closed ? 0 : 1)) * t,
				c = Math.floor(s),
				l = s - c;
			this.closed
				? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / o) + 1) * o)
				: 0 === l && c === o - 1 && ((c = o - 2), (l = 1)),
				this.closed || c > 0
					? (n = a[(c - 1) % o])
					: (Ac.subVectors(a[0], a[1]).add(a[0]), (n = Ac));
			var u = a[c % o],
				h = a[(c + 1) % o];
			if (
				(this.closed || c + 2 < o
					? (r = a[(c + 2) % o])
					: (Ac.subVectors(a[o - 1], a[o - 2]).add(a[o - 1]), (r = Ac)),
				'centripetal' === this.curveType || 'chordal' === this.curveType)
			) {
				var d = 'chordal' === this.curveType ? 0.5 : 0.25,
					p = Math.pow(n.distanceToSquared(u), d),
					f = Math.pow(u.distanceToSquared(h), d),
					m = Math.pow(h.distanceToSquared(r), d);
				f < 1e-4 && (f = 1),
					p < 1e-4 && (p = f),
					m < 1e-4 && (m = f),
					Lc.initNonuniformCatmullRom(n.x, u.x, h.x, r.x, p, f, m),
					Rc.initNonuniformCatmullRom(n.y, u.y, h.y, r.y, p, f, m),
					Cc.initNonuniformCatmullRom(n.z, u.z, h.z, r.z, p, f, m);
			} else
				'catmullrom' === this.curveType &&
					(Lc.initCatmullRom(n.x, u.x, h.x, r.x, this.tension),
					Rc.initCatmullRom(n.y, u.y, h.y, r.y, this.tension),
					Cc.initCatmullRom(n.z, u.z, h.z, r.z, this.tension));
			return i.set(Lc.calc(l), Rc.calc(l), Cc.calc(l)), i;
		}),
		(Pc.prototype.copy = function (t) {
			Mc.prototype.copy.call(this, t), (this.points = []);
			for (var e = 0, n = t.points.length; e < n; e++) {
				var r = t.points[e];
				this.points.push(r.clone());
			}
			return (
				(this.closed = t.closed),
				(this.curveType = t.curveType),
				(this.tension = t.tension),
				this
			);
		}),
		(Pc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			t.points = [];
			for (var e = 0, n = this.points.length; e < n; e++) {
				var r = this.points[e];
				t.points.push(r.toArray());
			}
			return (
				(t.closed = this.closed),
				(t.curveType = this.curveType),
				(t.tension = this.tension),
				t
			);
		}),
		(Pc.prototype.fromJSON = function (t) {
			Mc.prototype.fromJSON.call(this, t), (this.points = []);
			for (var e = 0, n = t.points.length; e < n; e++) {
				var r = t.points[e];
				this.points.push(new wt().fromArray(r));
			}
			return (
				(this.closed = t.closed),
				(this.curveType = t.curveType),
				(this.tension = t.tension),
				this
			);
		}),
		(Oc.prototype = Object.create(Mc.prototype)),
		(Oc.prototype.constructor = Oc),
		(Oc.prototype.isCubicBezierCurve = !0),
		(Oc.prototype.getPoint = function (t, e) {
			var n = e || new pt(),
				r = this.v0,
				i = this.v1,
				a = this.v2,
				o = this.v3;
			return n.set(Nc(t, r.x, i.x, a.x, o.x), Nc(t, r.y, i.y, a.y, o.y)), n;
		}),
		(Oc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				this.v0.copy(t.v0),
				this.v1.copy(t.v1),
				this.v2.copy(t.v2),
				this.v3.copy(t.v3),
				this
			);
		}),
		(Oc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (
				(t.v0 = this.v0.toArray()),
				(t.v1 = this.v1.toArray()),
				(t.v2 = this.v2.toArray()),
				(t.v3 = this.v3.toArray()),
				t
			);
		}),
		(Oc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				this.v0.fromArray(t.v0),
				this.v1.fromArray(t.v1),
				this.v2.fromArray(t.v2),
				this.v3.fromArray(t.v3),
				this
			);
		}),
		(Bc.prototype = Object.create(Mc.prototype)),
		(Bc.prototype.constructor = Bc),
		(Bc.prototype.isCubicBezierCurve3 = !0),
		(Bc.prototype.getPoint = function (t, e) {
			var n = e || new wt(),
				r = this.v0,
				i = this.v1,
				a = this.v2,
				o = this.v3;
			return (
				n.set(
					Nc(t, r.x, i.x, a.x, o.x),
					Nc(t, r.y, i.y, a.y, o.y),
					Nc(t, r.z, i.z, a.z, o.z)
				),
				n
			);
		}),
		(Bc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				this.v0.copy(t.v0),
				this.v1.copy(t.v1),
				this.v2.copy(t.v2),
				this.v3.copy(t.v3),
				this
			);
		}),
		(Bc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (
				(t.v0 = this.v0.toArray()),
				(t.v1 = this.v1.toArray()),
				(t.v2 = this.v2.toArray()),
				(t.v3 = this.v3.toArray()),
				t
			);
		}),
		(Bc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				this.v0.fromArray(t.v0),
				this.v1.fromArray(t.v1),
				this.v2.fromArray(t.v2),
				this.v3.fromArray(t.v3),
				this
			);
		}),
		(zc.prototype = Object.create(Mc.prototype)),
		(zc.prototype.constructor = zc),
		(zc.prototype.isLineCurve = !0),
		(zc.prototype.getPoint = function (t, e) {
			var n = e || new pt();
			return (
				1 === t
					? n.copy(this.v2)
					: (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
				n
			);
		}),
		(zc.prototype.getPointAt = function (t, e) {
			return this.getPoint(t, e);
		}),
		(zc.prototype.getTangent = function (t, e) {
			var n = e || new pt();
			return n.copy(this.v2).sub(this.v1).normalize(), n;
		}),
		(zc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				this.v1.copy(t.v1),
				this.v2.copy(t.v2),
				this
			);
		}),
		(zc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
		}),
		(zc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				this.v1.fromArray(t.v1),
				this.v2.fromArray(t.v2),
				this
			);
		}),
		(Gc.prototype = Object.create(Mc.prototype)),
		(Gc.prototype.constructor = Gc),
		(Gc.prototype.isLineCurve3 = !0),
		(Gc.prototype.getPoint = function (t, e) {
			var n = e || new wt();
			return (
				1 === t
					? n.copy(this.v2)
					: (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
				n
			);
		}),
		(Gc.prototype.getPointAt = function (t, e) {
			return this.getPoint(t, e);
		}),
		(Gc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				this.v1.copy(t.v1),
				this.v2.copy(t.v2),
				this
			);
		}),
		(Gc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
		}),
		(Gc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				this.v1.fromArray(t.v1),
				this.v2.fromArray(t.v2),
				this
			);
		}),
		(Fc.prototype = Object.create(Mc.prototype)),
		(Fc.prototype.constructor = Fc),
		(Fc.prototype.isQuadraticBezierCurve = !0),
		(Fc.prototype.getPoint = function (t, e) {
			var n = e || new pt(),
				r = this.v0,
				i = this.v1,
				a = this.v2;
			return n.set(Dc(t, r.x, i.x, a.x), Dc(t, r.y, i.y, a.y)), n;
		}),
		(Fc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				this.v0.copy(t.v0),
				this.v1.copy(t.v1),
				this.v2.copy(t.v2),
				this
			);
		}),
		(Fc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (
				(t.v0 = this.v0.toArray()),
				(t.v1 = this.v1.toArray()),
				(t.v2 = this.v2.toArray()),
				t
			);
		}),
		(Fc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				this.v0.fromArray(t.v0),
				this.v1.fromArray(t.v1),
				this.v2.fromArray(t.v2),
				this
			);
		}),
		(Uc.prototype = Object.create(Mc.prototype)),
		(Uc.prototype.constructor = Uc),
		(Uc.prototype.isQuadraticBezierCurve3 = !0),
		(Uc.prototype.getPoint = function (t, e) {
			var n = e || new wt(),
				r = this.v0,
				i = this.v1,
				a = this.v2;
			return (
				n.set(Dc(t, r.x, i.x, a.x), Dc(t, r.y, i.y, a.y), Dc(t, r.z, i.z, a.z)),
				n
			);
		}),
		(Uc.prototype.copy = function (t) {
			return (
				Mc.prototype.copy.call(this, t),
				this.v0.copy(t.v0),
				this.v1.copy(t.v1),
				this.v2.copy(t.v2),
				this
			);
		}),
		(Uc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			return (
				(t.v0 = this.v0.toArray()),
				(t.v1 = this.v1.toArray()),
				(t.v2 = this.v2.toArray()),
				t
			);
		}),
		(Uc.prototype.fromJSON = function (t) {
			return (
				Mc.prototype.fromJSON.call(this, t),
				this.v0.fromArray(t.v0),
				this.v1.fromArray(t.v1),
				this.v2.fromArray(t.v2),
				this
			);
		}),
		(Hc.prototype = Object.create(Mc.prototype)),
		(Hc.prototype.constructor = Hc),
		(Hc.prototype.isSplineCurve = !0),
		(Hc.prototype.getPoint = function (t, e) {
			var n = e || new pt(),
				r = this.points,
				i = (r.length - 1) * t,
				a = Math.floor(i),
				o = i - a,
				s = r[0 === a ? a : a - 1],
				c = r[a],
				l = r[a > r.length - 2 ? r.length - 1 : a + 1],
				u = r[a > r.length - 3 ? r.length - 1 : a + 2];
			return n.set(Ic(o, s.x, c.x, l.x, u.x), Ic(o, s.y, c.y, l.y, u.y)), n;
		}),
		(Hc.prototype.copy = function (t) {
			Mc.prototype.copy.call(this, t), (this.points = []);
			for (var e = 0, n = t.points.length; e < n; e++) {
				var r = t.points[e];
				this.points.push(r.clone());
			}
			return this;
		}),
		(Hc.prototype.toJSON = function () {
			var t = Mc.prototype.toJSON.call(this);
			t.points = [];
			for (var e = 0, n = this.points.length; e < n; e++) {
				var r = this.points[e];
				t.points.push(r.toArray());
			}
			return t;
		}),
		(Hc.prototype.fromJSON = function (t) {
			Mc.prototype.fromJSON.call(this, t), (this.points = []);
			for (var e = 0, n = t.points.length; e < n; e++) {
				var r = t.points[e];
				this.points.push(new pt().fromArray(r));
			}
			return this;
		});
	var kc = Object.freeze({
		__proto__: null,
		ArcCurve: Tc,
		CatmullRomCurve3: Pc,
		CubicBezierCurve: Oc,
		CubicBezierCurve3: Bc,
		EllipseCurve: Sc,
		LineCurve: zc,
		LineCurve3: Gc,
		QuadraticBezierCurve: Fc,
		QuadraticBezierCurve3: Uc,
		SplineCurve: Hc,
	});
	function Vc() {
		Mc.call(this),
			(this.type = 'CurvePath'),
			(this.curves = []),
			(this.autoClose = !1);
	}
	function Wc(t) {
		Vc.call(this),
			(this.type = 'Path'),
			(this.currentPoint = new pt()),
			t && this.setFromPoints(t);
	}
	function jc(t) {
		Wc.call(this, t),
			(this.uuid = st.generateUUID()),
			(this.type = 'Shape'),
			(this.holes = []);
	}
	function qc(t, e) {
		be.call(this),
			(this.type = 'Light'),
			(this.color = new Ve(t)),
			(this.intensity = void 0 !== e ? e : 1);
	}
	function Xc(t, e, n) {
		qc.call(this, t, n),
			(this.type = 'HemisphereLight'),
			this.position.copy(be.DefaultUp),
			this.updateMatrix(),
			(this.groundColor = new Ve(e));
	}
	function Yc(t) {
		(this.camera = t),
			(this.bias = 0),
			(this.normalBias = 0),
			(this.radius = 1),
			(this.mapSize = new pt(512, 512)),
			(this.map = null),
			(this.mapPass = null),
			(this.matrix = new Jt()),
			(this.autoUpdate = !0),
			(this.needsUpdate = !1),
			(this._frustum = new Qn()),
			(this._frameExtents = new pt(1, 1)),
			(this._viewportCount = 1),
			(this._viewports = [new yt(0, 0, 1, 1)]);
	}
	function Zc() {
		Yc.call(this, new Vn(50, 1, 0.5, 500)), (this.focus = 1);
	}
	function Jc(t, e, n, r, i, a) {
		qc.call(this, t, e),
			(this.type = 'SpotLight'),
			this.position.copy(be.DefaultUp),
			this.updateMatrix(),
			(this.target = new be()),
			Object.defineProperty(this, 'power', {
				get: function () {
					return this.intensity * Math.PI;
				},
				set: function (t) {
					this.intensity = t / Math.PI;
				},
			}),
			(this.distance = void 0 !== n ? n : 0),
			(this.angle = void 0 !== r ? r : Math.PI / 3),
			(this.penumbra = void 0 !== i ? i : 0),
			(this.decay = void 0 !== a ? a : 1),
			(this.shadow = new Zc());
	}
	function Qc() {
		Yc.call(this, new Vn(90, 1, 0.5, 500)),
			(this._frameExtents = new pt(4, 2)),
			(this._viewportCount = 6),
			(this._viewports = [
				new yt(2, 1, 1, 1),
				new yt(0, 1, 1, 1),
				new yt(3, 1, 1, 1),
				new yt(1, 1, 1, 1),
				new yt(3, 0, 1, 1),
				new yt(1, 0, 1, 1),
			]),
			(this._cubeDirections = [
				new wt(1, 0, 0),
				new wt(-1, 0, 0),
				new wt(0, 0, 1),
				new wt(0, 0, -1),
				new wt(0, 1, 0),
				new wt(0, -1, 0),
			]),
			(this._cubeUps = [
				new wt(0, 1, 0),
				new wt(0, 1, 0),
				new wt(0, 1, 0),
				new wt(0, 1, 0),
				new wt(0, 0, 1),
				new wt(0, 0, -1),
			]);
	}
	function Kc(t, e, n, r) {
		qc.call(this, t, e),
			(this.type = 'PointLight'),
			Object.defineProperty(this, 'power', {
				get: function () {
					return 4 * this.intensity * Math.PI;
				},
				set: function (t) {
					this.intensity = t / (4 * Math.PI);
				},
			}),
			(this.distance = void 0 !== n ? n : 0),
			(this.decay = void 0 !== r ? r : 1),
			(this.shadow = new Qc());
	}
	function $c(t, e, n, r, i, a) {
		kn.call(this),
			(this.type = 'OrthographicCamera'),
			(this.zoom = 1),
			(this.view = null),
			(this.left = void 0 !== t ? t : -1),
			(this.right = void 0 !== e ? e : 1),
			(this.top = void 0 !== n ? n : 1),
			(this.bottom = void 0 !== r ? r : -1),
			(this.near = void 0 !== i ? i : 0.1),
			(this.far = void 0 !== a ? a : 2e3),
			this.updateProjectionMatrix();
	}
	function tl() {
		Yc.call(this, new $c(-5, 5, 5, -5, 0.5, 500));
	}
	function el(t, e) {
		qc.call(this, t, e),
			(this.type = 'DirectionalLight'),
			this.position.copy(be.DefaultUp),
			this.updateMatrix(),
			(this.target = new be()),
			(this.shadow = new tl());
	}
	function nl(t, e) {
		qc.call(this, t, e), (this.type = 'AmbientLight');
	}
	function rl(t, e, n, r) {
		qc.call(this, t, e),
			(this.type = 'RectAreaLight'),
			(this.width = void 0 !== n ? n : 10),
			(this.height = void 0 !== r ? r : 10);
	}
	(Vc.prototype = Object.assign(Object.create(Mc.prototype), {
		constructor: Vc,
		add: function (t) {
			this.curves.push(t);
		},
		closePath: function () {
			var t = this.curves[0].getPoint(0),
				e = this.curves[this.curves.length - 1].getPoint(1);
			t.equals(e) || this.curves.push(new zc(e, t));
		},
		getPoint: function (t) {
			for (
				var e = t * this.getLength(), n = this.getCurveLengths(), r = 0;
				r < n.length;

			) {
				if (n[r] >= e) {
					var i = n[r] - e,
						a = this.curves[r],
						o = a.getLength(),
						s = 0 === o ? 0 : 1 - i / o;
					return a.getPointAt(s);
				}
				r++;
			}
			return null;
		},
		getLength: function () {
			var t = this.getCurveLengths();
			return t[t.length - 1];
		},
		updateArcLengths: function () {
			(this.needsUpdate = !0),
				(this.cacheLengths = null),
				this.getCurveLengths();
		},
		getCurveLengths: function () {
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
				return this.cacheLengths;
			for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++)
				(e += this.curves[n].getLength()), t.push(e);
			return (this.cacheLengths = t), t;
		},
		getSpacedPoints: function (t) {
			void 0 === t && (t = 40);
			for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
			return this.autoClose && e.push(e[0]), e;
		},
		getPoints: function (t) {
			t = t || 12;
			for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
				for (
					var a = i[r],
						o =
							a && a.isEllipseCurve
								? 2 * t
								: a && (a.isLineCurve || a.isLineCurve3)
								? 1
								: a && a.isSplineCurve
								? t * a.points.length
								: t,
						s = a.getPoints(o),
						c = 0;
					c < s.length;
					c++
				) {
					var l = s[c];
					(e && e.equals(l)) || (n.push(l), (e = l));
				}
			return (
				this.autoClose &&
					n.length > 1 &&
					!n[n.length - 1].equals(n[0]) &&
					n.push(n[0]),
				n
			);
		},
		copy: function (t) {
			Mc.prototype.copy.call(this, t), (this.curves = []);
			for (var e = 0, n = t.curves.length; e < n; e++) {
				var r = t.curves[e];
				this.curves.push(r.clone());
			}
			return (this.autoClose = t.autoClose), this;
		},
		toJSON: function () {
			var t = Mc.prototype.toJSON.call(this);
			(t.autoClose = this.autoClose), (t.curves = []);
			for (var e = 0, n = this.curves.length; e < n; e++) {
				var r = this.curves[e];
				t.curves.push(r.toJSON());
			}
			return t;
		},
		fromJSON: function (t) {
			Mc.prototype.fromJSON.call(this, t),
				(this.autoClose = t.autoClose),
				(this.curves = []);
			for (var e = 0, n = t.curves.length; e < n; e++) {
				var r = t.curves[e];
				this.curves.push(new kc[r.type]().fromJSON(r));
			}
			return this;
		},
	})),
		(Wc.prototype = Object.assign(Object.create(Vc.prototype), {
			constructor: Wc,
			setFromPoints: function (t) {
				this.moveTo(t[0].x, t[0].y);
				for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
				return this;
			},
			moveTo: function (t, e) {
				return this.currentPoint.set(t, e), this;
			},
			lineTo: function (t, e) {
				var n = new zc(this.currentPoint.clone(), new pt(t, e));
				return this.curves.push(n), this.currentPoint.set(t, e), this;
			},
			quadraticCurveTo: function (t, e, n, r) {
				var i = new Fc(this.currentPoint.clone(), new pt(t, e), new pt(n, r));
				return this.curves.push(i), this.currentPoint.set(n, r), this;
			},
			bezierCurveTo: function (t, e, n, r, i, a) {
				var o = new Oc(
					this.currentPoint.clone(),
					new pt(t, e),
					new pt(n, r),
					new pt(i, a)
				);
				return this.curves.push(o), this.currentPoint.set(i, a), this;
			},
			splineThru: function (t) {
				var e = new Hc([this.currentPoint.clone()].concat(t));
				return (
					this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
				);
			},
			arc: function (t, e, n, r, i, a) {
				var o = this.currentPoint.x,
					s = this.currentPoint.y;
				return this.absarc(t + o, e + s, n, r, i, a), this;
			},
			absarc: function (t, e, n, r, i, a) {
				return this.absellipse(t, e, n, n, r, i, a), this;
			},
			ellipse: function (t, e, n, r, i, a, o, s) {
				var c = this.currentPoint.x,
					l = this.currentPoint.y;
				return this.absellipse(t + c, e + l, n, r, i, a, o, s), this;
			},
			absellipse: function (t, e, n, r, i, a, o, s) {
				var c = new Sc(t, e, n, r, i, a, o, s);
				if (this.curves.length > 0) {
					var l = c.getPoint(0);
					l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
				}
				this.curves.push(c);
				var u = c.getPoint(1);
				return this.currentPoint.copy(u), this;
			},
			copy: function (t) {
				return (
					Vc.prototype.copy.call(this, t),
					this.currentPoint.copy(t.currentPoint),
					this
				);
			},
			toJSON: function () {
				var t = Vc.prototype.toJSON.call(this);
				return (t.currentPoint = this.currentPoint.toArray()), t;
			},
			fromJSON: function (t) {
				return (
					Vc.prototype.fromJSON.call(this, t),
					this.currentPoint.fromArray(t.currentPoint),
					this
				);
			},
		})),
		(jc.prototype = Object.assign(Object.create(Wc.prototype), {
			constructor: jc,
			getPointsHoles: function (t) {
				for (var e = [], n = 0, r = this.holes.length; n < r; n++)
					e[n] = this.holes[n].getPoints(t);
				return e;
			},
			extractPoints: function (t) {
				return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
			},
			copy: function (t) {
				Wc.prototype.copy.call(this, t), (this.holes = []);
				for (var e = 0, n = t.holes.length; e < n; e++) {
					var r = t.holes[e];
					this.holes.push(r.clone());
				}
				return this;
			},
			toJSON: function () {
				var t = Wc.prototype.toJSON.call(this);
				(t.uuid = this.uuid), (t.holes = []);
				for (var e = 0, n = this.holes.length; e < n; e++) {
					var r = this.holes[e];
					t.holes.push(r.toJSON());
				}
				return t;
			},
			fromJSON: function (t) {
				Wc.prototype.fromJSON.call(this, t),
					(this.uuid = t.uuid),
					(this.holes = []);
				for (var e = 0, n = t.holes.length; e < n; e++) {
					var r = t.holes[e];
					this.holes.push(new Wc().fromJSON(r));
				}
				return this;
			},
		})),
		(qc.prototype = Object.assign(Object.create(be.prototype), {
			constructor: qc,
			isLight: !0,
			copy: function (t) {
				return (
					be.prototype.copy.call(this, t),
					this.color.copy(t.color),
					(this.intensity = t.intensity),
					this
				);
			},
			toJSON: function (t) {
				var e = be.prototype.toJSON.call(this, t);
				return (
					(e.object.color = this.color.getHex()),
					(e.object.intensity = this.intensity),
					void 0 !== this.groundColor &&
						(e.object.groundColor = this.groundColor.getHex()),
					void 0 !== this.distance && (e.object.distance = this.distance),
					void 0 !== this.angle && (e.object.angle = this.angle),
					void 0 !== this.decay && (e.object.decay = this.decay),
					void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
					void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
					e
				);
			},
		})),
		(Xc.prototype = Object.assign(Object.create(qc.prototype), {
			constructor: Xc,
			isHemisphereLight: !0,
			copy: function (t) {
				return (
					qc.prototype.copy.call(this, t),
					this.groundColor.copy(t.groundColor),
					this
				);
			},
		})),
		Object.assign(Yc.prototype, {
			_projScreenMatrix: new Jt(),
			_lightPositionWorld: new wt(),
			_lookTarget: new wt(),
			getViewportCount: function () {
				return this._viewportCount;
			},
			getFrustum: function () {
				return this._frustum;
			},
			updateMatrices: function (t) {
				var e = this.camera,
					n = this.matrix,
					r = this._projScreenMatrix,
					i = this._lookTarget,
					a = this._lightPositionWorld;
				a.setFromMatrixPosition(t.matrixWorld),
					e.position.copy(a),
					i.setFromMatrixPosition(t.target.matrixWorld),
					e.lookAt(i),
					e.updateMatrixWorld(),
					r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
					this._frustum.setFromProjectionMatrix(r),
					n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
					n.multiply(e.projectionMatrix),
					n.multiply(e.matrixWorldInverse);
			},
			getViewport: function (t) {
				return this._viewports[t];
			},
			getFrameExtents: function () {
				return this._frameExtents;
			},
			copy: function (t) {
				return (
					(this.camera = t.camera.clone()),
					(this.bias = t.bias),
					(this.radius = t.radius),
					this.mapSize.copy(t.mapSize),
					this
				);
			},
			clone: function () {
				return new this.constructor().copy(this);
			},
			toJSON: function () {
				var t = {};
				return (
					0 !== this.bias && (t.bias = this.bias),
					0 !== this.normalBias && (t.normalBias = this.normalBias),
					1 !== this.radius && (t.radius = this.radius),
					(512 === this.mapSize.x && 512 === this.mapSize.y) ||
						(t.mapSize = this.mapSize.toArray()),
					(t.camera = this.camera.toJSON(!1).object),
					delete t.camera.matrix,
					t
				);
			},
		}),
		(Zc.prototype = Object.assign(Object.create(Yc.prototype), {
			constructor: Zc,
			isSpotLightShadow: !0,
			updateMatrices: function (t) {
				var e = this.camera,
					n = 2 * st.RAD2DEG * t.angle * this.focus,
					r = this.mapSize.width / this.mapSize.height,
					i = t.distance || e.far;
				(n === e.fov && r === e.aspect && i === e.far) ||
					((e.fov = n),
					(e.aspect = r),
					(e.far = i),
					e.updateProjectionMatrix()),
					Yc.prototype.updateMatrices.call(this, t);
			},
		})),
		(Jc.prototype = Object.assign(Object.create(qc.prototype), {
			constructor: Jc,
			isSpotLight: !0,
			copy: function (t) {
				return (
					qc.prototype.copy.call(this, t),
					(this.distance = t.distance),
					(this.angle = t.angle),
					(this.penumbra = t.penumbra),
					(this.decay = t.decay),
					(this.target = t.target.clone()),
					(this.shadow = t.shadow.clone()),
					this
				);
			},
		})),
		(Qc.prototype = Object.assign(Object.create(Yc.prototype), {
			constructor: Qc,
			isPointLightShadow: !0,
			updateMatrices: function (t, e) {
				void 0 === e && (e = 0);
				var n = this.camera,
					r = this.matrix,
					i = this._lightPositionWorld,
					a = this._lookTarget,
					o = this._projScreenMatrix;
				i.setFromMatrixPosition(t.matrixWorld),
					n.position.copy(i),
					a.copy(n.position),
					a.add(this._cubeDirections[e]),
					n.up.copy(this._cubeUps[e]),
					n.lookAt(a),
					n.updateMatrixWorld(),
					r.makeTranslation(-i.x, -i.y, -i.z),
					o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
					this._frustum.setFromProjectionMatrix(o);
			},
		})),
		(Kc.prototype = Object.assign(Object.create(qc.prototype), {
			constructor: Kc,
			isPointLight: !0,
			copy: function (t) {
				return (
					qc.prototype.copy.call(this, t),
					(this.distance = t.distance),
					(this.decay = t.decay),
					(this.shadow = t.shadow.clone()),
					this
				);
			},
		})),
		($c.prototype = Object.assign(Object.create(kn.prototype), {
			constructor: $c,
			isOrthographicCamera: !0,
			copy: function (t, e) {
				return (
					kn.prototype.copy.call(this, t, e),
					(this.left = t.left),
					(this.right = t.right),
					(this.top = t.top),
					(this.bottom = t.bottom),
					(this.near = t.near),
					(this.far = t.far),
					(this.zoom = t.zoom),
					(this.view = null === t.view ? null : Object.assign({}, t.view)),
					this
				);
			},
			setViewOffset: function (t, e, n, r, i, a) {
				null === this.view &&
					(this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1,
					}),
					(this.view.enabled = !0),
					(this.view.fullWidth = t),
					(this.view.fullHeight = e),
					(this.view.offsetX = n),
					(this.view.offsetY = r),
					(this.view.width = i),
					(this.view.height = a),
					this.updateProjectionMatrix();
			},
			clearViewOffset: function () {
				null !== this.view && (this.view.enabled = !1),
					this.updateProjectionMatrix();
			},
			updateProjectionMatrix: function () {
				var t = (this.right - this.left) / (2 * this.zoom),
					e = (this.top - this.bottom) / (2 * this.zoom),
					n = (this.right + this.left) / 2,
					r = (this.top + this.bottom) / 2,
					i = n - t,
					a = n + t,
					o = r + e,
					s = r - e;
				if (null !== this.view && this.view.enabled) {
					var c = (this.right - this.left) / this.view.fullWidth / this.zoom,
						l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
					(a = (i += c * this.view.offsetX) + c * this.view.width),
						(s = (o -= l * this.view.offsetY) - l * this.view.height);
				}
				this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far),
					this.projectionMatrixInverse.getInverse(this.projectionMatrix);
			},
			toJSON: function (t) {
				var e = be.prototype.toJSON.call(this, t);
				return (
					(e.object.zoom = this.zoom),
					(e.object.left = this.left),
					(e.object.right = this.right),
					(e.object.top = this.top),
					(e.object.bottom = this.bottom),
					(e.object.near = this.near),
					(e.object.far = this.far),
					null !== this.view && (e.object.view = Object.assign({}, this.view)),
					e
				);
			},
		})),
		(tl.prototype = Object.assign(Object.create(Yc.prototype), {
			constructor: tl,
			isDirectionalLightShadow: !0,
			updateMatrices: function (t) {
				Yc.prototype.updateMatrices.call(this, t);
			},
		})),
		(el.prototype = Object.assign(Object.create(qc.prototype), {
			constructor: el,
			isDirectionalLight: !0,
			copy: function (t) {
				return (
					qc.prototype.copy.call(this, t),
					(this.target = t.target.clone()),
					(this.shadow = t.shadow.clone()),
					this
				);
			},
		})),
		(nl.prototype = Object.assign(Object.create(qc.prototype), {
			constructor: nl,
			isAmbientLight: !0,
		})),
		(rl.prototype = Object.assign(Object.create(qc.prototype), {
			constructor: rl,
			isRectAreaLight: !0,
			copy: function (t) {
				return (
					qc.prototype.copy.call(this, t),
					(this.width = t.width),
					(this.height = t.height),
					this
				);
			},
			toJSON: function (t) {
				var e = qc.prototype.toJSON.call(this, t);
				return (
					(e.object.width = this.width), (e.object.height = this.height), e
				);
			},
		}));
	var il = (function () {
		function t() {
			Object.defineProperty(this, 'isSphericalHarmonics3', { value: !0 }),
				(this.coefficients = []);
			for (var t = 0; t < 9; t++) this.coefficients.push(new wt());
		}
		var e = t.prototype;
		return (
			(e.set = function (t) {
				for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
				return this;
			}),
			(e.zero = function () {
				for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
				return this;
			}),
			(e.getAt = function (t, e) {
				var n = t.x,
					r = t.y,
					i = t.z,
					a = this.coefficients;
				return (
					e.copy(a[0]).multiplyScalar(0.282095),
					e.addScaledVector(a[1], 0.488603 * r),
					e.addScaledVector(a[2], 0.488603 * i),
					e.addScaledVector(a[3], 0.488603 * n),
					e.addScaledVector(a[4], n * r * 1.092548),
					e.addScaledVector(a[5], r * i * 1.092548),
					e.addScaledVector(a[6], 0.315392 * (3 * i * i - 1)),
					e.addScaledVector(a[7], n * i * 1.092548),
					e.addScaledVector(a[8], 0.546274 * (n * n - r * r)),
					e
				);
			}),
			(e.getIrradianceAt = function (t, e) {
				var n = t.x,
					r = t.y,
					i = t.z,
					a = this.coefficients;
				return (
					e.copy(a[0]).multiplyScalar(0.886227),
					e.addScaledVector(a[1], 1.023328 * r),
					e.addScaledVector(a[2], 1.023328 * i),
					e.addScaledVector(a[3], 1.023328 * n),
					e.addScaledVector(a[4], 0.858086 * n * r),
					e.addScaledVector(a[5], 0.858086 * r * i),
					e.addScaledVector(a[6], 0.743125 * i * i - 0.247708),
					e.addScaledVector(a[7], 0.858086 * n * i),
					e.addScaledVector(a[8], 0.429043 * (n * n - r * r)),
					e
				);
			}),
			(e.add = function (t) {
				for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
				return this;
			}),
			(e.addScaledSH = function (t, e) {
				for (var n = 0; n < 9; n++)
					this.coefficients[n].addScaledVector(t.coefficients[n], e);
				return this;
			}),
			(e.scale = function (t) {
				for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
				return this;
			}),
			(e.lerp = function (t, e) {
				for (var n = 0; n < 9; n++)
					this.coefficients[n].lerp(t.coefficients[n], e);
				return this;
			}),
			(e.equals = function (t) {
				for (var e = 0; e < 9; e++)
					if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
				return !0;
			}),
			(e.copy = function (t) {
				return this.set(t.coefficients);
			}),
			(e.clone = function () {
				return new this.constructor().copy(this);
			}),
			(e.fromArray = function (t, e) {
				void 0 === e && (e = 0);
				for (var n = this.coefficients, r = 0; r < 9; r++)
					n[r].fromArray(t, e + 3 * r);
				return this;
			}),
			(e.toArray = function (t, e) {
				void 0 === t && (t = []), void 0 === e && (e = 0);
				for (var n = this.coefficients, r = 0; r < 9; r++)
					n[r].toArray(t, e + 3 * r);
				return t;
			}),
			(t.getBasisAt = function (t, e) {
				var n = t.x,
					r = t.y,
					i = t.z;
				(e[0] = 0.282095),
					(e[1] = 0.488603 * r),
					(e[2] = 0.488603 * i),
					(e[3] = 0.488603 * n),
					(e[4] = 1.092548 * n * r),
					(e[5] = 1.092548 * r * i),
					(e[6] = 0.315392 * (3 * i * i - 1)),
					(e[7] = 1.092548 * n * i),
					(e[8] = 0.546274 * (n * n - r * r));
			}),
			t
		);
	})();
	function al(t, e) {
		qc.call(this, void 0, e),
			(this.type = 'LightProbe'),
			(this.sh = void 0 !== t ? t : new il());
	}
	function ol(t) {
		fc.call(this, t), (this.textures = {});
	}
	(al.prototype = Object.assign(Object.create(qc.prototype), {
		constructor: al,
		isLightProbe: !0,
		copy: function (t) {
			return qc.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
		},
		fromJSON: function (t) {
			return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
		},
		toJSON: function (t) {
			var e = qc.prototype.toJSON.call(this, t);
			return (e.object.sh = this.sh.toArray()), e;
		},
	})),
		(ol.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: ol,
			load: function (t, e, n, r) {
				var i = this,
					a = new vc(i.manager);
				a.setPath(i.path),
					a.setRequestHeader(i.requestHeader),
					a.setWithCredentials(i.withCredentials),
					a.load(
						t,
						function (n) {
							try {
								e(i.parse(JSON.parse(n)));
							} catch (e) {
								r ? r(e) : console.error(e), i.manager.itemError(t);
							}
						},
						n,
						r
					);
			},
			parse: function (t) {
				var e = this.textures;
				function n(t) {
					return (
						void 0 === e[t] &&
							console.warn('THREE.MaterialLoader: Undefined texture', t),
						e[t]
					);
				}
				var r = new Zs[t.type]();
				if (
					(void 0 !== t.uuid && (r.uuid = t.uuid),
					void 0 !== t.name && (r.name = t.name),
					void 0 !== t.color && r.color.setHex(t.color),
					void 0 !== t.roughness && (r.roughness = t.roughness),
					void 0 !== t.metalness && (r.metalness = t.metalness),
					void 0 !== t.sheen && (r.sheen = new Ve().setHex(t.sheen)),
					void 0 !== t.emissive && r.emissive.setHex(t.emissive),
					void 0 !== t.specular && r.specular.setHex(t.specular),
					void 0 !== t.shininess && (r.shininess = t.shininess),
					void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat),
					void 0 !== t.clearcoatRoughness &&
						(r.clearcoatRoughness = t.clearcoatRoughness),
					void 0 !== t.fog && (r.fog = t.fog),
					void 0 !== t.flatShading && (r.flatShading = t.flatShading),
					void 0 !== t.blending && (r.blending = t.blending),
					void 0 !== t.combine && (r.combine = t.combine),
					void 0 !== t.side && (r.side = t.side),
					void 0 !== t.opacity && (r.opacity = t.opacity),
					void 0 !== t.transparent && (r.transparent = t.transparent),
					void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
					void 0 !== t.depthTest && (r.depthTest = t.depthTest),
					void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
					void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
					void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite),
					void 0 !== t.stencilWriteMask &&
						(r.stencilWriteMask = t.stencilWriteMask),
					void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc),
					void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef),
					void 0 !== t.stencilFuncMask &&
						(r.stencilFuncMask = t.stencilFuncMask),
					void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail),
					void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail),
					void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass),
					void 0 !== t.wireframe && (r.wireframe = t.wireframe),
					void 0 !== t.wireframeLinewidth &&
						(r.wireframeLinewidth = t.wireframeLinewidth),
					void 0 !== t.wireframeLinecap &&
						(r.wireframeLinecap = t.wireframeLinecap),
					void 0 !== t.wireframeLinejoin &&
						(r.wireframeLinejoin = t.wireframeLinejoin),
					void 0 !== t.rotation && (r.rotation = t.rotation),
					1 !== t.linewidth && (r.linewidth = t.linewidth),
					void 0 !== t.dashSize && (r.dashSize = t.dashSize),
					void 0 !== t.gapSize && (r.gapSize = t.gapSize),
					void 0 !== t.scale && (r.scale = t.scale),
					void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset),
					void 0 !== t.polygonOffsetFactor &&
						(r.polygonOffsetFactor = t.polygonOffsetFactor),
					void 0 !== t.polygonOffsetUnits &&
						(r.polygonOffsetUnits = t.polygonOffsetUnits),
					void 0 !== t.skinning && (r.skinning = t.skinning),
					void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
					void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals),
					void 0 !== t.dithering && (r.dithering = t.dithering),
					void 0 !== t.vertexTangents && (r.vertexTangents = t.vertexTangents),
					void 0 !== t.visible && (r.visible = t.visible),
					void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped),
					void 0 !== t.userData && (r.userData = t.userData),
					void 0 !== t.vertexColors &&
						('number' == typeof t.vertexColors
							? (r.vertexColors = t.vertexColors > 0)
							: (r.vertexColors = t.vertexColors)),
					void 0 !== t.uniforms)
				)
					for (var i in t.uniforms) {
						var a = t.uniforms[i];
						switch (((r.uniforms[i] = {}), a.type)) {
							case 't':
								r.uniforms[i].value = n(a.value);
								break;
							case 'c':
								r.uniforms[i].value = new Ve().setHex(a.value);
								break;
							case 'v2':
								r.uniforms[i].value = new pt().fromArray(a.value);
								break;
							case 'v3':
								r.uniforms[i].value = new wt().fromArray(a.value);
								break;
							case 'v4':
								r.uniforms[i].value = new yt().fromArray(a.value);
								break;
							case 'm3':
								r.uniforms[i].value = new ft().fromArray(a.value);
								break;
							case 'm4':
								r.uniforms[i].value = new Jt().fromArray(a.value);
								break;
							default:
								r.uniforms[i].value = a.value;
						}
					}
				if (
					(void 0 !== t.defines && (r.defines = t.defines),
					void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
					void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader),
					void 0 !== t.extensions)
				)
					for (var o in t.extensions) r.extensions[o] = t.extensions[o];
				if (
					(void 0 !== t.shading && (r.flatShading = 1 === t.shading),
					void 0 !== t.size && (r.size = t.size),
					void 0 !== t.sizeAttenuation &&
						(r.sizeAttenuation = t.sizeAttenuation),
					void 0 !== t.map && (r.map = n(t.map)),
					void 0 !== t.matcap && (r.matcap = n(t.matcap)),
					void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)),
					void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)),
					void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
					void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)),
					void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType),
					void 0 !== t.normalScale)
				) {
					var s = t.normalScale;
					!1 === Array.isArray(s) && (s = [s, s]),
						(r.normalScale = new pt().fromArray(s));
				}
				return (
					void 0 !== t.displacementMap &&
						(r.displacementMap = n(t.displacementMap)),
					void 0 !== t.displacementScale &&
						(r.displacementScale = t.displacementScale),
					void 0 !== t.displacementBias &&
						(r.displacementBias = t.displacementBias),
					void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)),
					void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)),
					void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)),
					void 0 !== t.emissiveIntensity &&
						(r.emissiveIntensity = t.emissiveIntensity),
					void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)),
					void 0 !== t.envMap && (r.envMap = n(t.envMap)),
					void 0 !== t.envMapIntensity &&
						(r.envMapIntensity = t.envMapIntensity),
					void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
					void 0 !== t.refractionRatio &&
						(r.refractionRatio = t.refractionRatio),
					void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)),
					void 0 !== t.lightMapIntensity &&
						(r.lightMapIntensity = t.lightMapIntensity),
					void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)),
					void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity),
					void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)),
					void 0 !== t.clearcoatMap && (r.clearcoatMap = n(t.clearcoatMap)),
					void 0 !== t.clearcoatRoughnessMap &&
						(r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
					void 0 !== t.clearcoatNormalMap &&
						(r.clearcoatNormalMap = n(t.clearcoatNormalMap)),
					void 0 !== t.clearcoatNormalScale &&
						(r.clearcoatNormalScale = new pt().fromArray(
							t.clearcoatNormalScale
						)),
					void 0 !== t.transmission && (r.transmission = t.transmission),
					void 0 !== t.transmissionMap &&
						(r.transmissionMap = n(t.transmissionMap)),
					r
				);
			},
			setTextures: function (t) {
				return (this.textures = t), this;
			},
		}));
	var sl = {
		decodeText: function (t) {
			if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(t);
			for (var e = '', n = 0, r = t.length; n < r; n++)
				e += String.fromCharCode(t[n]);
			try {
				return decodeURIComponent(escape(e));
			} catch (t) {
				return e;
			}
		},
		extractUrlBase: function (t) {
			var e = t.lastIndexOf('/');
			return -1 === e ? './' : t.substr(0, e + 1);
		},
	};
	function cl() {
		vn.call(this),
			(this.type = 'InstancedBufferGeometry'),
			(this.instanceCount = 1 / 0);
	}
	function ll(t, e, n, r) {
		'number' == typeof n &&
			((r = n),
			(n = !1),
			console.error(
				'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.'
			)),
			Je.call(this, t, e, n),
			(this.meshPerAttribute = r || 1);
	}
	function ul(t) {
		fc.call(this, t);
	}
	(cl.prototype = Object.assign(Object.create(vn.prototype), {
		constructor: cl,
		isInstancedBufferGeometry: !0,
		copy: function (t) {
			return (
				vn.prototype.copy.call(this, t),
				(this.instanceCount = t.instanceCount),
				this
			);
		},
		clone: function () {
			return new this.constructor().copy(this);
		},
		toJSON: function () {
			var t = vn.prototype.toJSON.call(this);
			return (
				(t.instanceCount = this.instanceCount),
				(t.isInstancedBufferGeometry = !0),
				t
			);
		},
	})),
		(ll.prototype = Object.assign(Object.create(Je.prototype), {
			constructor: ll,
			isInstancedBufferAttribute: !0,
			copy: function (t) {
				return (
					Je.prototype.copy.call(this, t),
					(this.meshPerAttribute = t.meshPerAttribute),
					this
				);
			},
			toJSON: function () {
				var t = Je.prototype.toJSON.call(this);
				return (
					(t.meshPerAttribute = this.meshPerAttribute),
					(t.isInstancedBufferAttribute = !0),
					t
				);
			},
		})),
		(ul.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: ul,
			load: function (t, e, n, r) {
				var i = this,
					a = new vc(i.manager);
				a.setPath(i.path),
					a.setRequestHeader(i.requestHeader),
					a.setWithCredentials(i.withCredentials),
					a.load(
						t,
						function (n) {
							try {
								e(i.parse(JSON.parse(n)));
							} catch (e) {
								r ? r(e) : console.error(e), i.manager.itemError(t);
							}
						},
						n,
						r
					);
			},
			parse: function (t) {
				var e = {},
					n = {};
				function r(t, r) {
					if (void 0 !== e[r]) return e[r];
					var i = t.interleavedBuffers[r],
						a = (function (t, e) {
							if (void 0 !== n[e]) return n[e];
							var r = t.arrayBuffers[e],
								i = new Uint32Array(r).buffer;
							return (n[e] = i), i;
						})(t, i.buffer),
						o = new ca(new dl[i.type](a), i.stride);
					return (o.uuid = i.uuid), (e[r] = o), o;
				}
				var i = t.isInstancedBufferGeometry ? new cl() : new vn(),
					a = t.data.index;
				if (void 0 !== a) {
					var o = new dl[a.type](a.array);
					i.setIndex(new Je(o, 1));
				}
				var s = t.data.attributes;
				for (var c in s) {
					var l = s[c],
						u = void 0;
					if (l.isInterleavedBufferAttribute) {
						u = new ha(r(t.data, l.data), l.itemSize, l.offset, l.normalized);
					} else {
						var h = new dl[l.type](l.array);
						u = new (l.isInstancedBufferAttribute ? ll : Je)(
							h,
							l.itemSize,
							l.normalized
						);
					}
					void 0 !== l.name && (u.name = l.name), i.setAttribute(c, u);
				}
				var d = t.data.morphAttributes;
				if (d)
					for (var p in d) {
						for (var f = d[p], m = [], v = 0, g = f.length; v < g; v++) {
							var y = f[v],
								x = void 0;
							if (y.isInterleavedBufferAttribute)
								x = new ha(
									r(t.data, y.data),
									y.itemSize,
									y.offset,
									y.normalized
								);
							else
								x = new Je(new dl[y.type](y.array), y.itemSize, y.normalized);
							void 0 !== y.name && (x.name = y.name), m.push(x);
						}
						i.morphAttributes[p] = m;
					}
				t.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
				var _ = t.data.groups || t.data.drawcalls || t.data.offsets;
				if (void 0 !== _)
					for (var b = 0, w = _.length; b !== w; ++b) {
						var M = _[b];
						i.addGroup(M.start, M.count, M.materialIndex);
					}
				var S = t.data.boundingSphere;
				if (void 0 !== S) {
					var T = new wt();
					void 0 !== S.center && T.fromArray(S.center),
						(i.boundingSphere = new Ht(T, S.radius));
				}
				return (
					t.name && (i.name = t.name),
					t.userData && (i.userData = t.userData),
					i
				);
			},
		}));
	var hl,
		dl = {
			Int8Array: Int8Array,
			Uint8Array: Uint8Array,
			Uint8ClampedArray:
				'undefined' != typeof Uint8ClampedArray
					? Uint8ClampedArray
					: Uint8Array,
			Int16Array: Int16Array,
			Uint16Array: Uint16Array,
			Int32Array: Int32Array,
			Uint32Array: Uint32Array,
			Float32Array: Float32Array,
			Float64Array: Float64Array,
		},
		pl = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.load = function (t, e, n, r) {
					var i = this,
						a = '' === this.path ? sl.extractUrlBase(t) : this.path;
					this.resourcePath = this.resourcePath || a;
					var o = new vc(this.manager);
					o.setPath(this.path),
						o.setRequestHeader(this.requestHeader),
						o.setWithCredentials(this.withCredentials),
						o.load(
							t,
							function (n) {
								var a = null;
								try {
									a = JSON.parse(n);
								} catch (e) {
									return (
										void 0 !== r && r(e),
										void console.error(
											"THREE:ObjectLoader: Can't parse " + t + '.',
											e.message
										)
									);
								}
								var o = a.metadata;
								void 0 !== o &&
								void 0 !== o.type &&
								'geometry' !== o.type.toLowerCase()
									? i.parse(a, e)
									: console.error("THREE.ObjectLoader: Can't load " + t);
							},
							n,
							r
						);
				}),
				(n.parse = function (t, e) {
					var n = this.parseShape(t.shapes),
						r = this.parseGeometries(t.geometries, n),
						i = this.parseImages(t.images, function () {
							void 0 !== e && e(s);
						}),
						a = this.parseTextures(t.textures, i),
						o = this.parseMaterials(t.materials, a),
						s = this.parseObject(t.object, r, o);
					return (
						t.animations && (s.animations = this.parseAnimations(t.animations)),
						(void 0 !== t.images && 0 !== t.images.length) ||
							(void 0 !== e && e(s)),
						s
					);
				}),
				(n.parseShape = function (t) {
					var e = {};
					if (void 0 !== t)
						for (var n = 0, r = t.length; n < r; n++) {
							var i = new jc().fromJSON(t[n]);
							e[i.uuid] = i;
						}
					return e;
				}),
				(n.parseGeometries = function (t, e) {
					var n,
						r = {};
					if (void 0 !== t)
						for (var i = new ul(), a = 0, o = t.length; a < o; a++) {
							var s = void 0,
								c = t[a];
							switch (c.type) {
								case 'PlaneGeometry':
								case 'PlaneBufferGeometry':
									s = new Gs[c.type](
										c.width,
										c.height,
										c.widthSegments,
										c.heightSegments
									);
									break;
								case 'BoxGeometry':
								case 'BoxBufferGeometry':
								case 'CubeGeometry':
									s = new Gs[c.type](
										c.width,
										c.height,
										c.depth,
										c.widthSegments,
										c.heightSegments,
										c.depthSegments
									);
									break;
								case 'CircleGeometry':
								case 'CircleBufferGeometry':
									s = new Gs[c.type](
										c.radius,
										c.segments,
										c.thetaStart,
										c.thetaLength
									);
									break;
								case 'CylinderGeometry':
								case 'CylinderBufferGeometry':
									s = new Gs[c.type](
										c.radiusTop,
										c.radiusBottom,
										c.height,
										c.radialSegments,
										c.heightSegments,
										c.openEnded,
										c.thetaStart,
										c.thetaLength
									);
									break;
								case 'ConeGeometry':
								case 'ConeBufferGeometry':
									s = new Gs[c.type](
										c.radius,
										c.height,
										c.radialSegments,
										c.heightSegments,
										c.openEnded,
										c.thetaStart,
										c.thetaLength
									);
									break;
								case 'SphereGeometry':
								case 'SphereBufferGeometry':
									s = new Gs[c.type](
										c.radius,
										c.widthSegments,
										c.heightSegments,
										c.phiStart,
										c.phiLength,
										c.thetaStart,
										c.thetaLength
									);
									break;
								case 'DodecahedronGeometry':
								case 'DodecahedronBufferGeometry':
								case 'IcosahedronGeometry':
								case 'IcosahedronBufferGeometry':
								case 'OctahedronGeometry':
								case 'OctahedronBufferGeometry':
								case 'TetrahedronGeometry':
								case 'TetrahedronBufferGeometry':
									s = new Gs[c.type](c.radius, c.detail);
									break;
								case 'RingGeometry':
								case 'RingBufferGeometry':
									s = new Gs[c.type](
										c.innerRadius,
										c.outerRadius,
										c.thetaSegments,
										c.phiSegments,
										c.thetaStart,
										c.thetaLength
									);
									break;
								case 'TorusGeometry':
								case 'TorusBufferGeometry':
									s = new Gs[c.type](
										c.radius,
										c.tube,
										c.radialSegments,
										c.tubularSegments,
										c.arc
									);
									break;
								case 'TorusKnotGeometry':
								case 'TorusKnotBufferGeometry':
									s = new Gs[c.type](
										c.radius,
										c.tube,
										c.tubularSegments,
										c.radialSegments,
										c.p,
										c.q
									);
									break;
								case 'TubeGeometry':
								case 'TubeBufferGeometry':
									s = new Gs[c.type](
										new kc[c.path.type]().fromJSON(c.path),
										c.tubularSegments,
										c.radius,
										c.radialSegments,
										c.closed
									);
									break;
								case 'LatheGeometry':
								case 'LatheBufferGeometry':
									s = new Gs[c.type](
										c.points,
										c.segments,
										c.phiStart,
										c.phiLength
									);
									break;
								case 'PolyhedronGeometry':
								case 'PolyhedronBufferGeometry':
									s = new Gs[c.type](
										c.vertices,
										c.indices,
										c.radius,
										c.details
									);
									break;
								case 'ShapeGeometry':
								case 'ShapeBufferGeometry':
									n = [];
									for (var l = 0, u = c.shapes.length; l < u; l++) {
										var h = e[c.shapes[l]];
										n.push(h);
									}
									s = new Gs[c.type](n, c.curveSegments);
									break;
								case 'ExtrudeGeometry':
								case 'ExtrudeBufferGeometry':
									n = [];
									for (var d = 0, p = c.shapes.length; d < p; d++) {
										var f = e[c.shapes[d]];
										n.push(f);
									}
									var m = c.options.extrudePath;
									void 0 !== m &&
										(c.options.extrudePath = new kc[m.type]().fromJSON(m)),
										(s = new Gs[c.type](n, c.options));
									break;
								case 'BufferGeometry':
								case 'InstancedBufferGeometry':
									s = i.parse(c);
									break;
								case 'Geometry':
									console.error(
										'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
									);
									break;
								default:
									console.warn(
										'THREE.ObjectLoader: Unsupported geometry type "' +
											c.type +
											'"'
									);
									continue;
							}
							(s.uuid = c.uuid),
								void 0 !== c.name && (s.name = c.name),
								!0 === s.isBufferGeometry &&
									void 0 !== c.userData &&
									(s.userData = c.userData),
								(r[c.uuid] = s);
						}
					return r;
				}),
				(n.parseMaterials = function (t, e) {
					var n = {},
						r = {};
					if (void 0 !== t) {
						var i = new ol();
						i.setTextures(e);
						for (var a = 0, o = t.length; a < o; a++) {
							var s = t[a];
							if ('MultiMaterial' === s.type) {
								for (var c = [], l = 0; l < s.materials.length; l++) {
									var u = s.materials[l];
									void 0 === n[u.uuid] && (n[u.uuid] = i.parse(u)),
										c.push(n[u.uuid]);
								}
								r[s.uuid] = c;
							} else
								void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)),
									(r[s.uuid] = n[s.uuid]);
						}
					}
					return r;
				}),
				(n.parseAnimations = function (t) {
					for (var e = [], n = 0; n < t.length; n++) {
						var r = t[n],
							i = lc.parse(r);
						void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i);
					}
					return e;
				}),
				(n.parseImages = function (t, e) {
					var n,
						r = this,
						i = {};
					function a(t) {
						return (
							r.manager.itemStart(t),
							n.load(
								t,
								function () {
									r.manager.itemEnd(t);
								},
								void 0,
								function () {
									r.manager.itemError(t), r.manager.itemEnd(t);
								}
							)
						);
					}
					if (void 0 !== t && t.length > 0) {
						var o = new dc(e);
						(n = new xc(o)).setCrossOrigin(this.crossOrigin);
						for (var s = 0, c = t.length; s < c; s++) {
							var l = t[s],
								u = l.url;
							if (Array.isArray(u)) {
								i[l.uuid] = [];
								for (var h = 0, d = u.length; h < d; h++) {
									var p = u[h],
										f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)
											? p
											: r.resourcePath + p;
									i[l.uuid].push(a(f));
								}
							} else {
								var m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url)
									? l.url
									: r.resourcePath + l.url;
								i[l.uuid] = a(m);
							}
						}
					}
					return i;
				}),
				(n.parseTextures = function (t, e) {
					function n(t, e) {
						return 'number' == typeof t
							? t
							: (console.warn(
									'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
									t
							  ),
							  e[t]);
					}
					var r = {};
					if (void 0 !== t)
						for (var i = 0, a = t.length; i < a; i++) {
							var o = t[i];
							void 0 === o.image &&
								console.warn(
									'THREE.ObjectLoader: No "image" specified for',
									o.uuid
								),
								void 0 === e[o.image] &&
									console.warn('THREE.ObjectLoader: Undefined image', o.image);
							var s = void 0;
							((s = Array.isArray(e[o.image])
								? new qn(e[o.image])
								: new gt(e[o.image])).needsUpdate = !0),
								(s.uuid = o.uuid),
								void 0 !== o.name && (s.name = o.name),
								void 0 !== o.mapping && (s.mapping = n(o.mapping, fl)),
								void 0 !== o.offset && s.offset.fromArray(o.offset),
								void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
								void 0 !== o.center && s.center.fromArray(o.center),
								void 0 !== o.rotation && (s.rotation = o.rotation),
								void 0 !== o.wrap &&
									((s.wrapS = n(o.wrap[0], ml)), (s.wrapT = n(o.wrap[1], ml))),
								void 0 !== o.format && (s.format = o.format),
								void 0 !== o.type && (s.type = o.type),
								void 0 !== o.encoding && (s.encoding = o.encoding),
								void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, vl)),
								void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, vl)),
								void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
								void 0 !== o.flipY && (s.flipY = o.flipY),
								void 0 !== o.premultiplyAlpha &&
									(s.premultiplyAlpha = o.premultiplyAlpha),
								void 0 !== o.unpackAlignment &&
									(s.unpackAlignment = o.unpackAlignment),
								(r[o.uuid] = s);
						}
					return r;
				}),
				(n.parseObject = function (t, e, n) {
					var r, i, a;
					function o(t) {
						return (
							void 0 === e[t] &&
								console.warn('THREE.ObjectLoader: Undefined geometry', t),
							e[t]
						);
					}
					function s(t) {
						if (void 0 !== t) {
							if (Array.isArray(t)) {
								for (var e = [], r = 0, i = t.length; r < i; r++) {
									var a = t[r];
									void 0 === n[a] &&
										console.warn('THREE.ObjectLoader: Undefined material', a),
										e.push(n[a]);
								}
								return e;
							}
							return (
								void 0 === n[t] &&
									console.warn('THREE.ObjectLoader: Undefined material', t),
								n[t]
							);
						}
					}
					switch (t.type) {
						case 'Scene':
							(r = new sa()),
								void 0 !== t.background &&
									Number.isInteger(t.background) &&
									(r.background = new Ve(t.background)),
								void 0 !== t.fog &&
									('Fog' === t.fog.type
										? (r.fog = new oa(t.fog.color, t.fog.near, t.fog.far))
										: 'FogExp2' === t.fog.type &&
										  (r.fog = new aa(t.fog.color, t.fog.density)));
							break;
						case 'PerspectiveCamera':
							(r = new Vn(t.fov, t.aspect, t.near, t.far)),
								void 0 !== t.focus && (r.focus = t.focus),
								void 0 !== t.zoom && (r.zoom = t.zoom),
								void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
								void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
								void 0 !== t.view && (r.view = Object.assign({}, t.view));
							break;
						case 'OrthographicCamera':
							(r = new $c(t.left, t.right, t.top, t.bottom, t.near, t.far)),
								void 0 !== t.zoom && (r.zoom = t.zoom),
								void 0 !== t.view && (r.view = Object.assign({}, t.view));
							break;
						case 'AmbientLight':
							r = new nl(t.color, t.intensity);
							break;
						case 'DirectionalLight':
							r = new el(t.color, t.intensity);
							break;
						case 'PointLight':
							r = new Kc(t.color, t.intensity, t.distance, t.decay);
							break;
						case 'RectAreaLight':
							r = new rl(t.color, t.intensity, t.width, t.height);
							break;
						case 'SpotLight':
							r = new Jc(
								t.color,
								t.intensity,
								t.distance,
								t.angle,
								t.penumbra,
								t.decay
							);
							break;
						case 'HemisphereLight':
							r = new Xc(t.color, t.groundColor, t.intensity);
							break;
						case 'LightProbe':
							r = new al().fromJSON(t);
							break;
						case 'SkinnedMesh':
							console.warn(
								'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.'
							);
						case 'Mesh':
							r = new Nn((i = o(t.geometry)), (a = s(t.material)));
							break;
						case 'InstancedMesh':
							(i = o(t.geometry)), (a = s(t.material));
							var c = t.count,
								l = t.instanceMatrix;
							(r = new Wa(i, a, c)).instanceMatrix = new Je(
								new Float32Array(l.array),
								16
							);
							break;
						case 'LOD':
							r = new Na();
							break;
						case 'Line':
							r = new Qa(o(t.geometry), s(t.material), t.mode);
							break;
						case 'LineLoop':
							r = new eo(o(t.geometry), s(t.material));
							break;
						case 'LineSegments':
							r = new to(o(t.geometry), s(t.material));
							break;
						case 'PointCloud':
						case 'Points':
							r = new so(o(t.geometry), s(t.material));
							break;
						case 'Sprite':
							r = new Ta(s(t.material));
							break;
						case 'Group':
							r = new $i();
							break;
						default:
							r = new be();
					}
					if (
						((r.uuid = t.uuid),
						void 0 !== t.name && (r.name = t.name),
						void 0 !== t.matrix
							? (r.matrix.fromArray(t.matrix),
							  void 0 !== t.matrixAutoUpdate &&
									(r.matrixAutoUpdate = t.matrixAutoUpdate),
							  r.matrixAutoUpdate &&
									r.matrix.decompose(r.position, r.quaternion, r.scale))
							: (void 0 !== t.position && r.position.fromArray(t.position),
							  void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
							  void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion),
							  void 0 !== t.scale && r.scale.fromArray(t.scale)),
						void 0 !== t.castShadow && (r.castShadow = t.castShadow),
						void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow),
						t.shadow &&
							(void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
							void 0 !== t.shadow.normalBias &&
								(r.shadow.normalBias = t.shadow.normalBias),
							void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius),
							void 0 !== t.shadow.mapSize &&
								r.shadow.mapSize.fromArray(t.shadow.mapSize),
							void 0 !== t.shadow.camera &&
								(r.shadow.camera = this.parseObject(t.shadow.camera))),
						void 0 !== t.visible && (r.visible = t.visible),
						void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled),
						void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder),
						void 0 !== t.userData && (r.userData = t.userData),
						void 0 !== t.layers && (r.layers.mask = t.layers),
						void 0 !== t.children)
					)
						for (var u = t.children, h = 0; h < u.length; h++)
							r.add(this.parseObject(u[h], e, n));
					if ('LOD' === t.type) {
						void 0 !== t.autoUpdate && (r.autoUpdate = t.autoUpdate);
						for (var d = t.levels, p = 0; p < d.length; p++) {
							var f = d[p],
								m = r.getObjectByProperty('uuid', f.object);
							void 0 !== m && r.addLevel(m, f.distance);
						}
					}
					return r;
				}),
				(n.setTexturePath = function (t) {
					return (
						console.warn(
							'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().'
						),
						this.setResourcePath(t)
					);
				}),
				e
			);
		})(fc),
		fl = {
			UVMapping: n,
			CubeReflectionMapping: r,
			CubeRefractionMapping: i,
			EquirectangularReflectionMapping: a,
			EquirectangularRefractionMapping: o,
			CubeUVReflectionMapping: s,
			CubeUVRefractionMapping: c,
		},
		ml = {
			RepeatWrapping: l,
			ClampToEdgeWrapping: u,
			MirroredRepeatWrapping: h,
		},
		vl = {
			NearestFilter: d,
			NearestMipmapNearestFilter: p,
			NearestMipmapLinearFilter: f,
			LinearFilter: m,
			LinearMipmapNearestFilter: v,
			LinearMipmapLinearFilter: g,
		};
	function gl(t) {
		'undefined' == typeof createImageBitmap &&
			console.warn(
				'THREE.ImageBitmapLoader: createImageBitmap() not supported.'
			),
			'undefined' == typeof fetch &&
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
			fc.call(this, t),
			(this.options = { premultiplyAlpha: 'none' });
	}
	function yl() {
		(this.type = 'ShapePath'),
			(this.color = new Ve()),
			(this.subPaths = []),
			(this.currentPath = null);
	}
	function xl(t) {
		(this.type = 'Font'), (this.data = t);
	}
	function _l(t, e, n, r, i) {
		var a = i.glyphs[t] || i.glyphs['?'];
		if (a) {
			var o,
				s,
				c,
				l,
				u,
				h,
				d,
				p,
				f = new yl();
			if (a.o)
				for (
					var m = a._cachedOutline || (a._cachedOutline = a.o.split(' ')),
						v = 0,
						g = m.length;
					v < g;

				) {
					switch (m[v++]) {
						case 'm':
							(o = m[v++] * e + n), (s = m[v++] * e + r), f.moveTo(o, s);
							break;
						case 'l':
							(o = m[v++] * e + n), (s = m[v++] * e + r), f.lineTo(o, s);
							break;
						case 'q':
							(c = m[v++] * e + n),
								(l = m[v++] * e + r),
								(u = m[v++] * e + n),
								(h = m[v++] * e + r),
								f.quadraticCurveTo(u, h, c, l);
							break;
						case 'b':
							(c = m[v++] * e + n),
								(l = m[v++] * e + r),
								(u = m[v++] * e + n),
								(h = m[v++] * e + r),
								(d = m[v++] * e + n),
								(p = m[v++] * e + r),
								f.bezierCurveTo(u, h, d, p, c, l);
					}
				}
			return { offsetX: a.ha * e, path: f };
		}
		console.error(
			'THREE.Font: character "' +
				t +
				'" does not exists in font family ' +
				i.familyName +
				'.'
		);
	}
	function bl(t) {
		fc.call(this, t);
	}
	(gl.prototype = Object.assign(Object.create(fc.prototype), {
		constructor: gl,
		isImageBitmapLoader: !0,
		setOptions: function (t) {
			return (this.options = t), this;
		},
		load: function (t, e, n, r) {
			void 0 === t && (t = ''),
				void 0 !== this.path && (t = this.path + t),
				(t = this.manager.resolveURL(t));
			var i = this,
				a = hc.get(t);
			if (void 0 !== a)
				return (
					i.manager.itemStart(t),
					setTimeout(function () {
						e && e(a), i.manager.itemEnd(t);
					}, 0),
					a
				);
			var o = {};
			(o.credentials =
				'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
				fetch(t, o)
					.then(function (t) {
						return t.blob();
					})
					.then(function (t) {
						return createImageBitmap(t, i.options);
					})
					.then(function (n) {
						hc.add(t, n), e && e(n), i.manager.itemEnd(t);
					})
					.catch(function (e) {
						r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
					}),
				i.manager.itemStart(t);
		},
	})),
		Object.assign(yl.prototype, {
			moveTo: function (t, e) {
				return (
					(this.currentPath = new Wc()),
					this.subPaths.push(this.currentPath),
					this.currentPath.moveTo(t, e),
					this
				);
			},
			lineTo: function (t, e) {
				return this.currentPath.lineTo(t, e), this;
			},
			quadraticCurveTo: function (t, e, n, r) {
				return this.currentPath.quadraticCurveTo(t, e, n, r), this;
			},
			bezierCurveTo: function (t, e, n, r, i, a) {
				return this.currentPath.bezierCurveTo(t, e, n, r, i, a), this;
			},
			splineThru: function (t) {
				return this.currentPath.splineThru(t), this;
			},
			toShapes: function (t, e) {
				function n(t) {
					for (var e = [], n = 0, r = t.length; n < r; n++) {
						var i = t[n],
							a = new jc();
						(a.curves = i.curves), e.push(a);
					}
					return e;
				}
				function r(t, e) {
					for (var n = e.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
						var o = e[i],
							s = e[a],
							c = s.x - o.x,
							l = s.y - o.y;
						if (Math.abs(l) > Number.EPSILON) {
							if (
								(l < 0 && ((o = e[a]), (c = -c), (s = e[i]), (l = -l)),
								t.y < o.y || t.y > s.y)
							)
								continue;
							if (t.y === o.y) {
								if (t.x === o.x) return !0;
							} else {
								var u = l * (t.x - o.x) - c * (t.y - o.y);
								if (0 === u) return !0;
								if (u < 0) continue;
								r = !r;
							}
						} else {
							if (t.y !== o.y) continue;
							if ((s.x <= t.x && t.x <= o.x) || (o.x <= t.x && t.x <= s.x))
								return !0;
						}
					}
					return r;
				}
				var i,
					a,
					o,
					s = as.isClockWise,
					c = this.subPaths;
				if (0 === c.length) return [];
				if (!0 === e) return n(c);
				var l = [];
				if (1 === c.length)
					return (a = c[0]), ((o = new jc()).curves = a.curves), l.push(o), l;
				var u = !s(c[0].getPoints());
				u = t ? !u : u;
				var h,
					d,
					p = [],
					f = [],
					m = [],
					v = 0;
				(f[v] = void 0), (m[v] = []);
				for (var g = 0, y = c.length; g < y; g++)
					(i = s((h = (a = c[g]).getPoints()))),
						(i = t ? !i : i)
							? (!u && f[v] && v++,
							  (f[v] = { s: new jc(), p: h }),
							  (f[v].s.curves = a.curves),
							  u && v++,
							  (m[v] = []))
							: m[v].push({ h: a, p: h[0] });
				if (!f[0]) return n(c);
				if (f.length > 1) {
					for (var x = !1, _ = [], b = 0, w = f.length; b < w; b++) p[b] = [];
					for (var M = 0, S = f.length; M < S; M++)
						for (var T = m[M], E = 0; E < T.length; E++) {
							for (var A = T[E], L = !0, R = 0; R < f.length; R++)
								r(A.p, f[R].p) &&
									(M !== R && _.push({ froms: M, tos: R, hole: E }),
									L ? ((L = !1), p[R].push(A)) : (x = !0));
							L && p[M].push(A);
						}
					_.length > 0 && (x || (m = p));
				}
				for (var C = 0, P = f.length; C < P; C++) {
					(o = f[C].s), l.push(o);
					for (var I = 0, D = (d = m[C]).length; I < D; I++)
						o.holes.push(d[I].h);
				}
				return l;
			},
		}),
		Object.assign(xl.prototype, {
			isFont: !0,
			generateShapes: function (t, e) {
				void 0 === e && (e = 100);
				for (
					var n = [],
						r = (function (t, e, n) {
							for (
								var r = Array.from ? Array.from(t) : String(t).split(''),
									i = e / n.resolution,
									a =
										(n.boundingBox.yMax -
											n.boundingBox.yMin +
											n.underlineThickness) *
										i,
									o = [],
									s = 0,
									c = 0,
									l = 0;
								l < r.length;
								l++
							) {
								var u = r[l];
								if ('\n' === u) (s = 0), (c -= a);
								else {
									var h = _l(u, i, s, c, n);
									(s += h.offsetX), o.push(h.path);
								}
							}
							return o;
						})(t, e, this.data),
						i = 0,
						a = r.length;
					i < a;
					i++
				)
					Array.prototype.push.apply(n, r[i].toShapes());
				return n;
			},
		}),
		(bl.prototype = Object.assign(Object.create(fc.prototype), {
			constructor: bl,
			load: function (t, e, n, r) {
				var i = this,
					a = new vc(this.manager);
				a.setPath(this.path),
					a.setRequestHeader(this.requestHeader),
					a.setWithCredentials(i.withCredentials),
					a.load(
						t,
						function (t) {
							var n;
							try {
								n = JSON.parse(t);
							} catch (e) {
								console.warn(
									'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.'
								),
									(n = JSON.parse(t.substring(65, t.length - 2)));
							}
							var r = i.parse(n);
							e && e(r);
						},
						n,
						r
					);
			},
			parse: function (t) {
				return new xl(t);
			},
		}));
	var wl = {
		getContext: function () {
			return (
				void 0 === hl &&
					(hl = new (window.AudioContext || window.webkitAudioContext)()),
				hl
			);
		},
		setContext: function (t) {
			hl = t;
		},
	};
	function Ml(t) {
		fc.call(this, t);
	}
	function Sl(t, e, n) {
		al.call(this, void 0, n);
		var r = new Ve().set(t),
			i = new Ve().set(e),
			a = new wt(r.r, r.g, r.b),
			o = new wt(i.r, i.g, i.b),
			s = Math.sqrt(Math.PI),
			c = s * Math.sqrt(0.75);
		this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
			this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
	}
	function Tl(t, e) {
		al.call(this, void 0, e);
		var n = new Ve().set(t);
		this.sh.coefficients[0]
			.set(n.r, n.g, n.b)
			.multiplyScalar(2 * Math.sqrt(Math.PI));
	}
	(Ml.prototype = Object.assign(Object.create(fc.prototype), {
		constructor: Ml,
		load: function (t, e, n, r) {
			var i = this,
				a = new vc(i.manager);
			a.setResponseType('arraybuffer'),
				a.setPath(i.path),
				a.setRequestHeader(i.requestHeader),
				a.setWithCredentials(i.withCredentials),
				a.load(
					t,
					function (n) {
						try {
							var a = n.slice(0);
							wl.getContext().decodeAudioData(a, function (t) {
								e(t);
							});
						} catch (e) {
							r ? r(e) : console.error(e), i.manager.itemError(t);
						}
					},
					n,
					r
				);
		},
	})),
		(Sl.prototype = Object.assign(Object.create(al.prototype), {
			constructor: Sl,
			isHemisphereLightProbe: !0,
			copy: function (t) {
				return al.prototype.copy.call(this, t), this;
			},
			toJSON: function (t) {
				return al.prototype.toJSON.call(this, t);
			},
		})),
		(Tl.prototype = Object.assign(Object.create(al.prototype), {
			constructor: Tl,
			isAmbientLightProbe: !0,
			copy: function (t) {
				return al.prototype.copy.call(this, t), this;
			},
			toJSON: function (t) {
				return al.prototype.toJSON.call(this, t);
			},
		}));
	var El = new Jt(),
		Al = new Jt();
	function Ll() {
		(this.type = 'StereoCamera'),
			(this.aspect = 1),
			(this.eyeSep = 0.064),
			(this.cameraL = new Vn()),
			this.cameraL.layers.enable(1),
			(this.cameraL.matrixAutoUpdate = !1),
			(this.cameraR = new Vn()),
			this.cameraR.layers.enable(2),
			(this.cameraR.matrixAutoUpdate = !1),
			(this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null,
			});
	}
	Object.assign(Ll.prototype, {
		update: function (t) {
			var e = this._cache;
			if (
				e.focus !== t.focus ||
				e.fov !== t.fov ||
				e.aspect !== t.aspect * this.aspect ||
				e.near !== t.near ||
				e.far !== t.far ||
				e.zoom !== t.zoom ||
				e.eyeSep !== this.eyeSep
			) {
				(e.focus = t.focus),
					(e.fov = t.fov),
					(e.aspect = t.aspect * this.aspect),
					(e.near = t.near),
					(e.far = t.far),
					(e.zoom = t.zoom),
					(e.eyeSep = this.eyeSep);
				var n,
					r,
					i = t.projectionMatrix.clone(),
					a = e.eyeSep / 2,
					o = (a * e.near) / e.focus,
					s = (e.near * Math.tan(st.DEG2RAD * e.fov * 0.5)) / e.zoom;
				(Al.elements[12] = -a),
					(El.elements[12] = a),
					(n = -s * e.aspect + o),
					(r = s * e.aspect + o),
					(i.elements[0] = (2 * e.near) / (r - n)),
					(i.elements[8] = (r + n) / (r - n)),
					this.cameraL.projectionMatrix.copy(i),
					(n = -s * e.aspect - o),
					(r = s * e.aspect - o),
					(i.elements[0] = (2 * e.near) / (r - n)),
					(i.elements[8] = (r + n) / (r - n)),
					this.cameraR.projectionMatrix.copy(i);
			}
			this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Al),
				this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(El);
		},
	});
	var Rl = (function () {
			function t(t) {
				(this.autoStart = void 0 === t || t),
					(this.startTime = 0),
					(this.oldTime = 0),
					(this.elapsedTime = 0),
					(this.running = !1);
			}
			var e = t.prototype;
			return (
				(e.start = function () {
					(this.startTime = (
						'undefined' == typeof performance ? Date : performance
					).now()),
						(this.oldTime = this.startTime),
						(this.elapsedTime = 0),
						(this.running = !0);
				}),
				(e.stop = function () {
					this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
				}),
				(e.getElapsedTime = function () {
					return this.getDelta(), this.elapsedTime;
				}),
				(e.getDelta = function () {
					var t = 0;
					if (this.autoStart && !this.running) return this.start(), 0;
					if (this.running) {
						var e = (
							'undefined' == typeof performance ? Date : performance
						).now();
						(t = (e - this.oldTime) / 1e3),
							(this.oldTime = e),
							(this.elapsedTime += t);
					}
					return t;
				}),
				t
			);
		})(),
		Cl = new wt(),
		Pl = new bt(),
		Il = new wt(),
		Dl = new wt(),
		Nl = (function (t) {
			function e() {
				var e;
				return (
					((e = t.call(this) || this).type = 'AudioListener'),
					(e.context = wl.getContext()),
					(e.gain = e.context.createGain()),
					e.gain.connect(e.context.destination),
					(e.filter = null),
					(e.timeDelta = 0),
					(e._clock = new Rl()),
					e
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.getInput = function () {
					return this.gain;
				}),
				(n.removeFilter = function () {
					return (
						null !== this.filter &&
							(this.gain.disconnect(this.filter),
							this.filter.disconnect(this.context.destination),
							this.gain.connect(this.context.destination),
							(this.filter = null)),
						this
					);
				}),
				(n.getFilter = function () {
					return this.filter;
				}),
				(n.setFilter = function (t) {
					return (
						null !== this.filter
							? (this.gain.disconnect(this.filter),
							  this.filter.disconnect(this.context.destination))
							: this.gain.disconnect(this.context.destination),
						(this.filter = t),
						this.gain.connect(this.filter),
						this.filter.connect(this.context.destination),
						this
					);
				}),
				(n.getMasterVolume = function () {
					return this.gain.gain.value;
				}),
				(n.setMasterVolume = function (t) {
					return (
						this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
						this
					);
				}),
				(n.updateMatrixWorld = function (e) {
					t.prototype.updateMatrixWorld.call(this, e);
					var n = this.context.listener,
						r = this.up;
					if (
						((this.timeDelta = this._clock.getDelta()),
						this.matrixWorld.decompose(Cl, Pl, Il),
						Dl.set(0, 0, -1).applyQuaternion(Pl),
						n.positionX)
					) {
						var i = this.context.currentTime + this.timeDelta;
						n.positionX.linearRampToValueAtTime(Cl.x, i),
							n.positionY.linearRampToValueAtTime(Cl.y, i),
							n.positionZ.linearRampToValueAtTime(Cl.z, i),
							n.forwardX.linearRampToValueAtTime(Dl.x, i),
							n.forwardY.linearRampToValueAtTime(Dl.y, i),
							n.forwardZ.linearRampToValueAtTime(Dl.z, i),
							n.upX.linearRampToValueAtTime(r.x, i),
							n.upY.linearRampToValueAtTime(r.y, i),
							n.upZ.linearRampToValueAtTime(r.z, i);
					} else
						n.setPosition(Cl.x, Cl.y, Cl.z),
							n.setOrientation(Dl.x, Dl.y, Dl.z, r.x, r.y, r.z);
				}),
				e
			);
		})(be),
		Ol = (function (t) {
			function e(e) {
				var n;
				return (
					((n = t.call(this) || this).type = 'Audio'),
					(n.listener = e),
					(n.context = e.context),
					(n.gain = n.context.createGain()),
					n.gain.connect(e.getInput()),
					(n.autoplay = !1),
					(n.buffer = null),
					(n.detune = 0),
					(n.loop = !1),
					(n.loopStart = 0),
					(n.loopEnd = 0),
					(n.offset = 0),
					(n.duration = void 0),
					(n.playbackRate = 1),
					(n.isPlaying = !1),
					(n.hasPlaybackControl = !0),
					(n.source = null),
					(n.sourceType = 'empty'),
					(n._startedAt = 0),
					(n._progress = 0),
					(n._connected = !1),
					(n.filters = []),
					n
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.getOutput = function () {
					return this.gain;
				}),
				(n.setNodeSource = function (t) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = 'audioNode'),
						(this.source = t),
						this.connect(),
						this
					);
				}),
				(n.setMediaElementSource = function (t) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = 'mediaNode'),
						(this.source = this.context.createMediaElementSource(t)),
						this.connect(),
						this
					);
				}),
				(n.setMediaStreamSource = function (t) {
					return (
						(this.hasPlaybackControl = !1),
						(this.sourceType = 'mediaStreamNode'),
						(this.source = this.context.createMediaStreamSource(t)),
						this.connect(),
						this
					);
				}),
				(n.setBuffer = function (t) {
					return (
						(this.buffer = t),
						(this.sourceType = 'buffer'),
						this.autoplay && this.play(),
						this
					);
				}),
				(n.play = function (t) {
					if ((void 0 === t && (t = 0), !0 !== this.isPlaying)) {
						if (!1 !== this.hasPlaybackControl) {
							this._startedAt = this.context.currentTime + t;
							var e = this.context.createBufferSource();
							return (
								(e.buffer = this.buffer),
								(e.loop = this.loop),
								(e.loopStart = this.loopStart),
								(e.loopEnd = this.loopEnd),
								(e.onended = this.onEnded.bind(this)),
								e.start(
									this._startedAt,
									this._progress + this.offset,
									this.duration
								),
								(this.isPlaying = !0),
								(this.source = e),
								this.setDetune(this.detune),
								this.setPlaybackRate(this.playbackRate),
								this.connect()
							);
						}
						console.warn('THREE.Audio: this Audio has no playback control.');
					} else console.warn('THREE.Audio: Audio is already playing.');
				}),
				(n.pause = function () {
					if (!1 !== this.hasPlaybackControl)
						return (
							!0 === this.isPlaying &&
								((this._progress +=
									Math.max(this.context.currentTime - this._startedAt, 0) *
									this.playbackRate),
								!0 === this.loop &&
									(this._progress =
										this._progress % (this.duration || this.buffer.duration)),
								this.source.stop(),
								(this.source.onended = null),
								(this.isPlaying = !1)),
							this
						);
					console.warn('THREE.Audio: this Audio has no playback control.');
				}),
				(n.stop = function () {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this._progress = 0),
							this.source.stop(),
							(this.source.onended = null),
							(this.isPlaying = !1),
							this
						);
					console.warn('THREE.Audio: this Audio has no playback control.');
				}),
				(n.connect = function () {
					if (this.filters.length > 0) {
						this.source.connect(this.filters[0]);
						for (var t = 1, e = this.filters.length; t < e; t++)
							this.filters[t - 1].connect(this.filters[t]);
						this.filters[this.filters.length - 1].connect(this.getOutput());
					} else this.source.connect(this.getOutput());
					return (this._connected = !0), this;
				}),
				(n.disconnect = function () {
					if (this.filters.length > 0) {
						this.source.disconnect(this.filters[0]);
						for (var t = 1, e = this.filters.length; t < e; t++)
							this.filters[t - 1].disconnect(this.filters[t]);
						this.filters[this.filters.length - 1].disconnect(this.getOutput());
					} else this.source.disconnect(this.getOutput());
					return (this._connected = !1), this;
				}),
				(n.getFilters = function () {
					return this.filters;
				}),
				(n.setFilters = function (t) {
					return (
						t || (t = []),
						!0 === this._connected
							? (this.disconnect(), (this.filters = t), this.connect())
							: (this.filters = t),
						this
					);
				}),
				(n.setDetune = function (t) {
					if (((this.detune = t), void 0 !== this.source.detune))
						return (
							!0 === this.isPlaying &&
								this.source.detune.setTargetAtTime(
									this.detune,
									this.context.currentTime,
									0.01
								),
							this
						);
				}),
				(n.getDetune = function () {
					return this.detune;
				}),
				(n.getFilter = function () {
					return this.getFilters()[0];
				}),
				(n.setFilter = function (t) {
					return this.setFilters(t ? [t] : []);
				}),
				(n.setPlaybackRate = function (t) {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this.playbackRate = t),
							!0 === this.isPlaying &&
								this.source.playbackRate.setTargetAtTime(
									this.playbackRate,
									this.context.currentTime,
									0.01
								),
							this
						);
					console.warn('THREE.Audio: this Audio has no playback control.');
				}),
				(n.getPlaybackRate = function () {
					return this.playbackRate;
				}),
				(n.onEnded = function () {
					this.isPlaying = !1;
				}),
				(n.getLoop = function () {
					return !1 === this.hasPlaybackControl
						? (console.warn('THREE.Audio: this Audio has no playback control.'),
						  !1)
						: this.loop;
				}),
				(n.setLoop = function (t) {
					if (!1 !== this.hasPlaybackControl)
						return (
							(this.loop = t),
							!0 === this.isPlaying && (this.source.loop = this.loop),
							this
						);
					console.warn('THREE.Audio: this Audio has no playback control.');
				}),
				(n.setLoopStart = function (t) {
					return (this.loopStart = t), this;
				}),
				(n.setLoopEnd = function (t) {
					return (this.loopEnd = t), this;
				}),
				(n.getVolume = function () {
					return this.gain.gain.value;
				}),
				(n.setVolume = function (t) {
					return (
						this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
						this
					);
				}),
				e
			);
		})(be),
		Bl = new wt(),
		zl = new bt(),
		Gl = new wt(),
		Fl = new wt(),
		Ul = (function (t) {
			function e(e) {
				var n;
				return (
					((n = t.call(this, e) || this).panner = n.context.createPanner()),
					(n.panner.panningModel = 'HRTF'),
					n.panner.connect(n.gain),
					n
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.getOutput = function () {
					return this.panner;
				}),
				(n.getRefDistance = function () {
					return this.panner.refDistance;
				}),
				(n.setRefDistance = function (t) {
					return (this.panner.refDistance = t), this;
				}),
				(n.getRolloffFactor = function () {
					return this.panner.rolloffFactor;
				}),
				(n.setRolloffFactor = function (t) {
					return (this.panner.rolloffFactor = t), this;
				}),
				(n.getDistanceModel = function () {
					return this.panner.distanceModel;
				}),
				(n.setDistanceModel = function (t) {
					return (this.panner.distanceModel = t), this;
				}),
				(n.getMaxDistance = function () {
					return this.panner.maxDistance;
				}),
				(n.setMaxDistance = function (t) {
					return (this.panner.maxDistance = t), this;
				}),
				(n.setDirectionalCone = function (t, e, n) {
					return (
						(this.panner.coneInnerAngle = t),
						(this.panner.coneOuterAngle = e),
						(this.panner.coneOuterGain = n),
						this
					);
				}),
				(n.updateMatrixWorld = function (e) {
					if (
						(t.prototype.updateMatrixWorld.call(this, e),
						!0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
					) {
						this.matrixWorld.decompose(Bl, zl, Gl),
							Fl.set(0, 0, 1).applyQuaternion(zl);
						var n = this.panner;
						if (n.positionX) {
							var r = this.context.currentTime + this.listener.timeDelta;
							n.positionX.linearRampToValueAtTime(Bl.x, r),
								n.positionY.linearRampToValueAtTime(Bl.y, r),
								n.positionZ.linearRampToValueAtTime(Bl.z, r),
								n.orientationX.linearRampToValueAtTime(Fl.x, r),
								n.orientationY.linearRampToValueAtTime(Fl.y, r),
								n.orientationZ.linearRampToValueAtTime(Fl.z, r);
						} else
							n.setPosition(Bl.x, Bl.y, Bl.z),
								n.setOrientation(Fl.x, Fl.y, Fl.z);
					}
				}),
				e
			);
		})(Ol),
		Hl = (function () {
			function t(t, e) {
				(this.analyser = t.context.createAnalyser()),
					(this.analyser.fftSize = void 0 !== e ? e : 2048),
					(this.data = new Uint8Array(this.analyser.frequencyBinCount)),
					t.getOutput().connect(this.analyser);
			}
			var e = t.prototype;
			return (
				(e.getFrequencyData = function () {
					return this.analyser.getByteFrequencyData(this.data), this.data;
				}),
				(e.getAverageFrequency = function () {
					for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
						t += e[n];
					return t / e.length;
				}),
				t
			);
		})();
	function kl(t, e, n) {
		var r, i, a;
		switch (((this.binding = t), (this.valueSize = n), e)) {
			case 'quaternion':
				(r = this._slerp),
					(i = this._slerpAdditive),
					(a = this._setAdditiveIdentityQuaternion),
					(this.buffer = new Float64Array(6 * n)),
					(this._workIndex = 5);
				break;
			case 'string':
			case 'bool':
				(r = this._select),
					(i = this._select),
					(a = this._setAdditiveIdentityOther),
					(this.buffer = new Array(5 * n));
				break;
			default:
				(r = this._lerp),
					(i = this._lerpAdditive),
					(a = this._setAdditiveIdentityNumeric),
					(this.buffer = new Float64Array(5 * n));
		}
		(this._mixBufferRegion = r),
			(this._mixBufferRegionAdditive = i),
			(this._setIdentity = a),
			(this._origIndex = 3),
			(this._addIndex = 4),
			(this.cumulativeWeight = 0),
			(this.cumulativeWeightAdditive = 0),
			(this.useCount = 0),
			(this.referenceCount = 0);
	}
	Object.assign(kl.prototype, {
		accumulate: function (t, e) {
			var n = this.buffer,
				r = this.valueSize,
				i = t * r + r,
				a = this.cumulativeWeight;
			if (0 === a) {
				for (var o = 0; o !== r; ++o) n[i + o] = n[o];
				a = e;
			} else {
				var s = e / (a += e);
				this._mixBufferRegion(n, i, 0, s, r);
			}
			this.cumulativeWeight = a;
		},
		accumulateAdditive: function (t) {
			var e = this.buffer,
				n = this.valueSize,
				r = n * this._addIndex;
			0 === this.cumulativeWeightAdditive && this._setIdentity(),
				this._mixBufferRegionAdditive(e, r, 0, t, n),
				(this.cumulativeWeightAdditive += t);
		},
		apply: function (t) {
			var e = this.valueSize,
				n = this.buffer,
				r = t * e + e,
				i = this.cumulativeWeight,
				a = this.cumulativeWeightAdditive,
				o = this.binding;
			if (
				((this.cumulativeWeight = 0),
				(this.cumulativeWeightAdditive = 0),
				i < 1)
			) {
				var s = e * this._origIndex;
				this._mixBufferRegion(n, r, s, 1 - i, e);
			}
			a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
			for (var c = e, l = e + e; c !== l; ++c)
				if (n[c] !== n[c + e]) {
					o.setValue(n, r);
					break;
				}
		},
		saveOriginalState: function () {
			var t = this.binding,
				e = this.buffer,
				n = this.valueSize,
				r = n * this._origIndex;
			t.getValue(e, r);
			for (var i = n, a = r; i !== a; ++i) e[i] = e[r + (i % n)];
			this._setIdentity(),
				(this.cumulativeWeight = 0),
				(this.cumulativeWeightAdditive = 0);
		},
		restoreOriginalState: function () {
			var t = 3 * this.valueSize;
			this.binding.setValue(this.buffer, t);
		},
		_setAdditiveIdentityNumeric: function () {
			for (
				var t = this._addIndex * this.valueSize, e = t + this.valueSize, n = t;
				n < e;
				n++
			)
				this.buffer[n] = 0;
		},
		_setAdditiveIdentityQuaternion: function () {
			this._setAdditiveIdentityNumeric(),
				(this.buffer[this._addIndex * this.valueSize + 3] = 1);
		},
		_setAdditiveIdentityOther: function () {
			for (
				var t = this._origIndex * this.valueSize,
					e = this._addIndex * this.valueSize,
					n = 0;
				n < this.valueSize;
				n++
			)
				this.buffer[e + n] = this.buffer[t + n];
		},
		_select: function (t, e, n, r, i) {
			if (r >= 0.5) for (var a = 0; a !== i; ++a) t[e + a] = t[n + a];
		},
		_slerp: function (t, e, n, r) {
			bt.slerpFlat(t, e, t, e, t, n, r);
		},
		_slerpAdditive: function (t, e, n, r, i) {
			var a = this._workIndex * i;
			bt.multiplyQuaternionsFlat(t, a, t, e, t, n),
				bt.slerpFlat(t, e, t, e, t, a, r);
		},
		_lerp: function (t, e, n, r, i) {
			for (var a = 1 - r, o = 0; o !== i; ++o) {
				var s = e + o;
				t[s] = t[s] * a + t[n + o] * r;
			}
		},
		_lerpAdditive: function (t, e, n, r, i) {
			for (var a = 0; a !== i; ++a) {
				var o = e + a;
				t[o] = t[o] + t[n + a] * r;
			}
		},
	});
	var Vl = '\\[\\]\\.:\\/',
		Wl = new RegExp('[\\[\\]\\.:\\/]', 'g'),
		jl = '[^\\[\\]\\.:\\/]',
		ql = '[^' + Vl.replace('\\.', '') + ']',
		Xl = /((?:WC+[\/:])*)/.source.replace('WC', jl),
		Yl = /(WCOD+)?/.source.replace('WCOD', ql),
		Zl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', jl),
		Jl = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', jl),
		Ql = new RegExp('^' + Xl + Yl + Zl + Jl + '$'),
		Kl = ['material', 'materials', 'bones'];
	function $l(t, e, n) {
		var r = n || tu.parseTrackName(e);
		(this._targetGroup = t), (this._bindings = t.subscribe_(e, r));
	}
	function tu(t, e, n) {
		(this.path = e),
			(this.parsedPath = n || tu.parseTrackName(e)),
			(this.node = tu.findNode(t, this.parsedPath.nodeName) || t),
			(this.rootNode = t);
	}
	function eu() {
		(this.uuid = st.generateUUID()),
			(this._objects = Array.prototype.slice.call(arguments)),
			(this.nCachedObjects_ = 0);
		var t = {};
		this._indicesByUUID = t;
		for (var e = 0, n = arguments.length; e !== n; ++e)
			t[arguments[e].uuid] = e;
		(this._paths = []),
			(this._parsedPaths = []),
			(this._bindings = []),
			(this._bindingsIndicesByPath = {});
		var r = this;
		this.stats = {
			objects: {
				get total() {
					return r._objects.length;
				},
				get inUse() {
					return this.total - r.nCachedObjects_;
				},
			},
			get bindingsPerObject() {
				return r._bindings.length;
			},
		};
	}
	Object.assign($l.prototype, {
		getValue: function (t, e) {
			this.bind();
			var n = this._targetGroup.nCachedObjects_,
				r = this._bindings[n];
			void 0 !== r && r.getValue(t, e);
		},
		setValue: function (t, e) {
			for (
				var n = this._bindings,
					r = this._targetGroup.nCachedObjects_,
					i = n.length;
				r !== i;
				++r
			)
				n[r].setValue(t, e);
		},
		bind: function () {
			for (
				var t = this._bindings,
					e = this._targetGroup.nCachedObjects_,
					n = t.length;
				e !== n;
				++e
			)
				t[e].bind();
		},
		unbind: function () {
			for (
				var t = this._bindings,
					e = this._targetGroup.nCachedObjects_,
					n = t.length;
				e !== n;
				++e
			)
				t[e].unbind();
		},
	}),
		Object.assign(tu, {
			Composite: $l,
			create: function (t, e, n) {
				return t && t.isAnimationObjectGroup
					? new tu.Composite(t, e, n)
					: new tu(t, e, n);
			},
			sanitizeNodeName: function (t) {
				return t.replace(/\s/g, '_').replace(Wl, '');
			},
			parseTrackName: function (t) {
				var e = Ql.exec(t);
				if (!e)
					throw new Error('PropertyBinding: Cannot parse trackName: ' + t);
				var n = {
						nodeName: e[2],
						objectName: e[3],
						objectIndex: e[4],
						propertyName: e[5],
						propertyIndex: e[6],
					},
					r = n.nodeName && n.nodeName.lastIndexOf('.');
				if (void 0 !== r && -1 !== r) {
					var i = n.nodeName.substring(r + 1);
					-1 !== Kl.indexOf(i) &&
						((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = i));
				}
				if (null === n.propertyName || 0 === n.propertyName.length)
					throw new Error(
						'PropertyBinding: can not parse propertyName from trackName: ' + t
					);
				return n;
			},
			findNode: function (t, e) {
				if (
					!e ||
					'' === e ||
					'.' === e ||
					-1 === e ||
					e === t.name ||
					e === t.uuid
				)
					return t;
				if (t.skeleton) {
					var n = t.skeleton.getBoneByName(e);
					if (void 0 !== n) return n;
				}
				if (t.children) {
					var r = (function t(n) {
						for (var r = 0; r < n.length; r++) {
							var i = n[r];
							if (i.name === e || i.uuid === e) return i;
							var a = t(i.children);
							if (a) return a;
						}
						return null;
					})(t.children);
					if (r) return r;
				}
				return null;
			},
		}),
		Object.assign(tu.prototype, {
			_getValue_unavailable: function () {},
			_setValue_unavailable: function () {},
			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3,
			},
			Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
			GetterByBindingType: [
				function (t, e) {
					t[e] = this.node[this.propertyName];
				},
				function (t, e) {
					for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)
						t[e++] = n[r];
				},
				function (t, e) {
					t[e] = this.resolvedProperty[this.propertyIndex];
				},
				function (t, e) {
					this.resolvedProperty.toArray(t, e);
				},
			],
			SetterByBindingTypeAndVersioning: [
				[
					function (t, e) {
						this.targetObject[this.propertyName] = t[e];
					},
					function (t, e) {
						(this.targetObject[this.propertyName] = t[e]),
							(this.targetObject.needsUpdate = !0);
					},
					function (t, e) {
						(this.targetObject[this.propertyName] = t[e]),
							(this.targetObject.matrixWorldNeedsUpdate = !0);
					},
				],
				[
					function (t, e) {
						for (
							var n = this.resolvedProperty, r = 0, i = n.length;
							r !== i;
							++r
						)
							n[r] = t[e++];
					},
					function (t, e) {
						for (
							var n = this.resolvedProperty, r = 0, i = n.length;
							r !== i;
							++r
						)
							n[r] = t[e++];
						this.targetObject.needsUpdate = !0;
					},
					function (t, e) {
						for (
							var n = this.resolvedProperty, r = 0, i = n.length;
							r !== i;
							++r
						)
							n[r] = t[e++];
						this.targetObject.matrixWorldNeedsUpdate = !0;
					},
				],
				[
					function (t, e) {
						this.resolvedProperty[this.propertyIndex] = t[e];
					},
					function (t, e) {
						(this.resolvedProperty[this.propertyIndex] = t[e]),
							(this.targetObject.needsUpdate = !0);
					},
					function (t, e) {
						(this.resolvedProperty[this.propertyIndex] = t[e]),
							(this.targetObject.matrixWorldNeedsUpdate = !0);
					},
				],
				[
					function (t, e) {
						this.resolvedProperty.fromArray(t, e);
					},
					function (t, e) {
						this.resolvedProperty.fromArray(t, e),
							(this.targetObject.needsUpdate = !0);
					},
					function (t, e) {
						this.resolvedProperty.fromArray(t, e),
							(this.targetObject.matrixWorldNeedsUpdate = !0);
					},
				],
			],
			getValue: function (t, e) {
				this.bind(), this.getValue(t, e);
			},
			setValue: function (t, e) {
				this.bind(), this.setValue(t, e);
			},
			bind: function () {
				var t = this.node,
					e = this.parsedPath,
					n = e.objectName,
					r = e.propertyName,
					i = e.propertyIndex;
				if (
					(t ||
						((t = tu.findNode(this.rootNode, e.nodeName) || this.rootNode),
						(this.node = t)),
					(this.getValue = this._getValue_unavailable),
					(this.setValue = this._setValue_unavailable),
					t)
				) {
					if (n) {
						var a = e.objectIndex;
						switch (n) {
							case 'materials':
								if (!t.material)
									return void console.error(
										'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
										this
									);
								if (!t.material.materials)
									return void console.error(
										'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
										this
									);
								t = t.material.materials;
								break;
							case 'bones':
								if (!t.skeleton)
									return void console.error(
										'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
										this
									);
								t = t.skeleton.bones;
								for (var o = 0; o < t.length; o++)
									if (t[o].name === a) {
										a = o;
										break;
									}
								break;
							default:
								if (void 0 === t[n])
									return void console.error(
										'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
										this
									);
								t = t[n];
						}
						if (void 0 !== a) {
							if (void 0 === t[a])
								return void console.error(
									'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
									this,
									t
								);
							t = t[a];
						}
					}
					var s = t[r];
					if (void 0 !== s) {
						var c = this.Versioning.None;
						(this.targetObject = t),
							void 0 !== t.needsUpdate
								? (c = this.Versioning.NeedsUpdate)
								: void 0 !== t.matrixWorldNeedsUpdate &&
								  (c = this.Versioning.MatrixWorldNeedsUpdate);
						var l = this.BindingType.Direct;
						if (void 0 !== i) {
							if ('morphTargetInfluences' === r) {
								if (!t.geometry)
									return void console.error(
										'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
										this
									);
								if (!t.geometry.isBufferGeometry)
									return void console.error(
										'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
										this
									);
								if (!t.geometry.morphAttributes)
									return void console.error(
										'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
										this
									);
								void 0 !== t.morphTargetDictionary[i] &&
									(i = t.morphTargetDictionary[i]);
							}
							(l = this.BindingType.ArrayElement),
								(this.resolvedProperty = s),
								(this.propertyIndex = i);
						} else
							void 0 !== s.fromArray && void 0 !== s.toArray
								? ((l = this.BindingType.HasFromToArray),
								  (this.resolvedProperty = s))
								: Array.isArray(s)
								? ((l = this.BindingType.EntireArray),
								  (this.resolvedProperty = s))
								: (this.propertyName = r);
						(this.getValue = this.GetterByBindingType[l]),
							(this.setValue = this.SetterByBindingTypeAndVersioning[l][c]);
					} else {
						var u = e.nodeName;
						console.error(
							'THREE.PropertyBinding: Trying to update property for track: ' +
								u +
								'.' +
								r +
								" but it wasn't found.",
							t
						);
					}
				} else
					console.error(
						'THREE.PropertyBinding: Trying to update node for track: ' +
							this.path +
							" but it wasn't found."
					);
			},
			unbind: function () {
				(this.node = null),
					(this.getValue = this._getValue_unbound),
					(this.setValue = this._setValue_unbound);
			},
		}),
		Object.assign(tu.prototype, {
			_getValue_unbound: tu.prototype.getValue,
			_setValue_unbound: tu.prototype.setValue,
		}),
		Object.assign(eu.prototype, {
			isAnimationObjectGroup: !0,
			add: function () {
				for (
					var t = this._objects,
						e = this._indicesByUUID,
						n = this._paths,
						r = this._parsedPaths,
						i = this._bindings,
						a = i.length,
						o = void 0,
						s = t.length,
						c = this.nCachedObjects_,
						l = 0,
						u = arguments.length;
					l !== u;
					++l
				) {
					var h = arguments[l],
						d = h.uuid,
						p = e[d];
					if (void 0 === p) {
						(p = s++), (e[d] = p), t.push(h);
						for (var f = 0, m = a; f !== m; ++f)
							i[f].push(new tu(h, n[f], r[f]));
					} else if (p < c) {
						o = t[p];
						var v = --c,
							g = t[v];
						(e[g.uuid] = p), (t[p] = g), (e[d] = v), (t[v] = h);
						for (var y = 0, x = a; y !== x; ++y) {
							var _ = i[y],
								b = _[v],
								w = _[p];
							(_[p] = b),
								void 0 === w && (w = new tu(h, n[y], r[y])),
								(_[v] = w);
						}
					} else
						t[p] !== o &&
							console.error(
								'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
							);
				}
				this.nCachedObjects_ = c;
			},
			remove: function () {
				for (
					var t = this._objects,
						e = this._indicesByUUID,
						n = this._bindings,
						r = n.length,
						i = this.nCachedObjects_,
						a = 0,
						o = arguments.length;
					a !== o;
					++a
				) {
					var s = arguments[a],
						c = s.uuid,
						l = e[c];
					if (void 0 !== l && l >= i) {
						var u = i++,
							h = t[u];
						(e[h.uuid] = l), (t[l] = h), (e[c] = u), (t[u] = s);
						for (var d = 0, p = r; d !== p; ++d) {
							var f = n[d],
								m = f[u],
								v = f[l];
							(f[l] = m), (f[u] = v);
						}
					}
				}
				this.nCachedObjects_ = i;
			},
			uncache: function () {
				for (
					var t = this._objects,
						e = this._indicesByUUID,
						n = this._bindings,
						r = n.length,
						i = this.nCachedObjects_,
						a = t.length,
						o = 0,
						s = arguments.length;
					o !== s;
					++o
				) {
					var c = arguments[o],
						l = c.uuid,
						u = e[l];
					if (void 0 !== u)
						if ((delete e[l], u < i)) {
							var h = --i,
								d = t[h],
								p = --a,
								f = t[p];
							(e[d.uuid] = u), (t[u] = d), (e[f.uuid] = h), (t[h] = f), t.pop();
							for (var m = 0, v = r; m !== v; ++m) {
								var g = n[m],
									y = g[h],
									x = g[p];
								(g[u] = y), (g[h] = x), g.pop();
							}
						} else {
							var _ = --a,
								b = t[_];
							(e[b.uuid] = u), (t[u] = b), t.pop();
							for (var w = 0, M = r; w !== M; ++w) {
								var S = n[w];
								(S[u] = S[_]), S.pop();
							}
						}
				}
				this.nCachedObjects_ = i;
			},
			subscribe_: function (t, e) {
				var n = this._bindingsIndicesByPath,
					r = n[t],
					i = this._bindings;
				if (void 0 !== r) return i[r];
				var a = this._paths,
					o = this._parsedPaths,
					s = this._objects,
					c = s.length,
					l = this.nCachedObjects_,
					u = new Array(c);
				(r = i.length), (n[t] = r), a.push(t), o.push(e), i.push(u);
				for (var h = l, d = s.length; h !== d; ++h) {
					var p = s[h];
					u[h] = new tu(p, t, e);
				}
				return u;
			},
			unsubscribe_: function (t) {
				var e = this._bindingsIndicesByPath,
					n = e[t];
				if (void 0 !== n) {
					var r = this._paths,
						i = this._parsedPaths,
						a = this._bindings,
						o = a.length - 1,
						s = a[o];
					(e[t[o]] = n),
						(a[n] = s),
						a.pop(),
						(i[n] = i[o]),
						i.pop(),
						(r[n] = r[o]),
						r.pop();
				}
			},
		});
	var nu = (function () {
		function t(t, e, n, r) {
			(this._mixer = t),
				(this._clip = e),
				(this._localRoot = n || null),
				(this.blendMode = r || e.blendMode);
			for (
				var i = e.tracks,
					a = i.length,
					o = new Array(a),
					s = { endingStart: H, endingEnd: H },
					c = 0;
				c !== a;
				++c
			) {
				var l = i[c].createInterpolant(null);
				(o[c] = l), (l.settings = s);
			}
			(this._interpolantSettings = s),
				(this._interpolants = o),
				(this._propertyBindings = new Array(a)),
				(this._cacheIndex = null),
				(this._byClipCacheIndex = null),
				(this._timeScaleInterpolant = null),
				(this._weightInterpolant = null),
				(this.loop = 2201),
				(this._loopCount = -1),
				(this._startTime = null),
				(this.time = 0),
				(this.timeScale = 1),
				(this._effectiveTimeScale = 1),
				(this.weight = 1),
				(this._effectiveWeight = 1),
				(this.repetitions = 1 / 0),
				(this.paused = !1),
				(this.enabled = !0),
				(this.clampWhenFinished = !1),
				(this.zeroSlopeAtStart = !0),
				(this.zeroSlopeAtEnd = !0);
		}
		var e = t.prototype;
		return (
			(e.play = function () {
				return this._mixer._activateAction(this), this;
			}),
			(e.stop = function () {
				return this._mixer._deactivateAction(this), this.reset();
			}),
			(e.reset = function () {
				return (
					(this.paused = !1),
					(this.enabled = !0),
					(this.time = 0),
					(this._loopCount = -1),
					(this._startTime = null),
					this.stopFading().stopWarping()
				);
			}),
			(e.isRunning = function () {
				return (
					this.enabled &&
					!this.paused &&
					0 !== this.timeScale &&
					null === this._startTime &&
					this._mixer._isActiveAction(this)
				);
			}),
			(e.isScheduled = function () {
				return this._mixer._isActiveAction(this);
			}),
			(e.startAt = function (t) {
				return (this._startTime = t), this;
			}),
			(e.setLoop = function (t, e) {
				return (this.loop = t), (this.repetitions = e), this;
			}),
			(e.setEffectiveWeight = function (t) {
				return (
					(this.weight = t),
					(this._effectiveWeight = this.enabled ? t : 0),
					this.stopFading()
				);
			}),
			(e.getEffectiveWeight = function () {
				return this._effectiveWeight;
			}),
			(e.fadeIn = function (t) {
				return this._scheduleFading(t, 0, 1);
			}),
			(e.fadeOut = function (t) {
				return this._scheduleFading(t, 1, 0);
			}),
			(e.crossFadeFrom = function (t, e, n) {
				if ((t.fadeOut(e), this.fadeIn(e), n)) {
					var r = this._clip.duration,
						i = t._clip.duration,
						a = i / r,
						o = r / i;
					t.warp(1, a, e), this.warp(o, 1, e);
				}
				return this;
			}),
			(e.crossFadeTo = function (t, e, n) {
				return t.crossFadeFrom(this, e, n);
			}),
			(e.stopFading = function () {
				var t = this._weightInterpolant;
				return (
					null !== t &&
						((this._weightInterpolant = null),
						this._mixer._takeBackControlInterpolant(t)),
					this
				);
			}),
			(e.setEffectiveTimeScale = function (t) {
				return (
					(this.timeScale = t),
					(this._effectiveTimeScale = this.paused ? 0 : t),
					this.stopWarping()
				);
			}),
			(e.getEffectiveTimeScale = function () {
				return this._effectiveTimeScale;
			}),
			(e.setDuration = function (t) {
				return (this.timeScale = this._clip.duration / t), this.stopWarping();
			}),
			(e.syncWith = function (t) {
				return (
					(this.time = t.time),
					(this.timeScale = t.timeScale),
					this.stopWarping()
				);
			}),
			(e.halt = function (t) {
				return this.warp(this._effectiveTimeScale, 0, t);
			}),
			(e.warp = function (t, e, n) {
				var r = this._mixer,
					i = r.time,
					a = this.timeScale,
					o = this._timeScaleInterpolant;
				null === o &&
					((o = r._lendControlInterpolant()), (this._timeScaleInterpolant = o));
				var s = o.parameterPositions,
					c = o.sampleValues;
				return (s[0] = i), (s[1] = i + n), (c[0] = t / a), (c[1] = e / a), this;
			}),
			(e.stopWarping = function () {
				var t = this._timeScaleInterpolant;
				return (
					null !== t &&
						((this._timeScaleInterpolant = null),
						this._mixer._takeBackControlInterpolant(t)),
					this
				);
			}),
			(e.getMixer = function () {
				return this._mixer;
			}),
			(e.getClip = function () {
				return this._clip;
			}),
			(e.getRoot = function () {
				return this._localRoot || this._mixer._root;
			}),
			(e._update = function (t, e, n, r) {
				if (this.enabled) {
					var i = this._startTime;
					if (null !== i) {
						var a = (t - i) * n;
						if (a < 0 || 0 === n) return;
						(this._startTime = null), (e = n * a);
					}
					e *= this._updateTimeScale(t);
					var o = this._updateTime(e),
						s = this._updateWeight(t);
					if (s > 0) {
						var c = this._interpolants,
							l = this._propertyBindings;
						switch (this.blendMode) {
							case j:
								for (var u = 0, h = c.length; u !== h; ++u)
									c[u].evaluate(o), l[u].accumulateAdditive(s);
								break;
							case W:
							default:
								for (var d = 0, p = c.length; d !== p; ++d)
									c[d].evaluate(o), l[d].accumulate(r, s);
						}
					}
				} else this._updateWeight(t);
			}),
			(e._updateWeight = function (t) {
				var e = 0;
				if (this.enabled) {
					e = this.weight;
					var n = this._weightInterpolant;
					if (null !== n) {
						var r = n.evaluate(t)[0];
						(e *= r),
							t > n.parameterPositions[1] &&
								(this.stopFading(), 0 === r && (this.enabled = !1));
					}
				}
				return (this._effectiveWeight = e), e;
			}),
			(e._updateTimeScale = function (t) {
				var e = 0;
				if (!this.paused) {
					e = this.timeScale;
					var n = this._timeScaleInterpolant;
					if (null !== n)
						(e *= n.evaluate(t)[0]),
							t > n.parameterPositions[1] &&
								(this.stopWarping(),
								0 === e ? (this.paused = !0) : (this.timeScale = e));
				}
				return (this._effectiveTimeScale = e), e;
			}),
			(e._updateTime = function (t) {
				var e = this._clip.duration,
					n = this.loop,
					r = this.time + t,
					i = this._loopCount,
					a = 2202 === n;
				if (0 === t) return -1 === i ? r : a && 1 == (1 & i) ? e - r : r;
				if (2200 === n) {
					-1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
					t: {
						if (r >= e) r = e;
						else {
							if (!(r < 0)) {
								this.time = r;
								break t;
							}
							r = 0;
						}
						this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
							(this.time = r),
							this._mixer.dispatchEvent({
								type: 'finished',
								action: this,
								direction: t < 0 ? -1 : 1,
							});
					}
				} else {
					if (
						(-1 === i &&
							(t >= 0
								? ((i = 0), this._setEndings(!0, 0 === this.repetitions, a))
								: this._setEndings(0 === this.repetitions, !0, a)),
						r >= e || r < 0)
					) {
						var o = Math.floor(r / e);
						(r -= e * o), (i += Math.abs(o));
						var s = this.repetitions - i;
						if (s <= 0)
							this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
								(r = t > 0 ? e : 0),
								(this.time = r),
								this._mixer.dispatchEvent({
									type: 'finished',
									action: this,
									direction: t > 0 ? 1 : -1,
								});
						else {
							if (1 === s) {
								var c = t < 0;
								this._setEndings(c, !c, a);
							} else this._setEndings(!1, !1, a);
							(this._loopCount = i),
								(this.time = r),
								this._mixer.dispatchEvent({
									type: 'loop',
									action: this,
									loopDelta: o,
								});
						}
					} else this.time = r;
					if (a && 1 == (1 & i)) return e - r;
				}
				return r;
			}),
			(e._setEndings = function (t, e, n) {
				var r = this._interpolantSettings;
				n
					? ((r.endingStart = k), (r.endingEnd = k))
					: ((r.endingStart = t ? (this.zeroSlopeAtStart ? k : H) : V),
					  (r.endingEnd = e ? (this.zeroSlopeAtEnd ? k : H) : V));
			}),
			(e._scheduleFading = function (t, e, n) {
				var r = this._mixer,
					i = r.time,
					a = this._weightInterpolant;
				null === a &&
					((a = r._lendControlInterpolant()), (this._weightInterpolant = a));
				var o = a.parameterPositions,
					s = a.sampleValues;
				return (o[0] = i), (s[0] = e), (o[1] = i + t), (s[1] = n), this;
			}),
			t
		);
	})();
	function ru(t) {
		(this._root = t),
			this._initMemoryManager(),
			(this._accuIndex = 0),
			(this.time = 0),
			(this.timeScale = 1);
	}
	ru.prototype = Object.assign(Object.create(rt.prototype), {
		constructor: ru,
		_bindAction: function (t, e) {
			var n = t._localRoot || this._root,
				r = t._clip.tracks,
				i = r.length,
				a = t._propertyBindings,
				o = t._interpolants,
				s = n.uuid,
				c = this._bindingsByRootAndName,
				l = c[s];
			void 0 === l && ((l = {}), (c[s] = l));
			for (var u = 0; u !== i; ++u) {
				var h = r[u],
					d = h.name,
					p = l[d];
				if (void 0 !== p) a[u] = p;
				else {
					if (void 0 !== (p = a[u])) {
						null === p._cacheIndex &&
							(++p.referenceCount, this._addInactiveBinding(p, s, d));
						continue;
					}
					var f = e && e._propertyBindings[u].binding.parsedPath;
					++(p = new kl(tu.create(n, d, f), h.ValueTypeName, h.getValueSize()))
						.referenceCount,
						this._addInactiveBinding(p, s, d),
						(a[u] = p);
				}
				o[u].resultBuffer = p.buffer;
			}
		},
		_activateAction: function (t) {
			if (!this._isActiveAction(t)) {
				if (null === t._cacheIndex) {
					var e = (t._localRoot || this._root).uuid,
						n = t._clip.uuid,
						r = this._actionsByClip[n];
					this._bindAction(t, r && r.knownActions[0]),
						this._addInactiveAction(t, n, e);
				}
				for (var i = t._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
					var s = i[a];
					0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState());
				}
				this._lendAction(t);
			}
		},
		_deactivateAction: function (t) {
			if (this._isActiveAction(t)) {
				for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
					var i = e[n];
					0 == --i.useCount &&
						(i.restoreOriginalState(), this._takeBackBinding(i));
				}
				this._takeBackAction(t);
			}
		},
		_initMemoryManager: function () {
			(this._actions = []),
				(this._nActiveActions = 0),
				(this._actionsByClip = {}),
				(this._bindings = []),
				(this._nActiveBindings = 0),
				(this._bindingsByRootAndName = {}),
				(this._controlInterpolants = []),
				(this._nActiveControlInterpolants = 0);
			var t = this;
			this.stats = {
				actions: {
					get total() {
						return t._actions.length;
					},
					get inUse() {
						return t._nActiveActions;
					},
				},
				bindings: {
					get total() {
						return t._bindings.length;
					},
					get inUse() {
						return t._nActiveBindings;
					},
				},
				controlInterpolants: {
					get total() {
						return t._controlInterpolants.length;
					},
					get inUse() {
						return t._nActiveControlInterpolants;
					},
				},
			};
		},
		_isActiveAction: function (t) {
			var e = t._cacheIndex;
			return null !== e && e < this._nActiveActions;
		},
		_addInactiveAction: function (t, e, n) {
			var r = this._actions,
				i = this._actionsByClip,
				a = i[e];
			if (void 0 === a)
				(a = { knownActions: [t], actionByRoot: {} }),
					(t._byClipCacheIndex = 0),
					(i[e] = a);
			else {
				var o = a.knownActions;
				(t._byClipCacheIndex = o.length), o.push(t);
			}
			(t._cacheIndex = r.length), r.push(t), (a.actionByRoot[n] = t);
		},
		_removeInactiveAction: function (t) {
			var e = this._actions,
				n = e[e.length - 1],
				r = t._cacheIndex;
			(n._cacheIndex = r), (e[r] = n), e.pop(), (t._cacheIndex = null);
			var i = t._clip.uuid,
				a = this._actionsByClip,
				o = a[i],
				s = o.knownActions,
				c = s[s.length - 1],
				l = t._byClipCacheIndex;
			(c._byClipCacheIndex = l),
				(s[l] = c),
				s.pop(),
				(t._byClipCacheIndex = null),
				delete o.actionByRoot[(t._localRoot || this._root).uuid],
				0 === s.length && delete a[i],
				this._removeInactiveBindingsForAction(t);
		},
		_removeInactiveBindingsForAction: function (t) {
			for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
				var i = e[n];
				0 == --i.referenceCount && this._removeInactiveBinding(i);
			}
		},
		_lendAction: function (t) {
			var e = this._actions,
				n = t._cacheIndex,
				r = this._nActiveActions++,
				i = e[r];
			(t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
		},
		_takeBackAction: function (t) {
			var e = this._actions,
				n = t._cacheIndex,
				r = --this._nActiveActions,
				i = e[r];
			(t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
		},
		_addInactiveBinding: function (t, e, n) {
			var r = this._bindingsByRootAndName,
				i = this._bindings,
				a = r[e];
			void 0 === a && ((a = {}), (r[e] = a)),
				(a[n] = t),
				(t._cacheIndex = i.length),
				i.push(t);
		},
		_removeInactiveBinding: function (t) {
			var e = this._bindings,
				n = t.binding,
				r = n.rootNode.uuid,
				i = n.path,
				a = this._bindingsByRootAndName,
				o = a[r],
				s = e[e.length - 1],
				c = t._cacheIndex;
			(s._cacheIndex = c),
				(e[c] = s),
				e.pop(),
				delete o[i],
				0 === Object.keys(o).length && delete a[r];
		},
		_lendBinding: function (t) {
			var e = this._bindings,
				n = t._cacheIndex,
				r = this._nActiveBindings++,
				i = e[r];
			(t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
		},
		_takeBackBinding: function (t) {
			var e = this._bindings,
				n = t._cacheIndex,
				r = --this._nActiveBindings,
				i = e[r];
			(t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
		},
		_lendControlInterpolant: function () {
			var t = this._controlInterpolants,
				e = this._nActiveControlInterpolants++,
				n = t[e];
			return (
				void 0 === n &&
					(((n = new $s(
						new Float32Array(2),
						new Float32Array(2),
						1,
						this._controlInterpolantsResultBuffer
					)).__cacheIndex = e),
					(t[e] = n)),
				n
			);
		},
		_takeBackControlInterpolant: function (t) {
			var e = this._controlInterpolants,
				n = t.__cacheIndex,
				r = --this._nActiveControlInterpolants,
				i = e[r];
			(t.__cacheIndex = r), (e[r] = t), (i.__cacheIndex = n), (e[n] = i);
		},
		_controlInterpolantsResultBuffer: new Float32Array(1),
		clipAction: function (t, e, n) {
			var r = e || this._root,
				i = r.uuid,
				a = 'string' == typeof t ? lc.findByName(r, t) : t,
				o = null !== a ? a.uuid : t,
				s = this._actionsByClip[o],
				c = null;
			if ((void 0 === n && (n = null !== a ? a.blendMode : W), void 0 !== s)) {
				var l = s.actionByRoot[i];
				if (void 0 !== l && l.blendMode === n) return l;
				(c = s.knownActions[0]), null === a && (a = c._clip);
			}
			if (null === a) return null;
			var u = new nu(this, a, e, n);
			return this._bindAction(u, c), this._addInactiveAction(u, o, i), u;
		},
		existingAction: function (t, e) {
			var n = e || this._root,
				r = n.uuid,
				i = 'string' == typeof t ? lc.findByName(n, t) : t,
				a = i ? i.uuid : t,
				o = this._actionsByClip[a];
			return (void 0 !== o && o.actionByRoot[r]) || null;
		},
		stopAllAction: function () {
			for (var t = this._actions, e = this._nActiveActions - 1; e >= 0; --e)
				t[e].stop();
			return this;
		},
		update: function (t) {
			t *= this.timeScale;
			for (
				var e = this._actions,
					n = this._nActiveActions,
					r = (this.time += t),
					i = Math.sign(t),
					a = (this._accuIndex ^= 1),
					o = 0;
				o !== n;
				++o
			) {
				e[o]._update(r, t, i, a);
			}
			for (
				var s = this._bindings, c = this._nActiveBindings, l = 0;
				l !== c;
				++l
			)
				s[l].apply(a);
			return this;
		},
		setTime: function (t) {
			this.time = 0;
			for (var e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
			return this.update(t);
		},
		getRoot: function () {
			return this._root;
		},
		uncacheClip: function (t) {
			var e = this._actions,
				n = t.uuid,
				r = this._actionsByClip,
				i = r[n];
			if (void 0 !== i) {
				for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
					var c = a[o];
					this._deactivateAction(c);
					var l = c._cacheIndex,
						u = e[e.length - 1];
					(c._cacheIndex = null),
						(c._byClipCacheIndex = null),
						(u._cacheIndex = l),
						(e[l] = u),
						e.pop(),
						this._removeInactiveBindingsForAction(c);
				}
				delete r[n];
			}
		},
		uncacheRoot: function (t) {
			var e = t.uuid,
				n = this._actionsByClip;
			for (var r in n) {
				var i = n[r].actionByRoot[e];
				void 0 !== i &&
					(this._deactivateAction(i), this._removeInactiveAction(i));
			}
			var a = this._bindingsByRootAndName[e];
			if (void 0 !== a)
				for (var o in a) {
					var s = a[o];
					s.restoreOriginalState(), this._removeInactiveBinding(s);
				}
		},
		uncacheAction: function (t, e) {
			var n = this.existingAction(t, e);
			null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
		},
	});
	var iu = (function () {
		function t(t) {
			'string' == typeof t &&
				(console.warn('THREE.Uniform: Type parameter is no longer needed.'),
				(t = arguments[1])),
				(this.value = t);
		}
		return (
			(t.prototype.clone = function () {
				return new t(
					void 0 === this.value.clone ? this.value : this.value.clone()
				);
			}),
			t
		);
	})();
	function au(t, e, n) {
		ca.call(this, t, e), (this.meshPerAttribute = n || 1);
	}
	function ou(t, e, n, r, i) {
		(this.buffer = t),
			(this.type = e),
			(this.itemSize = n),
			(this.elementSize = r),
			(this.count = i),
			(this.version = 0);
	}
	function su(t, e, n, r) {
		(this.ray = new Zt(t, e)),
			(this.near = n || 0),
			(this.far = r || 1 / 0),
			(this.camera = null),
			(this.layers = new se()),
			(this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {},
			}),
			Object.defineProperties(this.params, {
				PointCloud: {
					get: function () {
						return (
							console.warn(
								'THREE.Raycaster: params.PointCloud has been renamed to params.Points.'
							),
							this.Points
						);
					},
				},
			});
	}
	function cu(t, e) {
		return t.distance - e.distance;
	}
	function lu(t, e, n, r) {
		if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === r))
			for (var i = t.children, a = 0, o = i.length; a < o; a++)
				lu(i[a], e, n, !0);
	}
	(au.prototype = Object.assign(Object.create(ca.prototype), {
		constructor: au,
		isInstancedInterleavedBuffer: !0,
		copy: function (t) {
			return (
				ca.prototype.copy.call(this, t),
				(this.meshPerAttribute = t.meshPerAttribute),
				this
			);
		},
		clone: function (t) {
			var e = ca.prototype.clone.call(this, t);
			return (e.meshPerAttribute = this.meshPerAttribute), e;
		},
		toJSON: function (t) {
			var e = ca.prototype.toJSON.call(this, t);
			return (
				(e.isInstancedInterleavedBuffer = !0),
				(e.meshPerAttribute = this.meshPerAttribute),
				e
			);
		},
	})),
		Object.defineProperty(ou.prototype, 'needsUpdate', {
			set: function (t) {
				!0 === t && this.version++;
			},
		}),
		Object.assign(ou.prototype, {
			isGLBufferAttribute: !0,
			setBuffer: function (t) {
				return (this.buffer = t), this;
			},
			setType: function (t, e) {
				return (this.type = t), (this.elementSize = e), this;
			},
			setItemSize: function (t) {
				return (this.itemSize = t), this;
			},
			setCount: function (t) {
				return (this.count = t), this;
			},
		}),
		Object.assign(su.prototype, {
			set: function (t, e) {
				this.ray.set(t, e);
			},
			setFromCamera: function (t, e) {
				e && e.isPerspectiveCamera
					? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
					  this.ray.direction
							.set(t.x, t.y, 0.5)
							.unproject(e)
							.sub(this.ray.origin)
							.normalize(),
					  (this.camera = e))
					: e && e.isOrthographicCamera
					? (this.ray.origin
							.set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
							.unproject(e),
					  this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
					  (this.camera = e))
					: console.error('THREE.Raycaster: Unsupported camera type.');
			},
			intersectObject: function (t, e, n) {
				var r = n || [];
				return lu(t, this, r, e), r.sort(cu), r;
			},
			intersectObjects: function (t, e, n) {
				var r = n || [];
				if (!1 === Array.isArray(t))
					return (
						console.warn(
							'THREE.Raycaster.intersectObjects: objects is not an Array.'
						),
						r
					);
				for (var i = 0, a = t.length; i < a; i++) lu(t[i], this, r, e);
				return r.sort(cu), r;
			},
		});
	var uu = (function () {
			function t(t, e, n) {
				return (
					void 0 === t && (t = 1),
					void 0 === e && (e = 0),
					void 0 === n && (n = 0),
					(this.radius = t),
					(this.phi = e),
					(this.theta = n),
					this
				);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n) {
					return (this.radius = t), (this.phi = e), (this.theta = n), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return (
						(this.radius = t.radius),
						(this.phi = t.phi),
						(this.theta = t.theta),
						this
					);
				}),
				(e.makeSafe = function () {
					var t = 1e-6;
					return (
						(this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
					);
				}),
				(e.setFromVector3 = function (t) {
					return this.setFromCartesianCoords(t.x, t.y, t.z);
				}),
				(e.setFromCartesianCoords = function (t, e, n) {
					return (
						(this.radius = Math.sqrt(t * t + e * e + n * n)),
						0 === this.radius
							? ((this.theta = 0), (this.phi = 0))
							: ((this.theta = Math.atan2(t, n)),
							  (this.phi = Math.acos(st.clamp(e / this.radius, -1, 1)))),
						this
					);
				}),
				t
			);
		})(),
		hu = (function () {
			function t(t, e, n) {
				return (
					(this.radius = void 0 !== t ? t : 1),
					(this.theta = void 0 !== e ? e : 0),
					(this.y = void 0 !== n ? n : 0),
					this
				);
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e, n) {
					return (this.radius = t), (this.theta = e), (this.y = n), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return (
						(this.radius = t.radius),
						(this.theta = t.theta),
						(this.y = t.y),
						this
					);
				}),
				(e.setFromVector3 = function (t) {
					return this.setFromCartesianCoords(t.x, t.y, t.z);
				}),
				(e.setFromCartesianCoords = function (t, e, n) {
					return (
						(this.radius = Math.sqrt(t * t + n * n)),
						(this.theta = Math.atan2(t, n)),
						(this.y = e),
						this
					);
				}),
				t
			);
		})(),
		du = new pt(),
		pu = (function () {
			function t(t, e) {
				Object.defineProperty(this, 'isBox2', { value: !0 }),
					(this.min = void 0 !== t ? t : new pt(1 / 0, 1 / 0)),
					(this.max = void 0 !== e ? e : new pt(-1 / 0, -1 / 0));
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return this.min.copy(t), this.max.copy(e), this;
				}),
				(e.setFromPoints = function (t) {
					this.makeEmpty();
					for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
					return this;
				}),
				(e.setFromCenterAndSize = function (t, e) {
					var n = du.copy(e).multiplyScalar(0.5);
					return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return this.min.copy(t.min), this.max.copy(t.max), this;
				}),
				(e.makeEmpty = function () {
					return (
						(this.min.x = this.min.y = 1 / 0),
						(this.max.x = this.max.y = -1 / 0),
						this
					);
				}),
				(e.isEmpty = function () {
					return this.max.x < this.min.x || this.max.y < this.min.y;
				}),
				(e.getCenter = function (t) {
					return (
						void 0 === t &&
							(console.warn('THREE.Box2: .getCenter() target is now required'),
							(t = new pt())),
						this.isEmpty()
							? t.set(0, 0)
							: t.addVectors(this.min, this.max).multiplyScalar(0.5)
					);
				}),
				(e.getSize = function (t) {
					return (
						void 0 === t &&
							(console.warn('THREE.Box2: .getSize() target is now required'),
							(t = new pt())),
						this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
					);
				}),
				(e.expandByPoint = function (t) {
					return this.min.min(t), this.max.max(t), this;
				}),
				(e.expandByVector = function (t) {
					return this.min.sub(t), this.max.add(t), this;
				}),
				(e.expandByScalar = function (t) {
					return this.min.addScalar(-t), this.max.addScalar(t), this;
				}),
				(e.containsPoint = function (t) {
					return !(
						t.x < this.min.x ||
						t.x > this.max.x ||
						t.y < this.min.y ||
						t.y > this.max.y
					);
				}),
				(e.containsBox = function (t) {
					return (
						this.min.x <= t.min.x &&
						t.max.x <= this.max.x &&
						this.min.y <= t.min.y &&
						t.max.y <= this.max.y
					);
				}),
				(e.getParameter = function (t, e) {
					return (
						void 0 === e &&
							(console.warn(
								'THREE.Box2: .getParameter() target is now required'
							),
							(e = new pt())),
						e.set(
							(t.x - this.min.x) / (this.max.x - this.min.x),
							(t.y - this.min.y) / (this.max.y - this.min.y)
						)
					);
				}),
				(e.intersectsBox = function (t) {
					return !(
						t.max.x < this.min.x ||
						t.min.x > this.max.x ||
						t.max.y < this.min.y ||
						t.min.y > this.max.y
					);
				}),
				(e.clampPoint = function (t, e) {
					return (
						void 0 === e &&
							(console.warn('THREE.Box2: .clampPoint() target is now required'),
							(e = new pt())),
						e.copy(t).clamp(this.min, this.max)
					);
				}),
				(e.distanceToPoint = function (t) {
					return du.copy(t).clamp(this.min, this.max).sub(t).length();
				}),
				(e.intersect = function (t) {
					return this.min.max(t.min), this.max.min(t.max), this;
				}),
				(e.union = function (t) {
					return this.min.min(t.min), this.max.max(t.max), this;
				}),
				(e.translate = function (t) {
					return this.min.add(t), this.max.add(t), this;
				}),
				(e.equals = function (t) {
					return t.min.equals(this.min) && t.max.equals(this.max);
				}),
				t
			);
		})(),
		fu = new wt(),
		mu = new wt(),
		vu = (function () {
			function t(t, e) {
				(this.start = void 0 !== t ? t : new wt()),
					(this.end = void 0 !== e ? e : new wt());
			}
			var e = t.prototype;
			return (
				(e.set = function (t, e) {
					return this.start.copy(t), this.end.copy(e), this;
				}),
				(e.clone = function () {
					return new this.constructor().copy(this);
				}),
				(e.copy = function (t) {
					return this.start.copy(t.start), this.end.copy(t.end), this;
				}),
				(e.getCenter = function (t) {
					return (
						void 0 === t &&
							(console.warn('THREE.Line3: .getCenter() target is now required'),
							(t = new wt())),
						t.addVectors(this.start, this.end).multiplyScalar(0.5)
					);
				}),
				(e.delta = function (t) {
					return (
						void 0 === t &&
							(console.warn('THREE.Line3: .delta() target is now required'),
							(t = new wt())),
						t.subVectors(this.end, this.start)
					);
				}),
				(e.distanceSq = function () {
					return this.start.distanceToSquared(this.end);
				}),
				(e.distance = function () {
					return this.start.distanceTo(this.end);
				}),
				(e.at = function (t, e) {
					return (
						void 0 === e &&
							(console.warn('THREE.Line3: .at() target is now required'),
							(e = new wt())),
						this.delta(e).multiplyScalar(t).add(this.start)
					);
				}),
				(e.closestPointToPointParameter = function (t, e) {
					fu.subVectors(t, this.start), mu.subVectors(this.end, this.start);
					var n = mu.dot(mu),
						r = mu.dot(fu) / n;
					return e && (r = st.clamp(r, 0, 1)), r;
				}),
				(e.closestPointToPoint = function (t, e, n) {
					var r = this.closestPointToPointParameter(t, e);
					return (
						void 0 === n &&
							(console.warn(
								'THREE.Line3: .closestPointToPoint() target is now required'
							),
							(n = new wt())),
						this.delta(n).multiplyScalar(r).add(this.start)
					);
				}),
				(e.applyMatrix4 = function (t) {
					return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
				}),
				(e.equals = function (t) {
					return t.start.equals(this.start) && t.end.equals(this.end);
				}),
				t
			);
		})();
	function gu(t) {
		be.call(this),
			(this.material = t),
			(this.render = function () {}),
			(this.hasPositions = !1),
			(this.hasNormals = !1),
			(this.hasColors = !1),
			(this.hasUvs = !1),
			(this.positionArray = null),
			(this.normalArray = null),
			(this.colorArray = null),
			(this.uvArray = null),
			(this.count = 0);
	}
	(gu.prototype = Object.create(be.prototype)),
		(gu.prototype.constructor = gu),
		(gu.prototype.isImmediateRenderObject = !0);
	var yu = new wt(),
		xu = (function (t) {
			function e(e, n) {
				var r;
				((r = t.call(this) || this).light = e),
					r.light.updateMatrixWorld(),
					(r.matrix = e.matrixWorld),
					(r.matrixAutoUpdate = !1),
					(r.color = n);
				for (
					var i = new vn(),
						a = [
							0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
							1, 1, 0, 0, 0, 0, -1, 1,
						],
						o = 0,
						s = 1;
					o < 32;
					o++, s++
				) {
					var c = (o / 32) * Math.PI * 2,
						l = (s / 32) * Math.PI * 2;
					a.push(Math.cos(c), Math.sin(c), 1, Math.cos(l), Math.sin(l), 1);
				}
				i.setAttribute('position', new an(a, 3));
				var u = new ja({ fog: !1, toneMapped: !1 });
				return (r.cone = new to(i, u)), r.add(r.cone), r.update(), r;
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.dispose = function () {
					this.cone.geometry.dispose(), this.cone.material.dispose();
				}),
				(n.update = function () {
					this.light.updateMatrixWorld();
					var t = this.light.distance ? this.light.distance : 1e3,
						e = t * Math.tan(this.light.angle);
					this.cone.scale.set(e, e, t),
						yu.setFromMatrixPosition(this.light.target.matrixWorld),
						this.cone.lookAt(yu),
						void 0 !== this.color
							? this.cone.material.color.set(this.color)
							: this.cone.material.color.copy(this.light.color);
				}),
				e
			);
		})(be),
		_u = new wt(),
		bu = new Jt(),
		wu = new Jt(),
		Mu = (function (t) {
			function e(e) {
				for (
					var n,
						r = Su(e),
						i = new vn(),
						a = [],
						o = [],
						s = new Ve(0, 0, 1),
						c = new Ve(0, 1, 0),
						l = 0;
					l < r.length;
					l++
				) {
					var u = r[l];
					u.parent &&
						u.parent.isBone &&
						(a.push(0, 0, 0),
						a.push(0, 0, 0),
						o.push(s.r, s.g, s.b),
						o.push(c.r, c.g, c.b));
				}
				i.setAttribute('position', new an(a, 3)),
					i.setAttribute('color', new an(o, 3));
				var h = new ja({
					vertexColors: !0,
					depthTest: !1,
					depthWrite: !1,
					toneMapped: !1,
					transparent: !0,
				});
				return (
					((n = t.call(this, i, h) || this).type = 'SkeletonHelper'),
					(n.isSkeletonHelper = !0),
					(n.root = e),
					(n.bones = r),
					(n.matrix = e.matrixWorld),
					(n.matrixAutoUpdate = !1),
					n
				);
			}
			return (
				ut(e, t),
				(e.prototype.updateMatrixWorld = function (e) {
					var n = this.bones,
						r = this.geometry,
						i = r.getAttribute('position');
					wu.getInverse(this.root.matrixWorld);
					for (var a = 0, o = 0; a < n.length; a++) {
						var s = n[a];
						s.parent &&
							s.parent.isBone &&
							(bu.multiplyMatrices(wu, s.matrixWorld),
							_u.setFromMatrixPosition(bu),
							i.setXYZ(o, _u.x, _u.y, _u.z),
							bu.multiplyMatrices(wu, s.parent.matrixWorld),
							_u.setFromMatrixPosition(bu),
							i.setXYZ(o + 1, _u.x, _u.y, _u.z),
							(o += 2));
					}
					(r.getAttribute('position').needsUpdate = !0),
						t.prototype.updateMatrixWorld.call(this, e);
				}),
				e
			);
		})(to);
	function Su(t) {
		var e = [];
		t && t.isBone && e.push(t);
		for (var n = 0; n < t.children.length; n++)
			e.push.apply(e, Su(t.children[n]));
		return e;
	}
	var Tu = (function (t) {
			function e(e, n, r) {
				var i,
					a = new Ts(n, 4, 2),
					o = new Xe({ wireframe: !0, fog: !1, toneMapped: !1 });
				return (
					((i = t.call(this, a, o) || this).light = e),
					i.light.updateMatrixWorld(),
					(i.color = r),
					(i.type = 'PointLightHelper'),
					(i.matrix = i.light.matrixWorld),
					(i.matrixAutoUpdate = !1),
					i.update(),
					i
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.dispose = function () {
					this.geometry.dispose(), this.material.dispose();
				}),
				(n.update = function () {
					void 0 !== this.color
						? this.material.color.set(this.color)
						: this.material.color.copy(this.light.color);
				}),
				e
			);
		})(Nn),
		Eu = new wt(),
		Au = new Ve(),
		Lu = new Ve(),
		Ru = (function (t) {
			function e(e, n, r) {
				var i;
				((i = t.call(this) || this).light = e),
					i.light.updateMatrixWorld(),
					(i.matrix = e.matrixWorld),
					(i.matrixAutoUpdate = !1),
					(i.color = r);
				var a = new ms(n);
				a.rotateY(0.5 * Math.PI),
					(i.material = new Xe({ wireframe: !0, fog: !1, toneMapped: !1 })),
					void 0 === i.color && (i.material.vertexColors = !0);
				var o = a.getAttribute('position'),
					s = new Float32Array(3 * o.count);
				return (
					a.setAttribute('color', new Je(s, 3)),
					i.add(new Nn(a, i.material)),
					i.update(),
					i
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.dispose = function () {
					this.children[0].geometry.dispose(),
						this.children[0].material.dispose();
				}),
				(n.update = function () {
					var t = this.children[0];
					if (void 0 !== this.color) this.material.color.set(this.color);
					else {
						var e = t.geometry.getAttribute('color');
						Au.copy(this.light.color), Lu.copy(this.light.groundColor);
						for (var n = 0, r = e.count; n < r; n++) {
							var i = n < r / 2 ? Au : Lu;
							e.setXYZ(n, i.r, i.g, i.b);
						}
						e.needsUpdate = !0;
					}
					t.lookAt(Eu.setFromMatrixPosition(this.light.matrixWorld).negate());
				}),
				e
			);
		})(be),
		Cu = (function (t) {
			function e(e, n, r, i) {
				var a;
				(e = e || 10),
					(n = n || 10),
					(r = new Ve(void 0 !== r ? r : 4473924)),
					(i = new Ve(void 0 !== i ? i : 8947848));
				for (
					var o = n / 2,
						s = e / n,
						c = e / 2,
						l = [],
						u = [],
						h = 0,
						d = 0,
						p = -c;
					h <= n;
					h++, p += s
				) {
					l.push(-c, 0, p, c, 0, p), l.push(p, 0, -c, p, 0, c);
					var f = h === o ? r : i;
					f.toArray(u, d),
						(d += 3),
						f.toArray(u, d),
						(d += 3),
						f.toArray(u, d),
						(d += 3),
						f.toArray(u, d),
						(d += 3);
				}
				var m = new vn();
				m.setAttribute('position', new an(l, 3)),
					m.setAttribute('color', new an(u, 3));
				var v = new ja({ vertexColors: !0, toneMapped: !1 });
				return ((a = t.call(this, m, v) || this).type = 'GridHelper'), a;
			}
			return ut(e, t), e;
		})(to),
		Pu = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				(e = e || 10),
					(n = n || 16),
					(r = r || 8),
					(i = i || 64),
					(a = new Ve(void 0 !== a ? a : 4473924)),
					(o = new Ve(void 0 !== o ? o : 8947848));
				for (var c = [], l = [], u = 0; u <= n; u++) {
					var h = (u / n) * (2 * Math.PI),
						d = Math.sin(h) * e,
						p = Math.cos(h) * e;
					c.push(0, 0, 0), c.push(d, 0, p);
					var f = 1 & u ? a : o;
					l.push(f.r, f.g, f.b), l.push(f.r, f.g, f.b);
				}
				for (var m = 0; m <= r; m++)
					for (var v = 1 & m ? a : o, g = e - (e / r) * m, y = 0; y < i; y++) {
						var x = (y / i) * (2 * Math.PI),
							_ = Math.sin(x) * g,
							b = Math.cos(x) * g;
						c.push(_, 0, b),
							l.push(v.r, v.g, v.b),
							(x = ((y + 1) / i) * (2 * Math.PI)),
							(_ = Math.sin(x) * g),
							(b = Math.cos(x) * g),
							c.push(_, 0, b),
							l.push(v.r, v.g, v.b);
					}
				var w = new vn();
				w.setAttribute('position', new an(c, 3)),
					w.setAttribute('color', new an(l, 3));
				var M = new ja({ vertexColors: !0, toneMapped: !1 });
				return ((s = t.call(this, w, M) || this).type = 'PolarGridHelper'), s;
			}
			return ut(e, t), e;
		})(to),
		Iu = new wt(),
		Du = new wt(),
		Nu = new wt(),
		Ou = (function (t) {
			function e(e, n, r) {
				var i;
				((i = t.call(this) || this).light = e),
					i.light.updateMatrixWorld(),
					(i.matrix = e.matrixWorld),
					(i.matrixAutoUpdate = !1),
					(i.color = r),
					void 0 === n && (n = 1);
				var a = new vn();
				a.setAttribute(
					'position',
					new an([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3)
				);
				var o = new ja({ fog: !1, toneMapped: !1 });
				return (
					(i.lightPlane = new Qa(a, o)),
					i.add(i.lightPlane),
					(a = new vn()).setAttribute(
						'position',
						new an([0, 0, 0, 0, 0, 1], 3)
					),
					(i.targetLine = new Qa(a, o)),
					i.add(i.targetLine),
					i.update(),
					i
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.dispose = function () {
					this.lightPlane.geometry.dispose(),
						this.lightPlane.material.dispose(),
						this.targetLine.geometry.dispose(),
						this.targetLine.material.dispose();
				}),
				(n.update = function () {
					Iu.setFromMatrixPosition(this.light.matrixWorld),
						Du.setFromMatrixPosition(this.light.target.matrixWorld),
						Nu.subVectors(Du, Iu),
						this.lightPlane.lookAt(Du),
						void 0 !== this.color
							? (this.lightPlane.material.color.set(this.color),
							  this.targetLine.material.color.set(this.color))
							: (this.lightPlane.material.color.copy(this.light.color),
							  this.targetLine.material.color.copy(this.light.color)),
						this.targetLine.lookAt(Du),
						(this.targetLine.scale.z = Nu.length());
				}),
				e
			);
		})(be),
		Bu = new wt(),
		zu = new kn(),
		Gu = (function (t) {
			function e(e) {
				var n,
					r = new vn(),
					i = new ja({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
					a = [],
					o = [],
					s = {},
					c = new Ve(16755200),
					l = new Ve(16711680),
					u = new Ve(43775),
					h = new Ve(16777215),
					d = new Ve(3355443);
				function p(t, e, n) {
					f(t, n), f(e, n);
				}
				function f(t, e) {
					a.push(0, 0, 0),
						o.push(e.r, e.g, e.b),
						void 0 === s[t] && (s[t] = []),
						s[t].push(a.length / 3 - 1);
				}
				return (
					p('n1', 'n2', c),
					p('n2', 'n4', c),
					p('n4', 'n3', c),
					p('n3', 'n1', c),
					p('f1', 'f2', c),
					p('f2', 'f4', c),
					p('f4', 'f3', c),
					p('f3', 'f1', c),
					p('n1', 'f1', c),
					p('n2', 'f2', c),
					p('n3', 'f3', c),
					p('n4', 'f4', c),
					p('p', 'n1', l),
					p('p', 'n2', l),
					p('p', 'n3', l),
					p('p', 'n4', l),
					p('u1', 'u2', u),
					p('u2', 'u3', u),
					p('u3', 'u1', u),
					p('c', 't', h),
					p('p', 'c', d),
					p('cn1', 'cn2', d),
					p('cn3', 'cn4', d),
					p('cf1', 'cf2', d),
					p('cf3', 'cf4', d),
					r.setAttribute('position', new an(a, 3)),
					r.setAttribute('color', new an(o, 3)),
					((n = t.call(this, r, i) || this).type = 'CameraHelper'),
					(n.camera = e),
					n.camera.updateProjectionMatrix && n.camera.updateProjectionMatrix(),
					(n.matrix = e.matrixWorld),
					(n.matrixAutoUpdate = !1),
					(n.pointMap = s),
					n.update(),
					n
				);
			}
			return (
				ut(e, t),
				(e.prototype.update = function () {
					var t = this.geometry,
						e = this.pointMap;
					zu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
						Fu('c', e, t, zu, 0, 0, -1),
						Fu('t', e, t, zu, 0, 0, 1),
						Fu('n1', e, t, zu, -1, -1, -1),
						Fu('n2', e, t, zu, 1, -1, -1),
						Fu('n3', e, t, zu, -1, 1, -1),
						Fu('n4', e, t, zu, 1, 1, -1),
						Fu('f1', e, t, zu, -1, -1, 1),
						Fu('f2', e, t, zu, 1, -1, 1),
						Fu('f3', e, t, zu, -1, 1, 1),
						Fu('f4', e, t, zu, 1, 1, 1),
						Fu('u1', e, t, zu, 0.7, 1.1, -1),
						Fu('u2', e, t, zu, -0.7, 1.1, -1),
						Fu('u3', e, t, zu, 0, 2, -1),
						Fu('cf1', e, t, zu, -1, 0, 1),
						Fu('cf2', e, t, zu, 1, 0, 1),
						Fu('cf3', e, t, zu, 0, -1, 1),
						Fu('cf4', e, t, zu, 0, 1, 1),
						Fu('cn1', e, t, zu, -1, 0, -1),
						Fu('cn2', e, t, zu, 1, 0, -1),
						Fu('cn3', e, t, zu, 0, -1, -1),
						Fu('cn4', e, t, zu, 0, 1, -1),
						(t.getAttribute('position').needsUpdate = !0);
				}),
				e
			);
		})(to);
	function Fu(t, e, n, r, i, a, o) {
		Bu.set(i, a, o).unproject(r);
		var s = e[t];
		if (void 0 !== s)
			for (var c = n.getAttribute('position'), l = 0, u = s.length; l < u; l++)
				c.setXYZ(s[l], Bu.x, Bu.y, Bu.z);
	}
	var Uu,
		Hu,
		ku,
		Vu = new Tt(),
		Wu = (function (t) {
			function e(e, n) {
				var r;
				void 0 === n && (n = 16776960);
				var i = new Uint16Array([
						0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
						7,
					]),
					a = new Float32Array(24),
					o = new vn();
				return (
					o.setIndex(new Je(i, 1)),
					o.setAttribute('position', new Je(a, 3)),
					((r =
						t.call(this, o, new ja({ color: n, toneMapped: !1 })) ||
						this).object = e),
					(r.type = 'BoxHelper'),
					(r.matrixAutoUpdate = !1),
					r.update(),
					r
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.update = function (t) {
					if (
						(void 0 !== t &&
							console.warn(
								'THREE.BoxHelper: .update() has no longer arguments.'
							),
						void 0 !== this.object && Vu.setFromObject(this.object),
						!Vu.isEmpty())
					) {
						var e = Vu.min,
							n = Vu.max,
							r = this.geometry.attributes.position,
							i = r.array;
						(i[0] = n.x),
							(i[1] = n.y),
							(i[2] = n.z),
							(i[3] = e.x),
							(i[4] = n.y),
							(i[5] = n.z),
							(i[6] = e.x),
							(i[7] = e.y),
							(i[8] = n.z),
							(i[9] = n.x),
							(i[10] = e.y),
							(i[11] = n.z),
							(i[12] = n.x),
							(i[13] = n.y),
							(i[14] = e.z),
							(i[15] = e.x),
							(i[16] = n.y),
							(i[17] = e.z),
							(i[18] = e.x),
							(i[19] = e.y),
							(i[20] = e.z),
							(i[21] = n.x),
							(i[22] = e.y),
							(i[23] = e.z),
							(r.needsUpdate = !0),
							this.geometry.computeBoundingSphere();
					}
				}),
				(n.setFromObject = function (t) {
					return (this.object = t), this.update(), this;
				}),
				(n.copy = function (t) {
					return (
						to.prototype.copy.call(this, t), (this.object = t.object), this
					);
				}),
				e
			);
		})(to),
		ju = (function (t) {
			function e(e, n) {
				var r;
				void 0 === n && (n = 16776960);
				var i = new Uint16Array([
						0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
						7,
					]),
					a = new vn();
				return (
					a.setIndex(new Je(i, 1)),
					a.setAttribute(
						'position',
						new an(
							[
								1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
								-1, -1, 1, -1, -1,
							],
							3
						)
					),
					((r =
						t.call(this, a, new ja({ color: n, toneMapped: !1 })) || this).box =
						e),
					(r.type = 'Box3Helper'),
					r.geometry.computeBoundingSphere(),
					r
				);
			}
			return (
				ut(e, t),
				(e.prototype.updateMatrixWorld = function (e) {
					var n = this.box;
					n.isEmpty() ||
						(n.getCenter(this.position),
						n.getSize(this.scale),
						this.scale.multiplyScalar(0.5),
						t.prototype.updateMatrixWorld.call(this, e));
				}),
				e
			);
		})(to),
		qu = (function (t) {
			function e(e, n, r) {
				var i,
					a = void 0 !== r ? r : 16776960,
					o = new vn();
				o.setAttribute(
					'position',
					new an(
						[
							1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
							-1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
						],
						3
					)
				),
					o.computeBoundingSphere(),
					((i =
						t.call(this, o, new ja({ color: a, toneMapped: !1 })) ||
						this).type = 'PlaneHelper'),
					(i.plane = e),
					(i.size = void 0 === n ? 1 : n);
				var s = new vn();
				return (
					s.setAttribute(
						'position',
						new an(
							[1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
							3
						)
					),
					s.computeBoundingSphere(),
					i.add(
						new Nn(
							s,
							new Xe({
								color: a,
								opacity: 0.2,
								transparent: !0,
								depthWrite: !1,
								toneMapped: !1,
							})
						)
					),
					i
				);
			}
			return (
				ut(e, t),
				(e.prototype.updateMatrixWorld = function (e) {
					var n = -this.plane.constant;
					Math.abs(n) < 1e-8 && (n = 1e-8),
						this.scale.set(0.5 * this.size, 0.5 * this.size, n),
						(this.children[0].material.side = n < 0 ? 1 : 0),
						this.lookAt(this.plane.normal),
						t.prototype.updateMatrixWorld.call(this, e);
				}),
				e
			);
		})(Qa),
		Xu = new wt(),
		Yu = (function (t) {
			function e(e, n, r, i, a, o) {
				var s;
				return (
					((s = t.call(this) || this).type = 'ArrowHelper'),
					void 0 === e && (e = new wt(0, 0, 1)),
					void 0 === n && (n = new wt(0, 0, 0)),
					void 0 === r && (r = 1),
					void 0 === i && (i = 16776960),
					void 0 === a && (a = 0.2 * r),
					void 0 === o && (o = 0.2 * a),
					void 0 === Uu &&
						((Uu = new vn()).setAttribute(
							'position',
							new an([0, 0, 0, 0, 1, 0], 3)
						),
						(Hu = new wo(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
					s.position.copy(n),
					(s.line = new Qa(Uu, new ja({ color: i, toneMapped: !1 }))),
					(s.line.matrixAutoUpdate = !1),
					s.add(s.line),
					(s.cone = new Nn(Hu, new Xe({ color: i, toneMapped: !1 }))),
					(s.cone.matrixAutoUpdate = !1),
					s.add(s.cone),
					s.setDirection(e),
					s.setLength(r, a, o),
					s
				);
			}
			ut(e, t);
			var n = e.prototype;
			return (
				(n.setDirection = function (t) {
					if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
					else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
					else {
						Xu.set(t.z, 0, -t.x).normalize();
						var e = Math.acos(t.y);
						this.quaternion.setFromAxisAngle(Xu, e);
					}
				}),
				(n.setLength = function (t, e, n) {
					void 0 === e && (e = 0.2 * t),
						void 0 === n && (n = 0.2 * e),
						this.line.scale.set(1, Math.max(1e-4, t - e), 1),
						this.line.updateMatrix(),
						this.cone.scale.set(n, e, n),
						(this.cone.position.y = t),
						this.cone.updateMatrix();
				}),
				(n.setColor = function (t) {
					this.line.material.color.set(t), this.cone.material.color.set(t);
				}),
				(n.copy = function (e) {
					return (
						t.prototype.copy.call(this, e, !1),
						this.line.copy(e.line),
						this.cone.copy(e.cone),
						this
					);
				}),
				e
			);
		})(be),
		Zu = (function (t) {
			function e(e) {
				var n;
				void 0 === e && (e = 1);
				var r = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
					i = new vn();
				i.setAttribute('position', new an(r, 3)),
					i.setAttribute(
						'color',
						new an(
							[1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
							3
						)
					);
				var a = new ja({ vertexColors: !0, toneMapped: !1 });
				return ((n = t.call(this, i, a) || this).type = 'AxesHelper'), n;
			}
			return ut(e, t), e;
		})(to),
		Ju = Math.pow(2, 8),
		Qu = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
		Ku = 5 + Qu.length,
		$u = 20,
		th =
			(((ku = {})[3e3] = 0),
			(ku[3001] = 1),
			(ku[3002] = 2),
			(ku[3004] = 3),
			(ku[3005] = 4),
			(ku[3006] = 5),
			(ku[3007] = 6),
			ku),
		eh = new $c(),
		nh = dh(),
		rh = nh._lodPlanes,
		ih = nh._sizeLods,
		ah = nh._sigmas,
		oh = null,
		sh = (1 + Math.sqrt(5)) / 2,
		ch = 1 / sh,
		lh = [
			new wt(1, 1, 1),
			new wt(-1, 1, 1),
			new wt(1, 1, -1),
			new wt(-1, 1, -1),
			new wt(0, sh, ch),
			new wt(0, sh, -ch),
			new wt(ch, 0, sh),
			new wt(-ch, 0, sh),
			new wt(sh, ch, 0),
			new wt(-sh, ch, 0),
		],
		uh = (function () {
			function t(t) {
				var e, n, r;
				(this._renderer = t),
					(this._pingPongRenderTarget = null),
					(this._blurMaterial =
						((e = $u),
						(n = new Float32Array(e)),
						(r = new wt(0, 1, 0)),
						new Us({
							name: 'SphericalGaussianBlur',
							defines: { n: e },
							uniforms: {
								envMap: { value: null },
								samples: { value: 1 },
								weights: { value: n },
								latitudinal: { value: !1 },
								dTheta: { value: 0 },
								mipInt: { value: 0 },
								poleAxis: { value: r },
								inputEncoding: { value: th[3e3] },
								outputEncoding: { value: th[3e3] },
							},
							vertexShader:
								'\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
							fragmentShader:
								"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
							blending: 0,
							depthTest: !1,
							depthWrite: !1,
						}))),
					(this._equirectShader = null),
					(this._cubemapShader = null),
					this._compileMaterial(this._blurMaterial);
			}
			var e = t.prototype;
			return (
				(e.fromScene = function (t, e, n, r) {
					void 0 === e && (e = 0),
						void 0 === n && (n = 0.1),
						void 0 === r && (r = 100),
						(oh = this._renderer.getRenderTarget());
					var i = this._allocateTargets();
					return (
						this._sceneToCubeUV(t, n, r, i),
						e > 0 && this._blur(i, 0, 0, e),
						this._applyPMREM(i),
						this._cleanup(i),
						i
					);
				}),
				(e.fromEquirectangular = function (t) {
					return this._fromTexture(t);
				}),
				(e.fromCubemap = function (t) {
					return this._fromTexture(t);
				}),
				(e.compileCubemapShader = function () {
					null === this._cubemapShader &&
						((this._cubemapShader = vh()),
						this._compileMaterial(this._cubemapShader));
				}),
				(e.compileEquirectangularShader = function () {
					null === this._equirectShader &&
						((this._equirectShader = mh()),
						this._compileMaterial(this._equirectShader));
				}),
				(e.dispose = function () {
					this._blurMaterial.dispose(),
						null !== this._cubemapShader && this._cubemapShader.dispose(),
						null !== this._equirectShader && this._equirectShader.dispose();
					for (var t = 0; t < rh.length; t++) rh[t].dispose();
				}),
				(e._cleanup = function (t) {
					this._pingPongRenderTarget.dispose(),
						this._renderer.setRenderTarget(oh),
						(t.scissorTest = !1),
						fh(t, 0, 0, t.width, t.height);
				}),
				(e._fromTexture = function (t) {
					oh = this._renderer.getRenderTarget();
					var e = this._allocateTargets(t);
					return (
						this._textureToCubeUV(t, e),
						this._applyPMREM(e),
						this._cleanup(e),
						e
					);
				}),
				(e._allocateTargets = function (t) {
					var e = {
							magFilter: d,
							minFilter: d,
							generateMipmaps: !1,
							type: y,
							format: 1023,
							encoding: hh(t) ? t.encoding : Z,
							depthBuffer: !1,
						},
						n = ph(e);
					return (n.depthBuffer = !t), (this._pingPongRenderTarget = ph(e)), n;
				}),
				(e._compileMaterial = function (t) {
					var e = new Nn(rh[0], t);
					this._renderer.compile(e, eh);
				}),
				(e._sceneToCubeUV = function (t, e, n, r) {
					var i = new Vn(90, 1, e, n),
						a = [1, -1, 1, 1, 1, 1],
						o = [1, 1, 1, -1, -1, -1],
						s = this._renderer,
						c = s.outputEncoding,
						l = s.toneMapping,
						u = s.getClearColor(),
						h = s.getClearAlpha();
					(s.toneMapping = 0), (s.outputEncoding = q);
					var d = t.background;
					if (d && d.isColor) {
						d.convertSRGBToLinear();
						var p = Math.max(d.r, d.g, d.b),
							f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127);
						d = d.multiplyScalar(Math.pow(2, -f));
						var m = (f + 128) / 255;
						s.setClearColor(d, m), (t.background = null);
					}
					for (var v = 0; v < 6; v++) {
						var g = v % 3;
						0 == g
							? (i.up.set(0, a[v], 0), i.lookAt(o[v], 0, 0))
							: 1 == g
							? (i.up.set(0, 0, a[v]), i.lookAt(0, o[v], 0))
							: (i.up.set(0, a[v], 0), i.lookAt(0, 0, o[v])),
							fh(r, g * Ju, v > 2 ? Ju : 0, Ju, Ju),
							s.setRenderTarget(r),
							s.render(t, i);
					}
					(s.toneMapping = l), (s.outputEncoding = c), s.setClearColor(u, h);
				}),
				(e._textureToCubeUV = function (t, e) {
					var n = this._renderer;
					t.isCubeTexture
						? null == this._cubemapShader && (this._cubemapShader = vh())
						: null == this._equirectShader && (this._equirectShader = mh());
					var r = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
						i = new Nn(rh[0], r),
						a = r.uniforms;
					(a.envMap.value = t),
						t.isCubeTexture ||
							a.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
						(a.inputEncoding.value = th[t.encoding]),
						(a.outputEncoding.value = th[e.texture.encoding]),
						fh(e, 0, 0, 3 * Ju, 2 * Ju),
						n.setRenderTarget(e),
						n.render(i, eh);
				}),
				(e._applyPMREM = function (t) {
					var e = this._renderer,
						n = e.autoClear;
					e.autoClear = !1;
					for (var r = 1; r < Ku; r++) {
						var i = Math.sqrt(ah[r] * ah[r] - ah[r - 1] * ah[r - 1]),
							a = lh[(r - 1) % lh.length];
						this._blur(t, r - 1, r, i, a);
					}
					e.autoClear = n;
				}),
				(e._blur = function (t, e, n, r, i) {
					var a = this._pingPongRenderTarget;
					this._halfBlur(t, a, e, n, r, 'latitudinal', i),
						this._halfBlur(a, t, n, n, r, 'longitudinal', i);
				}),
				(e._halfBlur = function (t, e, n, r, i, a, o) {
					var s = this._renderer,
						c = this._blurMaterial;
					'latitudinal' !== a &&
						'longitudinal' !== a &&
						console.error(
							'blur direction must be either latitudinal or longitudinal!'
						);
					var l = new Nn(rh[r], c),
						u = c.uniforms,
						h = ih[n] - 1,
						d = isFinite(i) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
						p = i / d,
						f = isFinite(i) ? 1 + Math.floor(3 * p) : $u;
					f > $u &&
						console.warn(
							'sigmaRadians, ' +
								i +
								', is too large and will clip, as it requested ' +
								f +
								' samples when the maximum is set to ' +
								$u
						);
					for (var m = [], v = 0, g = 0; g < $u; ++g) {
						var y = g / p,
							x = Math.exp((-y * y) / 2);
						m.push(x), 0 == g ? (v += x) : g < f && (v += 2 * x);
					}
					for (var _ = 0; _ < m.length; _++) m[_] = m[_] / v;
					(u.envMap.value = t.texture),
						(u.samples.value = f),
						(u.weights.value = m),
						(u.latitudinal.value = 'latitudinal' === a),
						o && (u.poleAxis.value = o),
						(u.dTheta.value = d),
						(u.mipInt.value = 8 - n),
						(u.inputEncoding.value = th[t.texture.encoding]),
						(u.outputEncoding.value = th[t.texture.encoding]);
					var b = ih[r];
					fh(
						e,
						3 * Math.max(0, Ju - 2 * b),
						(0 === r ? 0 : 2 * Ju) + 2 * b * (r > 4 ? r - 8 + 4 : 0),
						3 * b,
						2 * b
					),
						s.setRenderTarget(e),
						s.render(l, eh);
				}),
				t
			);
		})();
	function hh(t) {
		return (
			void 0 !== t &&
			t.type === y &&
			(t.encoding === q || t.encoding === X || t.encoding === Y)
		);
	}
	function dh() {
		for (var t = [], e = [], n = [], r = 8, i = 0; i < Ku; i++) {
			var a = Math.pow(2, r);
			e.push(a);
			var o = 1 / a;
			i > 4 ? (o = Qu[i - 8 + 4 - 1]) : 0 == i && (o = 0), n.push(o);
			for (
				var s = 1 / (a - 1),
					c = -s / 2,
					l = 1 + s / 2,
					u = [c, c, l, c, l, l, c, c, l, l, c, l],
					h = new Float32Array(108),
					d = new Float32Array(72),
					p = new Float32Array(36),
					f = 0;
				f < 6;
				f++
			) {
				var m = ((f % 3) * 2) / 3 - 1,
					v = f > 2 ? 0 : -1,
					g = [
						m,
						v,
						0,
						m + 2 / 3,
						v,
						0,
						m + 2 / 3,
						v + 1,
						0,
						m,
						v,
						0,
						m + 2 / 3,
						v + 1,
						0,
						m,
						v + 1,
						0,
					];
				h.set(g, 18 * f), d.set(u, 12 * f);
				var y = [f, f, f, f, f, f];
				p.set(y, 6 * f);
			}
			var x = new vn();
			x.setAttribute('position', new Je(h, 3)),
				x.setAttribute('uv', new Je(d, 2)),
				x.setAttribute('faceIndex', new Je(p, 1)),
				t.push(x),
				r > 4 && r--;
		}
		return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
	}
	function ph(t) {
		var e = new xt(3 * Ju, 3 * Ju, t);
		return (
			(e.texture.mapping = s),
			(e.texture.name = 'PMREM.cubeUv'),
			(e.scissorTest = !0),
			e
		);
	}
	function fh(t, e, n, r, i) {
		t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
	}
	function mh() {
		return new Us({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				envMap: { value: null },
				texelSize: { value: new pt(1, 1) },
				inputEncoding: { value: th[3e3] },
				outputEncoding: { value: th[3e3] },
			},
			vertexShader:
				'\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
			fragmentShader:
				'\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
			blending: 0,
			depthTest: !1,
			depthWrite: !1,
		});
	}
	function vh() {
		return new Us({
			name: 'CubemapToCubeUV',
			uniforms: {
				envMap: { value: null },
				inputEncoding: { value: th[3e3] },
				outputEncoding: { value: th[3e3] },
			},
			vertexShader:
				'\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
			fragmentShader:
				'\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
			blending: 0,
			depthTest: !1,
			depthWrite: !1,
		});
	}
	function gh(t) {
		console.warn(
			'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'
		),
			Pc.call(this, t),
			(this.type = 'catmullrom'),
			(this.closed = !0);
	}
	function yh(t) {
		console.warn(
			'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'
		),
			Pc.call(this, t),
			(this.type = 'catmullrom');
	}
	function xh(t) {
		console.warn(
			'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.'
		),
			Pc.call(this, t),
			(this.type = 'catmullrom');
	}
	(Mc.create = function (t, e) {
		return (
			console.log('THREE.Curve.create() has been deprecated'),
			(t.prototype = Object.create(Mc.prototype)),
			(t.prototype.constructor = t),
			(t.prototype.getPoint = e),
			t
		);
	}),
		Object.assign(Vc.prototype, {
			createPointsGeometry: function (t) {
				console.warn(
					'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
				);
				var e = this.getPoints(t);
				return this.createGeometry(e);
			},
			createSpacedPointsGeometry: function (t) {
				console.warn(
					'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
				);
				var e = this.getSpacedPoints(t);
				return this.createGeometry(e);
			},
			createGeometry: function (t) {
				console.warn(
					'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
				);
				for (var e = new yo(), n = 0, r = t.length; n < r; n++) {
					var i = t[n];
					e.vertices.push(new wt(i.x, i.y, i.z || 0));
				}
				return e;
			},
		}),
		Object.assign(Wc.prototype, {
			fromPoints: function (t) {
				return (
					console.warn(
						'THREE.Path: .fromPoints() has been renamed to .setFromPoints().'
					),
					this.setFromPoints(t)
				);
			},
		}),
		(gh.prototype = Object.create(Pc.prototype)),
		(yh.prototype = Object.create(Pc.prototype)),
		(xh.prototype = Object.create(Pc.prototype)),
		Object.assign(xh.prototype, {
			initFromArray: function () {
				console.error('THREE.Spline: .initFromArray() has been removed.');
			},
			getControlPointsArray: function () {
				console.error(
					'THREE.Spline: .getControlPointsArray() has been removed.'
				);
			},
			reparametrizeByArcLength: function () {
				console.error(
					'THREE.Spline: .reparametrizeByArcLength() has been removed.'
				);
			},
		}),
		(Cu.prototype.setColors = function () {
			console.error(
				'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.'
			);
		}),
		(Mu.prototype.update = function () {
			console.error(
				'THREE.SkeletonHelper: update() no longer needs to be called.'
			);
		}),
		Object.assign(fc.prototype, {
			extractUrlBase: function (t) {
				return (
					console.warn(
						'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.'
					),
					sl.extractUrlBase(t)
				);
			},
		}),
		(fc.Handlers = {
			add: function () {
				console.error(
					'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.'
				);
			},
			get: function () {
				console.error(
					'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.'
				);
			},
		}),
		Object.assign(pu.prototype, {
			center: function (t) {
				return (
					console.warn(
						'THREE.Box2: .center() has been renamed to .getCenter().'
					),
					this.getCenter(t)
				);
			},
			empty: function () {
				return (
					console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().'),
					this.isEmpty()
				);
			},
			isIntersectionBox: function (t) {
				return (
					console.warn(
						'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().'
					),
					this.intersectsBox(t)
				);
			},
			size: function (t) {
				return (
					console.warn('THREE.Box2: .size() has been renamed to .getSize().'),
					this.getSize(t)
				);
			},
		}),
		Object.assign(Tt.prototype, {
			center: function (t) {
				return (
					console.warn(
						'THREE.Box3: .center() has been renamed to .getCenter().'
					),
					this.getCenter(t)
				);
			},
			empty: function () {
				return (
					console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'),
					this.isEmpty()
				);
			},
			isIntersectionBox: function (t) {
				return (
					console.warn(
						'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'
					),
					this.intersectsBox(t)
				);
			},
			isIntersectionSphere: function (t) {
				return (
					console.warn(
						'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'
					),
					this.intersectsSphere(t)
				);
			},
			size: function (t) {
				return (
					console.warn('THREE.Box3: .size() has been renamed to .getSize().'),
					this.getSize(t)
				);
			},
		}),
		Object.assign(Ht.prototype, {
			empty: function () {
				return (
					console.warn(
						'THREE.Sphere: .empty() has been renamed to .isEmpty().'
					),
					this.isEmpty()
				);
			},
		}),
		(Qn.prototype.setFromMatrix = function (t) {
			return (
				console.warn(
					'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().'
				),
				this.setFromProjectionMatrix(t)
			);
		}),
		(vu.prototype.center = function (t) {
			return (
				console.warn(
					'THREE.Line3: .center() has been renamed to .getCenter().'
				),
				this.getCenter(t)
			);
		}),
		Object.assign(st, {
			random16: function () {
				return (
					console.warn(
						'THREE.Math: .random16() has been deprecated. Use Math.random() instead.'
					),
					Math.random()
				);
			},
			nearestPowerOfTwo: function (t) {
				return (
					console.warn(
						'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().'
					),
					st.floorPowerOfTwo(t)
				);
			},
			nextPowerOfTwo: function (t) {
				return (
					console.warn(
						'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().'
					),
					st.ceilPowerOfTwo(t)
				);
			},
		}),
		Object.assign(ft.prototype, {
			flattenToArrayOffset: function (t, e) {
				return (
					console.warn(
						'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
					),
					this.toArray(t, e)
				);
			},
			multiplyVector3: function (t) {
				return (
					console.warn(
						'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.'
					),
					t.applyMatrix3(this)
				);
			},
			multiplyVector3Array: function () {
				console.error(
					'THREE.Matrix3: .multiplyVector3Array() has been removed.'
				);
			},
			applyToBufferAttribute: function (t) {
				return (
					console.warn(
						'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.'
					),
					t.applyMatrix3(this)
				);
			},
			applyToVector3Array: function () {
				console.error(
					'THREE.Matrix3: .applyToVector3Array() has been removed.'
				);
			},
		}),
		Object.assign(Jt.prototype, {
			extractPosition: function (t) {
				return (
					console.warn(
						'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'
					),
					this.copyPosition(t)
				);
			},
			flattenToArrayOffset: function (t, e) {
				return (
					console.warn(
						'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
					),
					this.toArray(t, e)
				);
			},
			getPosition: function () {
				return (
					console.warn(
						'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.'
					),
					new wt().setFromMatrixColumn(this, 3)
				);
			},
			setRotationFromQuaternion: function (t) {
				return (
					console.warn(
						'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().'
					),
					this.makeRotationFromQuaternion(t)
				);
			},
			multiplyToArray: function () {
				console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
			},
			multiplyVector3: function (t) {
				return (
					console.warn(
						'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.'
					),
					t.applyMatrix4(this)
				);
			},
			multiplyVector4: function (t) {
				return (
					console.warn(
						'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.'
					),
					t.applyMatrix4(this)
				);
			},
			multiplyVector3Array: function () {
				console.error(
					'THREE.Matrix4: .multiplyVector3Array() has been removed.'
				);
			},
			rotateAxis: function (t) {
				console.warn(
					'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.'
				),
					t.transformDirection(this);
			},
			crossVector: function (t) {
				return (
					console.warn(
						'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.'
					),
					t.applyMatrix4(this)
				);
			},
			translate: function () {
				console.error('THREE.Matrix4: .translate() has been removed.');
			},
			rotateX: function () {
				console.error('THREE.Matrix4: .rotateX() has been removed.');
			},
			rotateY: function () {
				console.error('THREE.Matrix4: .rotateY() has been removed.');
			},
			rotateZ: function () {
				console.error('THREE.Matrix4: .rotateZ() has been removed.');
			},
			rotateByAxis: function () {
				console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
			},
			applyToBufferAttribute: function (t) {
				return (
					console.warn(
						'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.'
					),
					t.applyMatrix4(this)
				);
			},
			applyToVector3Array: function () {
				console.error(
					'THREE.Matrix4: .applyToVector3Array() has been removed.'
				);
			},
			makeFrustum: function (t, e, n, r, i, a) {
				return (
					console.warn(
						'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.'
					),
					this.makePerspective(t, e, r, n, i, a)
				);
			},
		}),
		(Te.prototype.isIntersectionLine = function (t) {
			return (
				console.warn(
					'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'
				),
				this.intersectsLine(t)
			);
		}),
		(bt.prototype.multiplyVector3 = function (t) {
			return (
				console.warn(
					'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.'
				),
				t.applyQuaternion(this)
			);
		}),
		Object.assign(Zt.prototype, {
			isIntersectionBox: function (t) {
				return (
					console.warn(
						'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'
					),
					this.intersectsBox(t)
				);
			},
			isIntersectionPlane: function (t) {
				return (
					console.warn(
						'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'
					),
					this.intersectsPlane(t)
				);
			},
			isIntersectionSphere: function (t) {
				return (
					console.warn(
						'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'
					),
					this.intersectsSphere(t)
				);
			},
		}),
		Object.assign(Be.prototype, {
			area: function () {
				return (
					console.warn(
						'THREE.Triangle: .area() has been renamed to .getArea().'
					),
					this.getArea()
				);
			},
			barycoordFromPoint: function (t, e) {
				return (
					console.warn(
						'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'
					),
					this.getBarycoord(t, e)
				);
			},
			midpoint: function (t) {
				return (
					console.warn(
						'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'
					),
					this.getMidpoint(t)
				);
			},
			normal: function (t) {
				return (
					console.warn(
						'THREE.Triangle: .normal() has been renamed to .getNormal().'
					),
					this.getNormal(t)
				);
			},
			plane: function (t) {
				return (
					console.warn(
						'THREE.Triangle: .plane() has been renamed to .getPlane().'
					),
					this.getPlane(t)
				);
			},
		}),
		Object.assign(Be, {
			barycoordFromPoint: function (t, e, n, r, i) {
				return (
					console.warn(
						'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'
					),
					Be.getBarycoord(t, e, n, r, i)
				);
			},
			normal: function (t, e, n, r) {
				return (
					console.warn(
						'THREE.Triangle: .normal() has been renamed to .getNormal().'
					),
					Be.getNormal(t, e, n, r)
				);
			},
		}),
		Object.assign(jc.prototype, {
			extractAllPoints: function (t) {
				return (
					console.warn(
						'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.'
					),
					this.extractPoints(t)
				);
			},
			extrude: function (t) {
				return (
					console.warn(
						'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'
					),
					new us(this, t)
				);
			},
			makeGeometry: function (t) {
				return (
					console.warn(
						'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'
					),
					new Ss(this, t)
				);
			},
		}),
		Object.assign(pt.prototype, {
			fromAttribute: function (t, e, n) {
				return (
					console.warn(
						'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'
					),
					this.fromBufferAttribute(t, e, n)
				);
			},
			distanceToManhattan: function (t) {
				return (
					console.warn(
						'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
					),
					this.manhattanDistanceTo(t)
				);
			},
			lengthManhattan: function () {
				return (
					console.warn(
						'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'
					),
					this.manhattanLength()
				);
			},
		}),
		Object.assign(wt.prototype, {
			setEulerFromRotationMatrix: function () {
				console.error(
					'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.'
				);
			},
			setEulerFromQuaternion: function () {
				console.error(
					'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.'
				);
			},
			getPositionFromMatrix: function (t) {
				return (
					console.warn(
						'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().'
					),
					this.setFromMatrixPosition(t)
				);
			},
			getScaleFromMatrix: function (t) {
				return (
					console.warn(
						'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'
					),
					this.setFromMatrixScale(t)
				);
			},
			getColumnFromMatrix: function (t, e) {
				return (
					console.warn(
						'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().'
					),
					this.setFromMatrixColumn(e, t)
				);
			},
			applyProjection: function (t) {
				return (
					console.warn(
						'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.'
					),
					this.applyMatrix4(t)
				);
			},
			fromAttribute: function (t, e, n) {
				return (
					console.warn(
						'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'
					),
					this.fromBufferAttribute(t, e, n)
				);
			},
			distanceToManhattan: function (t) {
				return (
					console.warn(
						'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
					),
					this.manhattanDistanceTo(t)
				);
			},
			lengthManhattan: function () {
				return (
					console.warn(
						'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'
					),
					this.manhattanLength()
				);
			},
		}),
		Object.assign(yt.prototype, {
			fromAttribute: function (t, e, n) {
				return (
					console.warn(
						'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'
					),
					this.fromBufferAttribute(t, e, n)
				);
			},
			lengthManhattan: function () {
				return (
					console.warn(
						'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'
					),
					this.manhattanLength()
				);
			},
		}),
		Object.assign(yo.prototype, {
			computeTangents: function () {
				console.error('THREE.Geometry: .computeTangents() has been removed.');
			},
			computeLineDistances: function () {
				console.error(
					'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.'
				);
			},
			applyMatrix: function (t) {
				return (
					console.warn(
						'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().'
					),
					this.applyMatrix4(t)
				);
			},
		}),
		Object.assign(be.prototype, {
			getChildByName: function (t) {
				return (
					console.warn(
						'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'
					),
					this.getObjectByName(t)
				);
			},
			renderDepth: function () {
				console.warn(
					'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.'
				);
			},
			translate: function (t, e) {
				return (
					console.warn(
						'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.'
					),
					this.translateOnAxis(e, t)
				);
			},
			getWorldRotation: function () {
				console.error(
					'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.'
				);
			},
			applyMatrix: function (t) {
				return (
					console.warn(
						'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().'
					),
					this.applyMatrix4(t)
				);
			},
		}),
		Object.defineProperties(be.prototype, {
			eulerOrder: {
				get: function () {
					return (
						console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
						this.rotation.order
					);
				},
				set: function (t) {
					console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
						(this.rotation.order = t);
				},
			},
			useQuaternion: {
				get: function () {
					console.warn(
						'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
					);
				},
				set: function () {
					console.warn(
						'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
					);
				},
			},
		}),
		Object.assign(Nn.prototype, {
			setDrawMode: function () {
				console.error(
					'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
				);
			},
		}),
		Object.defineProperties(Nn.prototype, {
			drawMode: {
				get: function () {
					return (
						console.error(
							'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.'
						),
						0
					);
				},
				set: function () {
					console.error(
						'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
					);
				},
			},
		}),
		Object.defineProperties(Na.prototype, {
			objects: {
				get: function () {
					return (
						console.warn('THREE.LOD: .objects has been renamed to .levels.'),
						this.levels
					);
				},
			},
		}),
		Object.defineProperty(Ga.prototype, 'useVertexTexture', {
			get: function () {
				console.warn('THREE.Skeleton: useVertexTexture has been removed.');
			},
			set: function () {
				console.warn('THREE.Skeleton: useVertexTexture has been removed.');
			},
		}),
		(Oa.prototype.initBones = function () {
			console.error('THREE.SkinnedMesh: initBones() has been removed.');
		}),
		Object.defineProperty(Mc.prototype, '__arcLengthDivisions', {
			get: function () {
				return (
					console.warn(
						'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'
					),
					this.arcLengthDivisions
				);
			},
			set: function (t) {
				console.warn(
					'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'
				),
					(this.arcLengthDivisions = t);
			},
		}),
		(Vn.prototype.setLens = function (t, e) {
			console.warn(
				'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.'
			),
				void 0 !== e && (this.filmGauge = e),
				this.setFocalLength(t);
		}),
		Object.defineProperties(qc.prototype, {
			onlyShadow: {
				set: function () {
					console.warn('THREE.Light: .onlyShadow has been removed.');
				},
			},
			shadowCameraFov: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'
					),
						(this.shadow.camera.fov = t);
				},
			},
			shadowCameraLeft: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'
					),
						(this.shadow.camera.left = t);
				},
			},
			shadowCameraRight: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraRight is now .shadow.camera.right.'
					),
						(this.shadow.camera.right = t);
				},
			},
			shadowCameraTop: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraTop is now .shadow.camera.top.'
					),
						(this.shadow.camera.top = t);
				},
			},
			shadowCameraBottom: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'
					),
						(this.shadow.camera.bottom = t);
				},
			},
			shadowCameraNear: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraNear is now .shadow.camera.near.'
					),
						(this.shadow.camera.near = t);
				},
			},
			shadowCameraFar: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowCameraFar is now .shadow.camera.far.'
					),
						(this.shadow.camera.far = t);
				},
			},
			shadowCameraVisible: {
				set: function () {
					console.warn(
						'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.'
					);
				},
			},
			shadowBias: {
				set: function (t) {
					console.warn('THREE.Light: .shadowBias is now .shadow.bias.'),
						(this.shadow.bias = t);
				},
			},
			shadowDarkness: {
				set: function () {
					console.warn('THREE.Light: .shadowDarkness has been removed.');
				},
			},
			shadowMapWidth: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'
					),
						(this.shadow.mapSize.width = t);
				},
			},
			shadowMapHeight: {
				set: function (t) {
					console.warn(
						'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'
					),
						(this.shadow.mapSize.height = t);
				},
			},
		}),
		Object.defineProperties(Je.prototype, {
			length: {
				get: function () {
					return (
						console.warn(
							'THREE.BufferAttribute: .length has been deprecated. Use .count instead.'
						),
						this.array.length
					);
				},
			},
			dynamic: {
				get: function () {
					return (
						console.warn(
							'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'
						),
						this.usage === et
					);
				},
				set: function () {
					console.warn(
						'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'
					),
						this.setUsage(et);
				},
			},
		}),
		Object.assign(Je.prototype, {
			setDynamic: function (t) {
				return (
					console.warn(
						'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.'
					),
					this.setUsage(!0 === t ? et : tt),
					this
				);
			},
			copyIndicesArray: function () {
				console.error(
					'THREE.BufferAttribute: .copyIndicesArray() has been removed.'
				);
			},
			setArray: function () {
				console.error(
					'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
				);
			},
		}),
		Object.assign(vn.prototype, {
			addIndex: function (t) {
				console.warn(
					'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'
				),
					this.setIndex(t);
			},
			addAttribute: function (t, e) {
				return (
					console.warn(
						'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().'
					),
					(e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
						? 'index' === t
							? (console.warn(
									'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'
							  ),
							  this.setIndex(e),
							  this)
							: this.setAttribute(t, e)
						: (console.warn(
								'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'
						  ),
						  this.setAttribute(t, new Je(arguments[1], arguments[2])))
				);
			},
			addDrawCall: function (t, e, n) {
				void 0 !== n &&
					console.warn(
						'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'
					),
					console.warn(
						'THREE.BufferGeometry: .addDrawCall() is now .addGroup().'
					),
					this.addGroup(t, e);
			},
			clearDrawCalls: function () {
				console.warn(
					'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'
				),
					this.clearGroups();
			},
			computeTangents: function () {
				console.warn(
					'THREE.BufferGeometry: .computeTangents() has been removed.'
				);
			},
			computeOffsets: function () {
				console.warn(
					'THREE.BufferGeometry: .computeOffsets() has been removed.'
				);
			},
			removeAttribute: function (t) {
				return (
					console.warn(
						'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().'
					),
					this.deleteAttribute(t)
				);
			},
			applyMatrix: function (t) {
				return (
					console.warn(
						'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().'
					),
					this.applyMatrix4(t)
				);
			},
		}),
		Object.defineProperties(vn.prototype, {
			drawcalls: {
				get: function () {
					return (
						console.error(
							'THREE.BufferGeometry: .drawcalls has been renamed to .groups.'
						),
						this.groups
					);
				},
			},
			offsets: {
				get: function () {
					return (
						console.warn(
							'THREE.BufferGeometry: .offsets has been renamed to .groups.'
						),
						this.groups
					);
				},
			},
		}),
		Object.defineProperties(cl.prototype, {
			maxInstancedCount: {
				get: function () {
					return (
						console.warn(
							'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.'
						),
						this.instanceCount
					);
				},
				set: function (t) {
					console.warn(
						'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.'
					),
						(this.instanceCount = t);
				},
			},
		}),
		Object.defineProperties(su.prototype, {
			linePrecision: {
				get: function () {
					return (
						console.warn(
							'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.'
						),
						this.params.Line.threshold
					);
				},
				set: function (t) {
					console.warn(
						'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.'
					),
						(this.params.Line.threshold = t);
				},
			},
		}),
		Object.defineProperties(ca.prototype, {
			dynamic: {
				get: function () {
					return (
						console.warn(
							'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.'
						),
						this.usage === et
					);
				},
				set: function (t) {
					console.warn(
						'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.'
					),
						this.setUsage(t);
				},
			},
		}),
		Object.assign(ca.prototype, {
			setDynamic: function (t) {
				return (
					console.warn(
						'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.'
					),
					this.setUsage(!0 === t ? et : tt),
					this
				);
			},
			setArray: function () {
				console.error(
					'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
				);
			},
		}),
		Object.assign(cs.prototype, {
			getArrays: function () {
				console.error(
					'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.'
				);
			},
			addShapeList: function () {
				console.error(
					'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.'
				);
			},
			addShape: function () {
				console.error(
					'THREE.ExtrudeBufferGeometry: .addShape() has been removed.'
				);
			},
		}),
		Object.assign(sa.prototype, {
			dispose: function () {
				console.error('THREE.Scene: .dispose() has been removed.');
			},
		}),
		Object.defineProperties(iu.prototype, {
			dynamic: {
				set: function () {
					console.warn(
						'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.'
					);
				},
			},
			onUpdate: {
				value: function () {
					return (
						console.warn(
							'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.'
						),
						this
					);
				},
			},
		}),
		Object.defineProperties(qe.prototype, {
			wrapAround: {
				get: function () {
					console.warn('THREE.Material: .wrapAround has been removed.');
				},
				set: function () {
					console.warn('THREE.Material: .wrapAround has been removed.');
				},
			},
			overdraw: {
				get: function () {
					console.warn('THREE.Material: .overdraw has been removed.');
				},
				set: function () {
					console.warn('THREE.Material: .overdraw has been removed.');
				},
			},
			wrapRGB: {
				get: function () {
					return (
						console.warn('THREE.Material: .wrapRGB has been removed.'), new Ve()
					);
				},
			},
			shading: {
				get: function () {
					console.error(
						'THREE.' +
							this.type +
							': .shading has been removed. Use the boolean .flatShading instead.'
					);
				},
				set: function (t) {
					console.warn(
						'THREE.' +
							this.type +
							': .shading has been removed. Use the boolean .flatShading instead.'
					),
						(this.flatShading = 1 === t);
				},
			},
			stencilMask: {
				get: function () {
					return (
						console.warn(
							'THREE.' +
								this.type +
								': .stencilMask has been removed. Use .stencilFuncMask instead.'
						),
						this.stencilFuncMask
					);
				},
				set: function (t) {
					console.warn(
						'THREE.' +
							this.type +
							': .stencilMask has been removed. Use .stencilFuncMask instead.'
					),
						(this.stencilFuncMask = t);
				},
			},
		}),
		Object.defineProperties(Vs.prototype, {
			metal: {
				get: function () {
					return (
						console.warn(
							'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.'
						),
						!1
					);
				},
				set: function () {
					console.warn(
						'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead'
					);
				},
			},
		}),
		Object.defineProperties(ks.prototype, {
			transparency: {
				get: function () {
					return (
						console.warn(
							'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.'
						),
						this.transmission
					);
				},
				set: function (t) {
					console.warn(
						'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.'
					),
						(this.transmission = t);
				},
			},
		}),
		Object.defineProperties(Hn.prototype, {
			derivatives: {
				get: function () {
					return (
						console.warn(
							'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
						),
						this.extensions.derivatives
					);
				},
				set: function (t) {
					console.warn(
						'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
					),
						(this.extensions.derivatives = t);
				},
			},
		}),
		Object.assign(ra.prototype, {
			clearTarget: function (t, e, n, r) {
				console.warn(
					'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.'
				),
					this.setRenderTarget(t),
					this.clear(e, n, r);
			},
			animate: function (t) {
				console.warn(
					'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'
				),
					this.setAnimationLoop(t);
			},
			getCurrentRenderTarget: function () {
				return (
					console.warn(
						'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'
					),
					this.getRenderTarget()
				);
			},
			getMaxAnisotropy: function () {
				return (
					console.warn(
						'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().'
					),
					this.capabilities.getMaxAnisotropy()
				);
			},
			getPrecision: function () {
				return (
					console.warn(
						'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'
					),
					this.capabilities.precision
				);
			},
			resetGLState: function () {
				return (
					console.warn(
						'THREE.WebGLRenderer: .resetGLState() is now .state.reset().'
					),
					this.state.reset()
				);
			},
			supportsFloatTextures: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
					),
					this.extensions.get('OES_texture_float')
				);
			},
			supportsHalfFloatTextures: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
					),
					this.extensions.get('OES_texture_half_float')
				);
			},
			supportsStandardDerivatives: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
					),
					this.extensions.get('OES_standard_derivatives')
				);
			},
			supportsCompressedTextureS3TC: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
					),
					this.extensions.get('WEBGL_compressed_texture_s3tc')
				);
			},
			supportsCompressedTexturePVRTC: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
					),
					this.extensions.get('WEBGL_compressed_texture_pvrtc')
				);
			},
			supportsBlendMinMax: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
					),
					this.extensions.get('EXT_blend_minmax')
				);
			},
			supportsVertexTextures: function () {
				return (
					console.warn(
						'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.'
					),
					this.capabilities.vertexTextures
				);
			},
			supportsInstancedArrays: function () {
				return (
					console.warn(
						"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
					),
					this.extensions.get('ANGLE_instanced_arrays')
				);
			},
			enableScissorTest: function (t) {
				console.warn(
					'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'
				),
					this.setScissorTest(t);
			},
			initMaterial: function () {
				console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
			},
			addPrePlugin: function () {
				console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
			},
			addPostPlugin: function () {
				console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
			},
			updateShadowMap: function () {
				console.warn(
					'THREE.WebGLRenderer: .updateShadowMap() has been removed.'
				);
			},
			setFaceCulling: function () {
				console.warn(
					'THREE.WebGLRenderer: .setFaceCulling() has been removed.'
				);
			},
			allocTextureUnit: function () {
				console.warn(
					'THREE.WebGLRenderer: .allocTextureUnit() has been removed.'
				);
			},
			setTexture: function () {
				console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
			},
			setTexture2D: function () {
				console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
			},
			setTextureCube: function () {
				console.warn(
					'THREE.WebGLRenderer: .setTextureCube() has been removed.'
				);
			},
			getActiveMipMapLevel: function () {
				return (
					console.warn(
						'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().'
					),
					this.getActiveMipmapLevel()
				);
			},
		}),
		Object.defineProperties(ra.prototype, {
			shadowMapEnabled: {
				get: function () {
					return this.shadowMap.enabled;
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'
					),
						(this.shadowMap.enabled = t);
				},
			},
			shadowMapType: {
				get: function () {
					return this.shadowMap.type;
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'
					),
						(this.shadowMap.type = t);
				},
			},
			shadowMapCullFace: {
				get: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
					);
				},
				set: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
					);
				},
			},
			context: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.'
						),
						this.getContext()
					);
				},
			},
			vr: {
				get: function () {
					return (
						console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr'),
						this.xr
					);
				},
			},
			gammaInput: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
						),
						!1
					);
				},
				set: function () {
					console.warn(
						'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
					);
				},
			},
			gammaOutput: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
						),
						!1
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
					),
						(this.outputEncoding = !0 === t ? X : q);
				},
			},
			toneMappingWhitePoint: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'
						),
						1
					);
				},
				set: function () {
					console.warn(
						'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'
					);
				},
			},
		}),
		Object.defineProperties(Yi.prototype, {
			cullFace: {
				get: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
					);
				},
				set: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
					);
				},
			},
			renderReverseSided: {
				get: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
					);
				},
				set: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
					);
				},
			},
			renderSingleSided: {
				get: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
					);
				},
				set: function () {
					console.warn(
						'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
					);
				},
			},
		}),
		Object.defineProperties(xt.prototype, {
			wrapS: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'
						),
						this.texture.wrapS
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'
					),
						(this.texture.wrapS = t);
				},
			},
			wrapT: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'
						),
						this.texture.wrapT
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'
					),
						(this.texture.wrapT = t);
				},
			},
			magFilter: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'
						),
						this.texture.magFilter
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'
					),
						(this.texture.magFilter = t);
				},
			},
			minFilter: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'
						),
						this.texture.minFilter
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'
					),
						(this.texture.minFilter = t);
				},
			},
			anisotropy: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'
						),
						this.texture.anisotropy
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'
					),
						(this.texture.anisotropy = t);
				},
			},
			offset: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .offset is now .texture.offset.'
						),
						this.texture.offset
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .offset is now .texture.offset.'
					),
						(this.texture.offset = t);
				},
			},
			repeat: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'
						),
						this.texture.repeat
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'
					),
						(this.texture.repeat = t);
				},
			},
			format: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .format is now .texture.format.'
						),
						this.texture.format
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .format is now .texture.format.'
					),
						(this.texture.format = t);
				},
			},
			type: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .type is now .texture.type.'
						),
						this.texture.type
					);
				},
				set: function (t) {
					console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
						(this.texture.type = t);
				},
			},
			generateMipmaps: {
				get: function () {
					return (
						console.warn(
							'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
						),
						this.texture.generateMipmaps
					);
				},
				set: function (t) {
					console.warn(
						'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
					),
						(this.texture.generateMipmaps = t);
				},
			},
		}),
		Object.defineProperties(Ol.prototype, {
			load: {
				value: function (t) {
					console.warn(
						'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.'
					);
					var e = this;
					return (
						new Ml().load(t, function (t) {
							e.setBuffer(t);
						}),
						this
					);
				},
			},
			startTime: {
				set: function () {
					console.warn('THREE.Audio: .startTime is now .play( delay ).');
				},
			},
		}),
		(Hl.prototype.getData = function () {
			return (
				console.warn(
					'THREE.AudioAnalyser: .getData() is now .getFrequencyData().'
				),
				this.getFrequencyData()
			);
		}),
		(jn.prototype.updateCubeMap = function (t, e) {
			return (
				console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'),
				this.update(t, e)
			);
		});
	var _h = {
		merge: function (t, e, n) {
			var r;
			console.warn(
				'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.'
			),
				e.isMesh &&
					(e.matrixAutoUpdate && e.updateMatrix(),
					(r = e.matrix),
					(e = e.geometry)),
				t.merge(e, r, n);
		},
		center: function (t) {
			return (
				console.warn(
					'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.'
				),
				t.center()
			);
		},
	};
	(mt.crossOrigin = void 0),
		(mt.loadTexture = function (t, e, n, r) {
			console.warn(
				'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.'
			);
			var i = new wc();
			i.setCrossOrigin(this.crossOrigin);
			var a = i.load(t, n, void 0, r);
			return e && (a.mapping = e), a;
		}),
		(mt.loadTextureCube = function (t, e, n, r) {
			console.warn(
				'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.'
			);
			var i = new _c();
			i.setCrossOrigin(this.crossOrigin);
			var a = i.load(t, n, void 0, r);
			return e && (a.mapping = e), a;
		}),
		(mt.loadCompressedTexture = function () {
			console.error(
				'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.'
			);
		}),
		(mt.loadCompressedTextureCube = function () {
			console.error(
				'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.'
			);
		});
	var bh = {
		createMultiMaterialObject: function () {
			console.error(
				'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js'
			);
		},
		detach: function () {
			console.error(
				'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js'
			);
		},
		attach: function () {
			console.error(
				'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js'
			);
		},
	};
	'undefined' != typeof __THREE_DEVTOOLS__ &&
		__THREE_DEVTOOLS__.dispatchEvent(
			new CustomEvent('register', { detail: { revision: '121' } })
		),
		(t.ACESFilmicToneMapping = 4),
		(t.AddEquation = e),
		(t.AddOperation = 2),
		(t.AdditiveAnimationBlendMode = j),
		(t.AdditiveBlending = 2),
		(t.AlphaFormat = 1021),
		(t.AlwaysDepth = 1),
		(t.AlwaysStencilFunc = 519),
		(t.AmbientLight = nl),
		(t.AmbientLightProbe = Tl),
		(t.AnimationClip = lc),
		(t.AnimationLoader = gc),
		(t.AnimationMixer = ru),
		(t.AnimationObjectGroup = eu),
		(t.AnimationUtils = Js),
		(t.ArcCurve = Tc),
		(t.ArrayCamera = Ki),
		(t.ArrowHelper = Yu),
		(t.Audio = Ol),
		(t.AudioAnalyser = Hl),
		(t.AudioContext = wl),
		(t.AudioListener = Nl),
		(t.AudioLoader = Ml),
		(t.AxesHelper = Zu),
		(t.AxisHelper = function (t) {
			return (
				console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.'),
				new Zu(t)
			);
		}),
		(t.BackSide = 1),
		(t.BasicDepthPacking = 3200),
		(t.BasicShadowMap = 0),
		(t.BinaryTextureLoader = function (t) {
			return (
				console.warn(
					'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.'
				),
				new bc(t)
			);
		}),
		(t.Bone = Fa),
		(t.BooleanKeyframeTrack = nc),
		(t.BoundingBoxHelper = function (t, e) {
			return (
				console.warn(
					'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.'
				),
				new Wu(t, e)
			);
		}),
		(t.Box2 = pu),
		(t.Box3 = Tt),
		(t.Box3Helper = ju),
		(t.BoxBufferGeometry = zn),
		(t.BoxGeometry = xo),
		(t.BoxHelper = Wu),
		(t.BufferAttribute = Je),
		(t.BufferGeometry = vn),
		(t.BufferGeometryLoader = ul),
		(t.ByteType = 1010),
		(t.Cache = hc),
		(t.Camera = kn),
		(t.CameraHelper = Gu),
		(t.CanvasRenderer = function () {
			console.error('THREE.CanvasRenderer has been removed');
		}),
		(t.CanvasTexture = ho),
		(t.CatmullRomCurve3 = Pc),
		(t.CineonToneMapping = 3),
		(t.CircleBufferGeometry = _o),
		(t.CircleGeometry = bo),
		(t.ClampToEdgeWrapping = u),
		(t.Clock = Rl),
		(t.ClosedSplineCurve3 = gh),
		(t.Color = Ve),
		(t.ColorKeyframeTrack = rc),
		(t.CompressedTexture = uo),
		(t.CompressedTextureLoader = yc),
		(t.ConeBufferGeometry = To),
		(t.ConeGeometry = So),
		(t.CubeCamera = jn),
		(t.CubeGeometry = xo),
		(t.CubeReflectionMapping = r),
		(t.CubeRefractionMapping = i),
		(t.CubeTexture = qn),
		(t.CubeTextureLoader = _c),
		(t.CubeUVReflectionMapping = s),
		(t.CubeUVRefractionMapping = c),
		(t.CubicBezierCurve = Oc),
		(t.CubicBezierCurve3 = Bc),
		(t.CubicInterpolant = Ks),
		(t.CullFaceBack = 1),
		(t.CullFaceFront = 2),
		(t.CullFaceFrontBack = 3),
		(t.CullFaceNone = 0),
		(t.Curve = Mc),
		(t.CurvePath = Vc),
		(t.CustomBlending = 5),
		(t.CustomToneMapping = 5),
		(t.CylinderBufferGeometry = wo),
		(t.CylinderGeometry = Mo),
		(t.Cylindrical = hu),
		(t.DataTexture = Yn),
		(t.DataTexture2DArray = yr),
		(t.DataTexture3D = xr),
		(t.DataTextureLoader = bc),
		(t.DecrementStencilOp = 7683),
		(t.DecrementWrapStencilOp = 34056),
		(t.DefaultLoadingManager = pc),
		(t.DepthFormat = E),
		(t.DepthStencilFormat = A),
		(t.DepthTexture = po),
		(t.DirectionalLight = el),
		(t.DirectionalLightHelper = Ou),
		(t.DiscreteInterpolant = tc),
		(t.DodecahedronBufferGeometry = Ao),
		(t.DodecahedronGeometry = Lo),
		(t.DoubleSide = 2),
		(t.DstAlphaFactor = 206),
		(t.DstColorFactor = 208),
		(t.DynamicBufferAttribute = function (t, e) {
			return (
				console.warn(
					'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.'
				),
				new Je(t, e).setUsage(et)
			);
		}),
		(t.DynamicCopyUsage = 35050),
		(t.DynamicDrawUsage = et),
		(t.DynamicReadUsage = 35049),
		(t.EdgesGeometry = Do),
		(t.EdgesHelper = function (t, e) {
			return (
				console.warn(
					'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.'
				),
				new to(
					new Do(t.geometry),
					new ja({ color: void 0 !== e ? e : 16777215 })
				)
			);
		}),
		(t.EllipseCurve = Sc),
		(t.EqualDepth = 4),
		(t.EqualStencilFunc = 514),
		(t.EquirectangularReflectionMapping = a),
		(t.EquirectangularRefractionMapping = o),
		(t.Euler = ie),
		(t.EventDispatcher = rt),
		(t.ExtrudeBufferGeometry = cs),
		(t.ExtrudeGeometry = us),
		(t.Face3 = We),
		(t.Face4 = function (t, e, n, r, i, a, o) {
			return (
				console.warn(
					'THREE.Face4 has been removed. A THREE.Face3 will be created instead.'
				),
				new We(t, e, n, i, a, o)
			);
		}),
		(t.FaceColors = 1),
		(t.FileLoader = vc),
		(t.FlatShading = 1),
		(t.Float32Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.'
				),
				new an(t, e)
			);
		}),
		(t.Float32BufferAttribute = an),
		(t.Float64Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.'
				),
				new on(t, e)
			);
		}),
		(t.Float64BufferAttribute = on),
		(t.FloatType = b),
		(t.Fog = oa),
		(t.FogExp2 = aa),
		(t.Font = xl),
		(t.FontLoader = bl),
		(t.FrontSide = 0),
		(t.Frustum = Qn),
		(t.GLBufferAttribute = ou),
		(t.GLSL1 = '100'),
		(t.GLSL3 = nt),
		(t.GammaEncoding = Y),
		(t.Geometry = yo),
		(t.GeometryUtils = _h),
		(t.GreaterDepth = 6),
		(t.GreaterEqualDepth = 5),
		(t.GreaterEqualStencilFunc = 518),
		(t.GreaterStencilFunc = 516),
		(t.GridHelper = Cu),
		(t.Group = $i),
		(t.HalfFloatType = w),
		(t.HemisphereLight = Xc),
		(t.HemisphereLightHelper = Ru),
		(t.HemisphereLightProbe = Sl),
		(t.IcosahedronBufferGeometry = hs),
		(t.IcosahedronGeometry = ds),
		(t.ImageBitmapLoader = gl),
		(t.ImageLoader = xc),
		(t.ImageUtils = mt),
		(t.ImmediateRenderObject = gu),
		(t.IncrementStencilOp = 7682),
		(t.IncrementWrapStencilOp = 34055),
		(t.InstancedBufferAttribute = ll),
		(t.InstancedBufferGeometry = cl),
		(t.InstancedInterleavedBuffer = au),
		(t.InstancedMesh = Wa),
		(t.Int16Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.'
				),
				new tn(t, e)
			);
		}),
		(t.Int16BufferAttribute = tn),
		(t.Int32Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.'
				),
				new nn(t, e)
			);
		}),
		(t.Int32BufferAttribute = nn),
		(t.Int8Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.'
				),
				new Qe(t, e)
			);
		}),
		(t.Int8BufferAttribute = Qe),
		(t.IntType = 1013),
		(t.InterleavedBuffer = ca),
		(t.InterleavedBufferAttribute = ha),
		(t.Interpolant = Qs),
		(t.InterpolateDiscrete = G),
		(t.InterpolateLinear = F),
		(t.InterpolateSmooth = U),
		(t.InvertStencilOp = 5386),
		(t.JSONLoader = function () {
			console.error('THREE.JSONLoader has been removed.');
		}),
		(t.KeepStencilOp = $),
		(t.KeyframeTrack = ec),
		(t.LOD = Na),
		(t.LatheBufferGeometry = ps),
		(t.LatheGeometry = fs),
		(t.Layers = se),
		(t.LensFlare = function () {
			console.error(
				'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js'
			);
		}),
		(t.LessDepth = 2),
		(t.LessEqualDepth = 3),
		(t.LessEqualStencilFunc = 515),
		(t.LessStencilFunc = 513),
		(t.Light = qc),
		(t.LightProbe = al),
		(t.Line = Qa),
		(t.Line3 = vu),
		(t.LineBasicMaterial = ja),
		(t.LineCurve = zc),
		(t.LineCurve3 = Gc),
		(t.LineDashedMaterial = Ys),
		(t.LineLoop = eo),
		(t.LinePieces = 1),
		(t.LineSegments = to),
		(t.LineStrip = 0),
		(t.LinearEncoding = q),
		(t.LinearFilter = m),
		(t.LinearInterpolant = $s),
		(t.LinearMipMapLinearFilter = 1008),
		(t.LinearMipMapNearestFilter = 1007),
		(t.LinearMipmapLinearFilter = g),
		(t.LinearMipmapNearestFilter = v),
		(t.LinearToneMapping = 1),
		(t.Loader = fc),
		(t.LoaderUtils = sl),
		(t.LoadingManager = dc),
		(t.LogLuvEncoding = 3003),
		(t.LoopOnce = 2200),
		(t.LoopPingPong = 2202),
		(t.LoopRepeat = 2201),
		(t.LuminanceAlphaFormat = 1025),
		(t.LuminanceFormat = 1024),
		(t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }),
		(t.Material = qe),
		(t.MaterialLoader = ol),
		(t.Math = st),
		(t.MathUtils = st),
		(t.Matrix3 = ft),
		(t.Matrix4 = Jt),
		(t.MaxEquation = 104),
		(t.Mesh = Nn),
		(t.MeshBasicMaterial = Xe),
		(t.MeshDepthMaterial = qi),
		(t.MeshDistanceMaterial = Xi),
		(t.MeshFaceMaterial = function (t) {
			return (
				console.warn(
					'THREE.MeshFaceMaterial has been removed. Use an Array instead.'
				),
				t
			);
		}),
		(t.MeshLambertMaterial = qs),
		(t.MeshMatcapMaterial = Xs),
		(t.MeshNormalMaterial = js),
		(t.MeshPhongMaterial = Vs),
		(t.MeshPhysicalMaterial = ks),
		(t.MeshStandardMaterial = Hs),
		(t.MeshToonMaterial = Ws),
		(t.MinEquation = 103),
		(t.MirroredRepeatWrapping = h),
		(t.MixOperation = 1),
		(t.MultiMaterial = function (t) {
			return (
				void 0 === t && (t = []),
				console.warn(
					'THREE.MultiMaterial has been removed. Use an Array instead.'
				),
				(t.isMultiMaterial = !0),
				(t.materials = t),
				(t.clone = function () {
					return t.slice();
				}),
				t
			);
		}),
		(t.MultiplyBlending = 4),
		(t.MultiplyOperation = 0),
		(t.NearestFilter = d),
		(t.NearestMipMapLinearFilter = 1005),
		(t.NearestMipMapNearestFilter = 1004),
		(t.NearestMipmapLinearFilter = f),
		(t.NearestMipmapNearestFilter = p),
		(t.NeverDepth = 0),
		(t.NeverStencilFunc = 512),
		(t.NoBlending = 0),
		(t.NoColors = 0),
		(t.NoToneMapping = 0),
		(t.NormalAnimationBlendMode = W),
		(t.NormalBlending = 1),
		(t.NotEqualDepth = 7),
		(t.NotEqualStencilFunc = 517),
		(t.NumberKeyframeTrack = ic),
		(t.Object3D = be),
		(t.ObjectLoader = pl),
		(t.ObjectSpaceNormalMap = 1),
		(t.OctahedronBufferGeometry = ms),
		(t.OctahedronGeometry = vs),
		(t.OneFactor = 201),
		(t.OneMinusDstAlphaFactor = 207),
		(t.OneMinusDstColorFactor = 209),
		(t.OneMinusSrcAlphaFactor = 205),
		(t.OneMinusSrcColorFactor = 203),
		(t.OrthographicCamera = $c),
		(t.PCFShadowMap = 1),
		(t.PCFSoftShadowMap = 2),
		(t.PMREMGenerator = uh),
		(t.ParametricBufferGeometry = gs),
		(t.ParametricGeometry = ys),
		(t.Particle = function (t) {
			return (
				console.warn('THREE.Particle has been renamed to THREE.Sprite.'),
				new Ta(t)
			);
		}),
		(t.ParticleBasicMaterial = function (t) {
			return (
				console.warn(
					'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.'
				),
				new no(t)
			);
		}),
		(t.ParticleSystem = function (t, e) {
			return (
				console.warn('THREE.ParticleSystem has been renamed to THREE.Points.'),
				new so(t, e)
			);
		}),
		(t.ParticleSystemMaterial = function (t) {
			return (
				console.warn(
					'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.'
				),
				new no(t)
			);
		}),
		(t.Path = Wc),
		(t.PerspectiveCamera = Vn),
		(t.Plane = Te),
		(t.PlaneBufferGeometry = tr),
		(t.PlaneGeometry = xs),
		(t.PlaneHelper = qu),
		(t.PointCloud = function (t, e) {
			return (
				console.warn('THREE.PointCloud has been renamed to THREE.Points.'),
				new so(t, e)
			);
		}),
		(t.PointCloudMaterial = function (t) {
			return (
				console.warn(
					'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.'
				),
				new no(t)
			);
		}),
		(t.PointLight = Kc),
		(t.PointLightHelper = Tu),
		(t.Points = so),
		(t.PointsMaterial = no),
		(t.PolarGridHelper = Pu),
		(t.PolyhedronBufferGeometry = Eo),
		(t.PolyhedronGeometry = _s),
		(t.PositionalAudio = Ul),
		(t.PropertyBinding = tu),
		(t.PropertyMixer = kl),
		(t.QuadraticBezierCurve = Fc),
		(t.QuadraticBezierCurve3 = Uc),
		(t.Quaternion = bt),
		(t.QuaternionKeyframeTrack = oc),
		(t.QuaternionLinearInterpolant = ac),
		(t.REVISION = '121'),
		(t.RGBADepthPacking = 3201),
		(t.RGBAFormat = T),
		(t.RGBAIntegerFormat = 1033),
		(t.RGBA_ASTC_10x10_Format = 37819),
		(t.RGBA_ASTC_10x5_Format = 37816),
		(t.RGBA_ASTC_10x6_Format = 37817),
		(t.RGBA_ASTC_10x8_Format = 37818),
		(t.RGBA_ASTC_12x10_Format = 37820),
		(t.RGBA_ASTC_12x12_Format = 37821),
		(t.RGBA_ASTC_4x4_Format = 37808),
		(t.RGBA_ASTC_5x4_Format = 37809),
		(t.RGBA_ASTC_5x5_Format = 37810),
		(t.RGBA_ASTC_6x5_Format = 37811),
		(t.RGBA_ASTC_6x6_Format = 37812),
		(t.RGBA_ASTC_8x5_Format = 37813),
		(t.RGBA_ASTC_8x6_Format = 37814),
		(t.RGBA_ASTC_8x8_Format = 37815),
		(t.RGBA_BPTC_Format = 36492),
		(t.RGBA_ETC2_EAC_Format = z),
		(t.RGBA_PVRTC_2BPPV1_Format = O),
		(t.RGBA_PVRTC_4BPPV1_Format = N),
		(t.RGBA_S3TC_DXT1_Format = R),
		(t.RGBA_S3TC_DXT3_Format = C),
		(t.RGBA_S3TC_DXT5_Format = P),
		(t.RGBDEncoding = K),
		(t.RGBEEncoding = Z),
		(t.RGBEFormat = 1023),
		(t.RGBFormat = S),
		(t.RGBIntegerFormat = 1032),
		(t.RGBM16Encoding = Q),
		(t.RGBM7Encoding = J),
		(t.RGB_ETC1_Format = 36196),
		(t.RGB_ETC2_Format = B),
		(t.RGB_PVRTC_2BPPV1_Format = D),
		(t.RGB_PVRTC_4BPPV1_Format = I),
		(t.RGB_S3TC_DXT1_Format = L),
		(t.RGFormat = 1030),
		(t.RGIntegerFormat = 1031),
		(t.RawShaderMaterial = Us),
		(t.Ray = Zt),
		(t.Raycaster = su),
		(t.RectAreaLight = rl),
		(t.RedFormat = 1028),
		(t.RedIntegerFormat = 1029),
		(t.ReinhardToneMapping = 2),
		(t.RepeatWrapping = l),
		(t.ReplaceStencilOp = 7681),
		(t.ReverseSubtractEquation = 102),
		(t.RingBufferGeometry = bs),
		(t.RingGeometry = ws),
		(t.SRGB8_ALPHA8_ASTC_10x10_Format = 37851),
		(t.SRGB8_ALPHA8_ASTC_10x5_Format = 37848),
		(t.SRGB8_ALPHA8_ASTC_10x6_Format = 37849),
		(t.SRGB8_ALPHA8_ASTC_10x8_Format = 37850),
		(t.SRGB8_ALPHA8_ASTC_12x10_Format = 37852),
		(t.SRGB8_ALPHA8_ASTC_12x12_Format = 37853),
		(t.SRGB8_ALPHA8_ASTC_4x4_Format = 37840),
		(t.SRGB8_ALPHA8_ASTC_5x4_Format = 37841),
		(t.SRGB8_ALPHA8_ASTC_5x5_Format = 37842),
		(t.SRGB8_ALPHA8_ASTC_6x5_Format = 37843),
		(t.SRGB8_ALPHA8_ASTC_6x6_Format = 37844),
		(t.SRGB8_ALPHA8_ASTC_8x5_Format = 37845),
		(t.SRGB8_ALPHA8_ASTC_8x6_Format = 37846),
		(t.SRGB8_ALPHA8_ASTC_8x8_Format = 37847),
		(t.Scene = sa),
		(t.SceneUtils = bh),
		(t.ShaderChunk = er),
		(t.ShaderLib = rr),
		(t.ShaderMaterial = Hn),
		(t.ShadowMaterial = Fs),
		(t.Shape = jc),
		(t.ShapeBufferGeometry = Ms),
		(t.ShapeGeometry = Ss),
		(t.ShapePath = yl),
		(t.ShapeUtils = as),
		(t.ShortType = 1011),
		(t.Skeleton = Ga),
		(t.SkeletonHelper = Mu),
		(t.SkinnedMesh = Oa),
		(t.SmoothShading = 2),
		(t.Sphere = Ht),
		(t.SphereBufferGeometry = Ts),
		(t.SphereGeometry = Es),
		(t.Spherical = uu),
		(t.SphericalHarmonics3 = il),
		(t.Spline = xh),
		(t.SplineCurve = Hc),
		(t.SplineCurve3 = yh),
		(t.SpotLight = Jc),
		(t.SpotLightHelper = xu),
		(t.Sprite = Ta),
		(t.SpriteMaterial = da),
		(t.SrcAlphaFactor = 204),
		(t.SrcAlphaSaturateFactor = 210),
		(t.SrcColorFactor = 202),
		(t.StaticCopyUsage = 35046),
		(t.StaticDrawUsage = tt),
		(t.StaticReadUsage = 35045),
		(t.StereoCamera = Ll),
		(t.StreamCopyUsage = 35042),
		(t.StreamDrawUsage = 35040),
		(t.StreamReadUsage = 35041),
		(t.StringKeyframeTrack = sc),
		(t.SubtractEquation = 101),
		(t.SubtractiveBlending = 3),
		(t.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }),
		(t.TangentSpaceNormalMap = 0),
		(t.TetrahedronBufferGeometry = As),
		(t.TetrahedronGeometry = Ls),
		(t.TextBufferGeometry = Rs),
		(t.TextGeometry = Cs),
		(t.Texture = gt),
		(t.TextureLoader = wc),
		(t.TorusBufferGeometry = Ps),
		(t.TorusGeometry = Is),
		(t.TorusKnotBufferGeometry = Ds),
		(t.TorusKnotGeometry = Ns),
		(t.Triangle = Be),
		(t.TriangleFanDrawMode = 2),
		(t.TriangleStripDrawMode = 1),
		(t.TrianglesDrawMode = 0),
		(t.TubeBufferGeometry = Os),
		(t.TubeGeometry = Bs),
		(t.UVMapping = n),
		(t.Uint16Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.'
				),
				new en(t, e)
			);
		}),
		(t.Uint16BufferAttribute = en),
		(t.Uint32Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.'
				),
				new rn(t, e)
			);
		}),
		(t.Uint32BufferAttribute = rn),
		(t.Uint8Attribute = function (t, e) {
			return (
				console.warn(
					'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.'
				),
				new Ke(t, e)
			);
		}),
		(t.Uint8BufferAttribute = Ke),
		(t.Uint8ClampedAttribute = function (t, e) {
			return (
				console.warn(
					'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.'
				),
				new $e(t, e)
			);
		}),
		(t.Uint8ClampedBufferAttribute = $e),
		(t.Uniform = iu),
		(t.UniformsLib = nr),
		(t.UniformsUtils = Un),
		(t.UnsignedByteType = y),
		(t.UnsignedInt248Type = M),
		(t.UnsignedIntType = _),
		(t.UnsignedShort4444Type = 1017),
		(t.UnsignedShort5551Type = 1018),
		(t.UnsignedShort565Type = 1019),
		(t.UnsignedShortType = x),
		(t.VSMShadowMap = 3),
		(t.Vector2 = pt),
		(t.Vector3 = wt),
		(t.Vector4 = yt),
		(t.VectorKeyframeTrack = cc),
		(t.Vertex = function (t, e, n) {
			return (
				console.warn(
					'THREE.Vertex has been removed. Use THREE.Vector3 instead.'
				),
				new wt(t, e, n)
			);
		}),
		(t.VertexColors = 2),
		(t.VideoTexture = lo),
		(t.WebGL1Renderer = ia),
		(t.WebGLCubeRenderTarget = Xn),
		(t.WebGLMultisampleRenderTarget = _t),
		(t.WebGLRenderTarget = xt),
		(t.WebGLRenderTargetCube = function (t, e, n) {
			return (
				console.warn(
					'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).'
				),
				new Xn(t, n)
			);
		}),
		(t.WebGLRenderer = ra),
		(t.WebGLUtils = Qi),
		(t.WireframeGeometry = zs),
		(t.WireframeHelper = function (t, e) {
			return (
				console.warn(
					'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.'
				),
				new to(
					new zs(t.geometry),
					new ja({ color: void 0 !== e ? e : 16777215 })
				)
			);
		}),
		(t.WrapAroundEnding = V),
		(t.XHRLoader = function (t) {
			return (
				console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.'),
				new vc(t)
			);
		}),
		(t.ZeroCurvatureEnding = H),
		(t.ZeroFactor = 200),
		(t.ZeroSlopeEnding = k),
		(t.ZeroStencilOp = 0),
		(t.sRGBEncoding = X),
		Object.defineProperty(t, '__esModule', { value: !0 });
});

//download.js v4.2, by dandavis; 2008-2016. [CCBY2] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
// v4 adds AMD/UMD, commonJS, and plain browser support
// v4.1 adds url download capability via solo URL argument (same domain/CORS only)
// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
// https://github.com/rndme/download

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.download = factory();
	}
})(this, function () {
	return function download(data, strFileName, strMimeType) {
		var self = window, // this script is only for browsers anyway...
			defaultMime = 'application/octet-stream', // this default mime also triggers iframe downloads
			mimeType = strMimeType || defaultMime,
			payload = data,
			url = !strFileName && !strMimeType && payload,
			anchor = document.createElement('a'),
			toString = function (a) {
				return String(a);
			},
			myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,
			fileName = strFileName || 'download',
			blob,
			reader;
		myBlob = myBlob.call ? myBlob.bind(self) : Blob;

		if (String(this) === 'true') {
			//reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
			payload = [payload, mimeType];
			mimeType = payload[0];
			payload = payload[1];
		}

		if (url && url.length < 2048) {
			// if no filename and no mime, assume a url was passed as the only argument
			fileName = url.split('/').pop().split('?')[0];
			anchor.href = url; // assign href prop to temp anchor
			if (anchor.href.indexOf(url) !== -1) {
				// if the browser determines that it's a potentially valid url path:
				var ajax = new XMLHttpRequest();
				ajax.open('GET', url, true);
				ajax.responseType = 'blob';
				ajax.onload = function (e) {
					download(e.target.response, fileName, defaultMime);
				};
				setTimeout(function () {
					ajax.send();
				}, 0); // allows setting custom ajax headers using the return:
				return ajax;
			} // end if valid url?
		} // end if url?

		//go ahead and download dataURLs right away
		if (/^data\:[\w+\-]+\/[\w+\-]+[,;]/.test(payload)) {
			if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {
				payload = dataUrlToBlob(payload);
				mimeType = payload.type || defaultMime;
			} else {
				return navigator.msSaveBlob // IE10 can't do a[download], only Blobs:
					? navigator.msSaveBlob(dataUrlToBlob(payload), fileName)
					: saver(payload); // everyone else can save dataURLs un-processed
			}
		} //end if dataURL passed?

		blob =
			payload instanceof myBlob
				? payload
				: new myBlob([payload], { type: mimeType });

		function dataUrlToBlob(strUrl) {
			var parts = strUrl.split(/[:;,]/),
				type = parts[1],
				decoder = parts[2] == 'base64' ? atob : decodeURIComponent,
				binData = decoder(parts.pop()),
				mx = binData.length,
				i = 0,
				uiArr = new Uint8Array(mx);

			for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);

			return new myBlob([uiArr], { type: type });
		}

		function saver(url, winMode) {
			if ('download' in anchor) {
				//html5 A[download]
				anchor.href = url;
				anchor.setAttribute('download', fileName);
				anchor.className = 'download-js-link';
				anchor.innerHTML = 'downloading...';
				anchor.style.display = 'none';
				document.body.appendChild(anchor);
				setTimeout(function () {
					anchor.click();
					document.body.removeChild(anchor);
					if (winMode === true) {
						setTimeout(function () {
							self.URL.revokeObjectURL(anchor.href);
						}, 250);
					}
				}, 66);
				return true;
			}

			// handle non-a[download] safari as best we can:
			if (
				/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(
					navigator.userAgent
				)
			) {
				url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
				if (!window.open(url)) {
					// popup blocked, offer direct download:
					if (
						confirm(
							'Displaying New Document\n\nUse Save As... to download, then click back to return to this page.'
						)
					) {
						location.href = url;
					}
				}
				return true;
			}

			//do iframe dataURL download (old ch+FF):
			var f = document.createElement('iframe');
			document.body.appendChild(f);

			if (!winMode) {
				// force a mime that will download:
				url = 'data:' + url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
			}
			f.src = url;
			setTimeout(function () {
				document.body.removeChild(f);
			}, 333);
		} //end saver

		if (navigator.msSaveBlob) {
			// IE10+ : (has Blob, but not a[download] or URL)
			return navigator.msSaveBlob(blob, fileName);
		}

		if (self.URL) {
			// simple fast and modern way using Blob and URL:
			saver(self.URL.createObjectURL(blob), true);
		} else {
			// handle non-Blob()+non-URL browsers:
			if (typeof blob === 'string' || blob.constructor === toString) {
				try {
					return saver('data:' + mimeType + ';base64,' + self.btoa(blob));
				} catch (y) {
					return saver('data:' + mimeType + ',' + encodeURIComponent(blob));
				}
			}

			// Blob but not URL support:
			reader = new FileReader();
			reader.onload = function (e) {
				saver(this.result);
			};
			reader.readAsDataURL(blob);
		}
		return true;
	}; /* end download() */
});

(() => {
	var t = {
			9662: (t, r, e) => {
				var n = e(7854),
					o = e(614),
					i = e(6330),
					a = n.TypeError;
				t.exports = function (t) {
					if (o(t)) return t;
					throw a(i(t) + ' is not a function');
				};
			},
			9483: (t, r, e) => {
				var n = e(7854),
					o = e(4411),
					i = e(6330),
					a = n.TypeError;
				t.exports = function (t) {
					if (o(t)) return t;
					throw a(i(t) + ' is not a constructor');
				};
			},
			6077: (t, r, e) => {
				var n = e(7854),
					o = e(614),
					i = n.String,
					a = n.TypeError;
				t.exports = function (t) {
					if ('object' == typeof t || o(t)) return t;
					throw a("Can't set " + i(t) + ' as a prototype');
				};
			},
			5787: (t, r, e) => {
				var n = e(7854),
					o = e(7976),
					i = n.TypeError;
				t.exports = function (t, r) {
					if (o(r, t)) return t;
					throw i('Incorrect invocation');
				};
			},
			9670: (t, r, e) => {
				var n = e(7854),
					o = e(111),
					i = n.String,
					a = n.TypeError;
				t.exports = function (t) {
					if (o(t)) return t;
					throw a(i(t) + ' is not an object');
				};
			},
			8533: (t, r, e) => {
				'use strict';
				var n = e(2092).forEach,
					o = e(9341)('forEach');
				t.exports = o
					? [].forEach
					: function (t) {
							return n(this, t, arguments.length > 1 ? arguments[1] : void 0);
					  };
			},
			1318: (t, r, e) => {
				var n = e(5656),
					o = e(1400),
					i = e(6244),
					a = function (t) {
						return function (r, e, a) {
							var u,
								c = n(r),
								s = i(c),
								f = o(a, s);
							if (t && e != e) {
								for (; s > f; ) if ((u = c[f++]) != u) return !0;
							} else
								for (; s > f; f++)
									if ((t || f in c) && c[f] === e) return t || f || 0;
							return !t && -1;
						};
					};
				t.exports = { includes: a(!0), indexOf: a(!1) };
			},
			2092: (t, r, e) => {
				var n = e(9974),
					o = e(1702),
					i = e(8361),
					a = e(7908),
					u = e(6244),
					c = e(5417),
					s = o([].push),
					f = function (t) {
						var r = 1 == t,
							e = 2 == t,
							o = 3 == t,
							f = 4 == t,
							p = 6 == t,
							v = 7 == t,
							l = 5 == t || p;
						return function (h, d, y, m) {
							for (
								var g,
									b,
									x = a(h),
									w = i(x),
									S = n(d, y),
									j = u(w),
									O = 0,
									E = m || c,
									T = r ? E(h, j) : e || v ? E(h, 0) : void 0;
								j > O;
								O++
							)
								if ((l || O in w) && ((b = S((g = w[O]), O, x)), t))
									if (r) T[O] = b;
									else if (b)
										switch (t) {
											case 3:
												return !0;
											case 5:
												return g;
											case 6:
												return O;
											case 2:
												s(T, g);
										}
									else
										switch (t) {
											case 4:
												return !1;
											case 7:
												s(T, g);
										}
							return p ? -1 : o || f ? f : T;
						};
					};
				t.exports = {
					forEach: f(0),
					map: f(1),
					filter: f(2),
					some: f(3),
					every: f(4),
					find: f(5),
					findIndex: f(6),
					filterReject: f(7),
				};
			},
			9341: (t, r, e) => {
				'use strict';
				var n = e(7293);
				t.exports = function (t, r) {
					var e = [][t];
					return (
						!!e &&
						n(function () {
							e.call(
								null,
								r ||
									function () {
										return 1;
									},
								1
							);
						})
					);
				};
			},
			206: (t, r, e) => {
				var n = e(1702);
				t.exports = n([].slice);
			},
			7475: (t, r, e) => {
				var n = e(7854),
					o = e(3157),
					i = e(4411),
					a = e(111),
					u = e(5112)('species'),
					c = n.Array;
				t.exports = function (t) {
					var r;
					return (
						o(t) &&
							((r = t.constructor),
							((i(r) && (r === c || o(r.prototype))) ||
								(a(r) && null === (r = r[u]))) &&
								(r = void 0)),
						void 0 === r ? c : r
					);
				};
			},
			5417: (t, r, e) => {
				var n = e(7475);
				t.exports = function (t, r) {
					return new (n(t))(0 === r ? 0 : r);
				};
			},
			7072: (t, r, e) => {
				var n = e(5112)('iterator'),
					o = !1;
				try {
					var i = 0,
						a = {
							next: function () {
								return { done: !!i++ };
							},
							return: function () {
								o = !0;
							},
						};
					(a[n] = function () {
						return this;
					}),
						Array.from(a, function () {
							throw 2;
						});
				} catch (t) {}
				t.exports = function (t, r) {
					if (!r && !o) return !1;
					var e = !1;
					try {
						var i = {};
						(i[n] = function () {
							return {
								next: function () {
									return { done: (e = !0) };
								},
							};
						}),
							t(i);
					} catch (t) {}
					return e;
				};
			},
			4326: (t, r, e) => {
				var n = e(1702),
					o = n({}.toString),
					i = n(''.slice);
				t.exports = function (t) {
					return i(o(t), 8, -1);
				};
			},
			648: (t, r, e) => {
				var n = e(7854),
					o = e(1694),
					i = e(614),
					a = e(4326),
					u = e(5112)('toStringTag'),
					c = n.Object,
					s =
						'Arguments' ==
						a(
							(function () {
								return arguments;
							})()
						);
				t.exports = o
					? a
					: function (t) {
							var r, e, n;
							return void 0 === t
								? 'Undefined'
								: null === t
								? 'Null'
								: 'string' ==
								  typeof (e = (function (t, r) {
										try {
											return t[r];
										} catch (t) {}
								  })((r = c(t)), u))
								? e
								: s
								? a(r)
								: 'Object' == (n = a(r)) && i(r.callee)
								? 'Arguments'
								: n;
					  };
			},
			7741: (t, r, e) => {
				var n = e(1702)(''.replace),
					o = String(Error('zxcasd').stack),
					i = /\n\s*at [^:]*:[^\n]*/,
					a = i.test(o);
				t.exports = function (t, r) {
					if (a && 'string' == typeof t) for (; r--; ) t = n(t, i, '');
					return t;
				};
			},
			9920: (t, r, e) => {
				var n = e(2597),
					o = e(3887),
					i = e(1236),
					a = e(3070);
				t.exports = function (t, r, e) {
					for (var u = o(r), c = a.f, s = i.f, f = 0; f < u.length; f++) {
						var p = u[f];
						n(t, p) || (e && n(e, p)) || c(t, p, s(r, p));
					}
				};
			},
			8880: (t, r, e) => {
				var n = e(9781),
					o = e(3070),
					i = e(9114);
				t.exports = n
					? function (t, r, e) {
							return o.f(t, r, i(1, e));
					  }
					: function (t, r, e) {
							return (t[r] = e), t;
					  };
			},
			9114: (t) => {
				t.exports = function (t, r) {
					return {
						enumerable: !(1 & t),
						configurable: !(2 & t),
						writable: !(4 & t),
						value: r,
					};
				};
			},
			9781: (t, r, e) => {
				var n = e(7293);
				t.exports = !n(function () {
					return (
						7 !=
						Object.defineProperty({}, 1, {
							get: function () {
								return 7;
							},
						})[1]
					);
				});
			},
			317: (t, r, e) => {
				var n = e(7854),
					o = e(111),
					i = n.document,
					a = o(i) && o(i.createElement);
				t.exports = function (t) {
					return a ? i.createElement(t) : {};
				};
			},
			8324: (t) => {
				t.exports = {
					CSSRuleList: 0,
					CSSStyleDeclaration: 0,
					CSSValueList: 0,
					ClientRectList: 0,
					DOMRectList: 0,
					DOMStringList: 0,
					DOMTokenList: 1,
					DataTransferItemList: 0,
					FileList: 0,
					HTMLAllCollection: 0,
					HTMLCollection: 0,
					HTMLFormElement: 0,
					HTMLSelectElement: 0,
					MediaList: 0,
					MimeTypeArray: 0,
					NamedNodeMap: 0,
					NodeList: 1,
					PaintRequestList: 0,
					Plugin: 0,
					PluginArray: 0,
					SVGLengthList: 0,
					SVGNumberList: 0,
					SVGPathSegList: 0,
					SVGPointList: 0,
					SVGStringList: 0,
					SVGTransformList: 0,
					SourceBufferList: 0,
					StyleSheetList: 0,
					TextTrackCueList: 0,
					TextTrackList: 0,
					TouchList: 0,
				};
			},
			8509: (t, r, e) => {
				var n = e(317)('span').classList,
					o = n && n.constructor && n.constructor.prototype;
				t.exports = o === Object.prototype ? void 0 : o;
			},
			7871: (t) => {
				t.exports = 'object' == typeof window;
			},
			1528: (t, r, e) => {
				var n = e(8113),
					o = e(7854);
				t.exports = /ipad|iphone|ipod/i.test(n) && void 0 !== o.Pebble;
			},
			6833: (t, r, e) => {
				var n = e(8113);
				t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(n);
			},
			5268: (t, r, e) => {
				var n = e(4326),
					o = e(7854);
				t.exports = 'process' == n(o.process);
			},
			1036: (t, r, e) => {
				var n = e(8113);
				t.exports = /web0s(?!.*chrome)/i.test(n);
			},
			8113: (t, r, e) => {
				var n = e(5005);
				t.exports = n('navigator', 'userAgent') || '';
			},
			7392: (t, r, e) => {
				var n,
					o,
					i = e(7854),
					a = e(8113),
					u = i.process,
					c = i.Deno,
					s = (u && u.versions) || (c && c.version),
					f = s && s.v8;
				f && (o = (n = f.split('.'))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])),
					!o &&
						a &&
						(!(n = a.match(/Edge\/(\d+)/)) || n[1] >= 74) &&
						(n = a.match(/Chrome\/(\d+)/)) &&
						(o = +n[1]),
					(t.exports = o);
			},
			748: (t) => {
				t.exports = [
					'constructor',
					'hasOwnProperty',
					'isPrototypeOf',
					'propertyIsEnumerable',
					'toLocaleString',
					'toString',
					'valueOf',
				];
			},
			2914: (t, r, e) => {
				var n = e(7293),
					o = e(9114);
				t.exports = !n(function () {
					var t = Error('a');
					return (
						!('stack' in t) ||
						(Object.defineProperty(t, 'stack', o(1, 7)), 7 !== t.stack)
					);
				});
			},
			2109: (t, r, e) => {
				var n = e(7854),
					o = e(1236).f,
					i = e(8880),
					a = e(1320),
					u = e(3505),
					c = e(9920),
					s = e(4705);
				t.exports = function (t, r) {
					var e,
						f,
						p,
						v,
						l,
						h = t.target,
						d = t.global,
						y = t.stat;
					if ((e = d ? n : y ? n[h] || u(h, {}) : (n[h] || {}).prototype))
						for (f in r) {
							if (
								((v = r[f]),
								(p = t.noTargetGet ? (l = o(e, f)) && l.value : e[f]),
								!s(d ? f : h + (y ? '.' : '#') + f, t.forced) && void 0 !== p)
							) {
								if (typeof v == typeof p) continue;
								c(v, p);
							}
							(t.sham || (p && p.sham)) && i(v, 'sham', !0), a(e, f, v, t);
						}
				};
			},
			7293: (t) => {
				t.exports = function (t) {
					try {
						return !!t();
					} catch (t) {
						return !0;
					}
				};
			},
			2104: (t, r, e) => {
				var n = e(4374),
					o = Function.prototype,
					i = o.apply,
					a = o.call;
				t.exports =
					('object' == typeof Reflect && Reflect.apply) ||
					(n
						? a.bind(i)
						: function () {
								return a.apply(i, arguments);
						  });
			},
			9974: (t, r, e) => {
				var n = e(1702),
					o = e(9662),
					i = e(4374),
					a = n(n.bind);
				t.exports = function (t, r) {
					return (
						o(t),
						void 0 === r
							? t
							: i
							? a(t, r)
							: function () {
									return t.apply(r, arguments);
							  }
					);
				};
			},
			4374: (t, r, e) => {
				var n = e(7293);
				t.exports = !n(function () {
					var t = function () {}.bind();
					return 'function' != typeof t || t.hasOwnProperty('prototype');
				});
			},
			6916: (t, r, e) => {
				var n = e(4374),
					o = Function.prototype.call;
				t.exports = n
					? o.bind(o)
					: function () {
							return o.apply(o, arguments);
					  };
			},
			6530: (t, r, e) => {
				var n = e(9781),
					o = e(2597),
					i = Function.prototype,
					a = n && Object.getOwnPropertyDescriptor,
					u = o(i, 'name'),
					c = u && 'something' === function () {}.name,
					s = u && (!n || (n && a(i, 'name').configurable));
				t.exports = { EXISTS: u, PROPER: c, CONFIGURABLE: s };
			},
			1702: (t, r, e) => {
				var n = e(4374),
					o = Function.prototype,
					i = o.bind,
					a = o.call,
					u = n && i.bind(a, a);
				t.exports = n
					? function (t) {
							return t && u(t);
					  }
					: function (t) {
							return (
								t &&
								function () {
									return a.apply(t, arguments);
								}
							);
					  };
			},
			5005: (t, r, e) => {
				var n = e(7854),
					o = e(614),
					i = function (t) {
						return o(t) ? t : void 0;
					};
				t.exports = function (t, r) {
					return arguments.length < 2 ? i(n[t]) : n[t] && n[t][r];
				};
			},
			1246: (t, r, e) => {
				var n = e(648),
					o = e(8173),
					i = e(7497),
					a = e(5112)('iterator');
				t.exports = function (t) {
					if (null != t) return o(t, a) || o(t, '@@iterator') || i[n(t)];
				};
			},
			8554: (t, r, e) => {
				var n = e(7854),
					o = e(6916),
					i = e(9662),
					a = e(9670),
					u = e(6330),
					c = e(1246),
					s = n.TypeError;
				t.exports = function (t, r) {
					var e = arguments.length < 2 ? c(t) : r;
					if (i(e)) return a(o(e, t));
					throw s(u(t) + ' is not iterable');
				};
			},
			8173: (t, r, e) => {
				var n = e(9662);
				t.exports = function (t, r) {
					var e = t[r];
					return null == e ? void 0 : n(e);
				};
			},
			7854: (t, r, e) => {
				var n = function (t) {
					return t && t.Math == Math && t;
				};
				t.exports =
					n('object' == typeof globalThis && globalThis) ||
					n('object' == typeof window && window) ||
					n('object' == typeof self && self) ||
					n('object' == typeof e.g && e.g) ||
					(function () {
						return this;
					})() ||
					Function('return this')();
			},
			2597: (t, r, e) => {
				var n = e(1702),
					o = e(7908),
					i = n({}.hasOwnProperty);
				t.exports =
					Object.hasOwn ||
					function (t, r) {
						return i(o(t), r);
					};
			},
			3501: (t) => {
				t.exports = {};
			},
			842: (t, r, e) => {
				var n = e(7854);
				t.exports = function (t, r) {
					var e = n.console;
					e && e.error && (1 == arguments.length ? e.error(t) : e.error(t, r));
				};
			},
			490: (t, r, e) => {
				var n = e(5005);
				t.exports = n('document', 'documentElement');
			},
			4664: (t, r, e) => {
				var n = e(9781),
					o = e(7293),
					i = e(317);
				t.exports =
					!n &&
					!o(function () {
						return (
							7 !=
							Object.defineProperty(i('div'), 'a', {
								get: function () {
									return 7;
								},
							}).a
						);
					});
			},
			8361: (t, r, e) => {
				var n = e(7854),
					o = e(1702),
					i = e(7293),
					a = e(4326),
					u = n.Object,
					c = o(''.split);
				t.exports = i(function () {
					return !u('z').propertyIsEnumerable(0);
				})
					? function (t) {
							return 'String' == a(t) ? c(t, '') : u(t);
					  }
					: u;
			},
			9587: (t, r, e) => {
				var n = e(614),
					o = e(111),
					i = e(7674);
				t.exports = function (t, r, e) {
					var a, u;
					return (
						i &&
							n((a = r.constructor)) &&
							a !== e &&
							o((u = a.prototype)) &&
							u !== e.prototype &&
							i(t, u),
						t
					);
				};
			},
			2788: (t, r, e) => {
				var n = e(1702),
					o = e(614),
					i = e(5465),
					a = n(Function.toString);
				o(i.inspectSource) ||
					(i.inspectSource = function (t) {
						return a(t);
					}),
					(t.exports = i.inspectSource);
			},
			8340: (t, r, e) => {
				var n = e(111),
					o = e(8880);
				t.exports = function (t, r) {
					n(r) && 'cause' in r && o(t, 'cause', r.cause);
				};
			},
			9909: (t, r, e) => {
				var n,
					o,
					i,
					a = e(8536),
					u = e(7854),
					c = e(1702),
					s = e(111),
					f = e(8880),
					p = e(2597),
					v = e(5465),
					l = e(6200),
					h = e(3501),
					d = 'Object already initialized',
					y = u.TypeError,
					m = u.WeakMap;
				if (a || v.state) {
					var g = v.state || (v.state = new m()),
						b = c(g.get),
						x = c(g.has),
						w = c(g.set);
					(n = function (t, r) {
						if (x(g, t)) throw new y(d);
						return (r.facade = t), w(g, t, r), r;
					}),
						(o = function (t) {
							return b(g, t) || {};
						}),
						(i = function (t) {
							return x(g, t);
						});
				} else {
					var S = l('state');
					(h[S] = !0),
						(n = function (t, r) {
							if (p(t, S)) throw new y(d);
							return (r.facade = t), f(t, S, r), r;
						}),
						(o = function (t) {
							return p(t, S) ? t[S] : {};
						}),
						(i = function (t) {
							return p(t, S);
						});
				}
				t.exports = {
					set: n,
					get: o,
					has: i,
					enforce: function (t) {
						return i(t) ? o(t) : n(t, {});
					},
					getterFor: function (t) {
						return function (r) {
							var e;
							if (!s(r) || (e = o(r)).type !== t)
								throw y('Incompatible receiver, ' + t + ' required');
							return e;
						};
					},
				};
			},
			7659: (t, r, e) => {
				var n = e(5112),
					o = e(7497),
					i = n('iterator'),
					a = Array.prototype;
				t.exports = function (t) {
					return void 0 !== t && (o.Array === t || a[i] === t);
				};
			},
			3157: (t, r, e) => {
				var n = e(4326);
				t.exports =
					Array.isArray ||
					function (t) {
						return 'Array' == n(t);
					};
			},
			614: (t) => {
				t.exports = function (t) {
					return 'function' == typeof t;
				};
			},
			4411: (t, r, e) => {
				var n = e(1702),
					o = e(7293),
					i = e(614),
					a = e(648),
					u = e(5005),
					c = e(2788),
					s = function () {},
					f = [],
					p = u('Reflect', 'construct'),
					v = /^\s*(?:class|function)\b/,
					l = n(v.exec),
					h = !v.exec(s),
					d = function (t) {
						if (!i(t)) return !1;
						try {
							return p(s, f, t), !0;
						} catch (t) {
							return !1;
						}
					},
					y = function (t) {
						if (!i(t)) return !1;
						switch (a(t)) {
							case 'AsyncFunction':
							case 'GeneratorFunction':
							case 'AsyncGeneratorFunction':
								return !1;
						}
						try {
							return h || !!l(v, c(t));
						} catch (t) {
							return !0;
						}
					};
				(y.sham = !0),
					(t.exports =
						!p ||
						o(function () {
							var t;
							return (
								d(d.call) ||
								!d(Object) ||
								!d(function () {
									t = !0;
								}) ||
								t
							);
						})
							? y
							: d);
			},
			4705: (t, r, e) => {
				var n = e(7293),
					o = e(614),
					i = /#|\.prototype\./,
					a = function (t, r) {
						var e = c[u(t)];
						return e == f || (e != s && (o(r) ? n(r) : !!r));
					},
					u = (a.normalize = function (t) {
						return String(t).replace(i, '.').toLowerCase();
					}),
					c = (a.data = {}),
					s = (a.NATIVE = 'N'),
					f = (a.POLYFILL = 'P');
				t.exports = a;
			},
			111: (t, r, e) => {
				var n = e(614);
				t.exports = function (t) {
					return 'object' == typeof t ? null !== t : n(t);
				};
			},
			1913: (t) => {
				t.exports = !1;
			},
			2190: (t, r, e) => {
				var n = e(7854),
					o = e(5005),
					i = e(614),
					a = e(7976),
					u = e(3307),
					c = n.Object;
				t.exports = u
					? function (t) {
							return 'symbol' == typeof t;
					  }
					: function (t) {
							var r = o('Symbol');
							return i(r) && a(r.prototype, c(t));
					  };
			},
			408: (t, r, e) => {
				var n = e(7854),
					o = e(9974),
					i = e(6916),
					a = e(9670),
					u = e(6330),
					c = e(7659),
					s = e(6244),
					f = e(7976),
					p = e(8554),
					v = e(1246),
					l = e(9212),
					h = n.TypeError,
					d = function (t, r) {
						(this.stopped = t), (this.result = r);
					},
					y = d.prototype;
				t.exports = function (t, r, e) {
					var n,
						m,
						g,
						b,
						x,
						w,
						S,
						j = e && e.that,
						O = !(!e || !e.AS_ENTRIES),
						E = !(!e || !e.IS_ITERATOR),
						T = !(!e || !e.INTERRUPTED),
						P = o(r, j),
						L = function (t) {
							return n && l(n, 'normal', t), new d(!0, t);
						},
						_ = function (t) {
							return O
								? (a(t), T ? P(t[0], t[1], L) : P(t[0], t[1]))
								: T
								? P(t, L)
								: P(t);
						};
					if (E) n = t;
					else {
						if (!(m = v(t))) throw h(u(t) + ' is not iterable');
						if (c(m)) {
							for (g = 0, b = s(t); b > g; g++)
								if ((x = _(t[g])) && f(y, x)) return x;
							return new d(!1);
						}
						n = p(t, m);
					}
					for (w = n.next; !(S = i(w, n)).done; ) {
						try {
							x = _(S.value);
						} catch (t) {
							l(n, 'throw', t);
						}
						if ('object' == typeof x && x && f(y, x)) return x;
					}
					return new d(!1);
				};
			},
			9212: (t, r, e) => {
				var n = e(6916),
					o = e(9670),
					i = e(8173);
				t.exports = function (t, r, e) {
					var a, u;
					o(t);
					try {
						if (!(a = i(t, 'return'))) {
							if ('throw' === r) throw e;
							return e;
						}
						a = n(a, t);
					} catch (t) {
						(u = !0), (a = t);
					}
					if ('throw' === r) throw e;
					if (u) throw a;
					return o(a), e;
				};
			},
			7497: (t) => {
				t.exports = {};
			},
			6244: (t, r, e) => {
				var n = e(7466);
				t.exports = function (t) {
					return n(t.length);
				};
			},
			5948: (t, r, e) => {
				var n,
					o,
					i,
					a,
					u,
					c,
					s,
					f,
					p = e(7854),
					v = e(9974),
					l = e(1236).f,
					h = e(261).set,
					d = e(6833),
					y = e(1528),
					m = e(1036),
					g = e(5268),
					b = p.MutationObserver || p.WebKitMutationObserver,
					x = p.document,
					w = p.process,
					S = p.Promise,
					j = l(p, 'queueMicrotask'),
					O = j && j.value;
				O ||
					((n = function () {
						var t, r;
						for (g && (t = w.domain) && t.exit(); o; ) {
							(r = o.fn), (o = o.next);
							try {
								r();
							} catch (t) {
								throw (o ? a() : (i = void 0), t);
							}
						}
						(i = void 0), t && t.enter();
					}),
					d || g || m || !b || !x
						? !y && S && S.resolve
							? (((s = S.resolve(void 0)).constructor = S),
							  (f = v(s.then, s)),
							  (a = function () {
									f(n);
							  }))
							: g
							? (a = function () {
									w.nextTick(n);
							  })
							: ((h = v(h, p)),
							  (a = function () {
									h(n);
							  }))
						: ((u = !0),
						  (c = x.createTextNode('')),
						  new b(n).observe(c, { characterData: !0 }),
						  (a = function () {
								c.data = u = !u;
						  }))),
					(t.exports =
						O ||
						function (t) {
							var r = { fn: t, next: void 0 };
							i && (i.next = r), o || ((o = r), a()), (i = r);
						});
			},
			3366: (t, r, e) => {
				var n = e(7854);
				t.exports = n.Promise;
			},
			133: (t, r, e) => {
				var n = e(7392),
					o = e(7293);
				t.exports =
					!!Object.getOwnPropertySymbols &&
					!o(function () {
						var t = Symbol();
						return (
							!String(t) ||
							!(Object(t) instanceof Symbol) ||
							(!Symbol.sham && n && n < 41)
						);
					});
			},
			8536: (t, r, e) => {
				var n = e(7854),
					o = e(614),
					i = e(2788),
					a = n.WeakMap;
				t.exports = o(a) && /native code/.test(i(a));
			},
			8523: (t, r, e) => {
				'use strict';
				var n = e(9662),
					o = function (t) {
						var r, e;
						(this.promise = new t(function (t, n) {
							if (void 0 !== r || void 0 !== e)
								throw TypeError('Bad Promise constructor');
							(r = t), (e = n);
						})),
							(this.resolve = n(r)),
							(this.reject = n(e));
					};
				t.exports.f = function (t) {
					return new o(t);
				};
			},
			6277: (t, r, e) => {
				var n = e(1340);
				t.exports = function (t, r) {
					return void 0 === t ? (arguments.length < 2 ? '' : r) : n(t);
				};
			},
			3070: (t, r, e) => {
				var n = e(7854),
					o = e(9781),
					i = e(4664),
					a = e(3353),
					u = e(9670),
					c = e(4948),
					s = n.TypeError,
					f = Object.defineProperty,
					p = Object.getOwnPropertyDescriptor,
					v = 'enumerable',
					l = 'configurable',
					h = 'writable';
				r.f = o
					? a
						? function (t, r, e) {
								if (
									(u(t),
									(r = c(r)),
									u(e),
									'function' == typeof t &&
										'prototype' === r &&
										'value' in e &&
										h in e &&
										!e.writable)
								) {
									var n = p(t, r);
									n &&
										n.writable &&
										((t[r] = e.value),
										(e = {
											configurable: l in e ? e.configurable : n.configurable,
											enumerable: v in e ? e.enumerable : n.enumerable,
											writable: !1,
										}));
								}
								return f(t, r, e);
						  }
						: f
					: function (t, r, e) {
							if ((u(t), (r = c(r)), u(e), i))
								try {
									return f(t, r, e);
								} catch (t) {}
							if ('get' in e || 'set' in e) throw s('Accessors not supported');
							return 'value' in e && (t[r] = e.value), t;
					  };
			},
			1236: (t, r, e) => {
				var n = e(9781),
					o = e(6916),
					i = e(5296),
					a = e(9114),
					u = e(5656),
					c = e(4948),
					s = e(2597),
					f = e(4664),
					p = Object.getOwnPropertyDescriptor;
				r.f = n
					? p
					: function (t, r) {
							if (((t = u(t)), (r = c(r)), f))
								try {
									return p(t, r);
								} catch (t) {}
							if (s(t, r)) return a(!o(i.f, t, r), t[r]);
					  };
			},
			8006: (t, r, e) => {
				var n = e(6324),
					o = e(748).concat('length', 'prototype');
				r.f =
					Object.getOwnPropertyNames ||
					function (t) {
						return n(t, o);
					};
			},
			5181: (t, r) => {
				r.f = Object.getOwnPropertySymbols;
			},
			7976: (t, r, e) => {
				var n = e(1702);
				t.exports = n({}.isPrototypeOf);
			},
			6324: (t, r, e) => {
				var n = e(1702),
					o = e(2597),
					i = e(5656),
					a = e(1318).indexOf,
					u = e(3501),
					c = n([].push);
				t.exports = function (t, r) {
					var e,
						n = i(t),
						s = 0,
						f = [];
					for (e in n) !o(u, e) && o(n, e) && c(f, e);
					for (; r.length > s; ) o(n, (e = r[s++])) && (~a(f, e) || c(f, e));
					return f;
				};
			},
			1956: (t, r, e) => {
				var n = e(6324),
					o = e(748);
				t.exports =
					Object.keys ||
					function (t) {
						return n(t, o);
					};
			},
			5296: (t, r) => {
				'use strict';
				var e = {}.propertyIsEnumerable,
					n = Object.getOwnPropertyDescriptor,
					o = n && !e.call({ 1: 2 }, 1);
				r.f = o
					? function (t) {
							var r = n(this, t);
							return !!r && r.enumerable;
					  }
					: e;
			},
			7674: (t, r, e) => {
				var n = e(1702),
					o = e(9670),
					i = e(6077);
				t.exports =
					Object.setPrototypeOf ||
					('__proto__' in {}
						? (function () {
								var t,
									r = !1,
									e = {};
								try {
									(t = n(
										Object.getOwnPropertyDescriptor(
											Object.prototype,
											'__proto__'
										).set
									))(e, []),
										(r = e instanceof Array);
								} catch (t) {}
								return function (e, n) {
									return o(e), i(n), r ? t(e, n) : (e.__proto__ = n), e;
								};
						  })()
						: void 0);
			},
			288: (t, r, e) => {
				'use strict';
				var n = e(1694),
					o = e(648);
				t.exports = n
					? {}.toString
					: function () {
							return '[object ' + o(this) + ']';
					  };
			},
			2140: (t, r, e) => {
				var n = e(7854),
					o = e(6916),
					i = e(614),
					a = e(111),
					u = n.TypeError;
				t.exports = function (t, r) {
					var e, n;
					if ('string' === r && i((e = t.toString)) && !a((n = o(e, t))))
						return n;
					if (i((e = t.valueOf)) && !a((n = o(e, t)))) return n;
					if ('string' !== r && i((e = t.toString)) && !a((n = o(e, t))))
						return n;
					throw u("Can't convert object to primitive value");
				};
			},
			3887: (t, r, e) => {
				var n = e(5005),
					o = e(1702),
					i = e(8006),
					a = e(5181),
					u = e(9670),
					c = o([].concat);
				t.exports =
					n('Reflect', 'ownKeys') ||
					function (t) {
						var r = i.f(u(t)),
							e = a.f;
						return e ? c(r, e(t)) : r;
					};
			},
			2534: (t) => {
				t.exports = function (t) {
					try {
						return { error: !1, value: t() };
					} catch (t) {
						return { error: !0, value: t };
					}
				};
			},
			9478: (t, r, e) => {
				var n = e(9670),
					o = e(111),
					i = e(8523);
				t.exports = function (t, r) {
					if ((n(t), o(r) && r.constructor === t)) return r;
					var e = i.f(t);
					return (0, e.resolve)(r), e.promise;
				};
			},
			8572: (t) => {
				var r = function () {
					(this.head = null), (this.tail = null);
				};
				(r.prototype = {
					add: function (t) {
						var r = { item: t, next: null };
						this.head ? (this.tail.next = r) : (this.head = r), (this.tail = r);
					},
					get: function () {
						var t = this.head;
						if (t)
							return (
								(this.head = t.next),
								this.tail === t && (this.tail = null),
								t.item
							);
					},
				}),
					(t.exports = r);
			},
			2248: (t, r, e) => {
				var n = e(1320);
				t.exports = function (t, r, e) {
					for (var o in r) n(t, o, r[o], e);
					return t;
				};
			},
			1320: (t, r, e) => {
				var n = e(7854),
					o = e(614),
					i = e(2597),
					a = e(8880),
					u = e(3505),
					c = e(2788),
					s = e(9909),
					f = e(6530).CONFIGURABLE,
					p = s.get,
					v = s.enforce,
					l = String(String).split('String');
				(t.exports = function (t, r, e, c) {
					var s,
						p = !!c && !!c.unsafe,
						h = !!c && !!c.enumerable,
						d = !!c && !!c.noTargetGet,
						y = c && void 0 !== c.name ? c.name : r;
					o(e) &&
						('Symbol(' === String(y).slice(0, 7) &&
							(y = '[' + String(y).replace(/^Symbol\(([^)]*)\)/, '$1') + ']'),
						(!i(e, 'name') || (f && e.name !== y)) && a(e, 'name', y),
						(s = v(e)).source ||
							(s.source = l.join('string' == typeof y ? y : ''))),
						t !== n
							? (p ? !d && t[r] && (h = !0) : delete t[r],
							  h ? (t[r] = e) : a(t, r, e))
							: h
							? (t[r] = e)
							: u(r, e);
				})(Function.prototype, 'toString', function () {
					return (o(this) && p(this).source) || c(this);
				});
			},
			4488: (t, r, e) => {
				var n = e(7854).TypeError;
				t.exports = function (t) {
					if (null == t) throw n("Can't call method on " + t);
					return t;
				};
			},
			3505: (t, r, e) => {
				var n = e(7854),
					o = Object.defineProperty;
				t.exports = function (t, r) {
					try {
						o(n, t, { value: r, configurable: !0, writable: !0 });
					} catch (e) {
						n[t] = r;
					}
					return r;
				};
			},
			6340: (t, r, e) => {
				'use strict';
				var n = e(5005),
					o = e(3070),
					i = e(5112),
					a = e(9781),
					u = i('species');
				t.exports = function (t) {
					var r = n(t),
						e = o.f;
					a &&
						r &&
						!r[u] &&
						e(r, u, {
							configurable: !0,
							get: function () {
								return this;
							},
						});
				};
			},
			8003: (t, r, e) => {
				var n = e(3070).f,
					o = e(2597),
					i = e(5112)('toStringTag');
				t.exports = function (t, r, e) {
					t && !e && (t = t.prototype),
						t && !o(t, i) && n(t, i, { configurable: !0, value: r });
				};
			},
			6200: (t, r, e) => {
				var n = e(2309),
					o = e(9711),
					i = n('keys');
				t.exports = function (t) {
					return i[t] || (i[t] = o(t));
				};
			},
			5465: (t, r, e) => {
				var n = e(7854),
					o = e(3505),
					i = '__core-js_shared__',
					a = n[i] || o(i, {});
				t.exports = a;
			},
			2309: (t, r, e) => {
				var n = e(1913),
					o = e(5465);
				(t.exports = function (t, r) {
					return o[t] || (o[t] = void 0 !== r ? r : {});
				})('versions', []).push({
					version: '3.21.1',
					mode: n ? 'pure' : 'global',
					copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',
					license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
					source: 'https://github.com/zloirock/core-js',
				});
			},
			6707: (t, r, e) => {
				var n = e(9670),
					o = e(9483),
					i = e(5112)('species');
				t.exports = function (t, r) {
					var e,
						a = n(t).constructor;
					return void 0 === a || null == (e = n(a)[i]) ? r : o(e);
				};
			},
			261: (t, r, e) => {
				var n,
					o,
					i,
					a,
					u = e(7854),
					c = e(2104),
					s = e(9974),
					f = e(614),
					p = e(2597),
					v = e(7293),
					l = e(490),
					h = e(206),
					d = e(317),
					y = e(8053),
					m = e(6833),
					g = e(5268),
					b = u.setImmediate,
					x = u.clearImmediate,
					w = u.process,
					S = u.Dispatch,
					j = u.Function,
					O = u.MessageChannel,
					E = u.String,
					T = 0,
					P = {},
					L = 'onreadystatechange';
				try {
					n = u.location;
				} catch (t) {}
				var _ = function (t) {
						if (p(P, t)) {
							var r = P[t];
							delete P[t], r();
						}
					},
					F = function (t) {
						return function () {
							_(t);
						};
					},
					M = function (t) {
						_(t.data);
					},
					k = function (t) {
						u.postMessage(E(t), n.protocol + '//' + n.host);
					};
				(b && x) ||
					((b = function (t) {
						y(arguments.length, 1);
						var r = f(t) ? t : j(t),
							e = h(arguments, 1);
						return (
							(P[++T] = function () {
								c(r, void 0, e);
							}),
							o(T),
							T
						);
					}),
					(x = function (t) {
						delete P[t];
					}),
					g
						? (o = function (t) {
								w.nextTick(F(t));
						  })
						: S && S.now
						? (o = function (t) {
								S.now(F(t));
						  })
						: O && !m
						? ((a = (i = new O()).port2),
						  (i.port1.onmessage = M),
						  (o = s(a.postMessage, a)))
						: u.addEventListener &&
						  f(u.postMessage) &&
						  !u.importScripts &&
						  n &&
						  'file:' !== n.protocol &&
						  !v(k)
						? ((o = k), u.addEventListener('message', M, !1))
						: (o =
								L in d('script')
									? function (t) {
											l.appendChild(d('script')).onreadystatechange =
												function () {
													l.removeChild(this), _(t);
												};
									  }
									: function (t) {
											setTimeout(F(t), 0);
									  })),
					(t.exports = { set: b, clear: x });
			},
			1400: (t, r, e) => {
				var n = e(9303),
					o = Math.max,
					i = Math.min;
				t.exports = function (t, r) {
					var e = n(t);
					return e < 0 ? o(e + r, 0) : i(e, r);
				};
			},
			5656: (t, r, e) => {
				var n = e(8361),
					o = e(4488);
				t.exports = function (t) {
					return n(o(t));
				};
			},
			9303: (t) => {
				var r = Math.ceil,
					e = Math.floor;
				t.exports = function (t) {
					var n = +t;
					return n != n || 0 === n ? 0 : (n > 0 ? e : r)(n);
				};
			},
			7466: (t, r, e) => {
				var n = e(9303),
					o = Math.min;
				t.exports = function (t) {
					return t > 0 ? o(n(t), 9007199254740991) : 0;
				};
			},
			7908: (t, r, e) => {
				var n = e(7854),
					o = e(4488),
					i = n.Object;
				t.exports = function (t) {
					return i(o(t));
				};
			},
			7593: (t, r, e) => {
				var n = e(7854),
					o = e(6916),
					i = e(111),
					a = e(2190),
					u = e(8173),
					c = e(2140),
					s = e(5112),
					f = n.TypeError,
					p = s('toPrimitive');
				t.exports = function (t, r) {
					if (!i(t) || a(t)) return t;
					var e,
						n = u(t, p);
					if (n) {
						if (
							(void 0 === r && (r = 'default'), (e = o(n, t, r)), !i(e) || a(e))
						)
							return e;
						throw f("Can't convert object to primitive value");
					}
					return void 0 === r && (r = 'number'), c(t, r);
				};
			},
			4948: (t, r, e) => {
				var n = e(7593),
					o = e(2190);
				t.exports = function (t) {
					var r = n(t, 'string');
					return o(r) ? r : r + '';
				};
			},
			1694: (t, r, e) => {
				var n = {};
				(n[e(5112)('toStringTag')] = 'z'),
					(t.exports = '[object z]' === String(n));
			},
			1340: (t, r, e) => {
				var n = e(7854),
					o = e(648),
					i = n.String;
				t.exports = function (t) {
					if ('Symbol' === o(t))
						throw TypeError('Cannot convert a Symbol value to a string');
					return i(t);
				};
			},
			6330: (t, r, e) => {
				var n = e(7854).String;
				t.exports = function (t) {
					try {
						return n(t);
					} catch (t) {
						return 'Object';
					}
				};
			},
			9711: (t, r, e) => {
				var n = e(1702),
					o = 0,
					i = Math.random(),
					a = n((1).toString);
				t.exports = function (t) {
					return 'Symbol(' + (void 0 === t ? '' : t) + ')_' + a(++o + i, 36);
				};
			},
			3307: (t, r, e) => {
				var n = e(133);
				t.exports = n && !Symbol.sham && 'symbol' == typeof Symbol.iterator;
			},
			3353: (t, r, e) => {
				var n = e(9781),
					o = e(7293);
				t.exports =
					n &&
					o(function () {
						return (
							42 !=
							Object.defineProperty(function () {}, 'prototype', {
								value: 42,
								writable: !1,
							}).prototype
						);
					});
			},
			8053: (t, r, e) => {
				var n = e(7854).TypeError;
				t.exports = function (t, r) {
					if (t < r) throw n('Not enough arguments');
					return t;
				};
			},
			5112: (t, r, e) => {
				var n = e(7854),
					o = e(2309),
					i = e(2597),
					a = e(9711),
					u = e(133),
					c = e(3307),
					s = o('wks'),
					f = n.Symbol,
					p = f && f.for,
					v = c ? f : (f && f.withoutSetter) || a;
				t.exports = function (t) {
					if (!i(s, t) || (!u && 'string' != typeof s[t])) {
						var r = 'Symbol.' + t;
						u && i(f, t) ? (s[t] = f[t]) : (s[t] = c && p ? p(r) : v(r));
					}
					return s[t];
				};
			},
			9191: (t, r, e) => {
				'use strict';
				var n = e(5005),
					o = e(2597),
					i = e(8880),
					a = e(7976),
					u = e(7674),
					c = e(9920),
					s = e(9587),
					f = e(6277),
					p = e(8340),
					v = e(7741),
					l = e(2914),
					h = e(1913);
				t.exports = function (t, r, e, d) {
					var y = d ? 2 : 1,
						m = t.split('.'),
						g = m[m.length - 1],
						b = n.apply(null, m);
					if (b) {
						var x = b.prototype;
						if ((!h && o(x, 'cause') && delete x.cause, !e)) return b;
						var w = n('Error'),
							S = r(function (t, r) {
								var e = f(d ? r : t, void 0),
									n = d ? new b(t) : new b();
								return (
									void 0 !== e && i(n, 'message', e),
									l && i(n, 'stack', v(n.stack, 2)),
									this && a(x, this) && s(n, this, S),
									arguments.length > y && p(n, arguments[y]),
									n
								);
							});
						if (
							((S.prototype = x),
							'Error' !== g && (u ? u(S, w) : c(S, w, { name: !0 })),
							c(S, b),
							!h)
						)
							try {
								x.name !== g && i(x, 'name', g), (x.constructor = S);
							} catch (t) {}
						return S;
					}
				};
			},
			1703: (t, r, e) => {
				var n = e(2109),
					o = e(7854),
					i = e(2104),
					a = e(9191),
					u = 'WebAssembly',
					c = o.WebAssembly,
					s = 7 !== Error('e', { cause: 7 }).cause,
					f = function (t, r) {
						var e = {};
						(e[t] = a(t, r, s)), n({ global: !0, forced: s }, e);
					},
					p = function (t, r) {
						if (c && c[t]) {
							var e = {};
							(e[t] = a('WebAssembly.' + t, r, s)),
								n({ target: u, stat: !0, forced: s }, e);
						}
					};
				f('Error', function (t) {
					return function (r) {
						return i(t, this, arguments);
					};
				}),
					f('EvalError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					f('RangeError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					f('ReferenceError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					f('SyntaxError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					f('TypeError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					f('URIError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					p('CompileError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					p('LinkError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					}),
					p('RuntimeError', function (t) {
						return function (r) {
							return i(t, this, arguments);
						};
					});
			},
			8862: (t, r, e) => {
				var n = e(2109),
					o = e(7854),
					i = e(5005),
					a = e(2104),
					u = e(1702),
					c = e(7293),
					s = o.Array,
					f = i('JSON', 'stringify'),
					p = u(/./.exec),
					v = u(''.charAt),
					l = u(''.charCodeAt),
					h = u(''.replace),
					d = u((1).toString),
					y = /[\uD800-\uDFFF]/g,
					m = /^[\uD800-\uDBFF]$/,
					g = /^[\uDC00-\uDFFF]$/,
					b = function (t, r, e) {
						var n = v(e, r - 1),
							o = v(e, r + 1);
						return (p(m, t) && !p(g, o)) || (p(g, t) && !p(m, n))
							? '\\u' + d(l(t, 0), 16)
							: t;
					},
					x = c(function () {
						return (
							'"\\udf06\\ud834"' !== f('\udf06\ud834') ||
							'"\\udead"' !== f('\udead')
						);
					});
				f &&
					n(
						{ target: 'JSON', stat: !0, forced: x },
						{
							stringify: function (t, r, e) {
								for (var n = 0, o = arguments.length, i = s(o); n < o; n++)
									i[n] = arguments[n];
								var u = a(f, null, i);
								return 'string' == typeof u ? h(u, y, b) : u;
							},
						}
					);
			},
			9070: (t, r, e) => {
				var n = e(2109),
					o = e(9781),
					i = e(3070).f;
				n(
					{
						target: 'Object',
						stat: !0,
						forced: Object.defineProperty !== i,
						sham: !o,
					},
					{ defineProperty: i }
				);
			},
			7941: (t, r, e) => {
				var n = e(2109),
					o = e(7908),
					i = e(1956);
				n(
					{
						target: 'Object',
						stat: !0,
						forced: e(7293)(function () {
							i(1);
						}),
					},
					{
						keys: function (t) {
							return i(o(t));
						},
					}
				);
			},
			1539: (t, r, e) => {
				var n = e(1694),
					o = e(1320),
					i = e(288);
				n || o(Object.prototype, 'toString', i, { unsafe: !0 });
			},
			8674: (t, r, e) => {
				'use strict';
				var n,
					o,
					i,
					a,
					u = e(2109),
					c = e(1913),
					s = e(7854),
					f = e(5005),
					p = e(6916),
					v = e(3366),
					l = e(1320),
					h = e(2248),
					d = e(7674),
					y = e(8003),
					m = e(6340),
					g = e(9662),
					b = e(614),
					x = e(111),
					w = e(5787),
					S = e(2788),
					j = e(408),
					O = e(7072),
					E = e(6707),
					T = e(261).set,
					P = e(5948),
					L = e(9478),
					_ = e(842),
					F = e(8523),
					M = e(2534),
					k = e(8572),
					A = e(9909),
					D = e(4705),
					R = e(5112),
					I = e(7871),
					C = e(5268),
					N = e(7392),
					G = R('species'),
					V = 'Promise',
					q = A.getterFor(V),
					z = A.set,
					H = A.getterFor(V),
					U = v && v.prototype,
					W = v,
					B = U,
					J = s.TypeError,
					K = s.document,
					$ = s.process,
					X = F.f,
					Y = X,
					Q = !!(K && K.createEvent && s.dispatchEvent),
					Z = b(s.PromiseRejectionEvent),
					tt = 'unhandledrejection',
					rt = !1,
					et = D(V, function () {
						var t = S(W),
							r = t !== String(W);
						if (!r && 66 === N) return !0;
						if (c && !B.finally) return !0;
						if (N >= 51 && /native code/.test(t)) return !1;
						var e = new W(function (t) {
								t(1);
							}),
							n = function (t) {
								t(
									function () {},
									function () {}
								);
							};
						return (
							((e.constructor = {})[G] = n),
							!(rt = e.then(function () {}) instanceof n) || (!r && I && !Z)
						);
					}),
					nt =
						et ||
						!O(function (t) {
							W.all(t).catch(function () {});
						}),
					ot = function (t) {
						var r;
						return !(!x(t) || !b((r = t.then))) && r;
					},
					it = function (t, r) {
						var e,
							n,
							o,
							i = r.value,
							a = 1 == r.state,
							u = a ? t.ok : t.fail,
							c = t.resolve,
							s = t.reject,
							f = t.domain;
						try {
							u
								? (a || (2 === r.rejection && ft(r), (r.rejection = 1)),
								  !0 === u
										? (e = i)
										: (f && f.enter(), (e = u(i)), f && (f.exit(), (o = !0))),
								  e === t.promise
										? s(J('Promise-chain cycle'))
										: (n = ot(e))
										? p(n, e, c, s)
										: c(e))
								: s(i);
						} catch (t) {
							f && !o && f.exit(), s(t);
						}
					},
					at = function (t, r) {
						t.notified ||
							((t.notified = !0),
							P(function () {
								for (var e, n = t.reactions; (e = n.get()); ) it(e, t);
								(t.notified = !1), r && !t.rejection && ct(t);
							}));
					},
					ut = function (t, r, e) {
						var n, o;
						Q
							? (((n = K.createEvent('Event')).promise = r),
							  (n.reason = e),
							  n.initEvent(t, !1, !0),
							  s.dispatchEvent(n))
							: (n = { promise: r, reason: e }),
							!Z && (o = s['on' + t])
								? o(n)
								: t === tt && _('Unhandled promise rejection', e);
					},
					ct = function (t) {
						p(T, s, function () {
							var r,
								e = t.facade,
								n = t.value;
							if (
								st(t) &&
								((r = M(function () {
									C ? $.emit('unhandledRejection', n, e) : ut(tt, e, n);
								})),
								(t.rejection = C || st(t) ? 2 : 1),
								r.error)
							)
								throw r.value;
						});
					},
					st = function (t) {
						return 1 !== t.rejection && !t.parent;
					},
					ft = function (t) {
						p(T, s, function () {
							var r = t.facade;
							C
								? $.emit('rejectionHandled', r)
								: ut('rejectionhandled', r, t.value);
						});
					},
					pt = function (t, r, e) {
						return function (n) {
							t(r, n, e);
						};
					},
					vt = function (t, r, e) {
						t.done ||
							((t.done = !0),
							e && (t = e),
							(t.value = r),
							(t.state = 2),
							at(t, !0));
					},
					lt = function (t, r, e) {
						if (!t.done) {
							(t.done = !0), e && (t = e);
							try {
								if (t.facade === r) throw J("Promise can't be resolved itself");
								var n = ot(r);
								n
									? P(function () {
											var e = { done: !1 };
											try {
												p(n, r, pt(lt, e, t), pt(vt, e, t));
											} catch (r) {
												vt(e, r, t);
											}
									  })
									: ((t.value = r), (t.state = 1), at(t, !1));
							} catch (r) {
								vt({ done: !1 }, r, t);
							}
						}
					};
				if (
					et &&
					((B = (W = function (t) {
						w(this, B), g(t), p(n, this);
						var r = q(this);
						try {
							t(pt(lt, r), pt(vt, r));
						} catch (t) {
							vt(r, t);
						}
					}).prototype),
					((n = function (t) {
						z(this, {
							type: V,
							done: !1,
							notified: !1,
							parent: !1,
							reactions: new k(),
							rejection: !1,
							state: 0,
							value: void 0,
						});
					}).prototype = h(B, {
						then: function (t, r) {
							var e = H(this),
								n = X(E(this, W));
							return (
								(e.parent = !0),
								(n.ok = !b(t) || t),
								(n.fail = b(r) && r),
								(n.domain = C ? $.domain : void 0),
								0 == e.state
									? e.reactions.add(n)
									: P(function () {
											it(n, e);
									  }),
								n.promise
							);
						},
						catch: function (t) {
							return this.then(void 0, t);
						},
					})),
					(o = function () {
						var t = new n(),
							r = q(t);
						(this.promise = t),
							(this.resolve = pt(lt, r)),
							(this.reject = pt(vt, r));
					}),
					(F.f = X =
						function (t) {
							return t === W || t === i ? new o(t) : Y(t);
						}),
					!c && b(v) && U !== Object.prototype)
				) {
					(a = U.then),
						rt ||
							(l(
								U,
								'then',
								function (t, r) {
									var e = this;
									return new W(function (t, r) {
										p(a, e, t, r);
									}).then(t, r);
								},
								{ unsafe: !0 }
							),
							l(U, 'catch', B.catch, { unsafe: !0 }));
					try {
						delete U.constructor;
					} catch (t) {}
					d && d(U, B);
				}
				u({ global: !0, wrap: !0, forced: et }, { Promise: W }),
					y(W, V, !1, !0),
					m(V),
					(i = f(V)),
					u(
						{ target: V, stat: !0, forced: et },
						{
							reject: function (t) {
								var r = X(this);
								return p(r.reject, void 0, t), r.promise;
							},
						}
					),
					u(
						{ target: V, stat: !0, forced: c || et },
						{
							resolve: function (t) {
								return L(c && this === i ? W : this, t);
							},
						}
					),
					u(
						{ target: V, stat: !0, forced: nt },
						{
							all: function (t) {
								var r = this,
									e = X(r),
									n = e.resolve,
									o = e.reject,
									i = M(function () {
										var e = g(r.resolve),
											i = [],
											a = 0,
											u = 1;
										j(t, function (t) {
											var c = a++,
												s = !1;
											u++,
												p(e, r, t).then(function (t) {
													s || ((s = !0), (i[c] = t), --u || n(i));
												}, o);
										}),
											--u || n(i);
									});
								return i.error && o(i.value), e.promise;
							},
							race: function (t) {
								var r = this,
									e = X(r),
									n = e.reject,
									o = M(function () {
										var o = g(r.resolve);
										j(t, function (t) {
											p(o, r, t).then(e.resolve, n);
										});
									});
								return o.error && n(o.value), e.promise;
							},
						}
					);
			},
			4747: (t, r, e) => {
				var n = e(7854),
					o = e(8324),
					i = e(8509),
					a = e(8533),
					u = e(8880),
					c = function (t) {
						if (t && t.forEach !== a)
							try {
								u(t, 'forEach', a);
							} catch (r) {
								t.forEach = a;
							}
					};
				for (var s in o) o[s] && c(n[s] && n[s].prototype);
				c(i);
			},
		},
		r = {};
	function e(n) {
		var o = r[n];
		if (void 0 !== o) return o.exports;
		var i = (r[n] = { exports: {} });
		return t[n](i, i.exports, e), i.exports;
	}
	(e.d = (t, r) => {
		for (var n in r)
			e.o(r, n) &&
				!e.o(t, n) &&
				Object.defineProperty(t, n, { enumerable: !0, get: r[n] });
	}),
		(e.g = (function () {
			if ('object' == typeof globalThis) return globalThis;
			try {
				return this || new Function('return this')();
			} catch (t) {
				if ('object' == typeof window) return window;
			}
		})()),
		(e.o = (t, r) => Object.prototype.hasOwnProperty.call(t, r)),
		(e.r = (t) => {
			'undefined' != typeof Symbol &&
				Symbol.toStringTag &&
				Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
				Object.defineProperty(t, '__esModule', { value: !0 });
		});
	var n = {};
	(() => {
		'use strict';
		e.r(n),
			e.d(n, {
				default: () => p,
				init: () => r,
				send: () => s,
				sendForm: () => f,
			});
		var t = { _origin: 'https://api.emailjs.com' },
			r = function (r) {
				var e =
					arguments.length > 1 && void 0 !== arguments[1]
						? arguments[1]
						: 'https://api.emailjs.com';
				(t._userID = r), (t._origin = e);
			},
			o =
				(e(8862),
				function (t, r, e) {
					if (!t)
						throw 'The user ID is required. Visit https://dashboard.emailjs.com/admin/integration';
					if (!r)
						throw 'The service ID is required. Visit https://dashboard.emailjs.com/admin';
					if (!e)
						throw 'The template ID is required. Visit https://dashboard.emailjs.com/admin/templates';
					return !0;
				});
		e(1539), e(8674), e(4747), e(7941), e(1703), e(9070);
		function i(t, r) {
			for (var e = 0; e < r.length; e++) {
				var n = r[e];
				(n.enumerable = n.enumerable || !1),
					(n.configurable = !0),
					'value' in n && (n.writable = !0),
					Object.defineProperty(t, n.key, n);
			}
		}
		function a(t, r, e) {
			return r && i(t.prototype, r), e && i(t, e), t;
		}
		var u = a(function t(r) {
				!(function (t, r) {
					if (!(t instanceof r))
						throw new TypeError('Cannot call a class as a function');
				})(this, t),
					(this.status = r.status),
					(this.text = r.responseText);
			}),
			c = function (r, e) {
				var n =
					arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
				return new Promise(function (o, i) {
					var a = new XMLHttpRequest();
					a.addEventListener('load', function (t) {
						var r = t.target,
							e = new u(r);
						200 === e.status || 'OK' === e.text ? o(e) : i(e);
					}),
						a.addEventListener('error', function (t) {
							var r = t.target;
							i(new u(r));
						}),
						a.open('POST', t._origin + r, !0),
						Object.keys(n).forEach(function (t) {
							a.setRequestHeader(t, n[t]);
						}),
						a.send(e);
				});
			},
			s = function (r, e, n, i) {
				var a = i || t._userID;
				o(a, r, e);
				var u = {
					lib_version: '3.5.0',
					user_id: a,
					service_id: r,
					template_id: e,
					template_params: n,
				};
				return c('/api/v1.0/email/send', JSON.stringify(u), {
					'Content-type': 'application/json',
				});
			},
			f = function (r, e, n, i) {
				var a = i || t._userID,
					u = (function (t) {
						var r;
						if (
							!(r = 'string' == typeof t ? document.querySelector(t) : t) ||
							'FORM' !== r.nodeName
						)
							throw 'The 3rd parameter is expected to be the HTML form element or the style selector of form';
						return r;
					})(n);
				o(a, r, e);
				var s = new FormData(u);
				return (
					s.append('lib_version', '3.5.0'),
					s.append('service_id', r),
					s.append('template_id', e),
					s.append('user_id', a),
					c('/api/v1.0/email/send-form', s)
				);
			};
		const p = { init: r, send: s, sendForm: f };
	})(),
		(self.emailjs = n);
})();

!(function (t, e) {
	'object' == typeof exports && 'object' == typeof module
		? (module.exports = e())
		: 'function' == typeof define && define.amd
		? define([], e)
		: 'object' == typeof exports
		? (exports._vantaEffect = e())
		: (t._vantaEffect = e());
})('undefined' != typeof self ? self : this, function () {
	return (function (t) {
		var e = {};
		function i(o) {
			if (e[o]) return e[o].exports;
			var n = (e[o] = { i: o, l: !1, exports: {} });
			return t[o].call(n.exports, n, n.exports, i), (n.l = !0), n.exports;
		}
		return (
			(i.m = t),
			(i.c = e),
			(i.d = function (t, e, o) {
				i.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: o });
			}),
			(i.r = function (t) {
				'undefined' != typeof Symbol &&
					Symbol.toStringTag &&
					Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
					Object.defineProperty(t, '__esModule', { value: !0 });
			}),
			(i.t = function (t, e) {
				if ((1 & e && (t = i(t)), 8 & e)) return t;
				if (4 & e && 'object' == typeof t && t && t.__esModule) return t;
				var o = Object.create(null);
				if (
					(i.r(o),
					Object.defineProperty(o, 'default', { enumerable: !0, value: t }),
					2 & e && 'string' != typeof t)
				)
					for (var n in t)
						i.d(
							o,
							n,
							function (e) {
								return t[e];
							}.bind(null, n)
						);
				return o;
			}),
			(i.n = function (t) {
				var e =
					t && t.__esModule
						? function () {
								return t.default;
						  }
						: function () {
								return t;
						  };
				return i.d(e, 'a', e), e;
			}),
			(i.o = function (t, e) {
				return Object.prototype.hasOwnProperty.call(t, e);
			}),
			(i.p = ''),
			i((i.s = 5))
		);
	})([
		function (t, e, i) {
			'use strict';
			function o(t, e) {
				for (let i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				return t;
			}
			function n() {
				return 'undefined' != typeof navigator
					? /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
							navigator.userAgent
					  ) || window.innerWidth < 600
					: null;
			}
			i.d(e, 'c', function () {
				return o;
			}),
				i.d(e, 'e', function () {
					return n;
				}),
				i.d(e, 'i', function () {
					return s;
				}),
				i.d(e, 'h', function () {
					return r;
				}),
				i.d(e, 'g', function () {
					return h;
				}),
				i.d(e, 'f', function () {
					return a;
				}),
				i.d(e, 'a', function () {
					return u;
				}),
				i.d(e, 'b', function () {
					return c;
				}),
				i.d(e, 'd', function () {
					return l;
				}),
				(Number.prototype.clamp = function (t, e) {
					return Math.min(Math.max(this, t), e);
				});
			const s = (t) => t[Math.floor(Math.random() * t.length)];
			function r(t, e) {
				return (
					null == t && (t = 0),
					null == e && (e = 1),
					t + Math.random() * (e - t)
				);
			}
			function h(t, e) {
				return (
					null == t && (t = 0),
					null == e && (e = 1),
					Math.floor(t + Math.random() * (e - t + 1))
				);
			}
			const a = (t) => document.querySelector(t),
				u = (t) =>
					'number' == typeof t ? '#' + ('00000' + t.toString(16)).slice(-6) : t,
				c = (t, e = 1) => {
					const i = u(t),
						o = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i),
						n = o
							? {
									r: parseInt(o[1], 16),
									g: parseInt(o[2], 16),
									b: parseInt(o[3], 16),
							  }
							: null;
					return 'rgba(' + n.r + ',' + n.g + ',' + n.b + ',' + e + ')';
				},
				l = (t) => 0.299 * t.r + 0.587 * t.g + 0.114 * t.b;
		},
		function (t, e, i) {
			'use strict';
			i.d(e, 'a', function () {
				return r;
			});
			var o = i(0);
			const n = 'object' == typeof window;
			let s = (n && window.THREE) || {};
			n && !window.VANTA && (window.VANTA = {});
			const r = (n && window.VANTA) || {};
			(r.register = (t, e) => (r[t] = (t) => new e(t))), (r.version = '0.5.21');
			const h = function () {
				return (
					Array.prototype.unshift.call(arguments, '[VANTA]'),
					console.error.apply(this, arguments)
				);
			};
			(r.VantaBase = class {
				constructor(t = {}) {
					if (!n) return !1;
					(r.current = this),
						(this.windowMouseMoveWrapper =
							this.windowMouseMoveWrapper.bind(this)),
						(this.windowTouchWrapper = this.windowTouchWrapper.bind(this)),
						(this.windowGyroWrapper = this.windowGyroWrapper.bind(this)),
						(this.resize = this.resize.bind(this)),
						(this.animationLoop = this.animationLoop.bind(this)),
						(this.restart = this.restart.bind(this));
					const e =
						'function' == typeof this.getDefaultOptions
							? this.getDefaultOptions()
							: this.defaultOptions;
					if (
						((this.options = Object(o.c)(
							{
								mouseControls: !0,
								touchControls: !0,
								gyroControls: !1,
								minHeight: 200,
								minWidth: 200,
								scale: 1,
								scaleMobile: 1,
							},
							e
						)),
						(t instanceof HTMLElement || 'string' == typeof t) &&
							(t = { el: t }),
						Object(o.c)(this.options, t),
						this.options.THREE && (s = this.options.THREE),
						(this.el = this.options.el),
						null == this.el)
					)
						h('Instance needs "el" param!');
					else if (!(this.options.el instanceof HTMLElement)) {
						const t = this.el;
						if (((this.el = Object(o.f)(t)), !this.el))
							return void h('Cannot find element', t);
					}
					this.prepareEl(), this.initThree(), this.setSize();
					try {
						this.init();
					} catch (t) {
						return (
							h('Init error', t),
							this.renderer &&
								this.renderer.domElement &&
								this.el.removeChild(this.renderer.domElement),
							void (
								this.options.backgroundColor &&
								(console.log('[VANTA] Falling back to backgroundColor'),
								(this.el.style.background = Object(o.a)(
									this.options.backgroundColor
								)))
							)
						);
					}
					this.initMouse(), this.resize(), this.animationLoop();
					const i = window.addEventListener;
					i('resize', this.resize),
						window.requestAnimationFrame(this.resize),
						this.options.mouseControls &&
							(i('scroll', this.windowMouseMoveWrapper),
							i('mousemove', this.windowMouseMoveWrapper)),
						this.options.touchControls &&
							(i('touchstart', this.windowTouchWrapper),
							i('touchmove', this.windowTouchWrapper)),
						this.options.gyroControls &&
							i('deviceorientation', this.windowGyroWrapper);
				}
				setOptions(t = {}) {
					Object(o.c)(this.options, t), this.triggerMouseMove();
				}
				prepareEl() {
					let t, e;
					if ('undefined' != typeof Node && Node.TEXT_NODE)
						for (t = 0; t < this.el.childNodes.length; t++) {
							const e = this.el.childNodes[t];
							if (e.nodeType === Node.TEXT_NODE) {
								const t = document.createElement('span');
								(t.textContent = e.textContent),
									e.parentElement.insertBefore(t, e),
									e.remove();
							}
						}
					for (t = 0; t < this.el.children.length; t++)
						(e = this.el.children[t]),
							'static' === getComputedStyle(e).position &&
								(e.style.position = 'relative'),
							'auto' === getComputedStyle(e).zIndex && (e.style.zIndex = 1);
					'static' === getComputedStyle(this.el).position &&
						(this.el.style.position = 'relative');
				}
				applyCanvasStyles(t, e = {}) {
					Object(o.c)(t.style, {
						position: 'absolute',
						zIndex: 0,
						top: 0,
						left: 0,
						background: '',
					}),
						Object(o.c)(t.style, e),
						t.classList.add('vanta-canvas');
				}
				initThree() {
					s.WebGLRenderer
						? ((this.renderer = new s.WebGLRenderer({
								alpha: !0,
								antialias: !0,
						  })),
						  this.el.appendChild(this.renderer.domElement),
						  this.applyCanvasStyles(this.renderer.domElement),
						  isNaN(this.options.backgroundAlpha) &&
								(this.options.backgroundAlpha = 1),
						  (this.scene = new s.Scene()))
						: console.warn('[VANTA] No THREE defined on window');
				}
				getCanvasElement() {
					return this.renderer
						? this.renderer.domElement
						: this.p5renderer
						? this.p5renderer.canvas
						: void 0;
				}
				getCanvasRect() {
					const t = this.getCanvasElement();
					return !!t && t.getBoundingClientRect();
				}
				windowMouseMoveWrapper(t) {
					const e = this.getCanvasRect();
					if (!e) return !1;
					const i = t.clientX - e.left,
						o = t.clientY - e.top;
					i >= 0 &&
						o >= 0 &&
						i <= e.width &&
						o <= e.height &&
						((this.mouseX = i),
						(this.mouseY = o),
						this.options.mouseEase || this.triggerMouseMove(i, o));
				}
				windowTouchWrapper(t) {
					const e = this.getCanvasRect();
					if (!e) return !1;
					if (1 === t.touches.length) {
						const i = t.touches[0].clientX - e.left,
							o = t.touches[0].clientY - e.top;
						i >= 0 &&
							o >= 0 &&
							i <= e.width &&
							o <= e.height &&
							((this.mouseX = i),
							(this.mouseY = o),
							this.options.mouseEase || this.triggerMouseMove(i, o));
					}
				}
				windowGyroWrapper(t) {
					const e = this.getCanvasRect();
					if (!e) return !1;
					const i = Math.round(2 * t.alpha) - e.left,
						o = Math.round(2 * t.beta) - e.top;
					i >= 0 &&
						o >= 0 &&
						i <= e.width &&
						o <= e.height &&
						((this.mouseX = i),
						(this.mouseY = o),
						this.options.mouseEase || this.triggerMouseMove(i, o));
				}
				triggerMouseMove(t, e) {
					void 0 === t &&
						void 0 === e &&
						(this.options.mouseEase
							? ((t = this.mouseEaseX), (e = this.mouseEaseY))
							: ((t = this.mouseX), (e = this.mouseY))),
						this.uniforms &&
							((this.uniforms.iMouse.value.x = t / this.scale),
							(this.uniforms.iMouse.value.y = e / this.scale));
					const i = t / this.width,
						o = e / this.height;
					'function' == typeof this.onMouseMove && this.onMouseMove(i, o);
				}
				setSize() {
					this.scale || (this.scale = 1),
						Object(o.e)() && this.options.scaleMobile
							? (this.scale = this.options.scaleMobile)
							: this.options.scale && (this.scale = this.options.scale),
						(this.width = Math.max(this.el.offsetWidth, this.options.minWidth)),
						(this.height = Math.max(
							this.el.offsetHeight,
							this.options.minHeight
						));
				}
				initMouse() {
					((!this.mouseX && !this.mouseY) ||
						(this.mouseX === this.options.minWidth / 2 &&
							this.mouseY === this.options.minHeight / 2)) &&
						((this.mouseX = this.width / 2),
						(this.mouseY = this.height / 2),
						this.triggerMouseMove(this.mouseX, this.mouseY));
				}
				resize() {
					this.setSize(),
						this.camera &&
							((this.camera.aspect = this.width / this.height),
							'function' == typeof this.camera.updateProjectionMatrix &&
								this.camera.updateProjectionMatrix()),
						this.renderer &&
							(this.renderer.setSize(this.width, this.height),
							this.renderer.setPixelRatio(
								window.devicePixelRatio / this.scale
							)),
						'function' == typeof this.onResize && this.onResize();
				}
				isOnScreen() {
					const t = this.el.offsetHeight,
						e = this.el.getBoundingClientRect(),
						i =
							window.pageYOffset ||
							(
								document.documentElement ||
								document.body.parentNode ||
								document.body
							).scrollTop,
						o = e.top + i;
					return o - window.innerHeight <= i && i <= o + t;
				}
				animationLoop() {
					return (
						this.t || (this.t = 0),
						(this.t += 1),
						this.t2 || (this.t2 = 0),
						(this.t2 += this.options.speed || 1),
						this.uniforms && (this.uniforms.iTime.value = 0.016667 * this.t2),
						this.options.mouseEase &&
							((this.mouseEaseX = this.mouseEaseX || this.mouseX || 0),
							(this.mouseEaseY = this.mouseEaseY || this.mouseY || 0),
							Math.abs(this.mouseEaseX - this.mouseX) +
								Math.abs(this.mouseEaseY - this.mouseY) >
								0.1 &&
								((this.mouseEaseX += 0.05 * (this.mouseX - this.mouseEaseX)),
								(this.mouseEaseY += 0.05 * (this.mouseY - this.mouseEaseY)),
								this.triggerMouseMove(this.mouseEaseX, this.mouseEaseY))),
						(this.isOnScreen() || this.options.forceAnimate) &&
							('function' == typeof this.onUpdate && this.onUpdate(),
							this.scene &&
								this.camera &&
								(this.renderer.render(this.scene, this.camera),
								this.renderer.setClearColor(
									this.options.backgroundColor,
									this.options.backgroundAlpha
								)),
							this.fps && this.fps.update && this.fps.update(),
							'function' == typeof this.afterRender && this.afterRender()),
						(this.req = window.requestAnimationFrame(this.animationLoop))
					);
				}
				restart() {
					if (this.scene)
						for (; this.scene.children.length; )
							this.scene.remove(this.scene.children[0]);
					'function' == typeof this.onRestart && this.onRestart(), this.init();
				}
				init() {
					'function' == typeof this.onInit && this.onInit();
				}
				destroy() {
					'function' == typeof this.onDestroy && this.onDestroy();
					const t = window.removeEventListener;
					t('touchstart', this.windowTouchWrapper),
						t('touchmove', this.windowTouchWrapper),
						t('scroll', this.windowMouseMoveWrapper),
						t('mousemove', this.windowMouseMoveWrapper),
						t('deviceorientation', this.windowGyroWrapper),
						t('resize', this.resize),
						window.cancelAnimationFrame(this.req),
						this.renderer &&
							(this.renderer.domElement &&
								this.el.removeChild(this.renderer.domElement),
							(this.renderer = null),
							(this.scene = null)),
						r.current === this && (r.current = null);
				}
			}),
				(e.b = r.VantaBase);
		},
		function (t, e, i) {
			'use strict';
			i.d(e, 'b', function () {
				return r;
			});
			var o = i(1),
				n = i(0);
			i.d(e, 'a', function () {
				return o.a;
			});
			let s = 'object' == typeof window && window.THREE;
			class r extends o.b {
				constructor(t) {
					((s = t.THREE || s).Color.prototype.toVector = function () {
						return new s.Vector3(this.r, this.g, this.b);
					}),
						super(t),
						(this.updateUniforms = this.updateUniforms.bind(this));
				}
				init() {
					(this.mode = 'shader'),
						(this.uniforms = {
							iTime: { type: 'f', value: 1 },
							iResolution: { type: 'v2', value: new s.Vector2(1, 1) },
							iDpr: { type: 'f', value: window.devicePixelRatio || 1 },
							iMouse: {
								type: 'v2',
								value: new s.Vector2(this.mouseX || 0, this.mouseY || 0),
							},
						}),
						super.init(),
						this.fragmentShader && this.initBasicShader();
				}
				setOptions(t) {
					super.setOptions(t), this.updateUniforms();
				}
				initBasicShader(t = this.fragmentShader, e = this.vertexShader) {
					e ||
						(e =
							'uniform float uTime;\nuniform vec2 uResolution;\nvoid main() {\n  gl_Position = vec4( position, 1.0 );\n}'),
						this.updateUniforms(),
						'function' == typeof this.valuesChanger && this.valuesChanger();
					const i = new s.ShaderMaterial({
							uniforms: this.uniforms,
							vertexShader: e,
							fragmentShader: t,
						}),
						o = this.options.texturePath;
					o &&
						(this.uniforms.iTex = {
							type: 't',
							value: new s.TextureLoader().load(o),
						});
					const n = new s.Mesh(new s.PlaneGeometry(2, 2), i);
					this.scene.add(n),
						(this.camera = new s.Camera()),
						(this.camera.position.z = 1);
				}
				updateUniforms() {
					const t = {};
					let e, i;
					for (e in this.options)
						(i = this.options[e]),
							-1 !== e.toLowerCase().indexOf('color')
								? (t[e] = { type: 'v3', value: new s.Color(i).toVector() })
								: 'number' == typeof i && (t[e] = { type: 'f', value: i });
					return Object(n.c)(this.uniforms, t);
				}
				resize() {
					super.resize(),
						(this.uniforms.iResolution.value.x = this.width / this.scale),
						(this.uniforms.iResolution.value.y = this.height / this.scale);
				}
			}
		},
		,
		,
		function (t, e, i) {
			'use strict';
			i.r(e);
			var o = i(2);
			class n extends o.b {}
			(e.default = o.a.register('CELLS', n)),
				(n.prototype.defaultOptions = {
					color1: 35980,
					color2: 15918901,
					backgroundColor: 14155663,
					amplitudeFactor: 1,
					ringFactor: 1,
					rotationFactor: 1,
					size: 1.5,
					speed: 1,
					scaleMobile: 3,
				}),
				(n.prototype.fragmentShader =
					'uniform vec2 iResolution;\nuniform vec2 iMouse;\nuniform float iTime;\n\nuniform float blurFactor;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform vec3 backgroundColor;\nuniform float size;\nuniform float amplitudeFactor;\nuniform float ringFactor;\nuniform float rotationFactor;\n\nfloat length2(vec2 p) { return dot(p, p); }\n\nfloat noise(vec2 p){\n    return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n}\n\nfloat worley(vec2 p) {\n    float d = 1e30;\n    for (int xo = -1; xo <= 1; ++xo) {\n        for (int yo = -1; yo <= 1; ++yo) {\n            vec2 tp = floor(p) + vec2(xo, yo);\n            d = min(d, length2(p - tp - vec2(noise(tp))));\n        }\n    }\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float timeOffset =  0.15 * sin(iTime * 2.0 + 10.0*(uv.x - uv.y));\n    return 3.0*exp(-4.0*abs(2.0*d - 1.0 + timeOffset));\n}\n\nfloat fworley(vec2 p) {\n    return sqrt(sqrt(sqrt(\n    1.1 * // light\n    worley(p*5. + .3 + iTime*.0525) *\n    sqrt(worley(p * 50. / size + 0.3 + iTime * -0.15)) *\n    sqrt(sqrt(worley(p * -10. + 9.3))))));\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float t = fworley(uv * iResolution.xy / 1500.0);\n    t *= exp(-length2(abs(0.7*uv - 1.0)));\n\n    float tExp = pow(t, 0.5 - t);\n    vec3 c1 = color1 * (1.0 - t);\n    vec3 c2 = color2 * tExp;\n\n    gl_FragColor = vec4(pow(t, 1.0 - t) * (c1 + c2), 1.0);\n}\n');
		},
	]);
});

!(function (e, t) {
	'object' == typeof exports && 'undefined' != typeof module
		? (module.exports = t())
		: 'function' == typeof define && define.amd
		? define(t)
		: (e.AOS = t());
})(this, function () {
	'use strict';
	var e =
			'undefined' != typeof window
				? window
				: 'undefined' != typeof global
				? global
				: 'undefined' != typeof self
				? self
				: {},
		t = 'Expected a function',
		n = NaN,
		o = '[object Symbol]',
		i = /^\s+|\s+$/g,
		a = /^[-+]0x[0-9a-f]+$/i,
		r = /^0b[01]+$/i,
		c = /^0o[0-7]+$/i,
		s = parseInt,
		u = 'object' == typeof e && e && e.Object === Object && e,
		d = 'object' == typeof self && self && self.Object === Object && self,
		l = u || d || Function('return this')(),
		f = Object.prototype.toString,
		m = Math.max,
		p = Math.min,
		b = function () {
			return l.Date.now();
		};
	function v(e, n, o) {
		var i,
			a,
			r,
			c,
			s,
			u,
			d = 0,
			l = !1,
			f = !1,
			v = !0;
		if ('function' != typeof e) throw new TypeError(t);
		function y(t) {
			var n = i,
				o = a;
			return (i = a = void 0), (d = t), (c = e.apply(o, n));
		}
		function h(e) {
			var t = e - u;
			return void 0 === u || t >= n || t < 0 || (f && e - d >= r);
		}
		function k() {
			var e = b();
			if (h(e)) return x(e);
			s = setTimeout(
				k,
				(function (e) {
					var t = n - (e - u);
					return f ? p(t, r - (e - d)) : t;
				})(e)
			);
		}
		function x(e) {
			return (s = void 0), v && i ? y(e) : ((i = a = void 0), c);
		}
		function O() {
			var e = b(),
				t = h(e);
			if (((i = arguments), (a = this), (u = e), t)) {
				if (void 0 === s)
					return (function (e) {
						return (d = e), (s = setTimeout(k, n)), l ? y(e) : c;
					})(u);
				if (f) return (s = setTimeout(k, n)), y(u);
			}
			return void 0 === s && (s = setTimeout(k, n)), c;
		}
		return (
			(n = w(n) || 0),
			g(o) &&
				((l = !!o.leading),
				(r = (f = 'maxWait' in o) ? m(w(o.maxWait) || 0, n) : r),
				(v = 'trailing' in o ? !!o.trailing : v)),
			(O.cancel = function () {
				void 0 !== s && clearTimeout(s), (d = 0), (i = u = a = s = void 0);
			}),
			(O.flush = function () {
				return void 0 === s ? c : x(b());
			}),
			O
		);
	}
	function g(e) {
		var t = typeof e;
		return !!e && ('object' == t || 'function' == t);
	}
	function w(e) {
		if ('number' == typeof e) return e;
		if (
			(function (e) {
				return (
					'symbol' == typeof e ||
					((function (e) {
						return !!e && 'object' == typeof e;
					})(e) &&
						f.call(e) == o)
				);
			})(e)
		)
			return n;
		if (g(e)) {
			var t = 'function' == typeof e.valueOf ? e.valueOf() : e;
			e = g(t) ? t + '' : t;
		}
		if ('string' != typeof e) return 0 === e ? e : +e;
		e = e.replace(i, '');
		var u = r.test(e);
		return u || c.test(e) ? s(e.slice(2), u ? 2 : 8) : a.test(e) ? n : +e;
	}
	var y = function (e, n, o) {
			var i = !0,
				a = !0;
			if ('function' != typeof e) throw new TypeError(t);
			return (
				g(o) &&
					((i = 'leading' in o ? !!o.leading : i),
					(a = 'trailing' in o ? !!o.trailing : a)),
				v(e, n, { leading: i, maxWait: n, trailing: a })
			);
		},
		h = 'Expected a function',
		k = NaN,
		x = '[object Symbol]',
		O = /^\s+|\s+$/g,
		j = /^[-+]0x[0-9a-f]+$/i,
		E = /^0b[01]+$/i,
		N = /^0o[0-7]+$/i,
		z = parseInt,
		C = 'object' == typeof e && e && e.Object === Object && e,
		A = 'object' == typeof self && self && self.Object === Object && self,
		q = C || A || Function('return this')(),
		L = Object.prototype.toString,
		T = Math.max,
		M = Math.min,
		S = function () {
			return q.Date.now();
		};
	function D(e) {
		var t = typeof e;
		return !!e && ('object' == t || 'function' == t);
	}
	function H(e) {
		if ('number' == typeof e) return e;
		if (
			(function (e) {
				return (
					'symbol' == typeof e ||
					((function (e) {
						return !!e && 'object' == typeof e;
					})(e) &&
						L.call(e) == x)
				);
			})(e)
		)
			return k;
		if (D(e)) {
			var t = 'function' == typeof e.valueOf ? e.valueOf() : e;
			e = D(t) ? t + '' : t;
		}
		if ('string' != typeof e) return 0 === e ? e : +e;
		e = e.replace(O, '');
		var n = E.test(e);
		return n || N.test(e) ? z(e.slice(2), n ? 2 : 8) : j.test(e) ? k : +e;
	}
	var $ = function (e, t, n) {
			var o,
				i,
				a,
				r,
				c,
				s,
				u = 0,
				d = !1,
				l = !1,
				f = !0;
			if ('function' != typeof e) throw new TypeError(h);
			function m(t) {
				var n = o,
					a = i;
				return (o = i = void 0), (u = t), (r = e.apply(a, n));
			}
			function p(e) {
				var n = e - s;
				return void 0 === s || n >= t || n < 0 || (l && e - u >= a);
			}
			function b() {
				var e = S();
				if (p(e)) return v(e);
				c = setTimeout(
					b,
					(function (e) {
						var n = t - (e - s);
						return l ? M(n, a - (e - u)) : n;
					})(e)
				);
			}
			function v(e) {
				return (c = void 0), f && o ? m(e) : ((o = i = void 0), r);
			}
			function g() {
				var e = S(),
					n = p(e);
				if (((o = arguments), (i = this), (s = e), n)) {
					if (void 0 === c)
						return (function (e) {
							return (u = e), (c = setTimeout(b, t)), d ? m(e) : r;
						})(s);
					if (l) return (c = setTimeout(b, t)), m(s);
				}
				return void 0 === c && (c = setTimeout(b, t)), r;
			}
			return (
				(t = H(t) || 0),
				D(n) &&
					((d = !!n.leading),
					(a = (l = 'maxWait' in n) ? T(H(n.maxWait) || 0, t) : a),
					(f = 'trailing' in n ? !!n.trailing : f)),
				(g.cancel = function () {
					void 0 !== c && clearTimeout(c), (u = 0), (o = s = i = c = void 0);
				}),
				(g.flush = function () {
					return void 0 === c ? r : v(S());
				}),
				g
			);
		},
		W = function () {};
	function P(e) {
		e &&
			e.forEach(function (e) {
				var t = Array.prototype.slice.call(e.addedNodes),
					n = Array.prototype.slice.call(e.removedNodes);
				if (
					(function e(t) {
						var n = void 0,
							o = void 0;
						for (n = 0; n < t.length; n += 1) {
							if ((o = t[n]).dataset && o.dataset.aos) return !0;
							if (o.children && e(o.children)) return !0;
						}
						return !1;
					})(t.concat(n))
				)
					return W();
			});
	}
	function Y() {
		return (
			window.MutationObserver ||
			window.WebKitMutationObserver ||
			window.MozMutationObserver
		);
	}
	var _ = {
			isSupported: function () {
				return !!Y();
			},
			ready: function (e, t) {
				var n = window.document,
					o = new (Y())(P);
				(W = t),
					o.observe(n.documentElement, {
						childList: !0,
						subtree: !0,
						removedNodes: !0,
					});
			},
		},
		B = function (e, t) {
			if (!(e instanceof t))
				throw new TypeError('Cannot call a class as a function');
		},
		F = (function () {
			function e(e, t) {
				for (var n = 0; n < t.length; n++) {
					var o = t[n];
					(o.enumerable = o.enumerable || !1),
						(o.configurable = !0),
						'value' in o && (o.writable = !0),
						Object.defineProperty(e, o.key, o);
				}
			}
			return function (t, n, o) {
				return n && e(t.prototype, n), o && e(t, o), t;
			};
		})(),
		I =
			Object.assign ||
			function (e) {
				for (var t = 1; t < arguments.length; t++) {
					var n = arguments[t];
					for (var o in n)
						Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
				}
				return e;
			},
		K =
			/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
		G =
			/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
		J =
			/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,
		Q =
			/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
	function R() {
		return navigator.userAgent || navigator.vendor || window.opera || '';
	}
	var U = new ((function () {
			function e() {
				B(this, e);
			}
			return (
				F(e, [
					{
						key: 'phone',
						value: function () {
							var e = R();
							return !(!K.test(e) && !G.test(e.substr(0, 4)));
						},
					},
					{
						key: 'mobile',
						value: function () {
							var e = R();
							return !(!J.test(e) && !Q.test(e.substr(0, 4)));
						},
					},
					{
						key: 'tablet',
						value: function () {
							return this.mobile() && !this.phone();
						},
					},
					{
						key: 'ie11',
						value: function () {
							return (
								'-ms-scroll-limit' in document.documentElement.style &&
								'-ms-ime-align' in document.documentElement.style
							);
						},
					},
				]),
				e
			);
		})())(),
		V = function (e, t) {
			var n = void 0;
			return (
				U.ie11()
					? (n = document.createEvent('CustomEvent')).initCustomEvent(
							e,
							!0,
							!0,
							{ detail: t }
					  )
					: (n = new CustomEvent(e, { detail: t })),
				document.dispatchEvent(n)
			);
		},
		X = function (e) {
			return e.forEach(function (e, t) {
				return (function (e, t) {
					var n = e.options,
						o = e.position,
						i = e.node,
						a =
							(e.data,
							function () {
								e.animated &&
									((function (e, t) {
										t &&
											t.forEach(function (t) {
												return e.classList.remove(t);
											});
									})(i, n.animatedClassNames),
									V('aos:out', i),
									e.options.id && V('aos:in:' + e.options.id, i),
									(e.animated = !1));
							});
					n.mirror && t >= o.out && !n.once
						? a()
						: t >= o.in
						? e.animated ||
						  ((function (e, t) {
								t &&
									t.forEach(function (t) {
										return e.classList.add(t);
									});
						  })(i, n.animatedClassNames),
						  V('aos:in', i),
						  e.options.id && V('aos:in:' + e.options.id, i),
						  (e.animated = !0))
						: e.animated && !n.once && a();
				})(e, window.pageYOffset);
			});
		},
		Z = function (e) {
			for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop); )
				(t += e.offsetLeft - ('BODY' != e.tagName ? e.scrollLeft : 0)),
					(n += e.offsetTop - ('BODY' != e.tagName ? e.scrollTop : 0)),
					(e = e.offsetParent);
			return { top: n, left: t };
		},
		ee = function (e, t, n) {
			var o = e.getAttribute('data-aos-' + t);
			if (void 0 !== o) {
				if ('true' === o) return !0;
				if ('false' === o) return !1;
			}
			return o || n;
		},
		te = function (e, t) {
			return (
				e.forEach(function (e, n) {
					var o = ee(e.node, 'mirror', t.mirror),
						i = ee(e.node, 'once', t.once),
						a = ee(e.node, 'id'),
						r = t.useClassNames && e.node.getAttribute('data-aos'),
						c = [t.animatedClassName]
							.concat(r ? r.split(' ') : [])
							.filter(function (e) {
								return 'string' == typeof e;
							});
					t.initClassName && e.node.classList.add(t.initClassName),
						(e.position = {
							in: (function (e, t, n) {
								var o = window.innerHeight,
									i = ee(e, 'anchor'),
									a = ee(e, 'anchor-placement'),
									r = Number(ee(e, 'offset', a ? 0 : t)),
									c = a || n,
									s = e;
								i &&
									document.querySelectorAll(i) &&
									(s = document.querySelectorAll(i)[0]);
								var u = Z(s).top - o;
								switch (c) {
									case 'top-bottom':
										break;
									case 'center-bottom':
										u += s.offsetHeight / 2;
										break;
									case 'bottom-bottom':
										u += s.offsetHeight;
										break;
									case 'top-center':
										u += o / 2;
										break;
									case 'center-center':
										u += o / 2 + s.offsetHeight / 2;
										break;
									case 'bottom-center':
										u += o / 2 + s.offsetHeight;
										break;
									case 'top-top':
										u += o;
										break;
									case 'bottom-top':
										u += o + s.offsetHeight;
										break;
									case 'center-top':
										u += o + s.offsetHeight / 2;
								}
								return u + r;
							})(e.node, t.offset, t.anchorPlacement),
							out:
								o &&
								(function (e, t) {
									window.innerHeight;
									var n = ee(e, 'anchor'),
										o = ee(e, 'offset', t),
										i = e;
									return (
										n &&
											document.querySelectorAll(n) &&
											(i = document.querySelectorAll(n)[0]),
										Z(i).top + i.offsetHeight - o
									);
								})(e.node, t.offset),
						}),
						(e.options = { once: i, mirror: o, animatedClassNames: c, id: a });
				}),
				e
			);
		},
		ne = function () {
			var e = document.querySelectorAll('[data-aos]');
			return Array.prototype.map.call(e, function (e) {
				return { node: e };
			});
		},
		oe = [],
		ie = !1,
		ae = {
			offset: 120,
			delay: 0,
			easing: 'ease',
			duration: 400,
			disable: !1,
			once: !1,
			mirror: !1,
			anchorPlacement: 'top-bottom',
			startEvent: 'DOMContentLoaded',
			animatedClassName: 'aos-animate',
			initClassName: 'aos-init',
			useClassNames: !1,
			disableMutationObserver: !1,
			throttleDelay: 99,
			debounceDelay: 50,
		},
		re = function () {
			return document.all && !window.atob;
		},
		ce = function () {
			arguments.length > 0 &&
				void 0 !== arguments[0] &&
				arguments[0] &&
				(ie = !0),
				ie &&
					((oe = te(oe, ae)),
					X(oe),
					window.addEventListener(
						'scroll',
						y(function () {
							X(oe, ae.once);
						}, ae.throttleDelay)
					));
		},
		se = function () {
			if (((oe = ne()), de(ae.disable) || re())) return ue();
			ce();
		},
		ue = function () {
			oe.forEach(function (e, t) {
				e.node.removeAttribute('data-aos'),
					e.node.removeAttribute('data-aos-easing'),
					e.node.removeAttribute('data-aos-duration'),
					e.node.removeAttribute('data-aos-delay'),
					ae.initClassName && e.node.classList.remove(ae.initClassName),
					ae.animatedClassName && e.node.classList.remove(ae.animatedClassName);
			});
		},
		de = function (e) {
			return (
				!0 === e ||
				('mobile' === e && U.mobile()) ||
				('phone' === e && U.phone()) ||
				('tablet' === e && U.tablet()) ||
				('function' == typeof e && !0 === e())
			);
		};
	return {
		init: function (e) {
			return (
				(ae = I(ae, e)),
				(oe = ne()),
				ae.disableMutationObserver ||
					_.isSupported() ||
					(console.info(
						'\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '
					),
					(ae.disableMutationObserver = !0)),
				ae.disableMutationObserver || _.ready('[data-aos]', se),
				de(ae.disable) || re()
					? ue()
					: (document
							.querySelector('body')
							.setAttribute('data-aos-easing', ae.easing),
					  document
							.querySelector('body')
							.setAttribute('data-aos-duration', ae.duration),
					  document
							.querySelector('body')
							.setAttribute('data-aos-delay', ae.delay),
					  -1 === ['DOMContentLoaded', 'load'].indexOf(ae.startEvent)
							? document.addEventListener(ae.startEvent, function () {
									ce(!0);
							  })
							: window.addEventListener('load', function () {
									ce(!0);
							  }),
					  'DOMContentLoaded' === ae.startEvent &&
							['complete', 'interactive'].indexOf(document.readyState) > -1 &&
							ce(!0),
					  window.addEventListener('resize', $(ce, ae.debounceDelay, !0)),
					  window.addEventListener(
							'orientationchange',
							$(ce, ae.debounceDelay, !0)
					  ),
					  oe)
			);
		},
		refresh: ce,
		refreshHard: se,
	};
});

// ------------------------------------------
// Rellax.js
// Buttery smooth parallax library
// Copyright (c) 2016 Moe Amaya (@moeamaya)
// MIT license
//
// Thanks to Paraxify.js and Jaime Cabllero
// for parallax concepts
// ------------------------------------------

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof module === 'object' && module.exports) {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.Rellax = factory();
	}
})(typeof window !== 'undefined' ? window : global, function () {
	var Rellax = function (el, options) {
		'use strict';

		var self = Object.create(Rellax.prototype);

		var posY = 0;
		var screenY = 0;
		var posX = 0;
		var screenX = 0;
		var blocks = [];
		var pause = true;

		// check what requestAnimationFrame to use, and if
		// it's not supported, use the onscroll event
		var loop =
			window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			function (callback) {
				return setTimeout(callback, 1000 / 60);
			};

		// store the id for later use
		var loopId = null;

		// Test via a getter in the options object to see if the passive property is accessed
		var supportsPassive = false;
		try {
			var opts = Object.defineProperty({}, 'passive', {
				get: function () {
					supportsPassive = true;
				},
			});
			window.addEventListener('testPassive', null, opts);
			window.removeEventListener('testPassive', null, opts);
		} catch (e) {}

		// check what cancelAnimation method to use
		var clearLoop =
			window.cancelAnimationFrame ||
			window.mozCancelAnimationFrame ||
			clearTimeout;

		// check which transform property to use
		var transformProp =
			window.transformProp ||
			(function () {
				var testEl = document.createElement('div');
				if (testEl.style.transform === null) {
					var vendors = ['Webkit', 'Moz', 'ms'];
					for (var vendor in vendors) {
						if (testEl.style[vendors[vendor] + 'Transform'] !== undefined) {
							return vendors[vendor] + 'Transform';
						}
					}
				}
				return 'transform';
			})();

		// Default Settings
		self.options = {
			speed: -2,
			verticalSpeed: null,
			horizontalSpeed: null,
			breakpoints: [576, 768, 1201],
			center: false,
			wrapper: null,
			relativeToWrapper: false,
			round: true,
			vertical: true,
			horizontal: false,
			verticalScrollAxis: 'y',
			horizontalScrollAxis: 'x',
			callback: function () {},
		};

		// User defined options (might have more in the future)
		if (options) {
			Object.keys(options).forEach(function (key) {
				self.options[key] = options[key];
			});
		}

		function validateCustomBreakpoints() {
			if (
				self.options.breakpoints.length === 3 &&
				Array.isArray(self.options.breakpoints)
			) {
				var isAscending = true;
				var isNumerical = true;
				var lastVal;
				self.options.breakpoints.forEach(function (i) {
					if (typeof i !== 'number') isNumerical = false;
					if (lastVal !== null) {
						if (i < lastVal) isAscending = false;
					}
					lastVal = i;
				});
				if (isAscending && isNumerical) return;
			}
			// revert defaults if set incorrectly
			self.options.breakpoints = [576, 768, 1201];
			console.warn(
				'Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted'
			);
		}

		if (options && options.breakpoints) {
			validateCustomBreakpoints();
		}

		// By default, rellax class
		if (!el) {
			el = '.rellax';
		}

		// check if el is a className or a node
		var elements =
			typeof el === 'string' ? document.querySelectorAll(el) : [el];

		// Now query selector
		if (elements.length > 0) {
			self.elems = elements;
		}

		// The elements don't exist
		else {
			console.warn("Rellax: The elements you're trying to select don't exist.");
			return;
		}

		// Has a wrapper and it exists
		if (self.options.wrapper) {
			if (!self.options.wrapper.nodeType) {
				var wrapper = document.querySelector(self.options.wrapper);

				if (wrapper) {
					self.options.wrapper = wrapper;
				} else {
					console.warn(
						"Rellax: The wrapper you're trying to use doesn't exist."
					);
					return;
				}
			}
		}

		// set a placeholder for the current breakpoint
		var currentBreakpoint;

		// helper to determine current breakpoint
		var getCurrentBreakpoint = function (w) {
			var bp = self.options.breakpoints;
			if (w < bp[0]) return 'xs';
			if (w >= bp[0] && w < bp[1]) return 'sm';
			if (w >= bp[1] && w < bp[2]) return 'md';
			return 'lg';
		};

		// Get and cache initial position of all elements
		var cacheBlocks = function () {
			for (var i = 0; i < self.elems.length; i++) {
				var block = createBlock(self.elems[i]);
				blocks.push(block);
			}
		};

		// Let's kick this script off
		// Build array for cached element values
		var init = function () {
			for (var i = 0; i < blocks.length; i++) {
				self.elems[i].style.cssText = blocks[i].style;
			}

			blocks = [];

			screenY = window.innerHeight;
			screenX = window.innerWidth;
			currentBreakpoint = getCurrentBreakpoint(screenX);

			setPosition();

			cacheBlocks();

			animate();

			// If paused, unpause and set listener for window resizing events
			if (pause) {
				window.addEventListener('resize', init);
				pause = false;
				// Start the loop
				update();
			}
		};

		// We want to cache the parallax blocks'
		// values: base, top, height, speed
		// el: is dom object, return: el cache values
		var createBlock = function (el) {
			var dataPercentage = el.getAttribute('data-rellax-percentage');
			var dataSpeed = el.getAttribute('data-rellax-speed');
			var dataXsSpeed = el.getAttribute('data-rellax-xs-speed');
			var dataMobileSpeed = el.getAttribute('data-rellax-mobile-speed');
			var dataTabletSpeed = el.getAttribute('data-rellax-tablet-speed');
			var dataDesktopSpeed = el.getAttribute('data-rellax-desktop-speed');
			var dataVerticalSpeed = el.getAttribute('data-rellax-vertical-speed');
			var dataHorizontalSpeed = el.getAttribute('data-rellax-horizontal-speed');
			var dataVericalScrollAxis = el.getAttribute(
				'data-rellax-vertical-scroll-axis'
			);
			var dataHorizontalScrollAxis = el.getAttribute(
				'data-rellax-horizontal-scroll-axis'
			);
			var dataZindex = el.getAttribute('data-rellax-zindex') || 0;
			var dataMin = el.getAttribute('data-rellax-min');
			var dataMax = el.getAttribute('data-rellax-max');
			var dataMinX = el.getAttribute('data-rellax-min-x');
			var dataMaxX = el.getAttribute('data-rellax-max-x');
			var dataMinY = el.getAttribute('data-rellax-min-y');
			var dataMaxY = el.getAttribute('data-rellax-max-y');
			var mapBreakpoints;
			var breakpoints = true;

			if (
				!dataXsSpeed &&
				!dataMobileSpeed &&
				!dataTabletSpeed &&
				!dataDesktopSpeed
			) {
				breakpoints = false;
			} else {
				mapBreakpoints = {
					xs: dataXsSpeed,
					sm: dataMobileSpeed,
					md: dataTabletSpeed,
					lg: dataDesktopSpeed,
				};
			}

			// initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)
			// ensures elements are positioned based on HTML layout.
			//
			// If the element has the percentage attribute, the posY and posX needs to be
			// the current scroll position's value, so that the elements are still positioned based on HTML layout
			var wrapperPosY = self.options.wrapper
				? self.options.wrapper.scrollTop
				: window.pageYOffset ||
				  document.documentElement.scrollTop ||
				  document.body.scrollTop;
			// If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.
			if (self.options.relativeToWrapper) {
				var scrollPosY =
					window.pageYOffset ||
					document.documentElement.scrollTop ||
					document.body.scrollTop;
				wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;
			}
			var posY = self.options.vertical
				? dataPercentage || self.options.center
					? wrapperPosY
					: 0
				: 0;
			var posX = self.options.horizontal
				? dataPercentage || self.options.center
					? self.options.wrapper
						? self.options.wrapper.scrollLeft
						: window.pageXOffset ||
						  document.documentElement.scrollLeft ||
						  document.body.scrollLeft
					: 0
				: 0;

			var blockTop = posY + el.getBoundingClientRect().top;
			var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;

			var blockLeft = posX + el.getBoundingClientRect().left;
			var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;

			// apparently parallax equation everyone uses
			var percentageY = dataPercentage
				? dataPercentage
				: (posY - blockTop + screenY) / (blockHeight + screenY);
			var percentageX = dataPercentage
				? dataPercentage
				: (posX - blockLeft + screenX) / (blockWidth + screenX);
			if (self.options.center) {
				percentageX = 0.5;
				percentageY = 0.5;
			}

			// Optional individual block speed as data attr, otherwise global speed
			var speed =
				breakpoints && mapBreakpoints[currentBreakpoint] !== null
					? Number(mapBreakpoints[currentBreakpoint])
					: dataSpeed
					? dataSpeed
					: self.options.speed;
			var verticalSpeed = dataVerticalSpeed
				? dataVerticalSpeed
				: self.options.verticalSpeed;
			var horizontalSpeed = dataHorizontalSpeed
				? dataHorizontalSpeed
				: self.options.horizontalSpeed;

			// Optional individual block movement axis direction as data attr, otherwise global movement direction
			var verticalScrollAxis = dataVericalScrollAxis
				? dataVericalScrollAxis
				: self.options.verticalScrollAxis;
			var horizontalScrollAxis = dataHorizontalScrollAxis
				? dataHorizontalScrollAxis
				: self.options.horizontalScrollAxis;

			var bases = updatePosition(
				percentageX,
				percentageY,
				speed,
				verticalSpeed,
				horizontalSpeed
			);

			// ~~Store non-translate3d transforms~~
			// Store inline styles and extract transforms
			var style = el.style.cssText;
			var transform = '';

			// Check if there's an inline styled transform
			var searchResult = /transform\s*:/i.exec(style);
			if (searchResult) {
				// Get the index of the transform
				var index = searchResult.index;

				// Trim the style to the transform point and get the following semi-colon index
				var trimmedStyle = style.slice(index);
				var delimiter = trimmedStyle.indexOf(';');

				// Remove "transform" string and save the attribute
				if (delimiter) {
					transform =
						' ' + trimmedStyle.slice(11, delimiter).replace(/\s/g, '');
				} else {
					transform = ' ' + trimmedStyle.slice(11).replace(/\s/g, '');
				}
			}

			return {
				baseX: bases.x,
				baseY: bases.y,
				top: blockTop,
				left: blockLeft,
				height: blockHeight,
				width: blockWidth,
				speed: speed,
				verticalSpeed: verticalSpeed,
				horizontalSpeed: horizontalSpeed,
				verticalScrollAxis: verticalScrollAxis,
				horizontalScrollAxis: horizontalScrollAxis,
				style: style,
				transform: transform,
				zindex: dataZindex,
				min: dataMin,
				max: dataMax,
				minX: dataMinX,
				maxX: dataMaxX,
				minY: dataMinY,
				maxY: dataMaxY,
			};
		};

		// set scroll position (posY, posX)
		// side effect method is not ideal, but okay for now
		// returns true if the scroll changed, false if nothing happened
		var setPosition = function () {
			var oldY = posY;
			var oldX = posX;

			posY = self.options.wrapper
				? self.options.wrapper.scrollTop
				: (
						document.documentElement ||
						document.body.parentNode ||
						document.body
				  ).scrollTop || window.pageYOffset;
			posX = self.options.wrapper
				? self.options.wrapper.scrollLeft
				: (
						document.documentElement ||
						document.body.parentNode ||
						document.body
				  ).scrollLeft || window.pageXOffset;
			// If option relativeToWrapper is true, use relative wrapper value instead.
			if (self.options.relativeToWrapper) {
				var scrollPosY =
					(
						document.documentElement ||
						document.body.parentNode ||
						document.body
					).scrollTop || window.pageYOffset;
				posY = scrollPosY - self.options.wrapper.offsetTop;
			}

			if (oldY != posY && self.options.vertical) {
				// scroll changed, return true
				return true;
			}

			if (oldX != posX && self.options.horizontal) {
				// scroll changed, return true
				return true;
			}

			// scroll did not change
			return false;
		};

		// Ahh a pure function, gets new transform value
		// based on scrollPosition and speed
		// Allow for decimal pixel values
		var updatePosition = function (
			percentageX,
			percentageY,
			speed,
			verticalSpeed,
			horizontalSpeed
		) {
			var result = {};
			var valueX =
				(horizontalSpeed ? horizontalSpeed : speed) * (100 * (1 - percentageX));
			var valueY =
				(verticalSpeed ? verticalSpeed : speed) * (100 * (1 - percentageY));

			result.x = self.options.round
				? Math.round(valueX)
				: Math.round(valueX * 100) / 100;
			result.y = self.options.round
				? Math.round(valueY)
				: Math.round(valueY * 100) / 100;

			return result;
		};

		// Remove event listeners and loop again
		var deferredUpdate = function () {
			window.removeEventListener('resize', deferredUpdate);
			window.removeEventListener('orientationchange', deferredUpdate);
			(self.options.wrapper
				? self.options.wrapper
				: window
			).removeEventListener('scroll', deferredUpdate);
			(self.options.wrapper
				? self.options.wrapper
				: document
			).removeEventListener('touchmove', deferredUpdate);

			// loop again
			loopId = loop(update);
		};

		// Loop
		var update = function () {
			if (setPosition() && pause === false) {
				animate();

				// loop again
				loopId = loop(update);
			} else {
				loopId = null;

				// Don't animate until we get a position updating event
				window.addEventListener('resize', deferredUpdate);
				window.addEventListener('orientationchange', deferredUpdate);
				(self.options.wrapper ? self.options.wrapper : window).addEventListener(
					'scroll',
					deferredUpdate,
					supportsPassive ? { passive: true } : false
				);
				(self.options.wrapper
					? self.options.wrapper
					: document
				).addEventListener(
					'touchmove',
					deferredUpdate,
					supportsPassive ? { passive: true } : false
				);
			}
		};

		// Transform3d on parallax element
		var animate = function () {
			var positions;
			for (var i = 0; i < self.elems.length; i++) {
				// Determine relevant movement directions
				var verticalScrollAxis = blocks[i].verticalScrollAxis.toLowerCase();
				var horizontalScrollAxis = blocks[i].horizontalScrollAxis.toLowerCase();
				var verticalScrollX = verticalScrollAxis.indexOf('x') != -1 ? posY : 0;
				var verticalScrollY = verticalScrollAxis.indexOf('y') != -1 ? posY : 0;
				var horizontalScrollX =
					horizontalScrollAxis.indexOf('x') != -1 ? posX : 0;
				var horizontalScrollY =
					horizontalScrollAxis.indexOf('y') != -1 ? posX : 0;

				var percentageY =
					(verticalScrollY + horizontalScrollY - blocks[i].top + screenY) /
					(blocks[i].height + screenY);
				var percentageX =
					(verticalScrollX + horizontalScrollX - blocks[i].left + screenX) /
					(blocks[i].width + screenX);

				// Subtracting initialize value, so element stays in same spot as HTML
				positions = updatePosition(
					percentageX,
					percentageY,
					blocks[i].speed,
					blocks[i].verticalSpeed,
					blocks[i].horizontalSpeed
				);
				var positionY = positions.y - blocks[i].baseY;
				var positionX = positions.x - blocks[i].baseX;

				// The next two "if" blocks go like this:
				// Check if a limit is defined (first "min", then "max");
				// Check if we need to change the Y or the X
				// (Currently working only if just one of the axes is enabled)
				// Then, check if the new position is inside the allowed limit
				// If so, use new position. If not, set position to limit.

				// Check if a min limit is defined
				if (blocks[i].min !== null) {
					if (self.options.vertical && !self.options.horizontal) {
						positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;
					}
					if (self.options.horizontal && !self.options.vertical) {
						positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;
					}
				}

				// Check if directional min limits are defined
				if (blocks[i].minY != null) {
					positionY = positionY <= blocks[i].minY ? blocks[i].minY : positionY;
				}
				if (blocks[i].minX != null) {
					positionX = positionX <= blocks[i].minX ? blocks[i].minX : positionX;
				}

				// Check if a max limit is defined
				if (blocks[i].max !== null) {
					if (self.options.vertical && !self.options.horizontal) {
						positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;
					}
					if (self.options.horizontal && !self.options.vertical) {
						positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;
					}
				}

				// Check if directional max limits are defined
				if (blocks[i].maxY != null) {
					positionY = positionY >= blocks[i].maxY ? blocks[i].maxY : positionY;
				}
				if (blocks[i].maxX != null) {
					positionX = positionX >= blocks[i].maxX ? blocks[i].maxX : positionX;
				}

				var zindex = blocks[i].zindex;

				// Move that element
				// (Set the new translation and append initial inline transforms.)
				var translate =
					'translate3d(' +
					(self.options.horizontal ? positionX : '0') +
					'px,' +
					(self.options.vertical ? positionY : '0') +
					'px,' +
					zindex +
					'px) ' +
					blocks[i].transform;
				self.elems[i].style[transformProp] = translate;
			}
			self.options.callback(positions);
		};

		self.destroy = function () {
			for (var i = 0; i < self.elems.length; i++) {
				self.elems[i].style.cssText = blocks[i].style;
			}

			// Remove resize event listener if not pause, and pause
			if (!pause) {
				window.removeEventListener('resize', init);
				pause = true;
			}

			// Clear the animation loop to prevent possible memory leak
			clearLoop(loopId);
			loopId = null;
		};

		// Init
		init();

		// Allow to recalculate the initial values whenever we want
		self.refresh = init;

		return self;
	};
	return Rellax;
});
